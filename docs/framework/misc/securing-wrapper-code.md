---
title: ラッパー コードの保護
description: ラッパー コードをセキュリティで保護する方法を確認します。これにより、ラッパーがそれを使用するコードよりも高く信頼されている場合は特に、セキュリティの脆弱性の固有のセットを開くことができます。
ms.date: 03/30/2017
helpviewer_keywords:
- security [.NET Framework], wrapper code
- wrapper code, securing
- secure coding, wrapper code
- code security, wrapper code
ms.assetid: 1df6c516-5bba-48bd-b450-1070e04b7389
ms.openlocfilehash: b4c158f8b42618a3659a7d5cf3375b872f19f48b
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/26/2020
ms.locfileid: "96288217"
---
# <a name="securing-wrapper-code"></a><span data-ttu-id="2ed35-103">ラッパー コードの保護</span><span class="sxs-lookup"><span data-stu-id="2ed35-103">Securing Wrapper Code</span></span>

[!INCLUDE[net_security_note](../../../includes/net-security-note-md.md)]  
  
 <span data-ttu-id="2ed35-104">ラッパー コードで、使用しているコードよりもラッパーの信頼が高い場合には特に、特有のセキュリティ脆弱性が生じる恐れがあります。</span><span class="sxs-lookup"><span data-stu-id="2ed35-104">Wrapper code, especially where the wrapper has higher trust than code that uses it, can open a unique set of security weaknesses.</span></span> <span data-ttu-id="2ed35-105">呼び出し元の制限されたアクセス許可が適切なセキュリティ チェックに含まれないと、呼び出し元のために実行されるすべての処理が、悪用される可能性のある潜在的な脆弱性となります。</span><span class="sxs-lookup"><span data-stu-id="2ed35-105">Anything done on behalf of a caller, where the caller's limited permissions are not included in the appropriate security check, is a potential weakness to be exploited.</span></span>  
  
 <span data-ttu-id="2ed35-106">呼び出し元自体で実行できない処理をラッパーによって行うことがないようにしてください。</span><span class="sxs-lookup"><span data-stu-id="2ed35-106">Never enable something through the wrapper that the caller could not do itself.</span></span> <span data-ttu-id="2ed35-107">完全なスタック ウォーク要求とは対照的に、限定的なセキュリティ チェックしか行われずに何らかの処理が行われる場合に、この状況は特に危険です。</span><span class="sxs-lookup"><span data-stu-id="2ed35-107">This is a special danger when doing something that involves a limited security check, as opposed to a full stack walk demand.</span></span> <span data-ttu-id="2ed35-108">単一レベルのチェックが行われる場合、実際の呼び出し元と対象の API 要素との間にラッパー コードを挿入することによって、本来は成功すべきではないセキュリティ チェックが簡単に成功してしまう原因となる可能性があり、セキュリティが弱体化します。</span><span class="sxs-lookup"><span data-stu-id="2ed35-108">When single-level checks are involved, interposing the wrapper code between the real caller and the API element in question can easily cause the security check to succeed when it should not, thereby weakening security.</span></span>  
  
## <a name="delegates"></a><span data-ttu-id="2ed35-109">代理人</span><span class="sxs-lookup"><span data-stu-id="2ed35-109">Delegates</span></span>  

 <span data-ttu-id="2ed35-110">デリゲートのセキュリティは、.NET Framework のバージョンによって異なります。</span><span class="sxs-lookup"><span data-stu-id="2ed35-110">Delegate security differs between versions of the .NET Framework.</span></span>  <span data-ttu-id="2ed35-111">このセクションでは、各種デリゲートの動作と、関連するセキュリティ上の考慮事項について説明します。</span><span class="sxs-lookup"><span data-stu-id="2ed35-111">This section describes the different delegate behaviors and associated security considerations.</span></span>  
  
### <a name="in-version-10-and-11-of-the-net-framework"></a><span data-ttu-id="2ed35-112">.NET Framework バージョン 1.0 および 1.1 の場合</span><span class="sxs-lookup"><span data-stu-id="2ed35-112">In version 1.0 and 1.1 of the .NET Framework</span></span>  

 <span data-ttu-id="2ed35-113">.NET Framework バージョン 1.0 および 1.1 は、デリゲートの作成者とデリゲートの呼び出し元に対して、次のセキュリティ アクションを実行します。</span><span class="sxs-lookup"><span data-stu-id="2ed35-113">Version 1.0 and 1.1 of the .NET Framework perform the following security actions against a delegate creator and a delegate caller.</span></span>  
  
- <span data-ttu-id="2ed35-114">デリゲートが作成されると、デリゲート対象メソッドのセキュリティ リンク要求が、デリゲート作成者の許可セットに対して実行されます。</span><span class="sxs-lookup"><span data-stu-id="2ed35-114">When a delegate is created, security link demands on the delegate target method are performed against the grant set of the delegate creator.</span></span>  <span data-ttu-id="2ed35-115">セキュリティ アクションを満たすことができないと、<xref:System.Security.SecurityException> が結果として生じます。</span><span class="sxs-lookup"><span data-stu-id="2ed35-115">Failure to satisfy the security action results in a <xref:System.Security.SecurityException>.</span></span>  
  
- <span data-ttu-id="2ed35-116">デリゲートが呼び出されると、デリゲート呼び出し元の既存のセキュリティ要求が実行されます。</span><span class="sxs-lookup"><span data-stu-id="2ed35-116">When the delegate is invoked, any existing security demands on the delegate caller are performed.</span></span>  
  
 <span data-ttu-id="2ed35-117">ご使用のコードで <xref:System.Delegate> を取得するときに、それを呼び出すことができる信頼性の低いコードから取得する場合には、その信頼性の低いコードによってアクセス許可がエスカレートされることがないようにしてください。</span><span class="sxs-lookup"><span data-stu-id="2ed35-117">Whenever your code takes a <xref:System.Delegate> from less-trusted code that might call it, make sure that you are not enabling the less-trusted code to escalate its permissions.</span></span> <span data-ttu-id="2ed35-118">デリゲートを取得して後ほど使用するとき、デリゲートを作成したコードは呼び出しスタック上にはなく、デリゲートのコードまたはデリゲートを行うコードが保護された操作を試みる場合にアクセス許可がテストされないことになります。</span><span class="sxs-lookup"><span data-stu-id="2ed35-118">If you take a delegate and use it later, the code that created the delegate is not on the call stack and its permissions will not be tested if code in or under the delegate attempts a protected operation.</span></span> <span data-ttu-id="2ed35-119">ご使用のコードと呼び出し元のコードに作成者よりも高い特権がある場合、作成者は呼び出しスタックの一部になることなく、呼び出しパスを編成できます。</span><span class="sxs-lookup"><span data-stu-id="2ed35-119">If your code and the caller code have higher privileges than the creator, the creator can orchestrate the call path without being part of the call stack.</span></span>  
  
### <a name="in-version-20-and-later-versions-of-the-net-framework"></a><span data-ttu-id="2ed35-120">バージョン 2.0 以降の .NET Framework バージョンの場合</span><span class="sxs-lookup"><span data-stu-id="2ed35-120">In version 2.0 and later versions of the .NET Framework</span></span>  

 <span data-ttu-id="2ed35-121">.NET Framework のバージョン 2.0 以降のバージョンでは、それより前のバージョンとは異なり、デリゲートが作成されて呼び出されるときに、デリゲート作成者に対してセキュリティ アクションが実行されます。</span><span class="sxs-lookup"><span data-stu-id="2ed35-121">Unlike previous versions, version 2.0 and later versions of the .NET Framework performs security action against the delegate creator when the delegate is created and called.</span></span>  
  
- <span data-ttu-id="2ed35-122">デリゲートが作成されると、デリゲート対象メソッドのセキュリティ リンク要求が、デリゲート作成者の許可セットに対して実行されます。</span><span class="sxs-lookup"><span data-stu-id="2ed35-122">When a delegate is created, security link demands on the delegate target method are performed against the grant set of the delegate creator.</span></span>  <span data-ttu-id="2ed35-123">セキュリティ アクションを満たすことができないと、<xref:System.Security.SecurityException> が結果として生じます。</span><span class="sxs-lookup"><span data-stu-id="2ed35-123">Failure to satisfy the security action results in a <xref:System.Security.SecurityException>.</span></span>  
  
- <span data-ttu-id="2ed35-124">デリゲート作成時に、デリゲート作成者の許可セットも取得され、デリゲートと一緒に格納されます。</span><span class="sxs-lookup"><span data-stu-id="2ed35-124">The delegate creator's grant set is also captured during delegate creation and stored with the delegate.</span></span>  
  
- <span data-ttu-id="2ed35-125">デリゲートが呼び出されると、デリゲート作成者と呼び出し元が属するアセンブリが異なる場合には、現在のコンテキストの任意の要求に対して、デリゲート作成者の取得された許可セットが最初に評価されます。</span><span class="sxs-lookup"><span data-stu-id="2ed35-125">When the delegate is invoked, the delegate creator's captured grant set is first evaluated against any demands in the current context if the delegate creator and caller belong to different assemblies.</span></span>  <span data-ttu-id="2ed35-126">次に、デリゲート呼び出し元の既存のセキュリティ要求が実行されます。</span><span class="sxs-lookup"><span data-stu-id="2ed35-126">Next, any existing security demands on the delegate caller are performed.</span></span>  
  
## <a name="link-demands-and-wrappers"></a><span data-ttu-id="2ed35-127">リンク要求とラッパー</span><span class="sxs-lookup"><span data-stu-id="2ed35-127">Link demands and wrappers</span></span>  

 <span data-ttu-id="2ed35-128">リンク要求に関する特別な保護がセキュリティ インフラストラクチャで強化されましたが、依然としてコード内で脆弱性の原因となる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="2ed35-128">A special protection case with link demands has been strengthened in the security infrastructure, but it is still a source of possible weakness in your code.</span></span>  
  
 <span data-ttu-id="2ed35-129">完全に信頼されるコードにより、[LinkDemand](link-demands.md) によって保護されているプロパティ、イベント、メソッドが呼び出される場合、呼び出し元の **LinkDemand** アクセス許可チェックを満たしているとその呼び出しは成功します。</span><span class="sxs-lookup"><span data-stu-id="2ed35-129">If fully trusted code calls a property, event, or method protected by a [LinkDemand](link-demands.md), the call succeeds if the **LinkDemand** permission check for the caller is satisfied.</span></span> <span data-ttu-id="2ed35-130">さらに、完全に信頼されたコードがプロパティ名を受け取るクラスを公開し、リフレクションを使用して **get** アクセサーを呼び出すと、**get** アクセサーに対する呼び出しは、ユーザー コードにこのプロパティにアクセスする権限がない場合であっても成功します。</span><span class="sxs-lookup"><span data-stu-id="2ed35-130">Additionally, if the fully trusted code exposes a class that takes the name of a property and calls its **get** accessor using reflection, that call to the **get** accessor succeeds even though the user code does not have the right to access this property.</span></span> <span data-ttu-id="2ed35-131">これは、**LinkDemand** によってチェックされるのが、完全に信頼されたコードである直接の呼び出し元だけであることに起因します。</span><span class="sxs-lookup"><span data-stu-id="2ed35-131">This is because the **LinkDemand** checks only the immediate caller, which is the fully trusted code.</span></span> <span data-ttu-id="2ed35-132">基本的に、完全に信頼できるコードは、ユーザー コードに代わって呼び出す権限があり、その際、ユーザー コードに呼び出すための権限があるかどうかの確認は行いません。</span><span class="sxs-lookup"><span data-stu-id="2ed35-132">In essence, the fully trusted code is making a privileged call on behalf of user code without making sure that the user code has the right to make that call.</span></span>  
  
 <span data-ttu-id="2ed35-133">こうしたセキュリティ ホールを回避するには、共通言語ランタイムによるチェックを、**LinkDemand** によって保護されているメソッド、コンストラクター、プロパティ、イベントに対する間接呼び出しの完全なスタック ウォーク要求へと拡張します。</span><span class="sxs-lookup"><span data-stu-id="2ed35-133">To help prevent such security holes, the common language runtime extends the check into a full stack-walking demand on any indirect call to a method, constructor, property, or event protected by a **LinkDemand**.</span></span> <span data-ttu-id="2ed35-134">この保護により若干のパフォーマンス コストが発生し、セキュリティ チェックのセマンティクスが変更されます。より高速な単一レベルのチェックに合格していた場合にも完全なスタック ウォーク要求が失敗する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="2ed35-134">This protection incurs some performance costs and changes the semantics of the security check; the full stack-walk demand might fail where the faster, one-level check would have passed.</span></span>  
  
## <a name="assembly-loading-wrappers"></a><span data-ttu-id="2ed35-135">アセンブリ読み込みラッパー</span><span class="sxs-lookup"><span data-stu-id="2ed35-135">Assembly loading wrappers</span></span>  

 <span data-ttu-id="2ed35-136">マネージド コードの読み込みに使用されるいくつかのメソッド (<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> など) は、呼び出し元の証拠に基づいてアセンブリを読み込みます。</span><span class="sxs-lookup"><span data-stu-id="2ed35-136">Several methods used to load managed code, including <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>, load assemblies with the evidence of the caller.</span></span> <span data-ttu-id="2ed35-137">これらのメソッドのいずれかをラップする場合、セキュリティ システムがアセンブリを読み込むとき、ラッパーに対する呼び出し元のアクセス許可ではなく、ご使用のコードのアクセス許可を使用できることがあります。</span><span class="sxs-lookup"><span data-stu-id="2ed35-137">If you wrap any of these methods, the security system could use your code's permission grant, instead of the permissions of the caller to your wrapper, to load the assemblies.</span></span> <span data-ttu-id="2ed35-138">信頼性の低いコードに対して、ラッパーへの呼び出し元のアクセス許可より高いアクセス許可が付与されているコードの読み込みを許可しないでください。</span><span class="sxs-lookup"><span data-stu-id="2ed35-138">Don't allow less-trusted code to load code that is granted higher permissions than those of the caller to your wrapper.</span></span>  
  
 <span data-ttu-id="2ed35-139">完全な信頼のあるコード、または潜在的な呼び出し元 (インターネット アクセス許可レベルの呼び出し元など) よりも信頼が高いコードであっても、こうした方法でセキュリティが弱体化する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="2ed35-139">Any code that has full trust or significantly higher trust than a potential caller (including an Internet-permissions-level caller) could weaken security in this way.</span></span> <span data-ttu-id="2ed35-140">コードに、バイト配列を受け取って、それを **Assembly.Load** に渡すパブリック メソッドが含まれる場合、そうした呼び出し元のためにアセンブリを作成すると、セキュリティが破られる恐れがあります。</span><span class="sxs-lookup"><span data-stu-id="2ed35-140">If your code has a public method that takes a byte array and passes it to **Assembly.Load**, thereby creating an assembly on the caller's behalf, it might break security.</span></span>  
  
 <span data-ttu-id="2ed35-141">この問題は、次の API 要素に当てはまります。</span><span class="sxs-lookup"><span data-stu-id="2ed35-141">This issue applies to the following API elements:</span></span>  
  
- <xref:System.AppDomain.DefineDynamicAssembly%2A?displayProperty=nameWithType>  
  
- <xref:System.AppDomain.Load%2A?displayProperty=nameWithType>  
  
- <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>  
  
- <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>  
  
## <a name="demand-vs-linkdemand"></a><span data-ttu-id="2ed35-142">Demand とLinkDemand</span><span class="sxs-lookup"><span data-stu-id="2ed35-142">Demand vs. LinkDemand</span></span>  

 <span data-ttu-id="2ed35-143">宣言型セキュリティには 2 種類のセキュリティ チェックがあり、どちらも似ていますが、実行するチェックが異なります。</span><span class="sxs-lookup"><span data-stu-id="2ed35-143">Declarative security offers two kinds of security checks that are similar but perform different checks.</span></span> <span data-ttu-id="2ed35-144">選択を誤るとセキュリティの脆弱性やパフォーマンスの低下を招くことがあるため、両方の形式について理解することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="2ed35-144">It's good to understand both forms, because the wrong choice can result in weak security or performance loss.</span></span>  
  
 <span data-ttu-id="2ed35-145">宣言型のセキュリティには、次のセキュリティ チェックがあります。</span><span class="sxs-lookup"><span data-stu-id="2ed35-145">Declarative security offers the following security checks:</span></span>  
  
- <span data-ttu-id="2ed35-146"><xref:System.Security.Permissions.SecurityAction.Demand> はコード アクセス セキュリティのスタック ウォークを指定します。</span><span class="sxs-lookup"><span data-stu-id="2ed35-146"><xref:System.Security.Permissions.SecurityAction.Demand> specifies the code access security stack walk.</span></span> <span data-ttu-id="2ed35-147">スタック上の各呼び出し元が合格するには、指定のアクセス許可または ID が必要です。</span><span class="sxs-lookup"><span data-stu-id="2ed35-147">All callers on the stack must have the specified permission or identity to pass.</span></span> <span data-ttu-id="2ed35-148">スタックには異なる呼び出し元が含まれている可能性があるため、**Demand** は呼び出しごとに生じます。</span><span class="sxs-lookup"><span data-stu-id="2ed35-148">**Demand** occurs on every call because the stack might contain different callers.</span></span> <span data-ttu-id="2ed35-149">メソッドを繰り返し呼び出す場合は、このセキュリティ チェックが毎回行われます。</span><span class="sxs-lookup"><span data-stu-id="2ed35-149">If you call a method repeatedly, this security check occurs each time.</span></span> <span data-ttu-id="2ed35-150">**Demand** はおびき寄せによる攻撃に対して優れた保護となります。送り込まれようとする未承認のコードが検出されます。</span><span class="sxs-lookup"><span data-stu-id="2ed35-150">**Demand** is good protection against luring attacks; unauthorized code trying to get through it will be detected.</span></span>  
  
- <span data-ttu-id="2ed35-151">[LinkDemand](link-demands.md) は JIT (Just-In-Time) コンパイル時に生じて、直接の呼び出し元だけをチェックします。</span><span class="sxs-lookup"><span data-stu-id="2ed35-151">[LinkDemand](link-demands.md) happens at just-in-time (JIT) compilation time and checks only the immediate caller.</span></span> <span data-ttu-id="2ed35-152">このセキュリティ チェックでは、呼び出し元の呼び出し元はチェックされません。</span><span class="sxs-lookup"><span data-stu-id="2ed35-152">This security check does not check the caller's caller.</span></span> <span data-ttu-id="2ed35-153">このチェックに合格すると、呼び出し元が何度も呼び出す場合であってもさらにセキュリティ オーバーヘッドが生じることはありません。</span><span class="sxs-lookup"><span data-stu-id="2ed35-153">Once this check passes, there is no additional security overhead no matter how many times the caller might call.</span></span> <span data-ttu-id="2ed35-154">ただし、おびき寄せによる攻撃からの保護機能はありません。</span><span class="sxs-lookup"><span data-stu-id="2ed35-154">However, there is also no protection from luring attacks.</span></span> <span data-ttu-id="2ed35-155">**LinkDemand** を使用すると、テストに合格し、ご使用のコードを参照可能なすべてのコードで、セキュリティが破られるおそれが生じます。つまり、悪意のあるコードに対して、承認済みのコードを使用した呼び出しが許可される場合です。</span><span class="sxs-lookup"><span data-stu-id="2ed35-155">With **LinkDemand**, any code that passes the test and can reference your code can potentially break security by allowing malicious code to call using the authorized code.</span></span> <span data-ttu-id="2ed35-156">そのため、可能性のあるすべての脆弱性を完全に回避できるのでない限り、**LinkDemand** を使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="2ed35-156">Therefore, do not use **LinkDemand** unless all the possible weaknesses can be thoroughly avoided.</span></span>  
  
    > [!NOTE]
    > <span data-ttu-id="2ed35-157">.NET Framework 4 では、<xref:System.Security.SecurityRuleSet.Level2> アセンブリの <xref:System.Security.SecurityCriticalAttribute> 属性によってリンク要求が置換されています。</span><span class="sxs-lookup"><span data-stu-id="2ed35-157">In the .NET Framework 4, link demands have been replaced by the <xref:System.Security.SecurityCriticalAttribute> attribute in <xref:System.Security.SecurityRuleSet.Level2> assemblies.</span></span> <span data-ttu-id="2ed35-158"><xref:System.Security.SecurityCriticalAttribute> は完全な信頼のリンク要求に相当しますが、継承ルールにも影響を及ぼします。</span><span class="sxs-lookup"><span data-stu-id="2ed35-158">The <xref:System.Security.SecurityCriticalAttribute> is equivalent to a link demand for full trust; however, it also affects inheritance rules.</span></span> <span data-ttu-id="2ed35-159">この変更の詳細については、「[透過的セキュリティ コード、レベル 2](security-transparent-code-level-2.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="2ed35-159">For more information about this change, see [Security-Transparent Code, Level 2](security-transparent-code-level-2.md).</span></span>  
  
 <span data-ttu-id="2ed35-160">**LinkDemand** を使用するときに必要な特別な措置は、個別にプログラミングする必要があります。セキュリティ システムが実施に役立つ可能性があります。</span><span class="sxs-lookup"><span data-stu-id="2ed35-160">The extra precautions required when using **LinkDemand** must be programmed individually; the security system can help with enforcement.</span></span> <span data-ttu-id="2ed35-161">どのようなミスもセキュリティを脆弱化します。</span><span class="sxs-lookup"><span data-stu-id="2ed35-161">Any mistake opens a security weakness.</span></span> <span data-ttu-id="2ed35-162">作成したコードを使用する、承認されたすべてのコード側で、次の措置を行うことによって追加セキュリティを実装する責任があります。</span><span class="sxs-lookup"><span data-stu-id="2ed35-162">All authorized code that uses your code must be responsible for implementing additional security by doing the following:</span></span>  
  
- <span data-ttu-id="2ed35-163">呼び出し元のコードがクラスまたはアセンブリにアクセスするのを制限します。</span><span class="sxs-lookup"><span data-stu-id="2ed35-163">Restricting the calling code's access to the class or assembly.</span></span>  
  
- <span data-ttu-id="2ed35-164">呼び出されるコードに現れる呼び出し元のコードで同じセキュリティ チェックを配置し、呼び出し元にその実行義務を課します。</span><span class="sxs-lookup"><span data-stu-id="2ed35-164">Placing the same security checks on the calling code that appear on the code being called and obligating its callers to do so.</span></span> <span data-ttu-id="2ed35-165">たとえば、<xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> フラグを指定した <xref:System.Security.Permissions.SecurityPermission> に関して **LinkDemand** で保護されたメソッドを呼び出すコードを作成する場合、ご使用のメソッドでもこのアクセス許可について **LinkDemand** (またはより強力な **Demand**) を実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="2ed35-165">For example, if you write code that calls a method that is protected with a **LinkDemand** for the <xref:System.Security.Permissions.SecurityPermission> with the <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> flag specified, your method should also make a **LinkDemand** (or **Demand**, which is stronger) for this permission.</span></span> <span data-ttu-id="2ed35-166">ただし、ご使用のコードで **LinkDemand** 保護されたメソッドを、安全だと判断した限定的な方法でのみ使用していて、コードに他のセキュリティ保護機能 (Demand など) がある場合は例外です。</span><span class="sxs-lookup"><span data-stu-id="2ed35-166">The exception is if your code uses the **LinkDemand**-protected method in a limited way that you decide is safe, given other security protection mechanisms (such as demands) in your code.</span></span> <span data-ttu-id="2ed35-167">前述の例外的なケースでは、呼び出し側で、基になるコードでのセキュリティ保護の脆弱性に対処する必要があります。</span><span class="sxs-lookup"><span data-stu-id="2ed35-167">In this exceptional case, the caller takes responsibility in weakening the security protection on the underlying code.</span></span>  
  
- <span data-ttu-id="2ed35-168">呼び出し元のコードが、呼び出し先のコードに成り代わって、保護されているコードを呼び出すことがないようにしてください。</span><span class="sxs-lookup"><span data-stu-id="2ed35-168">Ensuring that your code's callers cannot trick your code into calling the protected code on their behalf.</span></span> <span data-ttu-id="2ed35-169">つまり、呼び出し元は承認されたコードに対して、保護されているコードに特定のパラメーターを渡したり、結果を送り返させたりすることはできません。</span><span class="sxs-lookup"><span data-stu-id="2ed35-169">In other words, callers cannot force the authorized code to pass specific parameters to the protected code, or to get results back from it.</span></span>  
  
### <a name="interfaces-and-link-demands"></a><span data-ttu-id="2ed35-170">インターフェイスとリンク要求</span><span class="sxs-lookup"><span data-stu-id="2ed35-170">Interfaces and Link Demands</span></span>  

 <span data-ttu-id="2ed35-171">**LinkDemand** を使用した仮想メソッド、プロパティ、イベントによって基本クラス メソッドがオーバーライドされる場合、オーバーライド対象メソッドで有効になるように、その基本クラス メソッドにも同じ **LinkDemand** が必要です。</span><span class="sxs-lookup"><span data-stu-id="2ed35-171">If a virtual method, property, or event with **LinkDemand** overrides a base class method, the base class method must also have the same **LinkDemand** for the overridden method in order to be effective.</span></span> <span data-ttu-id="2ed35-172">悪意のあるコードが、基本型にキャスト バックを行い、基本クラスのメソッドを呼び出す可能性があります。</span><span class="sxs-lookup"><span data-stu-id="2ed35-172">It is possible for malicious code to cast back to the base type and call the base class method.</span></span> <span data-ttu-id="2ed35-173">リンク要求を、<xref:System.Security.AllowPartiallyTrustedCallersAttribute> アセンブリ レベル属性を持たないアセンブリに暗黙的に追加できるという点にも注意してください。</span><span class="sxs-lookup"><span data-stu-id="2ed35-173">Also note that link demands can be added implicitly to assemblies that do not have the <xref:System.Security.AllowPartiallyTrustedCallersAttribute> assembly-level attribute.</span></span>  
  
 <span data-ttu-id="2ed35-174">インターフェイス メソッドでリンク要求も指定されている場合は、メソッドの実装をリンク要求で保護するのは良い方法です。</span><span class="sxs-lookup"><span data-stu-id="2ed35-174">It is a good practice to protect method implementations with link demands when interface methods also have link demands.</span></span> <span data-ttu-id="2ed35-175">リンク要求をインターフェイスと一緒に使用する場合、以下の点に注意してください。</span><span class="sxs-lookup"><span data-stu-id="2ed35-175">Note the following about using link demands with interfaces:</span></span>  
  
- <span data-ttu-id="2ed35-176">インターフェイス メソッドを実装するクラスのパブリック メソッドに **LinkDemand** を配置すると、そのインターフェイスをキャストしてメソッドを呼び出すときに **LinkDemand** は実施されません。</span><span class="sxs-lookup"><span data-stu-id="2ed35-176">If you place a **LinkDemand** on a public method of a class that implements an interface method, the **LinkDemand** will not be enforced if you then cast to the interface and call the method.</span></span> <span data-ttu-id="2ed35-177">この場合、インターフェイスに対してリンクされているため、インターフェイス上の **LinkDemand** のみが実行されます。</span><span class="sxs-lookup"><span data-stu-id="2ed35-177">In this case, because you linked against the interface, only the **LinkDemand** on the interface is honored.</span></span>  
  
 <span data-ttu-id="2ed35-178">セキュリティの問題に関して次の項目をレビューします。</span><span class="sxs-lookup"><span data-stu-id="2ed35-178">Review the following items for security issues:</span></span>  
  
- <span data-ttu-id="2ed35-179">インターフェイス メソッドでのリンク要求を明示的に指定します。</span><span class="sxs-lookup"><span data-stu-id="2ed35-179">Explicit link demands on interface methods.</span></span> <span data-ttu-id="2ed35-180">こうしたリンク要求が期待どおりの保護を提供することを確認します。</span><span class="sxs-lookup"><span data-stu-id="2ed35-180">Make sure these link demands offer the expected protection.</span></span> <span data-ttu-id="2ed35-181">悪意のあるコードがキャストを使用して、前述のようにリンク要求を迂回できるかどうかを判別します。</span><span class="sxs-lookup"><span data-stu-id="2ed35-181">Determine whether malicious code can use a cast to get around the link demands as described previously.</span></span>  
  
- <span data-ttu-id="2ed35-182">リンク要求が適用される仮想メソッド。</span><span class="sxs-lookup"><span data-stu-id="2ed35-182">Virtual methods with link demands applied.</span></span>  
  
- <span data-ttu-id="2ed35-183">実装する型とインターフェイス。</span><span class="sxs-lookup"><span data-stu-id="2ed35-183">Types and the interfaces they implement.</span></span> <span data-ttu-id="2ed35-184">一貫してリンク要求を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="2ed35-184">These should use link demands consistently.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="2ed35-185">関連項目</span><span class="sxs-lookup"><span data-stu-id="2ed35-185">See also</span></span>

- [<span data-ttu-id="2ed35-186">安全なコーディングのガイドライン</span><span class="sxs-lookup"><span data-stu-id="2ed35-186">Secure Coding Guidelines</span></span>](../../standard/security/secure-coding-guidelines.md)
