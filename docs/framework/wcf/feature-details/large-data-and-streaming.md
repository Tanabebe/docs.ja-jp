---
title: 大規模データとストリーミング
description: WCF XML ベースの通信、エンコーダー、およびストリーミング データ (バイナリ データの転送など) に関する考慮事項について説明します。
ms.date: 03/30/2017
ms.assetid: ab2851f5-966b-4549-80ab-c94c5c0502d2
ms.openlocfilehash: 09e020801486c09c027883fca3d67a6c2e2fe8d7
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/26/2020
ms.locfileid: "96234701"
---
# <a name="large-data-and-streaming"></a><span data-ttu-id="24248-103">大規模データとストリーミング</span><span class="sxs-lookup"><span data-stu-id="24248-103">Large Data and Streaming</span></span>

<span data-ttu-id="24248-104">Windows Communication Foundation (WCF) は、XML ベースの通信インフラストラクチャです。</span><span class="sxs-lookup"><span data-stu-id="24248-104">Windows Communication Foundation (WCF) is an XML-based communications infrastructure.</span></span> <span data-ttu-id="24248-105">XML データは通常、[XML 1.0 仕様](https://www.w3.org/TR/REC-xml/)で定義された標準テキスト形式でエンコードされるので、接続されたシステムの開発者および設計者にとって共通の関心事は、ネットワーク経由で送信されるメッセージのネットワーク フットプリント (サイズ) です。XML のエンコーディングをテキスト ベースで行う一方で、バイナリ データを効率的に転送することは容易ではありません。</span><span class="sxs-lookup"><span data-stu-id="24248-105">Because XML data is commonly encoded in the standard text format defined in the [XML 1.0 specification](https://www.w3.org/TR/REC-xml/), connected systems developers and architects are typically concerned about the wire footprint (or size) of messages sent across the network, and the text-based encoding of XML poses special challenges for the efficient transfer of binary data.</span></span>  
  
## <a name="basic-considerations"></a><span data-ttu-id="24248-106">基本的な考慮事項</span><span class="sxs-lookup"><span data-stu-id="24248-106">Basic Considerations</span></span>  

 <span data-ttu-id="24248-107">後で示される WCF の情報に関する背景情報として、接続されたシステムのインフラストラクチャ全般に当てはまる、エンコーディング、バイナリ データ、およびストリーミングに関する一般的な注意点や考慮事項から説明します。</span><span class="sxs-lookup"><span data-stu-id="24248-107">To provide background information about the following information for WCF, this section highlights some general concerns and considerations for encodings, binary data, and streaming that generally apply to connected systems infrastructures.</span></span>  
  
### <a name="encoding-data-text-vs-binary"></a><span data-ttu-id="24248-108">データのエンコーディング : テキストとバイナリ</span><span class="sxs-lookup"><span data-stu-id="24248-108">Encoding Data: Text vs. Binary</span></span>  

 <span data-ttu-id="24248-109">開発者が揃って口にする懸念には、開始タグと終了タグが繰り返し使用される XML では、バイナリ形式と比較してオーバーヘッドが大きくなるのではないか、数値のエンコーディングは、数値をテキスト値で表現するのでサイズが膨れ上がるのではないか、バイナリ データをテキスト形式に埋め込むためには特別なエンコーディングが必要なので、バイナリ データを効率的に表現することはできないのではないか、などがあります。</span><span class="sxs-lookup"><span data-stu-id="24248-109">Commonly expressed developer concerns include the perception that XML has significant overhead when compared to binary formats due to the repetitive nature of start tags and end tags, that the encoding of numerical values is considered to be significantly larger because they are expressed in text values, and that binary data cannot be expressed efficiently because it must be specially encoded for embedding into a text format.</span></span>  
  
 <span data-ttu-id="24248-110">このような懸念の多くは当然ではありますが、XML Web サービス環境で XML のテキスト エンコードされたメッセージと、従来のリモート プロシージャ コール (RPC) 環境でバイナリ エンコードされたメッセージとの間の実際の相違は、それほど大きくありません。</span><span class="sxs-lookup"><span data-stu-id="24248-110">While many of these and similar concerns are valid, the actual difference between XML-text encoded messages in an XML Web services environment and binary-encoded messages in a legacy remote procedure call (RPC) environment is often much less significant than the initial consideration might suggest.</span></span>  
  
 <span data-ttu-id="24248-111">XML のテキスト エンコードされたメッセージは、透過的であり、ユーザーが "読める" のに比べ、バイナリ メッセージのほとんどはわかりにくく、ツールなしでデコードすることは困難です。</span><span class="sxs-lookup"><span data-stu-id="24248-111">While XML-text encoded messages are transparent and "human readable", binary messages are often fairly obscure in comparison and difficult to decode without tools.</span></span> <span data-ttu-id="24248-112">このような読みやすさの違いから見過ごされる点は、バイナリ メッセージにはペイロードにインライン メタデータも含まれている場合が多く、これによって、XML テキスト メッセージと同様のオーバーヘッドが追加されるという事実です。</span><span class="sxs-lookup"><span data-stu-id="24248-112">This difference in legibility leads one to overlook that binary messages also often carry inline metadata in the payload, which adds overhead just as with XML text messages.</span></span> <span data-ttu-id="24248-113">これは特に、疎結合および動的呼び出しの実現を目的としたバイナリ形式に当てはまります。</span><span class="sxs-lookup"><span data-stu-id="24248-113">This is specifically true for binary formats that aim to provide loose-coupling and dynamic invocation capabilities.</span></span>  
  
 <span data-ttu-id="24248-114">ただし、バイナリ形式では、これらのメタデータ記述情報が "ヘッダー" に格納されるのが普通です。ヘッダーでは、後続のデータ レコードに関するデータ レイアウトも宣言します。</span><span class="sxs-lookup"><span data-stu-id="24248-114">However, binary formats commonly carry such descriptive metadata information in a "header," which also declares the data layout for the following data records.</span></span> <span data-ttu-id="24248-115">この共通メタデータ ブロック宣言の後に続くペイロードに伴うオーバーヘッドは最小限です。</span><span class="sxs-lookup"><span data-stu-id="24248-115">The payload then follows this common metadata block declaration with minimal further overhead.</span></span> <span data-ttu-id="24248-116">一方、XML では、各データ項目は要素または属性に囲まれ、外側のメタデータはシリアル化されたペイロード オブジェクトごとに、繰り返し含められます。</span><span class="sxs-lookup"><span data-stu-id="24248-116">In contrast, XML encloses each data item in an element or attribute so that the enclosing metadata is repetitively included for each serialized payload object.</span></span> <span data-ttu-id="24248-117">これらのことと、一部のメタデータ記述はテキストとバイナリの両方に対して必要になることを考えると、シリアル化するペイロード オブジェクトが 1 つであれば、テキスト表現とバイナリ表現のサイズは同様になることがわかります。ただしバイナリ形式の方が全体のオーバーヘッドが低いため、転送するペイロード オブジェクトの数が増えるごとに、共通のメタデータ記述によるメリットが生じます。</span><span class="sxs-lookup"><span data-stu-id="24248-117">As a result, the size of a single serialized payload object is similar when comparing text to binary representations as some descriptive metadata must be expressed for both, but the binary format benefits from the shared metadata description with each additional payload object that is transferred due to the lower overall overhead.</span></span>  
  
 <span data-ttu-id="24248-118">数値など特定のデータ型では、プレーンテキストの代わりに 128 ビットの decimal 型など固定サイズのバイナリ数値表現を使用するデメリットもあります。プレーンテキスト表現を使用すると何バイトか小さくなる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="24248-118">Still, for certain data types, such as numbers, there might be a disadvantage to using fixed-size, binary numerical representations, such as a 128-bit decimal type instead of plain text, as the plain text representation might be several bytes smaller.</span></span> <span data-ttu-id="24248-119">また、テキスト データには、より柔軟性に優れた XML テキスト エンコーディングのオプションから選択できることによるメリットがあります。一方、一部のバイナリ形式では、16 ビットまたは 32 ビットの Unicode が既定値として設定されている場合があります (これは、.NET Binary XML 形式には当てはまりません)。</span><span class="sxs-lookup"><span data-stu-id="24248-119">Text data also might have size benefits from the typically more flexible XML text encoding choices, while some binary formats might default to 16-bit or even 32-bit Unicode, which does not apply to the .NET Binary XML Format.</span></span>  
  
 <span data-ttu-id="24248-120">したがって、テキストかバイナリかを決定する場合、バイナリ メッセージは常に XML テキスト メッセージよりも小さいという推測に基づいて簡単に決めることはできません。</span><span class="sxs-lookup"><span data-stu-id="24248-120">As a result, deciding between text or binary is not quite as easy as assuming that binary messages are always smaller than XML-text messages.</span></span>  
  
 <span data-ttu-id="24248-121">XML テキスト メッセージは、標準ベースのメッセージであるため、きわめて広範囲な相互運用性オプションとプラットフォーム サポートが提供されるという明確な利点があります。</span><span class="sxs-lookup"><span data-stu-id="24248-121">A clear advantage of XML-text messages is that they are standards-based and offer the broadest choice of interoperability options and platform support.</span></span> <span data-ttu-id="24248-122">詳細については、このトピックで後述する「エンコーディング」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="24248-122">For more information, see the "Encodings" section later in this topic.</span></span>  
  
### <a name="binary-content"></a><span data-ttu-id="24248-123">バイナリ コンテンツ</span><span class="sxs-lookup"><span data-stu-id="24248-123">Binary Content</span></span>  

 <span data-ttu-id="24248-124">写真、ビデオ、サウンド クリップのほか、サービスとコンシューマーとの間で交換される他の不透明な形式のバイナリ データなど、サイズの大きいバイナリ データ項目の場合、生成されるメッセージ サイズに関しては、テキスト ベースのエンコーディングよりバイナリ エンコーディングの方が優れています。</span><span class="sxs-lookup"><span data-stu-id="24248-124">One area where binary encodings are superior to text-based encodings in terms of the resulting message size are large binary data items such as pictures, videos, sound clips, or any other form of opaque, binary data that must be exchanged between services and their consumers.</span></span> <span data-ttu-id="24248-125">このようなデータを XML テキストに格納するには、Base64 エンコーディングを使用してそのデータをエンコードするのが一般的です。</span><span class="sxs-lookup"><span data-stu-id="24248-125">To fit these types of data into XML text, the common approach is to encode them using the Base64 encoding.</span></span>  
  
 <span data-ttu-id="24248-126">Base64 でエンコードされた文字列では、各文字で元の 8 ビット データのうち 6 ビット分を表すので、その結果、Base64 ではエンコーディングとオーバーヘッドの比率が 4:3 になります。このとき、通常追加される書式設定文字 (復帰とライン フィード) は計算に入れていません。</span><span class="sxs-lookup"><span data-stu-id="24248-126">In a Base64-encoded string, each character represents 6-bits of the original 8-bit data, which results in a 4:3 encoding-overhead ratio for Base64, not counting extra formatting characters (carriage return/line feed) that are commonly added by convention.</span></span> <span data-ttu-id="24248-127">XML エンコーディングとバイナリ エンコーディングとの間の相違の大きさは、通常、シナリオによって異なりますが、500 MB のペイロードを送信するときにサイズの増加率が 33% を超えることは、受け入れられません。</span><span class="sxs-lookup"><span data-stu-id="24248-127">While the significance of the differences between XML and binary encodings typically depends on the scenario, a size gain of more than 33% when transmitting a 500-MB payload is usually not acceptable.</span></span>  
  
 <span data-ttu-id="24248-128">このようなエンコーディングのオーバーヘッドを回避するには、MTOM (Message Transmission Optimization Mechanism) 規格を使用すると、特別なエンコーディングを行うことなく、メッセージに含まれている大きいデータ要素を外部化し、それをバイナリ データとしてメッセージと共に送信できます。</span><span class="sxs-lookup"><span data-stu-id="24248-128">To avoid this encoding overhead, the Message Transmission Optimization Mechanism (MTOM) standard allows for externalizing large data elements that are contained in a message and carrying them with the message as binary data without any special encoding.</span></span> <span data-ttu-id="24248-129">MTOM でメッセージを交換する方法は、添付ファイルや埋め込みコンテンツ (写真やその他の埋め込みコンテンツ) が付属している簡易メール転送プロトコル (SMTP) 電子メール メッセージを交換する方法と似ています。MTOM メッセージは multipart/related MIME シーケンスとしてパッケージ化され、ルート パートが実際の SOAP メッセージになります。</span><span class="sxs-lookup"><span data-stu-id="24248-129">With MTOM, messages are exchanged in a similar fashion to Simple Mail Transfer Protocol (SMTP) email messages with attachments or embedded content (pictures and other embedded content); MTOM messages are packaged as multipart/related MIME sequences with the root part being the actual SOAP message.</span></span>  
  
 <span data-ttu-id="24248-130">MTOM SOAP メッセージが、エンコードされていないバージョンと異なるのは、メッセージ内でバイナリ データを含んでいた元の要素の代わりに、それぞれの MIME パートを参照している特別な要素タグが配置される点です。</span><span class="sxs-lookup"><span data-stu-id="24248-130">An MTOM SOAP message is modified from its un-encoded version so that special element tags that refer to the respective MIME parts take the place of the original elements in the message that contained binary data.</span></span> <span data-ttu-id="24248-131">つまり SOAP メッセージでは、メッセージと共に送信される MIME パートを指すことによってバイナリ コンテンツが参照されますが、含まれているのは XML テキスト データのみです。</span><span class="sxs-lookup"><span data-stu-id="24248-131">As a result, the SOAP message refers to binary content by pointing to the MIME parts sent with it, but otherwise just carries XML text data.</span></span> <span data-ttu-id="24248-132">このモデルは、広く確立している SMTP モデルに厳密に適合するように作成されています。このため、さまざまなプラットフォームで、MTOM メッセージをエンコードまたはデコードするための幅広いツール サポートが提供され、きわめて高い相互運用性が確保されています。</span><span class="sxs-lookup"><span data-stu-id="24248-132">Because this model is closely aligned with the well-established SMTP model, there is broad tooling support to encode and decode MTOM messages on many platforms, which makes it an extremely interoperable choice.</span></span>  
  
 <span data-ttu-id="24248-133">ただし MTOM でも Base64 の場合と同様、MIME 形式をサポートするためのオーバーヘッドが伴います。このため、MTOM を使用するメリットが現れるのは、バイナリ データ要素のサイズが約 1 KB を超える場合だけです。</span><span class="sxs-lookup"><span data-stu-id="24248-133">Still, as with Base64, MTOM also comes with some necessary overhead for the MIME format, so that advantages of using MTOM are only seen when the size of a binary data element exceeds about 1 KB.</span></span> <span data-ttu-id="24248-134">バイナリ ペイロードが 1 KB を下回る場合は、このオーバーヘッドが原因で、バイナリ データに Base64 エンコーディングを使用したメッセージよりも、エンコード済みの MTOM メッセージの方が大きくなる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="24248-134">Due to the overhead, MTOM-encoded messages might be larger than messages that use Base64 encoding for binary data, if the binary payload remains under that threshold.</span></span> <span data-ttu-id="24248-135">詳細については、このトピックで後述する「エンコーディング」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="24248-135">For more information, see the "Encodings" section later in this topic.</span></span>  
  
### <a name="large-data-content"></a><span data-ttu-id="24248-136">大規模データ コンテンツ</span><span class="sxs-lookup"><span data-stu-id="24248-136">Large Data Content</span></span>  

 <span data-ttu-id="24248-137">ネットワーク フットプリントとは別に、前述の例のようにペイロードが 500 MB であれば、サービスとクライアントにもローカルの問題が生じます。</span><span class="sxs-lookup"><span data-stu-id="24248-137">Wire-footprint aside, the previously mentioned 500-MB payload also poses a great local challenge at for the service and the client.</span></span> <span data-ttu-id="24248-138">WCF の既定では、メッセージが "*バッファー モード*" で処理されます。</span><span class="sxs-lookup"><span data-stu-id="24248-138">By default, WCF processes messages in *buffered mode*.</span></span> <span data-ttu-id="24248-139">つまり、メッセージ コンテンツ全体が、送信前にも受信後にもメモリに存在します。</span><span class="sxs-lookup"><span data-stu-id="24248-139">This means that the entire content of a message is present in memory before it is sent or after it is received.</span></span> <span data-ttu-id="24248-140">この方式は、ほとんどのシナリオに対して有効であり、デジタル署名や信頼できる配信などのメッセージング機能には必要ですが、メッセージが大きいと、システムのリソースが使い果たされてしまう可能性があります。</span><span class="sxs-lookup"><span data-stu-id="24248-140">While that is a good strategy for most scenarios, and necessary for messaging features such as digital signatures and reliable delivery, large messages could exhaust a system's resources.</span></span>  
  
 <span data-ttu-id="24248-141">ペイロードが大きい場合、有効な処理方法は、ストリーミングです。</span><span class="sxs-lookup"><span data-stu-id="24248-141">The strategy to deal with large payloads is streaming.</span></span> <span data-ttu-id="24248-142">メッセージ、特に XML で表現されているメッセージは一般的に、比較的小型のデータ パッケージであると思われがちですが、メッセージのサイズは数ギガバイトになることもあり、データ パッケージというよりも連続したデータ ストリームに似ています。</span><span class="sxs-lookup"><span data-stu-id="24248-142">While messages, especially those expressed in XML, are commonly thought of as being relatively compact data packages, a message might be multiple gigabytes in size and resemble a continuous data stream more than a data package.</span></span> <span data-ttu-id="24248-143">バッファー モードではなく、ストリーミング モードでデータを転送する場合、送信側が、メッセージ本体のコンテンツをストリームの形で受信側に対して準備します。続いてメッセージ インフラストラクチャは、このデータの準備が整い次第、送信側から受信側にデータを転送します。</span><span class="sxs-lookup"><span data-stu-id="24248-143">When data is transferred in streaming mode instead of buffered mode, the sender makes the contents of the message body available to the recipient in the form of a stream and the message infrastructure continuously forwards the data from sender to receiver as it becomes available.</span></span>  
  
 <span data-ttu-id="24248-144">このような大きいデータ コンテンツの転送が発生する最も一般的なシナリオは、次のようなバイナリ データ オブジェクトの転送です。</span><span class="sxs-lookup"><span data-stu-id="24248-144">The most common scenario in which such large data content transfers occur are transfers of binary data objects that:</span></span>  
  
- <span data-ttu-id="24248-145">簡単にメッセージ シーケンスに分割できないバイナリ データ オブジェクト</span><span class="sxs-lookup"><span data-stu-id="24248-145">Cannot be easily broken up into a message sequence.</span></span>  
  
- <span data-ttu-id="24248-146">タイムリーに配信する必要があるバイナリ データ オブジェクト</span><span class="sxs-lookup"><span data-stu-id="24248-146">Must be delivered in a timely manner.</span></span>  
  
- <span data-ttu-id="24248-147">転送の開始時に完全な形で準備されていないバイナリ データ オブジェクト</span><span class="sxs-lookup"><span data-stu-id="24248-147">Are not available in their entirety when the transfer is initiated.</span></span>  
  
 <span data-ttu-id="24248-148">通常、データにこのような制約がない場合は、1 つの大きいメッセージではなく、セッションの有効範囲内でメッセージ シーケンスを送信することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="24248-148">For data that does not have these constraints, it is typically better to send sequences of messages within the scope of a session than one large message.</span></span> <span data-ttu-id="24248-149">詳細については、このトピックで後述する「データのストリーミング」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="24248-149">For more information, see the "Streaming Data" section later in this topic.</span></span>  
  
 <span data-ttu-id="24248-150">大量のデータを送信する場合は、`maxAllowedContentLength` の IIS 設定 (詳細については、[IIS 要求の制限の構成](/iis/configuration/system.webServer/security/requestFiltering/requestLimits/)に関するページを参照してください) および `maxReceivedMessageSize` のバインディング設定 ([System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) や <xref:System.ServiceModel.NetTcpBinding.MaxReceivedMessageSize%2A> など) を行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="24248-150">When sending large amounts of data you will need to set the `maxAllowedContentLength` IIS setting (for more information see [Configuring IIS Request Limits](/iis/configuration/system.webServer/security/requestFiltering/requestLimits/)) and the `maxReceivedMessageSize` binding setting (for example [System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) or <xref:System.ServiceModel.NetTcpBinding.MaxReceivedMessageSize%2A>).</span></span> <span data-ttu-id="24248-151">`maxAllowedContentLength` プロパティの既定値は 28.6 MB で、`maxReceivedMessageSize` プロパティの既定値は 64 KB です。</span><span class="sxs-lookup"><span data-stu-id="24248-151">The `maxAllowedContentLength` property defaults to 28.6 MB and the `maxReceivedMessageSize` property defaults to 64KB.</span></span>  
  
## <a name="encodings"></a><span data-ttu-id="24248-152">エンコーディング</span><span class="sxs-lookup"><span data-stu-id="24248-152">Encodings</span></span>  

 <span data-ttu-id="24248-153">"*エンコーディング*" とは、ネットワーク上でのメッセージの表示方法に関する一連の規則を定義したものです。</span><span class="sxs-lookup"><span data-stu-id="24248-153">An *encoding* defines a set of rules about how to present messages on the wire.</span></span> <span data-ttu-id="24248-154">"*エンコーダー*" はこのようなエンコーディングを実装するもので、送信側では、メモリ内 <xref:System.ServiceModel.Channels.Message> を変換して、ネットワークで送信できるバイト ストリームまたはバイト バッファーにする役割を担います。</span><span class="sxs-lookup"><span data-stu-id="24248-154">An *encoder* implements such an encoding and is responsible, on the sender side, for turning an in-memory <xref:System.ServiceModel.Channels.Message> into a byte stream or byte buffer that can be sent across the network.</span></span> <span data-ttu-id="24248-155">受信側では、バイト シーケンスがエンコーダーによってメモリ内メッセージに変換されます。</span><span class="sxs-lookup"><span data-stu-id="24248-155">On the receiver side, the encoder turns a sequence of bytes into an in-memory message.</span></span>  
  
 <span data-ttu-id="24248-156">WCF には、3 つのエンコーダーが用意されています。開発者は、必要に応じて独自のエンコーダーを作成してプラグインすることもできます。</span><span class="sxs-lookup"><span data-stu-id="24248-156">WCF includes three encoders and allows you to write and plug in your own encoders, if necessary.</span></span>  
  
 <span data-ttu-id="24248-157">個々の標準バインディングには、構成済みのエンコーダーが含まれています。Net\* プレフィックスで始まるバインディングでは、(<xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> クラスを含めることで) バイナリ エンコーダーが使用されるのに対し、<xref:System.ServiceModel.BasicHttpBinding> クラスと <xref:System.ServiceModel.WSHttpBinding> クラスでは、既定で (<xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement> クラスを含めることで) テキスト メッセージ エンコーダーが使用されます。</span><span class="sxs-lookup"><span data-stu-id="24248-157">Each of the standard bindings includes a preconfigured encoder, whereby the bindings with the Net\* prefix use the binary encoder (by including the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> class) while the <xref:System.ServiceModel.BasicHttpBinding> and <xref:System.ServiceModel.WSHttpBinding> classes use the text message encoder (by means of the <xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement> class) by default.</span></span>  
  
|<span data-ttu-id="24248-158">エンコーダー バインド要素</span><span class="sxs-lookup"><span data-stu-id="24248-158">Encoder binding element</span></span>|<span data-ttu-id="24248-159">説明</span><span class="sxs-lookup"><span data-stu-id="24248-159">Description</span></span>|  
|-----------------------------|-----------------|  
|<xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement>|<span data-ttu-id="24248-160">テキスト メッセージ エンコーダーは、すべての HTTP ベースのバインディングに対する既定のエンコーダーで、相互運用性が特に重要になるカスタムのバインディングにも適しています。</span><span class="sxs-lookup"><span data-stu-id="24248-160">The text message encoder is the default encoder for all HTTP-based bindings and the appropriate choice for all custom bindings where interoperability is the highest concern.</span></span> <span data-ttu-id="24248-161">このエンコーダーで入出力が行われるのは、標準の SOAP 1.1/SOAP 1.2 テキスト メッセージであり、バイナリ データに対して特別な処理は行われません。</span><span class="sxs-lookup"><span data-stu-id="24248-161">This encoder reads and writes standard SOAP 1.1/SOAP 1.2 text messages with no special handling for binary data.</span></span> <span data-ttu-id="24248-162">メッセージの <xref:System.ServiceModel.Channels.MessageVersion?displayProperty=nameWithType> プロパティが <xref:System.ServiceModel.Channels.MessageVersion.None?displayProperty=nameWithType> に設定されている場合、出力から SOAP エンベロープ ラッパーが除去され、メッセージ本体のコンテンツだけがシリアル化されます。</span><span class="sxs-lookup"><span data-stu-id="24248-162">If the <xref:System.ServiceModel.Channels.MessageVersion?displayProperty=nameWithType> property of a message is set to <xref:System.ServiceModel.Channels.MessageVersion.None?displayProperty=nameWithType>, the SOAP envelope wrapper is omitted from the output and only the message body content is serialized.</span></span>|  
|<xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement>|<span data-ttu-id="24248-163">MTOM メッセージ エンコーダーは、バイナリ データに対する特別な処理を実装したテキスト エンコーダーです。このエンコーダーは、状況に応じた最適化を要するユーティリティなので、どの標準バインディングでも既定では使用されません。</span><span class="sxs-lookup"><span data-stu-id="24248-163">The MTOM message encoder is a text encoder that implements special handling for binary data and is not used by default in any of the standard bindings because it is strictly a case-by-case optimization utility.</span></span> <span data-ttu-id="24248-164">MTOM エンコーディングのメリットを生じるしきい値より大きいバイナリ データがメッセージにある場合、そのデータは、メッセージ エンベロープの後に続く MIME パートとして外部化されます。</span><span class="sxs-lookup"><span data-stu-id="24248-164">If the message contains binary data that exceeds a threshold where MTOM encoding yields a benefit, the data is externalized into a MIME part following the message envelope.</span></span> <span data-ttu-id="24248-165">このセクションの「MTOM の有効化」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="24248-165">See Enabling MTOM later in this section.</span></span>|  
|<xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>|<span data-ttu-id="24248-166">バイナリ メッセージ エンコーダーは、Net\* バインディングの既定のエンコーダーであり、送信側と受信側の両方が WCF をベースとしている場合にも適しています。</span><span class="sxs-lookup"><span data-stu-id="24248-166">The binary message encoder is the default encoder for the Net\* bindings and the appropriate choice whenever both communicating parties are based on WCF.</span></span> <span data-ttu-id="24248-167">バイナリ メッセージ エンコーダーでは、XML 情報セット (Infoset) を対象とした Microsoft 固有のバイナリ表現である .NET Binary XML 形式が使用されます。この形式ではバイナリ データがバイト ストリームとしてエンコードされ、通常は、同等の XML 1.0 表現よりもフットプリントが小さくなりきます。</span><span class="sxs-lookup"><span data-stu-id="24248-167">The binary message encoder uses the .NET Binary XML Format, a Microsoft-specific binary representation for XML Information Sets (Infosets) that generally yields a smaller footprint than the equivalent XML 1.0 representation and encodes binary data as a byte stream.</span></span>|  
  
 <span data-ttu-id="24248-168">相互運用性が要求される通信パスでは一般的にテキスト メッセージ エンコーディングが最適であり、それ以外の通信パスではバイナリ メッセージ エンコーディングが最適です。</span><span class="sxs-lookup"><span data-stu-id="24248-168">Text message encoding is typically the best choice for any communication path that requires interoperability, while binary message encoding is the best choice for any other communication path.</span></span> <span data-ttu-id="24248-169">バイナリ メッセージ エンコーディングで生成されるメッセージのサイズは、単一のメッセージであればテキストより小さくなることが普通ですが、通信セッションの間に、さらに小さくなっていきます。</span><span class="sxs-lookup"><span data-stu-id="24248-169">Binary message encoding typically yields smaller message sizes compared to text for a single message and progressively even smaller message sizes over the duration of a communication session.</span></span> <span data-ttu-id="24248-170">テキスト エンコーディングと異なり、バイナリ エンコーディングでは、Base64 を使用するなど、バイナリ データに対する特別な処理を行う必要がありません。このエンコーディングでは、バイトがバイトとして表現されます。</span><span class="sxs-lookup"><span data-stu-id="24248-170">Unlike text encoding, binary encoding does not have to use special handling for binary data, such as using Base64, but represents bytes as bytes.</span></span>  
  
 <span data-ttu-id="24248-171">ソリューションで、相互運用性は必要ではないが、HTTP トランスポートを使用する場合は、トランスポートとして <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> クラスを使用するカスタム バインディングに <xref:System.ServiceModel.Channels.HttpTransportBindingElement> を組み込むことができます。</span><span class="sxs-lookup"><span data-stu-id="24248-171">If your solution does not require interoperability, but you still want to use HTTP transport, you can compose the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> into a custom binding that uses the <xref:System.ServiceModel.Channels.HttpTransportBindingElement> class for the transport.</span></span> <span data-ttu-id="24248-172">サービスを利用する多数のクライアントが相互運用性を必要とする場合は、両者にとって適切な種類のトランスポートとエンコーディングがそれぞれに有効化された並行エンドポイントを公開することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="24248-172">If a number of clients on your service require interoperability, it is recommended that you expose parallel endpoints that each has the appropriate transport and encoding choices for the respective clients enabled.</span></span>  
  
### <a name="enabling-mtom"></a><span data-ttu-id="24248-173">MTOM の有効化</span><span class="sxs-lookup"><span data-stu-id="24248-173">Enabling MTOM</span></span>  

 <span data-ttu-id="24248-174">相互運用性が必須である一方で、大きなバイナリ データを送信する必要がある場合、エンコーディング方法のもう 1 つの選択肢に、MTOM メッセージ エンコーディングがあります。このエンコーディングを有効化するには、標準の <xref:System.ServiceModel.BasicHttpBinding> バインディングまたは <xref:System.ServiceModel.WSHttpBinding> バインディングでそれぞれの `MessageEncoding` プロパティを <xref:System.ServiceModel.WSMessageEncoding.Mtom> に設定するか、<xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement> に <xref:System.ServiceModel.Channels.CustomBinding> を組み込みます。</span><span class="sxs-lookup"><span data-stu-id="24248-174">When interoperability is a requirement and large binary data must be sent, then MTOM message encoding is the alternative encoding strategy that you can enable on the standard <xref:System.ServiceModel.BasicHttpBinding> or <xref:System.ServiceModel.WSHttpBinding> bindings by setting the respective `MessageEncoding` property to <xref:System.ServiceModel.WSMessageEncoding.Mtom> or by composing the <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement> into a <xref:System.ServiceModel.Channels.CustomBinding>.</span></span> <span data-ttu-id="24248-175">次のコード例は、「[MTOM エンコーディング](../samples/mtom-encoding.md)」のサンプルからの抜粋であり、構成で MTOM を有効化する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="24248-175">The following example code, extracted from the [MTOM Encoding](../samples/mtom-encoding.md) sample demonstrates how to enable MTOM in configuration.</span></span>  
  
```xml  
<system.serviceModel>  
     …  
    <bindings>  
      <wsHttpBinding>  
        <binding name="ExampleBinding" messageEncoding="Mtom"/>  
      </wsHttpBinding>  
    </bindings>  
     …  
</system.serviceModel>  
```  
  
 <span data-ttu-id="24248-176">前述のように、MTOM エンコーディングの使用が適しているかどうかは、送信するデータ量によって異なります。</span><span class="sxs-lookup"><span data-stu-id="24248-176">As mentioned earlier, the decision to use MTOM encoding depends on the data volume you are sending.</span></span> <span data-ttu-id="24248-177">また、MTOM はバインディング レベルで有効になるので、MTOM を有効にすると、個々のエンドポイント上のすべての操作に作用します。</span><span class="sxs-lookup"><span data-stu-id="24248-177">Also, because MTOM is enabled at the binding level, enabling MTOM affects all operations on a given endpoint.</span></span>  
  
 <span data-ttu-id="24248-178">MTOM エンコーダーでは、バイナリ データが最終的に外部化されるかどうかに関係なく、MTOM エンコードされた MIME/multipart メッセージが常に出力されるので、通常は、1 KB を超えるバイナリ データを含んだメッセージの交換が行われるエンドポイントに対してのみ、MTOM を有効にしてください。</span><span class="sxs-lookup"><span data-stu-id="24248-178">Because the MTOM encoder always emits an MTOM-encoded MIME/multi-part message regardless of whether binary data ends up being externalized, you should generally only enable MTOM for endpoints that exchange messages with more than 1 KB of binary data.</span></span> <span data-ttu-id="24248-179">また、MTOM が有効化されたエンドポイント用に設計されたサービス コントラクトは、可能であれば、このようなデータ転送操作を指定するように制限してください。</span><span class="sxs-lookup"><span data-stu-id="24248-179">Also, the service contracts designed for use with MTOM-enabled endpoints should, when possible, be constrained to specifying such data transfer operations.</span></span> <span data-ttu-id="24248-180">関連する制御機能は別のコントラクトに記述するようにしてください。</span><span class="sxs-lookup"><span data-stu-id="24248-180">Related control functionality should reside on a separate contract.</span></span> <span data-ttu-id="24248-181">この "MTOM のみ" の規則が当てはまるのは、MTOM が有効化されたエンドポイントを経由して送信されるメッセージだけです。MTOM 以外の受信メッセージについては、MTOM エンコーダーによって同様にデコードおよび解析されます。</span><span class="sxs-lookup"><span data-stu-id="24248-181">This "MTOM-only" rule applies only to messages sent through an MTOM-enabled endpoint; the MTOM-encoder can decode and parse incoming non-MTOM messages as well.</span></span>  
  
 <span data-ttu-id="24248-182">MTOM エンコーダーの使用は、他の WCF 機能すべてに適合しています。</span><span class="sxs-lookup"><span data-stu-id="24248-182">Using the MTOM encoder conforms with all other WCF features.</span></span> <span data-ttu-id="24248-183">セッション サポートが必要な場合などのように、すべての場合でこの規則が守られるわけではありません。</span><span class="sxs-lookup"><span data-stu-id="24248-183">Note that it may not be possible to observe this rule in all cases, such as when session support is required.</span></span>  
  
### <a name="programming-model"></a><span data-ttu-id="24248-184">プログラミング モデル</span><span class="sxs-lookup"><span data-stu-id="24248-184">Programming Model</span></span>  

 <span data-ttu-id="24248-185">3 つの組み込みエンコーダーのうち、どのエンコーダーをアプリケーションで使用する場合も、バイナリ データの転送に関するプログラミング方法は同じです。</span><span class="sxs-lookup"><span data-stu-id="24248-185">Regardless of which of the three built-in encoders you use in your application, the programming experience is identical with regards to transferring binary data.</span></span> <span data-ttu-id="24248-186">違いは、WCF による、データ型に基づいたデータ処理の方法です。</span><span class="sxs-lookup"><span data-stu-id="24248-186">The difference is in how WCF handles the data based on their data types.</span></span>  
  
```csharp
[DataContract]  
class MyData  
{  
    [DataMember]  
    byte[] binaryBuffer;  
    [DataMember]  
    string someStringData;  
}
```  
  
 <span data-ttu-id="24248-187">MTOM を使用する場合、上記のデータ コントラクトは次の規則に従ってシリアル化されます。</span><span class="sxs-lookup"><span data-stu-id="24248-187">When using MTOM, the preceding data contract is serialized according to the following rules:</span></span>  
  
- <span data-ttu-id="24248-188">`binaryBuffer` が `null` ではなく、それぞれに格納されているデータのサイズが大きい場合、つまり Base64 エンコーディングと比較しても MTOM 外部化によるオーバーヘッド (MIME ヘッダーなど) を正当化できるサイズである場合は、データが外部化され、バイナリ MIME パートとしてメッセージと共に転送されます。</span><span class="sxs-lookup"><span data-stu-id="24248-188">If `binaryBuffer` is not `null` and individually contains enough data to justify the MTOM externalization overhead (MIME headers, and so on) when compared to Base64 encoding, the data is externalized and carried with the message as a binary MIME part.</span></span> <span data-ttu-id="24248-189">しきい値を超えていない場合、データは Base64 としてエンコードされます。</span><span class="sxs-lookup"><span data-stu-id="24248-189">If the threshold is not exceeded, the data is encoded as Base64.</span></span>  
  
- <span data-ttu-id="24248-190">メッセージの本体で、文字列 (およびバイナリ以外のその他の型) はサイズに関係なく文字列として表現されます。</span><span class="sxs-lookup"><span data-stu-id="24248-190">The string (and all other types that are not binary) is always represented as a string inside the message body, regardless of size.</span></span>  
  
 <span data-ttu-id="24248-191">上記の例に示したような明示的なデータ コントラクトを使用する場合も、操作にパラメーター リストを使用する場合も、入れ子構造のデータ コントラクトを使用する場合も、コレクション内でデータ コントラクト オブジェクトを転送する場合も、MTOM エンコーディングへの作用は同じです。</span><span class="sxs-lookup"><span data-stu-id="24248-191">The effect on the MTOM encoding is the same whether you use an explicit data contract, as shown in the preceding example, use a parameter list in an operation, have nested data contracts, or transfer a data contract object inside a collection.</span></span> <span data-ttu-id="24248-192">バイト配列は、常に最適化の対象と見なされるため、最適化のしきい値条件を満たしていれば最適化されます。</span><span class="sxs-lookup"><span data-stu-id="24248-192">Byte arrays are always candidates for optimization and are optimized if the optimization thresholds are being met.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="24248-193">データ コントラクト内では <xref:System.IO.Stream?displayProperty=nameWithType> の派生型を使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="24248-193">You should not be using <xref:System.IO.Stream?displayProperty=nameWithType> derived types inside of data contracts.</span></span> <span data-ttu-id="24248-194">ストリーム データは、次の「データのストリーミング」で説明するストリーミング モデルを使用して送受信する必要があります。</span><span class="sxs-lookup"><span data-stu-id="24248-194">Stream data should be communicated using the streaming model, explained in the following "Streaming Data" section.</span></span>  
  
## <a name="streaming-data"></a><span data-ttu-id="24248-195">データのストリーミング</span><span class="sxs-lookup"><span data-stu-id="24248-195">Streaming Data</span></span>  

 <span data-ttu-id="24248-196">大量のデータを転送する場合、メッセージ全体をメモリ内でバッファー化および処理するという既定動作の代わりに、WCF のストリーミング転送モードを使用することができます。</span><span class="sxs-lookup"><span data-stu-id="24248-196">When you have a large amount of data to transfer, the streaming transfer mode in WCF is a feasible alternative to the default behavior of buffering and processing messages in memory in their entirety.</span></span>  
  
 <span data-ttu-id="24248-197">前述のように、ストリーミングの有効化は、データをセグメントに分割できない場合、メッセージをタイムリーに配信する必要がある場合、または転送の開始時にデータがすべて揃っていない場合に、テキストまたはバイナリのコンテンツを伴う大きなメッセージに関してのみ実行するようにしてください。</span><span class="sxs-lookup"><span data-stu-id="24248-197">As mentioned earlier, enable streaming only for large messages (with text or binary content) if the data cannot be segmented, if the message must be delivered in a timely fashion, or if the data is not yet fully available when the transfer is initiated.</span></span>  
  
### <a name="restrictions"></a><span data-ttu-id="24248-198">制限</span><span class="sxs-lookup"><span data-stu-id="24248-198">Restrictions</span></span>  

 <span data-ttu-id="24248-199">ストリーミングを有効化した状態では、WCF の多くの機能を使用できません。</span><span class="sxs-lookup"><span data-stu-id="24248-199">You cannot use a significant number of WCF features when streaming is enabled:</span></span>  
  
- <span data-ttu-id="24248-200">メッセージ本体に対するデジタル署名は実行できません。デジタル署名では、メッセージ コンテンツ全体に対してハッシュを計算する必要があります。</span><span class="sxs-lookup"><span data-stu-id="24248-200">Digital signatures for the message body cannot be performed because they require computing a hash over the entire message contents.</span></span> <span data-ttu-id="24248-201">ところがストリーミングでは、メッセージ ヘッダーが作成され、送信される時点では、メッセージ コンテンツがすべて揃っているわけではありません。デジタル署名を処理できないのは、このためです。</span><span class="sxs-lookup"><span data-stu-id="24248-201">With streaming, the content is not fully available when the message headers are constructed and sent and, therefore, a digital signature cannot be computed.</span></span>  
  
- <span data-ttu-id="24248-202">暗号化では、データが正しく再構築されていることを検証するために、デジタル署名が必要になります。</span><span class="sxs-lookup"><span data-stu-id="24248-202">Encryption depends on digital signatures to verify that the data has been reconstructed correctly.</span></span>  
  
- <span data-ttu-id="24248-203">信頼できるセッションでは、メッセージが転送中に失われた場合に再配信できるように、クライアントで送信メッセージをバッファー化する必要があります。また、サービス実装にメッセージを渡す前に、いったんメッセージをサービスで格納し、メッセージが正しい順序で受信されなかった場合に備えてメッセージの順序を保持する必要があります。</span><span class="sxs-lookup"><span data-stu-id="24248-203">Reliable sessions must buffer sent messages on the client for redelivery if a message gets lost in transfer and must hold messages on the service before handing them to the service implementation to preserve message order in case messages are received out-of-sequence.</span></span>  
  
 <span data-ttu-id="24248-204">このような機能上の制約により、ストリーミングではトランスポート レベルのセキュリティ オプションしか使用できず、信頼できるセッションを有効にできません。</span><span class="sxs-lookup"><span data-stu-id="24248-204">Because of these functional constraints, you can use only transport-level security options for streaming and you cannot turn on reliable sessions.</span></span> <span data-ttu-id="24248-205">ストリーミングは、以下のシステム定義バインディングでしか使用できません。</span><span class="sxs-lookup"><span data-stu-id="24248-205">Streaming is only available with the following system-defined bindings:</span></span>  
  
- <xref:System.ServiceModel.BasicHttpBinding>  
  
- <xref:System.ServiceModel.NetTcpBinding>  
  
- <xref:System.ServiceModel.NetNamedPipeBinding>  
  
- <xref:System.ServiceModel.WebHttpBinding>  
  
 <span data-ttu-id="24248-206">HTTP とは異なり、<xref:System.ServiceModel.NetTcpBinding> と <xref:System.ServiceModel.NetNamedPipeBinding> の基になるトランスポートには、信頼できる配信と接続ベースのセッション サポートが備わっているので、これら 2 つのバインディングが上記の制約から受ける影響はわずかです。</span><span class="sxs-lookup"><span data-stu-id="24248-206">Because the underlying transports of <xref:System.ServiceModel.NetTcpBinding> and <xref:System.ServiceModel.NetNamedPipeBinding> have inherent reliable delivery and connection-based session support, unlike HTTP, these two bindings are only minimally affected by these constraints, in practice.</span></span>  
  
 <span data-ttu-id="24248-207">ストリーミングは、メッセージ キュー (MSMQ) トランスポートでは利用できないため、<xref:System.ServiceModel.NetMsmqBinding> クラスまたは <xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding> クラスと共に使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="24248-207">Streaming is not available with the Message Queuing (MSMQ) transport and so cannot be used with the <xref:System.ServiceModel.NetMsmqBinding> or the <xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding> class.</span></span> <span data-ttu-id="24248-208">メッセージ キュー トランスポートでは、メッセージ サイズを制限したバッファー化によるデータ転送だけがサポートされています。これに対し他のトランスポートでは、ほとんどのシナリオにおいてメッセージ サイズの実質的な制限はありません。</span><span class="sxs-lookup"><span data-stu-id="24248-208">The Message Queuing transport only supports buffered data transfers with a constrained message size, while all other transports do not have any practical message size limit for the vast majority of scenarios.</span></span>  
  
 <span data-ttu-id="24248-209">ストリーミングは、ピア チャネル トランスポートを使用している場合も利用できないため、<xref:System.ServiceModel.NetPeerTcpBinding> と共に使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="24248-209">Streaming is also not available when using the Peer Channel transport, so is not available with the <xref:System.ServiceModel.NetPeerTcpBinding>.</span></span>  
  
#### <a name="streaming-and-sessions"></a><span data-ttu-id="24248-210">ストリーミングとセッション</span><span class="sxs-lookup"><span data-stu-id="24248-210">Streaming and Sessions</span></span>  

 <span data-ttu-id="24248-211">セッション ベースのバインディングでストリーミングを呼び出すと、予期しない動作を引き起こすことがあります。</span><span class="sxs-lookup"><span data-stu-id="24248-211">You may get unexpected behavior when streaming calls with a session-based binding.</span></span> <span data-ttu-id="24248-212">すべてのストリーミング呼び出しは単一のチャネル (データグラム チャネル) を通じて行われますが、このチャネルは使用されるバインディングがセッションを使用するように構成されている場合であっても、セッションをサポートしません。</span><span class="sxs-lookup"><span data-stu-id="24248-212">All streaming calls are made through a single channel (the datagram channel) that does not support sessions even if the binding being used is configured to use sessions.</span></span> <span data-ttu-id="24248-213">セッション ベースのバインディングによって複数のクライアントが同一のサービス オブジェクトに対してストリーミング呼び出しを行う場合、このサービス オブジェクトのコンカレンシー モードが単一に設定され、インスタンス コンテキスト モードが PerSession に設定されていると、すべての呼び出しがこのデータグラム チャネルを通過する必要があるため、同時に処理される呼び出しは 1 つに限られることになります。</span><span class="sxs-lookup"><span data-stu-id="24248-213">If multiple clients make streaming calls to the same service object over a session-based binding and the service object's concurrency mode is set to single and its instance context mode is set to PerSession, all calls must go through the datagram channel and so only one call is processed at a time.</span></span> <span data-ttu-id="24248-214">そのため、1 つ以上のクライアントがタイムアウトとなる可能性があります。サービス オブジェクトのインスタンス コンテキスト モードを呼び出しごと (PerCall) に設定するか、またはコンカレンシー モードを複数に設定することで、この問題を回避できます。</span><span class="sxs-lookup"><span data-stu-id="24248-214">One or more clients may then time out. You can work around this issue by either setting the service object's Instance Context Mode to PerCall or Concurrency to Multiple.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="24248-215">この場合、利用可能になる "セッション" は 1 つしかないため、MaxConcurrentSessions は効力を失います。</span><span class="sxs-lookup"><span data-stu-id="24248-215">MaxConcurrentSessions has no effect in this case because there is only one "session" available.</span></span>  
  
### <a name="enabling-streaming"></a><span data-ttu-id="24248-216">ストリーミングの有効化</span><span class="sxs-lookup"><span data-stu-id="24248-216">Enabling Streaming</span></span>  

 <span data-ttu-id="24248-217">ストリーミングは次の方法で有効にできます。</span><span class="sxs-lookup"><span data-stu-id="24248-217">You can enable streaming in the following ways:</span></span>  
  
- <span data-ttu-id="24248-218">ストリーミング モードで要求の送信および受け入れを行い、バッファー モードで応答の受け入れおよび返信を行う (<xref:System.ServiceModel.TransferMode.StreamedRequest>)。</span><span class="sxs-lookup"><span data-stu-id="24248-218">Send and accept requests in streaming mode, and accept and return responses in buffered mode (<xref:System.ServiceModel.TransferMode.StreamedRequest>).</span></span>  
  
- <span data-ttu-id="24248-219">バッファー モードで要求の送信および受け入れを行い、ストリーミング モードで応答の受け入れおよび返信を行う (<xref:System.ServiceModel.TransferMode.StreamedResponse>)。</span><span class="sxs-lookup"><span data-stu-id="24248-219">Send and accept requests in buffered mode, and accept and return responses in streamed mode (<xref:System.ServiceModel.TransferMode.StreamedResponse>).</span></span>  
  
- <span data-ttu-id="24248-220">両方向の要求および応答をストリーミング モードで送受信する </span><span class="sxs-lookup"><span data-stu-id="24248-220">Send and receive requests and responses in streamed mode in both directions.</span></span> <span data-ttu-id="24248-221">(<xref:System.ServiceModel.TransferMode.Streamed>).</span><span class="sxs-lookup"><span data-stu-id="24248-221">(<xref:System.ServiceModel.TransferMode.Streamed>).</span></span>  
  
 <span data-ttu-id="24248-222">ストリーミングを無効化するには、転送モードを <xref:System.ServiceModel.TransferMode.Buffered> (すべてのバインディングでの既定の設定) に設定します。</span><span class="sxs-lookup"><span data-stu-id="24248-222">You can disable streaming by setting the transfer mode to <xref:System.ServiceModel.TransferMode.Buffered>, which is the default setting on all bindings.</span></span> <span data-ttu-id="24248-223">構成で転送モードを設定する方法を次のコードに示します。</span><span class="sxs-lookup"><span data-stu-id="24248-223">The following code shows how to set the transfer mode in configuration.</span></span>  
  
```xml  
<system.serviceModel>  
     …  
    <bindings>  
      <basicHttpBinding>  
        <binding name="ExampleBinding" transferMode="Streamed"/>  
      </basicHttpBinding>  
    </bindings>  
     …  
</system.serviceModel>  
```  
  
 <span data-ttu-id="24248-224">コード内でバインディングをインスタンス化するときは、そのバインディングの `TransferMode` プロパティ (またはカスタム バインドを作成している場合は、トランスポート バインド要素) をそれぞれ上記の値のいずれかに設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="24248-224">When you instantiate your binding in code, you must set the respective `TransferMode` property of the binding (or the transport binding element if you are composing a custom binding) to one of the previously mentioned values.</span></span>  
  
 <span data-ttu-id="24248-225">送信側と受信側で別々に、要求または応答あるいは両方向に対してストリーミングを有効化しても、機能には影響しません。</span><span class="sxs-lookup"><span data-stu-id="24248-225">You can turn on streaming for requests and replies or for both directions independently at either side of the communicating parties without affecting functionality.</span></span> <span data-ttu-id="24248-226">ただし、転送されるデータのサイズが大きくて、ストリーミングを有効化することが双方にとってのメリットになるかどうかを常に前提として判断する必要があります。</span><span class="sxs-lookup"><span data-stu-id="24248-226">However, you should always assume that the transferred data size is so significant that enabling streaming is justified on both endpoints of a communication link.</span></span> <span data-ttu-id="24248-227">一方のエンドポイントに WCF が実装されていないようなクロス プラットフォームの通信の場合、ストリーミングが使用できるかどうかは、そのプラットフォームのストリーミング機能に依存します。</span><span class="sxs-lookup"><span data-stu-id="24248-227">For cross-platform communication where one of the endpoints is not implemented with WCF, the ability to use streaming depends on the platform's streaming capabilities.</span></span> <span data-ttu-id="24248-228">もう 1 つのまれな例外は、クライアントまたはサービスが作業セットを最小限に抑える必要があり、使用できるバッファー サイズが制限されるような、メモリ消費重視のシナリオです。</span><span class="sxs-lookup"><span data-stu-id="24248-228">Another rare exception might be a memory-consumption driven scenario where a client or service must minimize its working set and can only afford small buffer sizes.</span></span>  
  
### <a name="enabling-asynchronous-streaming"></a><span data-ttu-id="24248-229">非同期ストリーミングの有効化</span><span class="sxs-lookup"><span data-stu-id="24248-229">Enabling Asynchronous Streaming</span></span>  

 <span data-ttu-id="24248-230">非同期ストリーミングを有効にするには、エンドポイントの <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior> 動作をサービス ホストに追加し、その <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior.AsynchronousSendEnabled%2A> プロパティを `true` に設定します。</span><span class="sxs-lookup"><span data-stu-id="24248-230">To enable asynchronous streaming, add the  <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior> endpoint behavior to the service host and set its <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior.AsynchronousSendEnabled%2A> property to `true`.</span></span> <span data-ttu-id="24248-231">送信側に実際の非同期ストリーミング機能も追加されています。</span><span class="sxs-lookup"><span data-stu-id="24248-231">We have also added the capability of true asynchronous streaming on the send side.</span></span> <span data-ttu-id="24248-232">これによって、複数のクライアントにメッセージをストリーム出力するシナリオで、一部のクライアントがネットワークの混雑により読み取りが遅いか、読み取りをまったく行っていない場合に、サービスのスケーラビリティが向上します。</span><span class="sxs-lookup"><span data-stu-id="24248-232">This improves scalability of the service in scenarios where it is streaming messages to multiple clients some of which are slow in reading possibly due to network congestion or are not reading at all.</span></span> <span data-ttu-id="24248-233">このようなシナリオでは、クライアントごとのサービスの個別のスレッドがブロックされないようになりました。</span><span class="sxs-lookup"><span data-stu-id="24248-233">In these scenarios we now do not block individual threads on the service per client.</span></span> <span data-ttu-id="24248-234">サービスはこれによってこれまで以上のクライアントを処理できるようになり、スケーラビリティが向上します。</span><span class="sxs-lookup"><span data-stu-id="24248-234">This ensures that the service is able to process many more clients thereby improving the scalability of the service.</span></span>  
  
### <a name="programming-model-for-streamed-transfers"></a><span data-ttu-id="24248-235">ストリーミング転送のプログラミング モデル</span><span class="sxs-lookup"><span data-stu-id="24248-235">Programming Model for Streamed Transfers</span></span>  

 <span data-ttu-id="24248-236">ストリーミングのプログラミング モデルは単純です。</span><span class="sxs-lookup"><span data-stu-id="24248-236">The programming model for streaming is straightforward.</span></span> <span data-ttu-id="24248-237">ストリーム化されたデータを受信するには、<xref:System.IO.Stream> 型の入力パラメーターを 1 つ使用する操作コントラクトを指定します。</span><span class="sxs-lookup"><span data-stu-id="24248-237">For receiving streamed data, specify an operation contract that has a single <xref:System.IO.Stream> typed input parameter.</span></span> <span data-ttu-id="24248-238">ストリーム化されたデータを返信するには、<xref:System.IO.Stream> 参照を返します。</span><span class="sxs-lookup"><span data-stu-id="24248-238">For returning streamed data, return a <xref:System.IO.Stream> reference.</span></span>  
  
```csharp
[ServiceContract(Namespace="http://Microsoft.ServiceModel.Samples")]  
public interface IStreamedService  
{  
    [OperationContract]  
    Stream Echo(Stream data);  
    [OperationContract]  
    Stream RequestInfo(string query);  
    [OperationContract(OneWay=true)]  
    void ProvideInfo(Stream data);  
}  
```  
  
 <span data-ttu-id="24248-239">上記の例で操作 `Echo` は、ストリームの受信および返信を行うので、<xref:System.ServiceModel.TransferMode.Streamed> が設定されたバインディングで使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="24248-239">The operation `Echo` in the preceding example receives and returns a stream and should therefore be used on a binding with <xref:System.ServiceModel.TransferMode.Streamed>.</span></span> <span data-ttu-id="24248-240">`RequestInfo` 操作の場合、<xref:System.ServiceModel.TransferMode.StreamedResponse> だけを返すので、<xref:System.IO.Stream> が最も適しています。</span><span class="sxs-lookup"><span data-stu-id="24248-240">For the operation `RequestInfo`, <xref:System.ServiceModel.TransferMode.StreamedResponse> is best suited, because it only returns a <xref:System.IO.Stream>.</span></span> <span data-ttu-id="24248-241">一方向操作は、<xref:System.ServiceModel.TransferMode.StreamedRequest> に最適です。</span><span class="sxs-lookup"><span data-stu-id="24248-241">The one-way operation is best suited for <xref:System.ServiceModel.TransferMode.StreamedRequest>.</span></span>  
  
 <span data-ttu-id="24248-242">次の `Echo` 操作または `ProvideInfo` 操作に 2 つ目のパラメーターを追加すると、サービス モデルはバッファー モードに戻り、ストリームの実行時シリアル化表現が使用されます。</span><span class="sxs-lookup"><span data-stu-id="24248-242">Note that adding a second parameter to the following `Echo` or `ProvideInfo` operations causes the service model to revert back to a buffered strategy and use the run-time serialization representation of the stream.</span></span> <span data-ttu-id="24248-243">エンドツーエンドの要求ストリーミングとの互換性があるのは、単一の入力ストリーム パラメーターを使用する操作だけです。</span><span class="sxs-lookup"><span data-stu-id="24248-243">Only operations with a single input stream parameter are compatible with end-to-end request streaming.</span></span>  
  
 <span data-ttu-id="24248-244">この規則は、メッセージ コントラクトにも同様に適用されます。</span><span class="sxs-lookup"><span data-stu-id="24248-244">This rule similarly applies to message contracts.</span></span> <span data-ttu-id="24248-245">次の例に示すように、メッセージ コントラクトには、ストリームであるメッセージ本体メンバーを 1 つだけ指定できます。</span><span class="sxs-lookup"><span data-stu-id="24248-245">As shown in the following message contract, you can have only a single body member in your message contract that is a stream.</span></span> <span data-ttu-id="24248-246">ストリームと共に他の追加情報も転送する場合、追加情報はメッセージ ヘッダーに入れる必要があります。</span><span class="sxs-lookup"><span data-stu-id="24248-246">If you want to communicate additional information with the stream, this information must be a carried in message headers.</span></span> <span data-ttu-id="24248-247">メッセージ本体は、ストリーム コンテンツ専用として予約されています。</span><span class="sxs-lookup"><span data-stu-id="24248-247">The message body is exclusively reserved for the stream content.</span></span>  
  
```csharp
[MessageContract]  
public class UploadStreamMessage  
{  
   [MessageHeader]  
   public string appRef;  
   [MessageBodyMember]  
   public Stream data;  
}
```  
  
 <span data-ttu-id="24248-248">ストリームがファイルの末尾 (EOF) に達すると、ストリーミング転送は終了し、メッセージが閉じられます。</span><span class="sxs-lookup"><span data-stu-id="24248-248">Streamed transfers end and the message is closed when the stream reaches the end of file (EOF).</span></span> <span data-ttu-id="24248-249">値を返したり操作を呼び出したりするためにメッセージを送信する際には、<xref:System.IO.FileStream> を渡すことができます。すると、WCF インフラストラクチャにより、ストリームの読み出しが完了して EOF に達するまで、ストリームのデータがすべて獲得されます。</span><span class="sxs-lookup"><span data-stu-id="24248-249">When sending a message (returning a value or invoking an operation), you can pass a <xref:System.IO.FileStream> and the WCF infrastructure subsequently pulls all the data from that stream until the stream has been completely read and reached EOF.</span></span> <span data-ttu-id="24248-250">ストリーム化されたデータを転送する際に、このような <xref:System.IO.Stream> のビルド済み派生クラスがそのデータのソースに存在しない場合は、対応するクラスを作成し、そのクラスでストリーム ソースを覆ったうえで、これを引数または戻り値として使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="24248-250">To transfer streamed data for the source that no such pre-built <xref:System.IO.Stream> derived class exists, construct such a class, overlay that class over your stream source, and use that as the argument or return value.</span></span>  
  
 <span data-ttu-id="24248-251">メッセージを受信したとき、WCF では、Base64 でエンコードされたメッセージ本体のコンテンツ (MTOM が使用されていれば各 MIME パート) についてストリームが作成されます。コンテンツの読み取りが完了した時点でストリームは EOF に達します。</span><span class="sxs-lookup"><span data-stu-id="24248-251">When receiving a message, WCF constructs a stream over the Base64-encoded message body content (or the respective MIME part if using MTOM) and the stream reaches EOF when the content has been read.</span></span>  
  
 <span data-ttu-id="24248-252">トランスポート レベルのストリーミングは、その他のメッセージ コントラクト型 (パラメーター リスト、データ コントラクトの引数、明示的なメッセージ コントラクト) でも使用できますが、このような型指定メッセージのシリアル化および逆シリアル化には、シリアライザーによるバッファー化が必要なので、これらの使用は適切ではありません。</span><span class="sxs-lookup"><span data-stu-id="24248-252">Transport-level streaming also works with any other message contract type (parameter lists, data contract arguments, and explicit message contract), but because the serialization and deserialization of such typed messages requires buffering by the serializer, using such contract variants is not advisable.</span></span>  
  
### <a name="special-security-considerations-for-large-data"></a><span data-ttu-id="24248-253">大規模データに関するセキュリティの考慮事項</span><span class="sxs-lookup"><span data-stu-id="24248-253">Special Security Considerations for Large Data</span></span>  

 <span data-ttu-id="24248-254">すべてのバインディングで、受信メッセージのサイズを制限して、サービス拒否攻撃を防止できます。</span><span class="sxs-lookup"><span data-stu-id="24248-254">All bindings allow you to constrain the size of incoming messages to prevent denial-of-service attacks.</span></span> <span data-ttu-id="24248-255">たとえば、<xref:System.ServiceModel.BasicHttpBinding> では、受信メッセージのサイズを制限し、メッセージの処理時にアクセスされるメモリの最大容量も制限する [System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) プロパティが公開されます。</span><span class="sxs-lookup"><span data-stu-id="24248-255">The <xref:System.ServiceModel.BasicHttpBinding>, for example, exposes a [System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) property that bounds the size of the incoming message, and so also bounds the maximum amount of memory that is accessed when processing the message.</span></span> <span data-ttu-id="24248-256">この単位はバイトで設定されます。既定値は 65,536 バイトです。</span><span class="sxs-lookup"><span data-stu-id="24248-256">This unit is set in bytes with a default value of 65,536 bytes.</span></span>  
  
 <span data-ttu-id="24248-257">大きなデータのストリーミングを行うシナリオに特有のセキュリティの脅威は、受信側が、データがストリーミングされることを想定しているときに、データをバッファーさせることで、サービス拒否が誘発されることです。</span><span class="sxs-lookup"><span data-stu-id="24248-257">A security threat that is specific to the large data streaming scenario provokes a denial of service by causing data to be buffered when the receiver expects it to be streamed.</span></span> <span data-ttu-id="24248-258">たとえば、WCF ではメッセージの SOAP ヘッダーが常にバッファーされるため、攻撃者は、すべてがヘッダーで構成されている悪意のある大きなメッセージを作成して、データを強制的にバッファーすることができます。</span><span class="sxs-lookup"><span data-stu-id="24248-258">For example, WCF always buffers the SOAP headers of a message, and so an attacker may construct a large malicious message that consists entirely of headers to force the data to be buffered.</span></span> <span data-ttu-id="24248-259">ストリーミングが有効になっている場合は、`MaxReceivedMessageSize` を極端に大きい値に設定できます。これは、受信側が、一度にメッセージ全体をメモリにバッファーすることを想定していないためです。</span><span class="sxs-lookup"><span data-stu-id="24248-259">When streaming is enabled, the `MaxReceivedMessageSize` may be set to an extremely large value, because the receiver never expects the entire message to be buffered in memory at once.</span></span> <span data-ttu-id="24248-260">メッセージをバッファーするように WCF に強制している場合は、メモリのオーバーフローが発生します。</span><span class="sxs-lookup"><span data-stu-id="24248-260">If WCF is forced to buffer the message, a memory overflow occurs.</span></span>  
  
 <span data-ttu-id="24248-261">そのため、この場合は、受信メッセージの最大サイズを制限するだけでは不十分です。</span><span class="sxs-lookup"><span data-stu-id="24248-261">Therefore, restricting the maximum incoming message size is not enough in this case.</span></span> <span data-ttu-id="24248-262">WCF によってバッファーされるメモリを制限するには、`MaxBufferSize` プロパティが必要です。</span><span class="sxs-lookup"><span data-stu-id="24248-262">The `MaxBufferSize` property is required to constrain the memory that WCF buffers.</span></span> <span data-ttu-id="24248-263">ストリーミングを使用する場合は、これを安全な値に設定する (または既定値のままにしておく) ことが重要です。</span><span class="sxs-lookup"><span data-stu-id="24248-263">It is important to set this to a safe value (or keep it at the default value) when streaming.</span></span> <span data-ttu-id="24248-264">たとえば、サービスでは、サイズが 4 GB までのファイルを受信し、それをローカル ディスクに格納する必要があるとします。</span><span class="sxs-lookup"><span data-stu-id="24248-264">For example, suppose your service must receive files up to 4 GB in size and store them on the local disk.</span></span> <span data-ttu-id="24248-265">また、一度に 64 KB のデータしかバッファーできないようにメモリが制限されているとします。</span><span class="sxs-lookup"><span data-stu-id="24248-265">Suppose also that your memory is constrained in such a way that you can only buffer 64 KB of data at a time.</span></span> <span data-ttu-id="24248-266">その場合、`MaxReceivedMessageSize` を 4 GB、`MaxBufferSize` を 64 KB に設定します。</span><span class="sxs-lookup"><span data-stu-id="24248-266">Then you would set the `MaxReceivedMessageSize` to 4 GB and `MaxBufferSize` to 64 KB.</span></span> <span data-ttu-id="24248-267">また、サービス実装において、64 KB ずつ受信ストリームから読み取り、前のデータがディスクに書き込まれ、メモリから破棄されるまで次のデータを読み取らないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="24248-267">Also, in your service implementation, you must ensure that you read only from the incoming stream in 64-KB chunks and do not read the next chunk before the previous one has been written to disk and discarded from memory.</span></span>  
  
 <span data-ttu-id="24248-268">このクォータは、WCF によって行われるバッファーリングのみを制限するものであり、独自のサービスまたはクライアント実装で行うバッファーリングからは保護できないことを理解しておくことも重要です。</span><span class="sxs-lookup"><span data-stu-id="24248-268">It is also important to understand that this quota only limits the buffering done by WCF and cannot protect you against any buffering that you do in your own service or client implementation.</span></span> <span data-ttu-id="24248-269">セキュリティについてのその他の考慮事項の詳細については、「[セキュリティに関するデータの考慮事項](security-considerations-for-data.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="24248-269">For more information about additional security considerations, see [Security Considerations for Data](security-considerations-for-data.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="24248-270">バッファー転送とストリーミング転送のどちらを使用するかは、エンドポイントごとにローカルに決定します。</span><span class="sxs-lookup"><span data-stu-id="24248-270">The decision to use either buffered or streamed transfers is a local decision of the endpoint.</span></span> <span data-ttu-id="24248-271">HTTP トランスポートの場合、転送モードは、接続、つまりプロキシ サーバーなどの中継局に伝達されません。</span><span class="sxs-lookup"><span data-stu-id="24248-271">For HTTP transports, the transfer mode does not propagate across a connection or to proxy servers and other intermediaries.</span></span> <span data-ttu-id="24248-272">転送モードの設定は、サービス インターフェイスの記述に反映されません。</span><span class="sxs-lookup"><span data-stu-id="24248-272">Setting the transfer mode is not reflected in the description of the service interface.</span></span> <span data-ttu-id="24248-273">サービスに対して WCF クライアントを生成した後、ストリーミング転送で使用する予定のサービスの構成ファイルを編集し、モードを設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="24248-273">After generating a WCF client to a service, you must edit the configuration file for services intended to be used with streamed transfers to set the mode.</span></span> <span data-ttu-id="24248-274">TCP トランスポートと名前付きパイプ トランスポートの場合、転送モードはポリシー アサーションとして伝達されます。</span><span class="sxs-lookup"><span data-stu-id="24248-274">For TCP and named pipe transports, the transfer mode is propagated as a policy assertion.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="24248-275">関連項目</span><span class="sxs-lookup"><span data-stu-id="24248-275">See also</span></span>

- [<span data-ttu-id="24248-276">方法: ストリーミングを有効にする</span><span class="sxs-lookup"><span data-stu-id="24248-276">How to: Enable Streaming</span></span>](how-to-enable-streaming.md)
