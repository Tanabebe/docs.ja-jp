---
description: '詳細情報: メッセージ交換パターンの選択'
title: メッセージ交換パターンの選択
ms.date: 03/30/2017
ms.assetid: 0f502ca1-6a8e-4607-ba15-59198c0e6146
ms.openlocfilehash: c0849ddb16596ebd6e064bb39f0727ac51642eb7
ms.sourcegitcommit: 46cfed35d79d70e08c313b9c664c7e76babab39e
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/10/2021
ms.locfileid: "102605361"
---
# <a name="choosing-a-message-exchange-pattern"></a><span data-ttu-id="27bed-103">メッセージ交換パターンの選択</span><span class="sxs-lookup"><span data-stu-id="27bed-103">Choosing a Message Exchange Pattern</span></span>

<span data-ttu-id="27bed-104">カスタムトランスポートを記述する最初の手順は、開発中のチャネルに必要な *メッセージ交換パターン* (meps) を決定することです。</span><span class="sxs-lookup"><span data-stu-id="27bed-104">The first step in writing a custom transport is to decide which *message exchange patterns* (or MEPs) are required for the channel you are developing.</span></span> <span data-ttu-id="27bed-105">ここでは、使用できるオプションとさまざまな要件について説明します。</span><span class="sxs-lookup"><span data-stu-id="27bed-105">This topic describes the options available and discusses the various requirements.</span></span> <span data-ttu-id="27bed-106">これは、「チャネルの [開発](developing-channels.md)」で説明されているチャネル開発タスクリストの最初のタスクです。</span><span class="sxs-lookup"><span data-stu-id="27bed-106">This is the first task in the channel development task list described in [Developing Channels](developing-channels.md).</span></span>  
  
## <a name="six-message-exchange-patterns"></a><span data-ttu-id="27bed-107">6 つのメッセージ交換パターン</span><span class="sxs-lookup"><span data-stu-id="27bed-107">Six Message Exchange Patterns</span></span>  

 <span data-ttu-id="27bed-108">次の 3 つの MEP から選択できます。</span><span class="sxs-lookup"><span data-stu-id="27bed-108">There are three MEPs to choose from:</span></span>  
  
- <span data-ttu-id="27bed-109">データグラム (<xref:System.ServiceModel.Channels.IInputChannel> と <xref:System.ServiceModel.Channels.IOutputChannel>)</span><span class="sxs-lookup"><span data-stu-id="27bed-109">Datagram (<xref:System.ServiceModel.Channels.IInputChannel> and <xref:System.ServiceModel.Channels.IOutputChannel>)</span></span>  
  
     <span data-ttu-id="27bed-110">データグラム MEP を使用する場合、クライアントは火災を使用してメッセージを送信し、exchange を *破棄* します。</span><span class="sxs-lookup"><span data-stu-id="27bed-110">When using a datagram MEP, a client sends a message using a *fire and forget* exchange.</span></span> <span data-ttu-id="27bed-111">このような交換では、配信の成否について帯域外での確認が必要になります。</span><span class="sxs-lookup"><span data-stu-id="27bed-111">A fire and forget exchange is one that requires out-of-band confirmation of successful delivery.</span></span> <span data-ttu-id="27bed-112">メッセージが移動中に失われて、サービスに到達しない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="27bed-112">The message might be lost in transit and never reach the service.</span></span> <span data-ttu-id="27bed-113">クライアントで送信操作が正常に完了したとしても、リモート エンドポイントでメッセージが受信されたとは限りません。</span><span class="sxs-lookup"><span data-stu-id="27bed-113">If the send operation completes successfully at the client end, it does not guarantee that the remote endpoint has received the message.</span></span> <span data-ttu-id="27bed-114">データグラムはメッセージングの基礎となるビルド ブロックであり、その上に信頼できるプロトコルや安全なプロトコルなどの独自のプロトコルを構築できます。</span><span class="sxs-lookup"><span data-stu-id="27bed-114">The datagram is a fundamental building block for messaging, as you can build your own protocols on top of it—including reliable protocols and secure protocols.</span></span> <span data-ttu-id="27bed-115">クライアント データグラム チャネルには、<xref:System.ServiceModel.Channels.IOutputChannel> インターフェイスが実装され、サービス データグラム チャネルには <xref:System.ServiceModel.Channels.IInputChannel> インターフェイスが実装されます。</span><span class="sxs-lookup"><span data-stu-id="27bed-115">Client datagram channels implement the <xref:System.ServiceModel.Channels.IOutputChannel> interface and service datagram channels implement the <xref:System.ServiceModel.Channels.IInputChannel> interface.</span></span>  
  
- <span data-ttu-id="27bed-116">要求 - 応答 (<xref:System.ServiceModel.Channels.IRequestChannel> と <xref:System.ServiceModel.Channels.IReplyChannel>)</span><span class="sxs-lookup"><span data-stu-id="27bed-116">Request-Response (<xref:System.ServiceModel.Channels.IRequestChannel> and <xref:System.ServiceModel.Channels.IReplyChannel>)</span></span>  
  
     <span data-ttu-id="27bed-117">この MEP では、メッセージが送信されて、応答が受信されます。</span><span class="sxs-lookup"><span data-stu-id="27bed-117">In this MEP, a message is sent, and a reply is received.</span></span> <span data-ttu-id="27bed-118">パターンは、要求 - 応答のペアで構成されます。</span><span class="sxs-lookup"><span data-stu-id="27bed-118">The pattern consists of request-response pairs.</span></span> <span data-ttu-id="27bed-119">要求 - 応答呼び出しの例として、リモート プロシージャ コール (RPC) やブラウザー GET 要求などがあります。</span><span class="sxs-lookup"><span data-stu-id="27bed-119">Examples of request-response calls are remote procedure calls (RPC) and browser GET requests.</span></span> <span data-ttu-id="27bed-120">このパターンは、半二重とも呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="27bed-120">This pattern is also known as half-duplex.</span></span> <span data-ttu-id="27bed-121">この MEP では、クライアント チャネルには <xref:System.ServiceModel.Channels.IRequestChannel> が実装され、サービス チャネルには <xref:System.ServiceModel.Channels.IReplyChannel> が実装されます。</span><span class="sxs-lookup"><span data-stu-id="27bed-121">In this MEP, client channels implement <xref:System.ServiceModel.Channels.IRequestChannel> and service channels implement <xref:System.ServiceModel.Channels.IReplyChannel>.</span></span>  
  
- <span data-ttu-id="27bed-122">二重 (<xref:System.ServiceModel.Channels.IDuplexChannel>)</span><span class="sxs-lookup"><span data-stu-id="27bed-122">Duplex (<xref:System.ServiceModel.Channels.IDuplexChannel>)</span></span>  
  
     <span data-ttu-id="27bed-123">二重 MEP では、クライアントにより任意の数のメッセージを送信して、任意の順序で受信できます。</span><span class="sxs-lookup"><span data-stu-id="27bed-123">The duplex MEP allows an arbitrary number of messages to be sent by a client and received in any order.</span></span> <span data-ttu-id="27bed-124">二重 MEP は、話される語の 1 つずつがメッセージである電話の会話に似ています。</span><span class="sxs-lookup"><span data-stu-id="27bed-124">The duplex MEP is like a phone conversation, where each word being spoken is a message.</span></span> <span data-ttu-id="27bed-125">この MEP ではどちらの側も送信および受信できるので、クライアントおよびサービス チャネルによって実装されるインターフェイスは <xref:System.ServiceModel.Channels.IDuplexChannel> になります。</span><span class="sxs-lookup"><span data-stu-id="27bed-125">Because both sides can send and receive in this MEP, the interface implemented by the client and service channels is <xref:System.ServiceModel.Channels.IDuplexChannel>.</span></span>  
  
 ![3つの基本的なメッセージ交換パターンを示すフローチャート](./media/wcfc-basicthreemepsc.gif)  
<span data-ttu-id="27bed-127">3 つの基本的なメッセージ交換パターンです。</span><span class="sxs-lookup"><span data-stu-id="27bed-127">The three basic message exchange patterns.</span></span> <span data-ttu-id="27bed-128">上から順に、データグラム、要求 - 応答、二重。</span><span class="sxs-lookup"><span data-stu-id="27bed-128">Top to bottom: datagram, request-response, and duplex.</span></span>  
  
 <span data-ttu-id="27bed-129">これらの各 MEPs は、 *セッション* をサポートすることもできます。</span><span class="sxs-lookup"><span data-stu-id="27bed-129">Each of these MEPs can also support *sessions*.</span></span> <span data-ttu-id="27bed-130">セッション (および <xref:System.ServiceModel.Channels.ISessionChannel%601?displayProperty=nameWithType> 型の <xref:System.ServiceModel.Channels.ISession?displayProperty=nameWithType> の実装) は、チャネルで送受信されるすべてのメッセージを相互に関連付けます。</span><span class="sxs-lookup"><span data-stu-id="27bed-130">A session (and implementation of <xref:System.ServiceModel.Channels.ISessionChannel%601?displayProperty=nameWithType> of type <xref:System.ServiceModel.Channels.ISession?displayProperty=nameWithType>) correlates all messages sent and received on a channel.</span></span> <span data-ttu-id="27bed-131">要求 - 応答パターンはスタンドアロンの 2 メッセージ セッションで、要求と応答が相互に関連付けられています。</span><span class="sxs-lookup"><span data-stu-id="27bed-131">The request-response pattern is a stand-alone two-message session, as the request and reply are correlated.</span></span> <span data-ttu-id="27bed-132">一方、セッションをサポートする要求 - 応答パターンは、そのチャネルのすべての要求 - 応答ペアが互いに関連付けられることを意味しています。</span><span class="sxs-lookup"><span data-stu-id="27bed-132">In contrast, the request-response pattern that supports sessions implies that all request/response pairs on that channel are correlated with each other.</span></span> <span data-ttu-id="27bed-133">したがって、次のように合計 6 つの MEP から選択できます。</span><span class="sxs-lookup"><span data-stu-id="27bed-133">This gives you a total of six MEPs to choose from:</span></span>  
  
- <span data-ttu-id="27bed-134">データグラム</span><span class="sxs-lookup"><span data-stu-id="27bed-134">Datagram</span></span>  
  
- <span data-ttu-id="27bed-135">要求 – 応答</span><span class="sxs-lookup"><span data-stu-id="27bed-135">Request-response</span></span>  
  
- <span data-ttu-id="27bed-136">二重</span><span class="sxs-lookup"><span data-stu-id="27bed-136">Duplex</span></span>  
  
- <span data-ttu-id="27bed-137">セッション対応データグラム</span><span class="sxs-lookup"><span data-stu-id="27bed-137">Datagram with sessions</span></span>  
  
- <span data-ttu-id="27bed-138">セッション対応要求 – 応答</span><span class="sxs-lookup"><span data-stu-id="27bed-138">Request-response with sessions</span></span>  
  
- <span data-ttu-id="27bed-139">セッション対応二重</span><span class="sxs-lookup"><span data-stu-id="27bed-139">Duplex with sessions</span></span>  
  
> [!NOTE]
> <span data-ttu-id="27bed-140">UDP トランスポートでは、サポートされている MEP はデータグラムだけです。これは、UDP がファイア アンド フォーゲット (撃ち放し) のプロトコルだからです。</span><span class="sxs-lookup"><span data-stu-id="27bed-140">For the UDP transport, the only MEP that is supported is datagram, because UDP is inherently a fire and forget protocol.</span></span>  
  
## <a name="sessions-and-sessionful-channels"></a><span data-ttu-id="27bed-141">セッションとセッションの多いチャネル</span><span class="sxs-lookup"><span data-stu-id="27bed-141">Sessions and Sessionful Channels</span></span>  

 <span data-ttu-id="27bed-142">ネットワーク プロトコルには、接続指向プロトコル (TCP など) とコネクションレス プロトコル (UDP など) があります。</span><span class="sxs-lookup"><span data-stu-id="27bed-142">In the networking world, there are connection-oriented protocols (for example, TCP) and connection-less protocols (for example, UDP).</span></span> <span data-ttu-id="27bed-143">WCF では、セッションという用語を使用して、接続に似た論理抽象化を意味します。</span><span class="sxs-lookup"><span data-stu-id="27bed-143">WCF uses the term session to mean a connection-like logical abstraction.</span></span> <span data-ttu-id="27bed-144">セッションの多い WCF プロトコルは、接続指向ネットワーク プロトコルに似ており、セッションの少ない WCF プロトコルは、コネクションレス ネットワーク プロトコルに似ています。</span><span class="sxs-lookup"><span data-stu-id="27bed-144">Sessionful WCF protocols are similar to connection-oriented network protocols and sessionless WCF protocols are similar to connection-less network protocols.</span></span>  
  
 <span data-ttu-id="27bed-145">チャネル オブジェクト モデルでは、各論理セッションは、セッションの多いチャネルの 1 つのインスタンスとしてマニフェストされます。</span><span class="sxs-lookup"><span data-stu-id="27bed-145">In the channel object model, each logical session manifests as an instance of a sessionful channel.</span></span> <span data-ttu-id="27bed-146">したがって、クライアントによって作成され、サービスで受け入れられるすべての新しいセッションは、それぞれの側のセッションの多い新しいチャネルに対応します。</span><span class="sxs-lookup"><span data-stu-id="27bed-146">Therefore every new session created by the client, and accepted on the service, corresponds to a new sessionful channel on each side.</span></span> <span data-ttu-id="27bed-147">セッションの少ないチャネルの構造 (上) と、セッションの多いチャネルの構造 (下) を次の図に示します。</span><span class="sxs-lookup"><span data-stu-id="27bed-147">The following diagram shows, on the top, the structure of sessionless channels, and on the bottom, the structure of sessionful channels.</span></span>  
  
 ![セッションレスチャネルとセッションフルチャネルの構造を示すフローチャート](./media/wcfc-sessionandsessionlesschannelsc.gif)  
  
 <span data-ttu-id="27bed-149">クライアントがセッションの多い新しいチャネルを作成し、メッセージを送信します。</span><span class="sxs-lookup"><span data-stu-id="27bed-149">A client creates a new sessionful channel and sends a message.</span></span> <span data-ttu-id="27bed-150">サービス側では、チャネル リスナーがこのメッセージを受信し、メッセージが新しいセッションに属することを検出します。チャネル リスナーはセッションの多い新しいチャネルを作成し、(チャネル リスナーで AcceptChannel を呼び出しているアプリケーションへの応答として) アプリケーションに渡します。</span><span class="sxs-lookup"><span data-stu-id="27bed-150">On the service side, the channel listener receives this message and detects that it belongs to a new session so it creates a new sessionful channel and hands it to the application (in response to the application calling AcceptChannel on the channel listener).</span></span> <span data-ttu-id="27bed-151">アプリケーションは、同じセッションの多いチャネルを介して、このメッセージと同じセッションで送信される後続のすべてのメッセージを受信します。</span><span class="sxs-lookup"><span data-stu-id="27bed-151">The application then receives this message and all subsequent messages sent in the same session through the same sessionful channel.</span></span>  
  
 <span data-ttu-id="27bed-152">別のクライアント (または同じクライアント) がセッションの多い新しいチャネルを作成し、メッセージを送信します。</span><span class="sxs-lookup"><span data-stu-id="27bed-152">Another client (or the same client) creates a new sessionful and sends a message.</span></span> <span data-ttu-id="27bed-153">チャネル リスナーは、このメッセージが新しいセッションに属することを検出し、セッションの多い新しいチャネルを作成してプロセスが繰り返されます。</span><span class="sxs-lookup"><span data-stu-id="27bed-153">The channel listener detects this message is in a new session and creates a new sessionful channel and the process repeats.</span></span>  
  
 <span data-ttu-id="27bed-154">セッションを使用しない場合、チャネルとセッション間に相関関係はありません。</span><span class="sxs-lookup"><span data-stu-id="27bed-154">Without sessions, there is no correlation between channels and sessions.</span></span> <span data-ttu-id="27bed-155">したがって、チャネル リスナーが作成するチャネルは 1 つしかなく、このチャネルを介して、受信したすべてのメッセージをアプリケーションに配信します。</span><span class="sxs-lookup"><span data-stu-id="27bed-155">Therefore a channel listener creates only one channel through which all received messages are delivered to the application.</span></span> <span data-ttu-id="27bed-156">メッセージの順序を維持するためのセッションが存在しないため、メッセージの順序もありません。</span><span class="sxs-lookup"><span data-stu-id="27bed-156">There is also no message ordering because there is no session within which to maintain message order.</span></span> <span data-ttu-id="27bed-157">前の図の上部は、セッションの少ないメッセージ交換を示しています。</span><span class="sxs-lookup"><span data-stu-id="27bed-157">The top portion of the preceding graphic illustrates a sessionless message exchange.</span></span>  
  
## <a name="starting-and-terminating-sessions"></a><span data-ttu-id="27bed-158">セッションの開始と終了</span><span class="sxs-lookup"><span data-stu-id="27bed-158">Starting and Terminating Sessions</span></span>  

 <span data-ttu-id="27bed-159">セッションの多い新しいチャネルを作成することにより、クライアントでセッションが開始されます。</span><span class="sxs-lookup"><span data-stu-id="27bed-159">Sessions are started on the client by simply creating a new sessionful channel.</span></span> <span data-ttu-id="27bed-160">新しいセッションで送信されたメッセージをサービスが受信すると、サービスでセッションが開始されます。</span><span class="sxs-lookup"><span data-stu-id="27bed-160">They are started on the service when the service receives a message that was sent in a new session.</span></span> <span data-ttu-id="27bed-161">同様に、セッションの多いチャネルを閉じるか中止すると、セッションが終了します。</span><span class="sxs-lookup"><span data-stu-id="27bed-161">Likewise, sessions are terminated by closing or aborting a sessionful channel.</span></span>  
  
 <span data-ttu-id="27bed-162">セッションの多い双方向通信パターンで、メッセージの送信と受信の両方に使用する <xref:System.ServiceModel.Channels.IDuplexSessionChannel> はこの例外です。</span><span class="sxs-lookup"><span data-stu-id="27bed-162">The exception to this is <xref:System.ServiceModel.Channels.IDuplexSessionChannel> which is used for both sending and receiving messages in a duplex, sessionful communication pattern.</span></span> <span data-ttu-id="27bed-163">一方の側がメッセージの送信を停止しても、メッセージの受信は続行する必要がある可能性があります。そのため、<xref:System.ServiceModel.Channels.IDuplexSessionChannel> を使用する場合には、これ以上メッセージを送信しないことを示すために出力セッションを閉じ、メッセージの受信は続行できるように、入力セッションは開いたまましておくことができる機構があります。</span><span class="sxs-lookup"><span data-stu-id="27bed-163">It is possible that one side will want to stop sending messages but continue to receive messages therefore when using <xref:System.ServiceModel.Channels.IDuplexSessionChannel> there is a mechanism that lets you close the output session indicating you will not send any more messages but keep the input session opened allowing you to continue to receive messages.</span></span>  
  
 <span data-ttu-id="27bed-164">通常、セッションは受信側ではなく送信側で閉じます。</span><span class="sxs-lookup"><span data-stu-id="27bed-164">In general, sessions are closed on the outgoing side and not on the incoming side.</span></span> <span data-ttu-id="27bed-165">つまり、セッションの多い出力チャネルを閉じることで、セッションを完全に終了できます。</span><span class="sxs-lookup"><span data-stu-id="27bed-165">That is, sessionful output channels can be closed, thereby cleanly terminating the session.</span></span> <span data-ttu-id="27bed-166">セッションの多い出力チャネルを閉じると、対応するセッションの多い入力チャネルは、<xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> の <xref:System.ServiceModel.Channels.IDuplexSessionChannel> を呼び出しているアプリケーションに対して null を返します。</span><span class="sxs-lookup"><span data-stu-id="27bed-166">Closing a sessionful output channel causes the corresponding sessionful input channel to return null to the application calling <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> on the <xref:System.ServiceModel.Channels.IDuplexSessionChannel>.</span></span>  
  
 <span data-ttu-id="27bed-167">ただし、<xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> の <xref:System.ServiceModel.Channels.IDuplexSessionChannel> が null を返して、セッションが既に閉じていることを示していない場合は、セッションの多い入力チャネルを閉じないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="27bed-167">However sessionful input channels should not be closed unless <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> on the <xref:System.ServiceModel.Channels.IDuplexSessionChannel> returns null, indicating that the session is already closed.</span></span> <span data-ttu-id="27bed-168"><xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> の <xref:System.ServiceModel.Channels.IDuplexSessionChannel> が null を返していない場合に、セッションの多い入力チャネルを閉じると、例外がスローされることがあります。これは、チャネルを閉じている間に、予期しないメッセージを受信することがあるためです。</span><span class="sxs-lookup"><span data-stu-id="27bed-168">If <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> on the <xref:System.ServiceModel.Channels.IDuplexSessionChannel> has not returned null, closing a sessionful input channel may throw an exception because it may receive unexpected messages while closing.</span></span> <span data-ttu-id="27bed-169">送信側がセッションを終了する前に、受信側でセッションを終了する必要がある場合は、入力チャネルで <xref:System.ServiceModel.ICommunicationObject.Abort%2A> を呼び出します。この呼び出しにより、セッションはその場で終了します。</span><span class="sxs-lookup"><span data-stu-id="27bed-169">If a receiver wishes to terminate a session before the sender does, it should call <xref:System.ServiceModel.ICommunicationObject.Abort%2A> on the input channel, which abruptly terminates the session.</span></span>  
  
## <a name="writing-sessionful-channels"></a><span data-ttu-id="27bed-170">セッションの多いチャネルの作成</span><span class="sxs-lookup"><span data-stu-id="27bed-170">Writing Sessionful Channels</span></span>  

 <span data-ttu-id="27bed-171">セッションの多いチャネルを作成した場合、セッションを提供するためにチャネルで実行しなければならないことがいくつかあります。</span><span class="sxs-lookup"><span data-stu-id="27bed-171">As a sessionful channel author, there are a few things your channel must do to provide sessions.</span></span> <span data-ttu-id="27bed-172">送信側では、チャネルで以下を行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="27bed-172">On the send side, your channel needs to:</span></span>  
  
- <span data-ttu-id="27bed-173">新しいチャネルごとに、新しいセッションを作成し、新しいセッション ID (一意の文字列) に関連付けます。</span><span class="sxs-lookup"><span data-stu-id="27bed-173">For each new channel, create a new session and associate it with a new session id which is a unique string.</span></span> <span data-ttu-id="27bed-174">または、スタック内で、作成したチャネルの下にあるセッションの多いチャネルから新しいセッションを取得します。</span><span class="sxs-lookup"><span data-stu-id="27bed-174">Or obtain a new session from the sessionful channel below you in the stack.</span></span>  
  
- <span data-ttu-id="27bed-175">(下のレイヤーからセッションを取得したのではなく) チャネルでセッションを作成した場合は、このチャネルを使用して送信される各メッセージについて、メッセージをセッションに関連付ける必要があります。</span><span class="sxs-lookup"><span data-stu-id="27bed-175">For each message sent using this channel, if your channel created the session (as opposed to obtaining it from the layer below you), you need to associate the message with the session.</span></span> <span data-ttu-id="27bed-176">プロトコル チャネルの場合、通常は SOAP ヘッダーを追加することによってこの関連付けを行います。</span><span class="sxs-lookup"><span data-stu-id="27bed-176">For protocol channels, this is typically done by adding a SOAP header.</span></span> <span data-ttu-id="27bed-177">トランスポート チャネルの場合は、新しいトランスポート接続を作成するか、フレーミング プロトコルにセッション情報を追加します。</span><span class="sxs-lookup"><span data-stu-id="27bed-177">For transport channels, this is typically done by creating a new transport connection or adding session information to the framing protocol.</span></span>  
  
- <span data-ttu-id="27bed-178">このチャネルを使用して送信される各メッセージについて、前述の配信保証を提供する必要があります。</span><span class="sxs-lookup"><span data-stu-id="27bed-178">For each message sent using this channel, you need to provide the delivery guarantees mentioned above.</span></span> <span data-ttu-id="27bed-179">下のレイヤーのチャネルを使用してセッションを提供している場合、そのチャネルでも配信保証を提供します。</span><span class="sxs-lookup"><span data-stu-id="27bed-179">If you are relying on the channel below you to provide the session, that channel will also provide the delivery guarantees.</span></span> <span data-ttu-id="27bed-180">セッションを独自に提供する場合は、これらの保証をプロトコルの一部として実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="27bed-180">If you’re providing the session yourself, you need to implement those guarantees as part of your protocol.</span></span> <span data-ttu-id="27bed-181">通常、両方の側で WCF を想定したプロトコル チャネルを作成する場合、TCP トランスポート チャネルまたは信頼できるメッセージング チャネルが必要となり、セッションを提供するためにこれらのいずれかに依存します。</span><span class="sxs-lookup"><span data-stu-id="27bed-181">In general, if you are writing a protocol channel that assumes WCF on both sides you may require the TCP transport or the Reliable Messaging channel and rely on either one to provide a session.</span></span>  
  
- <span data-ttu-id="27bed-182">チャネルで <xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> が呼び出されたときに、指定したタイムアウトまたは既定のタイムアウトを使用して、セッションを閉じるために必要な作業を実行します。</span><span class="sxs-lookup"><span data-stu-id="27bed-182">When <xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> is called on your channel, perform the necessary work to close the session using either the specified timeout or the default one.</span></span> <span data-ttu-id="27bed-183">これは、下のレイヤーのチャネルで <xref:System.ServiceModel.ICommunicationObject.Close%2A> を呼び出すか (そのチャネルからセッションを取得しただけの場合)、特殊な SOAP メッセージを送信するか、またはトランスポート接続を閉じるだけです。</span><span class="sxs-lookup"><span data-stu-id="27bed-183">This can be as simple as calling <xref:System.ServiceModel.ICommunicationObject.Close%2A> on the channel below you (if you just obtained the session from it) or sending a special SOAP message or closing a transport connection.</span></span>  
  
- <span data-ttu-id="27bed-184">チャネルで <xref:System.ServiceModel.ICommunicationObject.Abort%2A> が呼び出されたときに、I/O を実行せずにセッションをその場で終了します。</span><span class="sxs-lookup"><span data-stu-id="27bed-184">When <xref:System.ServiceModel.ICommunicationObject.Abort%2A> is called on your channel, terminate the session abruptly without performing I/O.</span></span> <span data-ttu-id="27bed-185">これは、何も実行しないことを意味する場合もあれば、ネットワーク接続または他の何らかのリソースの中止を伴う場合もあります。</span><span class="sxs-lookup"><span data-stu-id="27bed-185">This may mean doing nothing or may involve aborting a network connection or some other resource.</span></span>  
  
 <span data-ttu-id="27bed-186">受信側では、チャネルで以下を行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="27bed-186">On the receive side, your channel needs to:</span></span>  
  
- <span data-ttu-id="27bed-187">各受信メッセージについて、チャネル リスナーは、そのメッセージが属しているセッションを検出する必要があります。</span><span class="sxs-lookup"><span data-stu-id="27bed-187">For each incoming message, the channel listener must detect the session it belongs to.</span></span> <span data-ttu-id="27bed-188">メッセージがセッションの最初のメッセージである場合、チャネル リスナーは新しいチャネルを作成し、<xref:System.ServiceModel.Channels.IChannelListener%601.AcceptChannel%2A?displayProperty=nameWithType> の呼び出しからそのチャネルを返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="27bed-188">If this is the first message in the session, the channel listener must create a new channel and return it from the call to <xref:System.ServiceModel.Channels.IChannelListener%601.AcceptChannel%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="27bed-189">それ以外の場合は、チャネル リスナーはセッションに対応する既存のチャネルを検出し、そのチャネルを介してメッセージを配信する必要があります。</span><span class="sxs-lookup"><span data-stu-id="27bed-189">Otherwise the channel listener must find the existing channel that corresponds to the session and deliver the message through that channel.</span></span>  
  
- <span data-ttu-id="27bed-190">独自のチャネルで (必要な配信保証と共に) セッションを提供する場合、受信側はメッセージの順序付けや受信確認の送信など、いくつかのアクションを実行することが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="27bed-190">If your channel is providing the session (along with the required delivery guarantees) the receive side may be required to perform some actions such as re-order messages or send acknowledgements.</span></span>  
  
- <span data-ttu-id="27bed-191">チャネルで <xref:System.ServiceModel.ICommunicationObject.Close%2A> が呼び出されたときに、指定したタイムアウトまたは既定のタイムアウトを使用して、セッションを閉じるために必要な作業を実行します。</span><span class="sxs-lookup"><span data-stu-id="27bed-191">When <xref:System.ServiceModel.ICommunicationObject.Close%2A> is called on your channel, perform the necessary work to close the session either the specified timeout or the default one.</span></span> <span data-ttu-id="27bed-192">この作業を実行すると、チャネルがタイムアウトになるのを待機している間にメッセージを受信した場合に、例外が発生することがあります。</span><span class="sxs-lookup"><span data-stu-id="27bed-192">This could result in exceptions if the channel receives a message while waiting for the close timeout to expire.</span></span> <span data-ttu-id="27bed-193">これは、メッセージを受信したときに、チャネルが終了状態になっているためです。この場合、例外がスローされることになります。</span><span class="sxs-lookup"><span data-stu-id="27bed-193">That’s because the channel will be in the Closing state when it receives a message so it would throw.</span></span>  
  
- <span data-ttu-id="27bed-194">チャネルで <xref:System.ServiceModel.ICommunicationObject.Abort%2A> が呼び出されたときに、I/O を実行せずにセッションをその場で終了します。</span><span class="sxs-lookup"><span data-stu-id="27bed-194">When <xref:System.ServiceModel.ICommunicationObject.Abort%2A> is called on your channel, terminate the session abruptly without performing I/O.</span></span> <span data-ttu-id="27bed-195">このときも、何も実行しないことを意味する場合もあれば、ネットワーク接続または他のリソースの中止を伴う場合もあります。</span><span class="sxs-lookup"><span data-stu-id="27bed-195">Again, this may mean doing nothing or may involve aborting a network connection or some other resource.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="27bed-196">関連項目</span><span class="sxs-lookup"><span data-stu-id="27bed-196">See also</span></span>

- [<span data-ttu-id="27bed-197">チャネル モデルの概要</span><span class="sxs-lookup"><span data-stu-id="27bed-197">Channel Model Overview</span></span>](channel-model-overview.md)
