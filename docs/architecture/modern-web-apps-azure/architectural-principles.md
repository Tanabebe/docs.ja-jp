---
title: アーキテクチャの原則
description: ASP.NET Core および Azure での最新の Web アプリケーションの設計 | アーキテクチャの原則
author: ardalis
ms.author: wiwagn
ms.date: 12/01/2020
ms.openlocfilehash: bab860b73f029687873949f1cafed02cfcea7220
ms.sourcegitcommit: c7f0beaa2bd66ebca86362ca17d673f7e8256ca6
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/23/2021
ms.locfileid: "104873069"
---
# <a name="architectural-principles"></a><span data-ttu-id="183d2-103">アーキテクチャの原則</span><span class="sxs-lookup"><span data-stu-id="183d2-103">Architectural principles</span></span>

> <span data-ttu-id="183d2-104">"プログラマーがプログラムを記述するやり方で建設業者がビルを建てたなら、最初にやって来たキツツキによって文明は破壊されてしまうでしょう。"</span><span class="sxs-lookup"><span data-stu-id="183d2-104">"If builders built buildings the way programmers wrote programs, then the first woodpecker that came along would destroy civilization."</span></span>  
> <span data-ttu-id="183d2-105">_\- Gerald Weinberg_</span><span class="sxs-lookup"><span data-stu-id="183d2-105">_\- Gerald Weinberg_</span></span>

<span data-ttu-id="183d2-106">ソフトウェア ソリューションを設計する場合は、保守容易性を念頭に置く必要があります。</span><span class="sxs-lookup"><span data-stu-id="183d2-106">You should architect and design software solutions with maintainability in mind.</span></span> <span data-ttu-id="183d2-107">このセクションで概説する原則は、クリーンで保守性の高いアプリケーションをもたらすアーキテクチャを決定する上で役に立ちます。</span><span class="sxs-lookup"><span data-stu-id="183d2-107">The principles outlined in this section can help guide you toward architectural decisions that will result in clean, maintainable applications.</span></span> <span data-ttu-id="183d2-108">一般に、これらの原則に従うことで、明示的なインターフェイスまたはメッセージング システムを介してやり取りするコンポーネントでなく、アプリケーションの他の部分と密結合されていないそれぞれ独立したコンポーネントからアプリケーションを構築できるようになります。</span><span class="sxs-lookup"><span data-stu-id="183d2-108">Generally, these principles will guide you toward building applications out of discrete components that are not tightly coupled to other parts of your application, but rather communicate through explicit interfaces or messaging systems.</span></span>

## <a name="common-design-principles"></a><span data-ttu-id="183d2-109">一般的な設計の原則</span><span class="sxs-lookup"><span data-stu-id="183d2-109">Common design principles</span></span>

### <a name="separation-of-concerns"></a><span data-ttu-id="183d2-110">懸念事項の分離</span><span class="sxs-lookup"><span data-stu-id="183d2-110">Separation of concerns</span></span>

<span data-ttu-id="183d2-111">開発時の基本原則は、**懸念事項の分離** です。</span><span class="sxs-lookup"><span data-stu-id="183d2-111">A guiding principle when developing is **Separation of Concerns**.</span></span> <span data-ttu-id="183d2-112">この原則では、ソフトウェアが実行する処理の種類に基づいてソフトウェアを分離する必要があると表明しています。</span><span class="sxs-lookup"><span data-stu-id="183d2-112">This principle asserts that software should be separated based on the kinds of work it performs.</span></span> <span data-ttu-id="183d2-113">たとえば、ユーザーに表示する注目すべき項目を識別し、さらにそのような項目を特定の方法で書式設定して一段と目立つようにするロジックを備えたアプリケーションを検討します。</span><span class="sxs-lookup"><span data-stu-id="183d2-113">For instance, consider an application that includes logic for identifying noteworthy items to display to the user, and which formats such items in a particular way to make them more noticeable.</span></span> <span data-ttu-id="183d2-114">書式設定する項目の選定を担当するビヘイビアーと、項目の書式設定を担当するビヘイビアーとは切り離しておく必要があります。これらは別々の懸念事項であり、偶然に関連しているに過ぎないからです。</span><span class="sxs-lookup"><span data-stu-id="183d2-114">The behavior responsible for choosing which items to format should be kept separate from the behavior responsible for formatting the items, since these behaviors are separate concerns that are only coincidentally related to one another.</span></span>

<span data-ttu-id="183d2-115">アーキテクチャの面から見て、インフラストラクチャおよびユーザー インターフェイス ロジックからコア ビジネス ビヘイビアーを切り離せば、この原則に従うアプリケーションを論理的に構築することができます。</span><span class="sxs-lookup"><span data-stu-id="183d2-115">Architecturally, applications can be logically built to follow this principle by separating core business behavior from infrastructure and user-interface logic.</span></span> <span data-ttu-id="183d2-116">理想的には、ビジネス ルールとロジックを独立したプロジェクトに配置し、そのプロジェクトがアプリケーション内の他のプロジェクトに依存しないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="183d2-116">Ideally, business rules and logic should reside in a separate project, which should not depend on other projects in the application.</span></span> <span data-ttu-id="183d2-117">このように切り離すことで、ビジネス モデルはテストするのが容易になり、さらに低レベルの実装の詳細に密結合せずに展開させることができます。</span><span class="sxs-lookup"><span data-stu-id="183d2-117">This separation helps ensure that the business model is easy to test and can evolve without being tightly coupled to low-level implementation details.</span></span> <span data-ttu-id="183d2-118">懸念事項の分離は、アプリケーション アーキテクチャでのレイヤー使用の背後にある主要な検討事項です。</span><span class="sxs-lookup"><span data-stu-id="183d2-118">Separation of concerns is a key consideration behind the use of layers in application architectures.</span></span>

### <a name="encapsulation"></a><span data-ttu-id="183d2-119">カプセル化</span><span class="sxs-lookup"><span data-stu-id="183d2-119">Encapsulation</span></span>

<span data-ttu-id="183d2-120">アプリケーションのそれぞれの部分は、**カプセル化** を使用してアプリケーションの他の部分と切り離す必要があります。</span><span class="sxs-lookup"><span data-stu-id="183d2-120">Different parts of an application should use **encapsulation** to insulate them from other parts of the application.</span></span> <span data-ttu-id="183d2-121">アプリケーションのコンポーネントとレイヤーでは、外部のコントラクトに違反しない限りは、共同作業者を分断することなく内部の実装を調整できる必要があります。</span><span class="sxs-lookup"><span data-stu-id="183d2-121">Application components and layers should be able to adjust their internal implementation without breaking their collaborators as long as external contracts are not violated.</span></span> <span data-ttu-id="183d2-122">同じインターフェイスが保持される限りは、オブジェクトとパッケージを代替実装に置換できることから、カプセル化を適切に使用すれば、アプリケーションの設計において疎結合とモジュール化を達成できます。</span><span class="sxs-lookup"><span data-stu-id="183d2-122">Proper use of encapsulation helps achieve loose coupling and modularity in application designs, since objects and packages can be replaced with alternative implementations so long as the same interface is maintained.</span></span>

<span data-ttu-id="183d2-123">クラスでは、クラスの内部状態への外部アクセスを制限することによってカプセル化が実現されます。</span><span class="sxs-lookup"><span data-stu-id="183d2-123">In classes, encapsulation is achieved by limiting outside access to the class's internal state.</span></span> <span data-ttu-id="183d2-124">オブジェクトの状態を操作する外部アクターの場合、オブジェクトのプライベートな状態に直接アクセスするのでなく、適切に定義された関数 (またはプロパティ セッター) を介して操作を行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="183d2-124">If an outside actor wants to manipulate the state of the object, it should do so through a well-defined function (or property setter), rather than having direct access to the private state of the object.</span></span> <span data-ttu-id="183d2-125">同様に、アプリケーション コンポーネントおよびアプリケーション自体においても、状態に直接変更を加えることを許可するのではなく、適切に定義されたインターフェイスを公開して共同作業者が使用できるようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="183d2-125">Likewise, application components and applications themselves should expose well-defined interfaces for their collaborators to use, rather than allowing their state to be modified directly.</span></span> <span data-ttu-id="183d2-126">このアプローチにより、パブリック コントラクトが保持される限りは、時間の経過と共に変化するアプリケーションの内部設計が解放され、それによるコラボレーターの分断を心配する必要がなくなります。</span><span class="sxs-lookup"><span data-stu-id="183d2-126">This approach frees the application's internal design to evolve over time without worrying that doing so will break collaborators, so long as the public contracts are maintained.</span></span>

### <a name="dependency-inversion"></a><span data-ttu-id="183d2-127">依存関係の逆転</span><span class="sxs-lookup"><span data-stu-id="183d2-127">Dependency inversion</span></span>

<span data-ttu-id="183d2-128">アプリケーション内の依存関係の方向は、実装の詳細の方向ではなく、抽象化の方向とする必要があります。</span><span class="sxs-lookup"><span data-stu-id="183d2-128">The direction of dependency within the application should be in the direction of abstraction, not implementation details.</span></span> <span data-ttu-id="183d2-129">大部分のアプリケーションは、コンパイル時の依存関係のフローがランタイム実行の方向になるように記述され、直接的な依存関係グラフが生成されます。</span><span class="sxs-lookup"><span data-stu-id="183d2-129">Most applications are written such that compile-time dependency flows in the direction of runtime execution, producing a direct dependency graph.</span></span> <span data-ttu-id="183d2-130">つまり、クラス A がクラス B のメソッドを呼び出し、クラス B がクラス C のメソッドを呼び出す場合は、図 4-1 に示すように、コンパイル時にクラス A はクラス B に依存し、クラス B はクラス C に依存します。</span><span class="sxs-lookup"><span data-stu-id="183d2-130">That is, if class A calls a method of class B and class B calls a method of class C, then at compile time class A will depend on class B, and class B will depend on class C, as shown in Figure 4-1.</span></span>

![直接的な依存関係グラフ](./media/image4-1.png)

<span data-ttu-id="183d2-132">**図 4-1**</span><span class="sxs-lookup"><span data-stu-id="183d2-132">**Figure 4-1.**</span></span> <span data-ttu-id="183d2-133">直接的な依存関係グラフ。</span><span class="sxs-lookup"><span data-stu-id="183d2-133">Direct dependency graph.</span></span>

<span data-ttu-id="183d2-134">依存関係逆転の原則を適用すると、A は B によって実装された抽象化でメソッドを呼び出すことができます。このことは、実行時に A が B を呼び出し、コンパイル時には B が、A によって制御されるインターフェイスに依存することを可能にします (つまり、通常のコンパイル時の依存関係が *逆転* されます)。</span><span class="sxs-lookup"><span data-stu-id="183d2-134">Applying the dependency inversion principle allows A to call methods on an abstraction that B implements, making it possible for A to call B at runtime, but for B to depend on an interface controlled by A at compile time (thus, *inverting* the typical compile-time dependency).</span></span> <span data-ttu-id="183d2-135">実行時に、プログラム実行のフローには変更がありませんが、インターフェイスの導入により、このインターフェイスのさまざまな実装を簡単に接続できるようになります。</span><span class="sxs-lookup"><span data-stu-id="183d2-135">At run time, the flow of program execution remains unchanged, but the introduction of interfaces means that different implementations of these interfaces can easily be plugged in.</span></span>

![逆転された依存関係グラフ](./media/image4-2.png)

<span data-ttu-id="183d2-137">**図 4-2**</span><span class="sxs-lookup"><span data-stu-id="183d2-137">**Figure 4-2.**</span></span> <span data-ttu-id="183d2-138">逆転された依存関係グラフ。</span><span class="sxs-lookup"><span data-stu-id="183d2-138">Inverted dependency graph.</span></span>

<span data-ttu-id="183d2-139">**依存関係逆転** は、疎結合のアプリケーションをビルドする上で重要な部分となります。その理由は、より低いレベルの抽象化ではなく、より高いレベルの抽象化に依存しそれらを実装するように、実装の詳細を記述することができるからです。</span><span class="sxs-lookup"><span data-stu-id="183d2-139">**Dependency inversion** is a key part of building loosely coupled applications, since implementation details can be written to depend on and implement higher-level abstractions, rather than the other way around.</span></span> <span data-ttu-id="183d2-140">したがって、結果として得られるアプリケーションは、テストが容易で、モジュール性が高く、保守も容易です。</span><span class="sxs-lookup"><span data-stu-id="183d2-140">The resulting applications are more testable, modular, and maintainable as a result.</span></span> <span data-ttu-id="183d2-141">*依存関係挿入* の実施は、次に示す依存関係逆転の原則に従うことで可能になります。</span><span class="sxs-lookup"><span data-stu-id="183d2-141">The practice of *dependency injection* is made possible by following the dependency inversion principle.</span></span>

### <a name="explicit-dependencies"></a><span data-ttu-id="183d2-142">明示的な依存関係</span><span class="sxs-lookup"><span data-stu-id="183d2-142">Explicit dependencies</span></span>

<span data-ttu-id="183d2-143">**メソッドやクラスでは、正しく機能するために必要となるコラボレーション オブジェクトをすべて明示的に要求すべきです。**</span><span class="sxs-lookup"><span data-stu-id="183d2-143">**Methods and classes should explicitly require any collaborating objects they need in order to function correctly.**</span></span> <span data-ttu-id="183d2-144">クラスのコンストラクターは、クラスが有効な状態になるため、および適切に機能するために必要なことを、クラスが識別できるようにします。</span><span class="sxs-lookup"><span data-stu-id="183d2-144">Class constructors provide an opportunity for classes to identify the things they need in order to be in a valid state and to function properly.</span></span> <span data-ttu-id="183d2-145">構成および呼び出し可能なクラスであるが、特定のグローバルまたはインフラストラクチャ コンポーネントが揃っている場合にのみ適切に機能するクラスを定義した場合、そのようなクラスはクライアントに対して "*悪意を持つ*" クラスとなります。</span><span class="sxs-lookup"><span data-stu-id="183d2-145">If you define classes that can be constructed and called, but that will only function properly if certain global or infrastructure components are in place, these classes are being *dishonest* with their clients.</span></span> <span data-ttu-id="183d2-146">コンストラクターのコントラクトは、指定された内容のみ必要であるとクライアントに通知します (クラスでパラメーターなしのコンストラクターのみが使用されている場合は、何もない可能性があります) が、実行時に、オブジェクトが実際に必要としたものは他の内容であったという結果になっています。</span><span class="sxs-lookup"><span data-stu-id="183d2-146">The constructor contract is telling the client that it only needs the things specified (possibly nothing if the class is just using a parameterless constructor), but then at runtime it turns out the object really did need something else.</span></span>

<span data-ttu-id="183d2-147">明示的な依存関係の原則に従うことで、クラスとメソッドは、機能するために何が必要かを、クライアントに対して正確に知らせるようになります。</span><span class="sxs-lookup"><span data-stu-id="183d2-147">By following the explicit dependencies principle, your classes and methods are being honest with their clients about what they need in order to function.</span></span> <span data-ttu-id="183d2-148">原則に従うと、コードの自動文書化が進み、コーディング コントラクトがわかりやすくなります。これは、必要な内容がメソッドまたはコンストラクターのパラメーターの形式で指定される限り、操作するオブジェクトが実行時に正しく動作することを信頼できるようになるからです。</span><span class="sxs-lookup"><span data-stu-id="183d2-148">Following the principle makes your code more self-documenting and your coding contracts more user-friendly, since users will come to trust that as long as they provide what's required in the form of method or constructor parameters, the objects they're working with will behave correctly at run time.</span></span>

### <a name="single-responsibility"></a><span data-ttu-id="183d2-149">単一責任</span><span class="sxs-lookup"><span data-stu-id="183d2-149">Single responsibility</span></span>

<span data-ttu-id="183d2-150">単一責任の原則は、オブジェクト指向の設計に適用されますが、懸念事項の分離に類似したアーキテクチャ原則と考えることもできます。</span><span class="sxs-lookup"><span data-stu-id="183d2-150">The single responsibility principle applies to object-oriented design, but can also be considered as an architectural principle similar to separation of concerns.</span></span> <span data-ttu-id="183d2-151">この原則では、オブジェクトの責任は 1 つのみとし、オブジェクトの変更理由も 1 つのみとする必要があると明記されています。</span><span class="sxs-lookup"><span data-stu-id="183d2-151">It states that objects should have only one responsibility and that they should have only one reason to change.</span></span> <span data-ttu-id="183d2-152">具体的に、オブジェクトの変更が必要な状況は、オブジェクトの単一責任の実行方法を更新する必要がある場合のみとなります。</span><span class="sxs-lookup"><span data-stu-id="183d2-152">Specifically, the only situation in which the object should change is if the manner in which it performs its one responsibility must be updated.</span></span> <span data-ttu-id="183d2-153">この原則に従えば、既存のクラスに他の責任を追加するのでなく、さまざまな種類の新しいビヘイビアーを新しいクラスとして実装できるので、疎結合でモジュール性の高いシステムがもたらされます。</span><span class="sxs-lookup"><span data-stu-id="183d2-153">Following this principle helps to produce more loosely coupled and modular systems, since many kinds of new behavior can be implemented as new classes, rather than by adding additional responsibility to existing classes.</span></span> <span data-ttu-id="183d2-154">新しいクラスを追加する方が既存のクラスを変更するよりも常に安全です。その理由はコードがまだ、新しいクラスに依存していないというところにあります。</span><span class="sxs-lookup"><span data-stu-id="183d2-154">Adding new classes is always safer than changing existing classes, since no code yet depends on the new classes.</span></span>

<span data-ttu-id="183d2-155">モノリシック アプリケーションでは、高レベルにある単一責任の原則をアプリケーション内のレイヤーに適用できます。</span><span class="sxs-lookup"><span data-stu-id="183d2-155">In a monolithic application, we can apply the single responsibility principle at a high level to the layers in the application.</span></span> <span data-ttu-id="183d2-156">プレゼンテーション責任は UI プロジェクト内に留め、データ アクセス責任はインフラストラクチャ プロジェクト内で保持する必要があります。</span><span class="sxs-lookup"><span data-stu-id="183d2-156">Presentation responsibility should remain in the UI project, while data access responsibility should be kept within an infrastructure project.</span></span> <span data-ttu-id="183d2-157">ビジネス ロジックは、アプリケーション コア プロジェクトで保持する必要があります。そこでは、ビジネス ロジックを容易にテストし、他の責任とは別個に発展させることができます。</span><span class="sxs-lookup"><span data-stu-id="183d2-157">Business logic should be kept in the application core project, where it can be easily tested and can evolve independently from other responsibilities.</span></span>

<span data-ttu-id="183d2-158">この原則がアプリケーション アーキテクチャに適用され、その論理エンドポイントに到達すると、マイクロサービスが得られます。</span><span class="sxs-lookup"><span data-stu-id="183d2-158">When this principle is applied to application architecture and taken to its logical endpoint, you get microservices.</span></span> <span data-ttu-id="183d2-159">指定されたマイクロサービスは、単一責任を持つ必要があります。</span><span class="sxs-lookup"><span data-stu-id="183d2-159">A given microservice should have a single responsibility.</span></span> <span data-ttu-id="183d2-160">システムのビヘイビアーを拡張する必要がある場合は、既存の責任にさらに責任を追加するのでなく、別のマイクロサービスを追加することによって目的を達成することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="183d2-160">If you need to extend the behavior of a system, it's usually better to do it by adding additional microservices, rather than by adding responsibility to an existing one.</span></span>

[<span data-ttu-id="183d2-161">マイクロサービス アーキテクチャの詳細</span><span class="sxs-lookup"><span data-stu-id="183d2-161">Learn more about microservices architecture</span></span>](https://aka.ms/MicroservicesEbook)

### <a name="dont-repeat-yourself-dry"></a><span data-ttu-id="183d2-162">DRY 原則</span><span class="sxs-lookup"><span data-stu-id="183d2-162">Don't repeat yourself (DRY)</span></span>

<span data-ttu-id="183d2-163">アプリケーションでは、特定の概念に関連するビヘイビアーを複数の場所で指定すると、エラーの原因となることが多いので、回避する必要があります。</span><span class="sxs-lookup"><span data-stu-id="183d2-163">The application should avoid specifying behavior related to a particular concept in multiple places as this practice is a frequent source of errors.</span></span> <span data-ttu-id="183d2-164">どこかの時点で要件を変更するには、この動作を変更する必要があります。</span><span class="sxs-lookup"><span data-stu-id="183d2-164">At some point, a change in requirements will require changing this behavior.</span></span> <span data-ttu-id="183d2-165">ビヘイビアーの少なくとも 1 つのインスタンスが更新に失敗し、システムの動作が不整合になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="183d2-165">It's likely that at least one instance of the behavior will fail to be updated, and the system will behave inconsistently.</span></span>

<span data-ttu-id="183d2-166">ロジックは複製するのではなく、プログラミング コンストラクト内でカプセル化します。</span><span class="sxs-lookup"><span data-stu-id="183d2-166">Rather than duplicating logic, encapsulate it in a programming construct.</span></span> <span data-ttu-id="183d2-167">このコンストラクトをこのビヘイビアーに対する単一権限とし、このビヘイビアーを必要とするアプリケーションの他の部分で新しいコンストラクターを使用するようにします。</span><span class="sxs-lookup"><span data-stu-id="183d2-167">Make this construct the single authority over this behavior, and have any other part of the application that requires this behavior use the new construct.</span></span>

> [!NOTE]
> <span data-ttu-id="183d2-168">偶然に発生した繰り返しに過ぎないビヘイビアーを一緒にバインドすることは避けてください。</span><span class="sxs-lookup"><span data-stu-id="183d2-168">Avoid binding together behavior that is only coincidentally repetitive.</span></span> <span data-ttu-id="183d2-169">たとえば、概念的に 2 つの異なる定数がさまざまな内容を参照している場合、両方の定数の値が同じであるからといって、1 つの定数のみを使用すればよいという意味にはなりません。</span><span class="sxs-lookup"><span data-stu-id="183d2-169">For example, just because two different constants both have the same value, that doesn't mean you should have only one constant, if conceptually they're referring to different things.</span></span>

### <a name="persistence-ignorance"></a><span data-ttu-id="183d2-170">永続性の無視</span><span class="sxs-lookup"><span data-stu-id="183d2-170">Persistence ignorance</span></span>

<span data-ttu-id="183d2-171">**永続性の無視** (PI) は永続化を必要とする型を参照しますが、そのコードは永続化技術の選択による影響を受けません。</span><span class="sxs-lookup"><span data-stu-id="183d2-171">**Persistence ignorance** (PI) refers to types that need to be persisted, but whose code is unaffected by the choice of persistence technology.</span></span> <span data-ttu-id="183d2-172">そのような .NET 内の型は、特定の基本クラスから継承することも、特定のインターフェイスを実装することも必要ないため、Plain Old CLR Object (POCO) と呼ばれることがあります。</span><span class="sxs-lookup"><span data-stu-id="183d2-172">Such types in .NET are sometimes referred to as Plain Old CLR Objects (POCOs), because they do not need to inherit from a particular base class or implement a particular interface.</span></span> <span data-ttu-id="183d2-173">永続性の無視は重要です。これにより、同じビジネス モデルを複数の方法で永続化することができ、アプリケーションの柔軟性が向上するからです。</span><span class="sxs-lookup"><span data-stu-id="183d2-173">Persistence ignorance is valuable because it allows the same business model to be persisted in multiple ways, offering additional flexibility to the application.</span></span> <span data-ttu-id="183d2-174">永続化の選択肢は時間の経過と共に、あるデータベース技術から別のデータベース技術へと変化する場合があります。また、アプリケーションを起動したものすべて (たとえば、リレーショナル データベースに加えて、Redis キャッシュまたは Azure Cosmos DB を使用) に加えて、永続化の追加フォームが必要な場合があります。</span><span class="sxs-lookup"><span data-stu-id="183d2-174">Persistence choices might change over time, from one database technology to another, or additional forms of persistence might be required in addition to whatever the application started with (for example, using a Redis cache or Azure Cosmos DB in addition to a relational database).</span></span>

<span data-ttu-id="183d2-175">この原則に対する違反の例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="183d2-175">Some examples of violations of this principle include:</span></span>

- <span data-ttu-id="183d2-176">必要な基本クラス</span><span class="sxs-lookup"><span data-stu-id="183d2-176">A required base class.</span></span>

- <span data-ttu-id="183d2-177">必要なインターフェイスの実装</span><span class="sxs-lookup"><span data-stu-id="183d2-177">A required interface implementation.</span></span>

- <span data-ttu-id="183d2-178">自身を保存する責任のあるクラス ("アクティブ レコード" パターンなど)</span><span class="sxs-lookup"><span data-stu-id="183d2-178">Classes responsible for saving themselves (such as the Active Record pattern).</span></span>

- <span data-ttu-id="183d2-179">必要なパラメーターなしのコンストラクター。</span><span class="sxs-lookup"><span data-stu-id="183d2-179">Required parameterless constructor.</span></span>

- <span data-ttu-id="183d2-180">仮想キーワードを必要とするプロパティ</span><span class="sxs-lookup"><span data-stu-id="183d2-180">Properties requiring virtual keyword.</span></span>

- <span data-ttu-id="183d2-181">必要とされる永続化に固有の属性</span><span class="sxs-lookup"><span data-stu-id="183d2-181">Persistence-specific required attributes.</span></span>

<span data-ttu-id="183d2-182">上記のいずれかの機能またはビヘイビアーがクラスに含まれる必要があるという要件では、永続化する型と永続化技術の選択肢との間に結合が追加されるため、後で新しいデータ アクセス方法を採用することが難しくなります。</span><span class="sxs-lookup"><span data-stu-id="183d2-182">The requirement that classes have any of the above features or behaviors adds coupling between the types to be persisted and the choice of persistence technology, making it more difficult to adopt new data access strategies in the future.</span></span>

### <a name="bounded-contexts"></a><span data-ttu-id="183d2-183">境界付けられたコンテキスト</span><span class="sxs-lookup"><span data-stu-id="183d2-183">Bounded contexts</span></span>

<span data-ttu-id="183d2-184">**境界付けられたコンテキスト** は、ドメイン駆動設計で中心となるパターンです。</span><span class="sxs-lookup"><span data-stu-id="183d2-184">**Bounded contexts** are a central pattern in Domain-Driven Design.</span></span> <span data-ttu-id="183d2-185">このコンテキストでは、大規模なアプリケーションまたは組織における複雑さを個々の概念モジュールに分割して、その複雑さに対応する方法を提供します。</span><span class="sxs-lookup"><span data-stu-id="183d2-185">They provide a way of tackling complexity in large applications or organizations by breaking it up into separate conceptual modules.</span></span> <span data-ttu-id="183d2-186">各概念モジュールは、他のコンテキストから分離された (境界付けされた) コンテキストを表し、個別に展開できます。</span><span class="sxs-lookup"><span data-stu-id="183d2-186">Each conceptual module then represents a context that is separated from other contexts (hence, bounded), and can evolve independently.</span></span> <span data-ttu-id="183d2-187">各境界付けられたコンテキストは、コンテキスト内で概念を表す独自の名前を自由に選択できることが理想的であり、独自の永続化ストアへの排他的なアクセス権限を有する必要があります。</span><span class="sxs-lookup"><span data-stu-id="183d2-187">Each bounded context should ideally be free to choose its own names for concepts within it, and should have exclusive access to its own persistence store.</span></span>

<span data-ttu-id="183d2-188">少なくとも、個々の Web アプリケーションでは、データベースを他のアプリケーションと共有するのでなく、ビジネス モデルに対して独自の永続化ストアを備えることで、独自の境界付けられたコンテキストになることを目指す必要があります。</span><span class="sxs-lookup"><span data-stu-id="183d2-188">At a minimum, individual web applications should strive to be their own bounded context, with their own persistence store for their business model, rather than sharing a database with other applications.</span></span> <span data-ttu-id="183d2-189">境界付けられたコンテキスト間の通信は、共有データベースを介してではなくプログラム インターフェイスを介して行われます。これにより、発生した変更に応じてビジネス ロジックおよびイベントを実行することができます。</span><span class="sxs-lookup"><span data-stu-id="183d2-189">Communication between bounded contexts occurs through programmatic interfaces, rather than through a shared database, which allows for business logic and events to take place in response to changes that take place.</span></span> <span data-ttu-id="183d2-190">境界付けられたコンテキストはマイクロサービスに正確にマップされます。このマイクロサービスもまた、それぞれ独自の境界付けられたコンテキストとして実装されるのが理想的です。</span><span class="sxs-lookup"><span data-stu-id="183d2-190">Bounded contexts map closely to microservices, which also are ideally implemented as their own individual bounded contexts.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="183d2-191">その他の技術情報</span><span class="sxs-lookup"><span data-stu-id="183d2-191">Additional resources</span></span>

- [<span data-ttu-id="183d2-192">Java の設計パターン: 原則</span><span class="sxs-lookup"><span data-stu-id="183d2-192">JAVA Design Patterns: Principles</span></span>](https://java-design-patterns.com/principles/)
- [<span data-ttu-id="183d2-193">境界付けられたコンテキスト</span><span class="sxs-lookup"><span data-stu-id="183d2-193">Bounded Context</span></span>](https://martinfowler.com/bliki/BoundedContext.html)

>[!div class="step-by-step"]
><span data-ttu-id="183d2-194">[前へ](choose-between-traditional-web-and-single-page-apps.md)
>[次へ](common-web-application-architectures.md)</span><span class="sxs-lookup"><span data-stu-id="183d2-194">[Previous](choose-between-traditional-web-and-single-page-apps.md)
[Next](common-web-application-architectures.md)</span></span>
