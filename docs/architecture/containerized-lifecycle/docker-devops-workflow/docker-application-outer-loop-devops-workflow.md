---
title: Docker アプリケーションの外側のループ DevOps ワークフローの手順
description: DevOps の "外部ループ" ワークフローの手順について学習する
ms.date: 01/06/2021
ms.openlocfilehash: 8bca36d5aa0fef95d684a96a5c6017ec15956358
ms.sourcegitcommit: 5ce37699c2a51ed173171813be68ef7577b1aba5
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/23/2021
ms.locfileid: "104881095"
---
# <a name="steps-in-the-outer-loop-devops-workflow-for-a-docker-application"></a><span data-ttu-id="f1ec3-103">Docker アプリケーションの外側のループ DevOps ワークフローの手順</span><span class="sxs-lookup"><span data-stu-id="f1ec3-103">Steps in the outer-loop DevOps workflow for a Docker application</span></span>

<span data-ttu-id="f1ec3-104">図 5-1 は、DevOps の外部ループ ワークフローを構成するエンド ツー エンド手順を表したものです。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-104">Figure 5-1 presents an end-to-end depiction of the steps comprising the DevOps outer-loop workflow.</span></span> <span data-ttu-id="f1ec3-105">これは DevOps の "外側のループ" を示します。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-105">It shows the "outer loop" of DevOps.</span></span> <span data-ttu-id="f1ec3-106">コードがリポジトリにプッシュされると、CI パイプラインが開始されてから CD パイプラインが開始され、そこでアプリケーションが配置されます。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-106">When code is pushed to the repo, a CI pipeline is started, then begins the CD pipeline, where the application gets deployed.</span></span> <span data-ttu-id="f1ec3-107">デプロイされたアプリケーションから収集されたメトリックは開発ワークロードにフィードバックされ、そこで "内部ループ" が発生します。したがって、開発チームは実際のデータを得てユーザーおよびビジネスのニーズに応えることができます。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-107">Metrics collected from deployed applications are fed back into the development workload, where the "inner loop" occurs, so development teams have actual data to respond to user and business needs.</span></span>

![DevOps の外側のループ ワークフローの 6 つの手順を示す図。](./media/docker-application-outer-loop-devops-workflow/overview-dev-ops-outter-loop-workflow.png)

<span data-ttu-id="f1ec3-109">**図 5-1**.</span><span class="sxs-lookup"><span data-stu-id="f1ec3-109">**Figure 5-1**.</span></span> <span data-ttu-id="f1ec3-110">Microsoft ツールを使用する Docker アプリケーションの DevOps 外部ループ ワークフロー</span><span class="sxs-lookup"><span data-stu-id="f1ec3-110">DevOps outer-loop workflow for Docker applications with Microsoft tools</span></span>

<span data-ttu-id="f1ec3-111">それでは、以下の手順をそれぞれ詳しく見ていきましょう。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-111">Now, let's examine each of these steps in greater detail.</span></span>

## <a name="step-1-inner-loop-development-workflow"></a><span data-ttu-id="f1ec3-112">手順 1: 内部ループの開発ワークフロー</span><span class="sxs-lookup"><span data-stu-id="f1ec3-112">Step 1: Inner-loop development workflow</span></span>

<span data-ttu-id="f1ec3-113">この手順は第 4 章で詳しく説明されていますが、要約するため、ここでは外部ループが開始され、その時点で開発者は CI パイプライン アクションを開始するソース コントロール管理システム (Git など) にコードをプッシュします。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-113">This step is explained in detail in Chapter 4, but, to recap, here is where the outer-loop begins, the moment at which a developer pushes code to the source control management system (like Git) initiating CI pipeline actions.</span></span>

## <a name="step-2-source-code-control-integration-and-management-with-azure-devops-services-and-git"></a><span data-ttu-id="f1ec3-114">手順 2: Azure DevOps Services と Git を使用するソース コード コントロールの統合と管理</span><span class="sxs-lookup"><span data-stu-id="f1ec3-114">Step 2: Source-Code Control integration and management with Azure DevOps Services and Git</span></span>

<span data-ttu-id="f1ec3-115">この手順では、チーム内のさまざまな開発者からの統合されたバージョンのコードをすべて収集するために、バージョン管理システムが必要になります。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-115">At this step, you need to have a version-control system to gather a consolidated version of all the code coming from the different developers in the team.</span></span>

<span data-ttu-id="f1ec3-116">ほとんどの開発者がソース コード コントロール (SCC) とソース コード管理に慣れているように見えても、DevOps ライフ サイクルで Docker アプリケーションを作成するときに、開発者のコンピューターからグローバルな Docker Registry (Azure Container Registry や Docker Hub など) に直接、Docker イメージをアプリケーションとともに送信してはいけないことを強調することが重要です。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-116">Even though source-code control (SCC) and source-code management might seem second-nature to most developers, when creating Docker applications in a DevOps life cycle, it's critical to emphasize that you must not submit the Docker images with the application directly to the global Docker Registry (like Azure Container Registry or Docker Hub) from the developer's machine.</span></span> <span data-ttu-id="f1ec3-117">一方、リリースして運用環境にデプロイする Docker イメージは、ソース コード リポジトリ (Git など) に基づいてグローバル ビルドまたは CI パイプラインで統合される、ソース コードでのみ作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-117">On the contrary, the Docker images to be released and deployed to production environments must be created solely on the source code that's being integrated in your global build or CI pipeline based on your source-code repository (like Git).</span></span>

<span data-ttu-id="f1ec3-118">開発者によって生成される、ローカル イメージは、独自のコンピューター内でテストするときにのみ、使用される必要があります。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-118">The local images, generated by developers, should just be used by them when testing within their own machines.</span></span> <span data-ttu-id="f1ec3-119">これが、SCC コードから DevOps パイプラインをアクティブ化することが重要である理由です。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-119">That's why it's critical to have the DevOps pipeline activated from the SCC code.</span></span>

<span data-ttu-id="f1ec3-120">Azure DevOps Services および Team Foundation Server では、Git と Team Foundation バージョン管理がサポートされます。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-120">Azure DevOps Services and Team Foundation Server support Git and Team Foundation Version Control.</span></span> <span data-ttu-id="f1ec3-121">いずれかを選択し、それをエンド ツー エンドの Microsoft エクスペリエンスで使用することができます。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-121">You can choose between them and use it for an end-to-end Microsoft experience.</span></span> <span data-ttu-id="f1ec3-122">しかし、外部リポジトリ (GitHub、オンプレミスの Git リポジトリ、Subversion など) でコードを管理することもでき、引き続き、それに接続し、DevOps CI パイプラインの開始点としてコードを取得することができます。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-122">However, you can also manage your code in external repositories (like GitHub, on-premises Git repositories, or Subversion) and still be able to connect to it and get the code as the starting point for your DevOps CI pipeline.</span></span>

## <a name="step-3-build-ci-integrate-and-test-with-azure-devops-services-and-docker"></a><span data-ttu-id="f1ec3-123">手順 3: Azure DevOps Services と Docker を使用するビルド、CI、統合、およびテスト</span><span class="sxs-lookup"><span data-stu-id="f1ec3-123">Step 3: Build, CI, Integrate, and Test with Azure DevOps Services and Docker</span></span>

<span data-ttu-id="f1ec3-124">CI は、最新のソフトウェアのテストおよび配布のための標準として登場しました。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-124">CI has emerged as a standard for modern software testing and delivery.</span></span> <span data-ttu-id="f1ec3-125">Docker ソリューションでは、開発および運用チーム間の懸念事項を明確に分離させておくことができます。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-125">The Docker solution maintains a clear separation of concerns between the development and operations teams.</span></span> <span data-ttu-id="f1ec3-126">Docker イメージの不変性により、CI を介して開発し、テストし、運用環境で実行する対象の間で反復可能なデプロイが保証されます。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-126">The immutability of Docker images ensures a repeatable deployment between what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="f1ec3-127">開発者のノート PC とテスト インフラストラクチャ全体にデプロイされた Docker エンジンにより、環境間でのコンテナーの移植が可能になります。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-127">Docker Engine deployed across the developer laptops and test infrastructure makes the containers portable across environments.</span></span>

<span data-ttu-id="f1ec3-128">ここで、正しいコードが送信され、バージョン管理システムの準備ができた後、コードを選択してグローバル ビルドとテストを実行するための "*ビルドサービス*" が必要になります。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-128">At this point, after you have a version-control system with the correct code submitted, you need a *build service* to pick up the code and run the global build and tests.</span></span>

<span data-ttu-id="f1ec3-129">この手順 (CI、ビルド、テスト) の内部ワークフローは、コード リポジトリ (Git など)、ビルド サーバー (Azure DevOps Services)、Docker エンジン、および Docker レジストリで構成される CI パイプラインの構築に関するものです。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-129">The internal workflow for this step (CI, build, test) is about the construction of a CI pipeline consisting of your code repository (Git, etc.), your build server (Azure DevOps Services), Docker Engine, and a Docker Registry.</span></span>

<span data-ttu-id="f1ec3-130">アプリケーションのビルドと CI パイプラインの設定のため、およびビルドされた "成果物" の "成果物リポジトリ" へのプッシュのための基盤として、Azure DevOps Services を使用できます。これについては、次の手順で説明します。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-130">You can use Azure DevOps Services as the foundation for building your applications and setting your CI pipeline, and for publishing the built "artifacts" to an "artifacts repository," which is explained in the next step.</span></span>

<span data-ttu-id="f1ec3-131">デプロイで Docker を使用する場合、デプロイされる "最終的な成果物" は、その中に埋め込まれているアプリケーションまたはサービスを含む Docker イメージです。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-131">When using Docker for the deployment, the "final artifacts" to be deployed are Docker images with your application or services embedded within them.</span></span> <span data-ttu-id="f1ec3-132">これらのイメージは、*Docker レジストリ* (Azure Container Registry で使用できるものなどのプライベート リポジトリ、または公式の基本イメージで一般的に使用される、Docker Hub Registry などのパブリックのもの) にプッシュまたは公開されます。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-132">Those images are pushed or published to a *Docker Registry* (a private repository like the ones you can have in Azure Container Registry, or a public one like Docker Hub Registry, which is commonly used for official base images).</span></span>

<span data-ttu-id="f1ec3-133">基本的な概念を以下に示します。CI パイプラインは、Git などの SCC へのコミットによって開始されます。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-133">Here is the basic concept: The CI pipeline will be kicked-off by a commit to an SCC repository like Git.</span></span> <span data-ttu-id="f1ec3-134">図 5-2 に示すように、コミットにより、Azure DevOps Services では Docker コンテナー内でビルド ジョブが実行され、そのジョブが正常に完了すると、Docker イメージが Docker レジストリにプッシュされるようになります。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-134">The commit will cause Azure DevOps Services to run a build job within a Docker container and, upon successful completion of that job, push a Docker image to the Docker Registry, as illustrated in Figure 5-2.</span></span> <span data-ttu-id="f1ec3-135">外部ループの最初の部分は手順 1 から 3、つまり、コード、実行、デバッグ、検証、その後のコード リポジトリ、ビルドとテスト CI 手順までが関連します。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-135">The first part of the outer loop involves steps 1 to 3, from code, run, debug and validate, then the code repo up to the build and test CI step.</span></span>

![CI ワークフローに関連する 3 つの手順を示す図](./media/docker-application-outer-loop-devops-workflow/continuous-integration-steps.png)

<span data-ttu-id="f1ec3-137">**図 5-2**</span><span class="sxs-lookup"><span data-stu-id="f1ec3-137">**Figure 5-2**.</span></span> <span data-ttu-id="f1ec3-138">CI に関連する手順</span><span class="sxs-lookup"><span data-stu-id="f1ec3-138">The steps involved in CI</span></span>

<span data-ttu-id="f1ec3-139">Docker と Azure DevOps Services を使用する基本的な CI ワークフロー手順を以下に示します。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-139">Here are the basic CI workflow steps with Docker and Azure DevOps Services:</span></span>

1. <span data-ttu-id="f1ec3-140">開発者は、SCC リポジトリ (Git/Azure DevOps Services、GitHub など) にコミットをプッシュします。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-140">The developer pushes a commit to an SCC repository (Git/Azure DevOps Services, GitHub, etc.).</span></span>

2. <span data-ttu-id="f1ec3-141">Azure DevOps Services または Git を使用する場合、CI は組み込まれています。つまり、Azure DevOps Services でチェック ボックスをオンにするのと同じくらいシンプルです。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-141">If you're using Azure DevOps Services or Git, CI is built in, which means that it's as simple as selecting a check box in Azure DevOps Services.</span></span> <span data-ttu-id="f1ec3-142">外部 SCC (GitHub など) を使用する場合は、`webhook` によって、Azure DevOps Services に更新プログラムが通知されるか、Git/GitHub にプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-142">If you're using an external SCC (like GitHub), a `webhook` will notify Azure DevOps Services of the update or push to Git/GitHub.</span></span>

3. <span data-ttu-id="f1ec3-143">Azure DevOps Services では、アプリケーションとテスト コードだけでなく、イメージを記述する Dockerfile を含む、SCC リポジトリがプルされます。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-143">Azure DevOps Services pulls the SCC repository, including the Dockerfile describing the image, as well as the application and test code.</span></span>

4. <span data-ttu-id="f1ec3-144">Azure DevOps Services によって Docker イメージがビルドされ、ビルド番号でラベルが付けられます。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-144">Azure DevOps Services builds a Docker image and labels it with a build number.</span></span>

5. <span data-ttu-id="f1ec3-145">Azure DevOps Services では、プロビジョニング済みの Docker ホスト内で Docker コンテナーがインスタンス化され、適切なテストが実行されます。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-145">Azure DevOps Services instantiates the Docker container within the provisioned Docker Host, and runs the appropriate tests.</span></span>

6. <span data-ttu-id="f1ec3-146">テストに成功した場合、イメージはまず、わかりやすい名前にラベルが書き換えられるため、それが "blessed ビルド" ("/1.0.0" やその他のラベルなど) であることがわかります。その後、Docker レジストリ (Docker Hub、Azure Container Registry、DTR など) までプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-146">If the tests are successful, the image is first relabeled to a meaningful name so that you know it's a "blessed build" (like "/1.0.0" or any other label), and then pushed up to your Docker Registry (Docker Hub, Azure Container Registry, DTR, etc.)</span></span>

### <a name="implementing-the-ci-pipeline-with-azure-devops-services-and-the-docker-extension-for-azure-devops-services"></a><span data-ttu-id="f1ec3-147">Azure DevOps Services および Azure DevOps Services 用の Docker 拡張機能を使用する CI パイプラインの実装</span><span class="sxs-lookup"><span data-stu-id="f1ec3-147">Implementing the CI pipeline with Azure DevOps Services and the Docker extension for Azure DevOps Services</span></span>

<span data-ttu-id="f1ec3-148">Visual Studio の Azure DevOps Services にはビルドとリリース テンプレートが含まれており、これらを CI/CD パイプラインで使用でき、Docker イメージをビルドしたり、認証済みの Docker レジストリに Docker イメージをプッシュしたり、Docker CLI によって提供される他の操作を実行したりすることができます。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-148">Visual Studio Azure DevOps Services contains Build & Release Templates that you can use in your CI/CD pipeline with which you can build Docker images, push Docker images to an authenticated Docker registry, run Docker images, or run other operations offered by the Docker CLI.</span></span> <span data-ttu-id="f1ec3-149">また、Docker Compose タスクが追加されます。これを使用して、図 5-3 に示すように、複数コンテナーの Docker アプリケーションをビルド、プッシュ、実行したり、Docker Compose CLI によって提供される他の操作を実行したりすることができます。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-149">It also adds a Docker Compose task that you can use to build, push, and run multi-container Docker applications, or run other operations offered by the Docker Compose CLI, as shown in Figure 5-3.</span></span>

![Azure DevOps の Docker CI パイプラインのスクリーンショット。](./media/docker-application-outer-loop-devops-workflow/docker-ci-pipeline-azure-devops.png)

<span data-ttu-id="f1ec3-151">**図 5-3**</span><span class="sxs-lookup"><span data-stu-id="f1ec3-151">**Figure 5-3**.</span></span> <span data-ttu-id="f1ec3-152">ビルドとリリース テンプレートおよび関連するタスクを含む、Azure DevOps Service の Docker CI パイプライン。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-152">The Docker CI pipeline in Azure DevOps Services including Build & Release Templates and associated tasks.</span></span>

<span data-ttu-id="f1ec3-153">これらのテンプレートとタスクを使用して、Azure Service Fabric、Azure Kubernetes Service、および同様のオファリングでビルド/テストおよびデプロイのための CI/CD 成果物を構築することができます。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-153">You can use these templates and tasks to construct your CI/CD artifacts to Build / Test and Deploy in Azure Service Fabric, Azure Kubernetes Service, and similar offerings.</span></span>

<span data-ttu-id="f1ec3-154">これらの Visual Studio Team Services タスク、Azure でプロビジョニングされたビルド Linux-Docker ホスト/VM、および任意の Docker レジストリ (Azure Container Registry、Docker Hub、プライベート Docker DTR、またはその他の Docker レジストリ) では、非常に一貫した方法で Docker CI パイプラインをアセンブルすることができます。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-154">With these Visual Studio Team Services tasks, a build Linux-Docker Host/VM provisioned in Azure and your preferred Docker registry (Azure Container Registry, Docker Hub, private Docker DTR, or any other Docker registry) you can assemble your Docker CI pipeline in a very consistent way.</span></span>

<span data-ttu-id="f1ec3-155">***要件:***</span><span class="sxs-lookup"><span data-stu-id="f1ec3-155">***Requirements:***</span></span>

- <span data-ttu-id="f1ec3-156">Azure DevOps Services。オンプレミス インストールの場合は、Team Foundation Server 2015 Update 3 以降。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-156">Azure DevOps Services, or for on-premises installations, Team Foundation Server 2015 Update 3 or later.</span></span>

- <span data-ttu-id="f1ec3-157">Docker バイナリを含む Azure DevOps Services エージェント。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-157">An Azure DevOps Services agent that has the Docker binaries.</span></span>

  <span data-ttu-id="f1ec3-158">これらのエージェントのいずれかを作成する簡単な方法は、Docker を使用し、Azure DevOps Services エージェントの Docker イメージに基づいてコンテナーを実行することです。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-158">An easy way to create one of these agents is to use Docker to run a container based on the Azure DevOps Services agent Docker image.</span></span>

> [!TIP]
> <span data-ttu-id="f1ec3-159">Azure DevOps Services Docker CI パイプラインのアセンブルの詳細を確認し、そのチュートリアルを表示するには、次のサイトにアクセスしてください。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-159">To read more about assembling an Azure DevOps Services Docker CI pipeline and view the walkthroughs, visit these sites:</span></span>
>
> - <span data-ttu-id="f1ec3-160">Docker コンテナーとしての Visual Studio Team Services (現在の Azure DevOps Services) エージェントの実行: </span><span class="sxs-lookup"><span data-stu-id="f1ec3-160">Running a Visual Studio Team Services (Now Azure DevOps Services) agent as a Docker container: </span></span>\
>   <https://hub.docker.com/_/microsoft-azure-pipelines-vsts-agent>
>
> - <span data-ttu-id="f1ec3-161">Azure DevOps Services を使用する .NET Linux Docker イメージのビルド: </span><span class="sxs-lookup"><span data-stu-id="f1ec3-161">Building .NET Linux Docker images with Azure DevOps Services: </span></span>\
>   <https://docs.microsoft.com/archive/blogs/stevelasker/building-net-core-linux-docker-images-with-visual-studio-team-services>
>
> - <span data-ttu-id="f1ec3-162">Docker サポートを利用する Linux ベースの Visual Studio Team Service ビルド コンピューターのビルド: </span><span class="sxs-lookup"><span data-stu-id="f1ec3-162">Building a Linux-based Visual Studio Team Service build machine with Docker support: </span></span>\
>   <https://www.donovanbrown.com/post/Building-a-Linux-Based-Visual-Studio-Team-Service-Build-Machine-with-Docker-Support>

### <a name="integrate-test-and-validate-multi-container-docker-applications"></a><span data-ttu-id="f1ec3-163">複数コンテナーの Docker アプリケーションを統合、テスト、および確認する</span><span class="sxs-lookup"><span data-stu-id="f1ec3-163">Integrate, test, and validate multi-container Docker applications</span></span>

<span data-ttu-id="f1ec3-164">通常、ほとんどの Docker アプリケーションは、単一のコンテナーではなく、複数のコンテナーで構成されます。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-164">Typically, most Docker applications are composed of multiple containers rather than a single container.</span></span> <span data-ttu-id="f1ec3-165">その良い例が、マイクロサービスごとに 1 つのコンテナーを使用する、マイクロサービス指向のアプリケーションです。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-165">A good example is a microservices-oriented application for which you would have one container per microservice.</span></span> <span data-ttu-id="f1ec3-166">しかし、マイクロサービスのアプローチ パターンに厳密に従わなくても、Docker アプリケーションが複数のコンテナーまたはサービスで構成される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-166">But, even without strictly following the microservices approach patterns, it's probable that your Docker application would be composed of multiple containers or services.</span></span>

<span data-ttu-id="f1ec3-167">そのため、CI パイプラインでアプリケーション コンテナーをビルドした後、統合 Docker ホスト内、さらにはコンテナーが分散されるテスト クラスター内に、そのすべてのコンテナーを含めまとめてアプリケーションをデプロイ、統合、およびテストする必要もあります。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-167">Therefore, after building the application containers in the CI pipeline, you also need to deploy, integrate, and test the application as a whole with all of its containers within an integration Docker host or even into a test cluster to which your containers are distributed.</span></span>

<span data-ttu-id="f1ec3-168">単一のホストを使用する場合は、docker-compose などの Docker コマンドを使用して、関連するコンテナーをビルドおよびデプロイし、単一の VM で Docker 環境をテストおよび確認することができます。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-168">If you're using a single host, you can use Docker commands such as docker-compose to build and deploy related containers to test and validate the Docker environment in a single VM.</span></span> <span data-ttu-id="f1ec3-169">しかし、DC/OS、Kubernetes、Docker Swarm などのオーケストレーター クラスターを操作する場合は、選択したクラスター/スケジューラに応じて、異なるメカニズムまたはオーケストレーターを介してコンテナーをデプロイする必要があります。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-169">But, if you're working with an orchestrator cluster like DC/OS, Kubernetes, or Docker Swarm, you need to deploy your containers through a different mechanism or orchestrator, depending on your selected cluster/scheduler.</span></span>

<span data-ttu-id="f1ec3-170">Docker コンテナーに対して実行できるいくつかの種類のテストを以下に示します。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-170">The following are several types of tests that you can run against Docker containers:</span></span>

- <span data-ttu-id="f1ec3-171">Docker コンテナーの単体テスト</span><span class="sxs-lookup"><span data-stu-id="f1ec3-171">Unit tests for Docker containers</span></span>

- <span data-ttu-id="f1ec3-172">相互に関連するアプリケーションまたはマイクロサービスのグループ テスト</span><span class="sxs-lookup"><span data-stu-id="f1ec3-172">Testing groups of interrelated applications or microservices</span></span>

- <span data-ttu-id="f1ec3-173">運用および "カナリア" リリースでのテスト</span><span class="sxs-lookup"><span data-stu-id="f1ec3-173">Test in production and "canary" releases</span></span>

<span data-ttu-id="f1ec3-174">重要な点は、統合および機能テストを実行するときに、コンテナーの外部からそれらのテストを実行する必要があることです。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-174">The important point is that when running integration and functional tests, you must run those tests from outside of the containers.</span></span> <span data-ttu-id="f1ec3-175">デプロイするコンテナーではテストは含まれず、実行されません。これは、コンテナーが、運用環境にデプロイするのとまったく同じである必要がある静的イメージに基づくためです。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-175">Tests are not contained or run in the containers you're deploying, because the containers are based on static images that should be exactly like the ones you'll be deploying to production.</span></span>

<span data-ttu-id="f1ec3-176">いくつかのクラスター (テスト クラスター、ステージング クラスター、運用クラスター) を含む、より高度なシナリオをテストする場合の実用的なオプションは、イメージをレジストリに公開することです。これにより、さまざまなクラスターでテストすることができます。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-176">A practical option when testing more advanced scenarios, like including several clusters (test cluster, staging cluster, and production cluster) is to publish the images to a registry, so it can be tested in various clusters.</span></span>

### <a name="push-the-custom-application-docker-image-into-your-global-docker-registry"></a><span data-ttu-id="f1ec3-177">グローバルな Docker レジストリにカスタム アプリケーションの Docker イメージをプッシュする</span><span class="sxs-lookup"><span data-stu-id="f1ec3-177">Push the custom application Docker image into your global Docker Registry</span></span>

<span data-ttu-id="f1ec3-178">Docker イメージがテストされ、確認された後、それらにタグを付け、Docker レジストリに公開する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-178">After the Docker images have been tested and validated, you'll want to tag and publish them to your Docker registry.</span></span> <span data-ttu-id="f1ec3-179">Docker レジストリは Docker アプリケーション ライフ サイクルにおける重要な部分です。これは、QA および運用環境にデプロイされる ("blessed イメージ" ともいう) カスタム テストを格納する中央の場所であるためです。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-179">The Docker registry is a critical piece in the Docker application life cycle because it's the central place where you store your custom test (also known as "blessed images") to be deployed into QA and production environments.</span></span>

<span data-ttu-id="f1ec3-180">SCC リポジトリ (Git など) に格納されているアプリケーション コードが "信頼できるソース" であるのと同様、Docker リポジトリは QA または運用環境にデプロイされるバイナリ アプリケーションあるいはビットの "信頼できるソース" です。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-180">Similar to how the application code stored in your SCC repository (Git, etc.) is your "source of truth," the Docker registry is your "source of truth" for your binary application or bits to be deployed to the QA or production environments.</span></span>

<span data-ttu-id="f1ec3-181">通常、Azure Container Registry 内のプライベート リポジトリまたは Docker Trusted Registry などのオンプレミス レジストリ、あるいは (Docker Hub などの) アクセスが制限されたパブリック クラウド レジストリでは、カスタム イメージ用のプライベート リポジトリが必要な場合があります。ただし、最後のケースでは、コードがオープンソースでない場合、ベンダーのセキュリティを信頼する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-181">Typically, you might want to have your private repositories for your custom images either in a private repository in Azure Container Registry or in an on-premises registry like Docker Trusted Registry, or in a public-cloud registry with restricted access (like Docker Hub), although in this last case if your code is not open source, you must trust the vendor's security.</span></span> <span data-ttu-id="f1ec3-182">いずれの場合も、使用する方法は似ており、図 5-4 に示すように、`docker push` コマンドに基づきます。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-182">Either way, the method you use is similar and is based on the `docker push` command, as shown in Figure 5-4.</span></span>

![カスタム イメージをコンテナー レジストリにプッシュする方法を示す図。](./media/docker-application-outer-loop-devops-workflow/docker-push-custom-images.png)

<span data-ttu-id="f1ec3-184">**図 5-4**</span><span class="sxs-lookup"><span data-stu-id="f1ec3-184">**Figure 5-4**.</span></span> <span data-ttu-id="f1ec3-185">カスタム イメージの Docker レジストリへの公開</span><span class="sxs-lookup"><span data-stu-id="f1ec3-185">Publishing custom images to Docker Registry</span></span>

<span data-ttu-id="f1ec3-186">ビルド、統合およびテスト (CI) に関する手順 3 では、結果の Docker イメージをプライベートまたはパブリック レジストリに公開する場合があります。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-186">In step 3, for building integration and testing (CI) you might publish the resulting docker images to a private or public registry.</span></span> <span data-ttu-id="f1ec3-187">Azure Container Registry、Amazon Web Services Container Registry、Google Container Registry、Quay レジストリなど、クラウド ベンダーからの Docker レジストリには複数のオファリングがあります。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-187">There are multiple offerings of Docker registries from cloud vendors like Azure Container Registry, Amazon Web Services Container Registry, Google Container Registry, Quay Registry, and so on.</span></span>

<span data-ttu-id="f1ec3-188">図 5-5 に示すように、Docker タスクを使用することで、`docker-compose.yml` ファイルで定義されている、複数のタグの付いた一連のサービス イメージを、認証済みの Docker レジストリ (Azure Container Registry など) にプッシュすることができます。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-188">Using the Docker tasks, you can push a set of service images defined by a `docker-compose.yml` file, with multiple tags, to an authenticated Docker registry (like Azure Container Registry), as shown in Figure 5-5.</span></span>

![レジストリにイメージを発行する手順を示すスクリーンショット。](./media/docker-application-outer-loop-devops-workflow/publish-custom-image-to-docker-registry.png)

<span data-ttu-id="f1ec3-190">**図 5-5**</span><span class="sxs-lookup"><span data-stu-id="f1ec3-190">**Figure 5-5**.</span></span> <span data-ttu-id="f1ec3-191">Azure DevOps Services を使用する Docker レジストリへのカスタム イメージの公開</span><span class="sxs-lookup"><span data-stu-id="f1ec3-191">Using Azure DevOps Services to publishing custom images to a Docker Registry</span></span>

> [!TIP]
> <span data-ttu-id="f1ec3-192">Azure Container Registry の詳細については、<https://aka.ms/azurecontainerregistry> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-192">For more information about Azure Container Registry, see <https://aka.ms/azurecontainerregistry>.</span></span>

## <a name="step-4-cd-deploy"></a><span data-ttu-id="f1ec3-193">手順 4: CD、デプロイ</span><span class="sxs-lookup"><span data-stu-id="f1ec3-193">Step 4: CD, Deploy</span></span>

<span data-ttu-id="f1ec3-194">Docker イメージの不変性により、CI を介して開発し、テストし、運用環境で実行する対象で反復可能なデプロイが保証されます。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-194">The immutability of Docker images ensures a repeatable deployment with what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="f1ec3-195">Docker レジストリ (プライベートまたはパブリック) でアプリケーションの Docker イメージを公開した後、Azure DevOps Services パイプライン タスクまたは Azure DevOps Services Release Management を使って、CD パイプラインから使用する可能性のあるいくつかの環境 (運用、QA、ステージングなど) にデプロイすることができます。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-195">After you have the application Docker images published in your Docker registry (either private or public), you can deploy them to the several environments that you might have (production, QA, staging, etc.) from your CD pipeline by using Azure DevOps Services pipeline tasks or Azure DevOps Services Release Management.</span></span>

<span data-ttu-id="f1ec3-196">しかし、この時点では、これはデプロイする Docker アプリケーションの種類によって異なります。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-196">However, at this point it depends on what kind of Docker application you're deploying.</span></span> <span data-ttu-id="f1ec3-197">いくつかのコンテナーまたはサービスを構成し、いくつかのサーバーまたは VM にデプロイされたモノシリック アプリケーションなど、(構成およびデプロイの観点から) シンプルなアプリケーションをデプロイすることは、ハイパースケール機能を備えたマイクロサービス指向のアプリケーションのようなより複雑なアプリケーションをデプロイすることとは異なります。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-197">Deploying a simple application (from a composition and deployment point of view) like a monolithic application comprising a few containers or services and deployed to a few servers or VMs is different from deploying a more complex application like a microservices-oriented application with hyperscale capabilities.</span></span> <span data-ttu-id="f1ec3-198">これら 2 つのシナリオについては、次のセクションで説明します。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-198">These two scenarios are explained in the following sections.</span></span>

### <a name="deploying-composed-docker-applications-to-multiple-docker-environments"></a><span data-ttu-id="f1ec3-199">複数の Docker 環境への構成された Docker アプリケーションのデプロイ</span><span class="sxs-lookup"><span data-stu-id="f1ec3-199">Deploying composed Docker applications to multiple Docker environments</span></span>

<span data-ttu-id="f1ec3-200">最初に、単一の環境または複数の環境 (QA、ステージング、運用) でシンプルな Docker ホスト (VM またはサーバー) にデプロイする、あまり複雑ではないシナリオを見ていきましょう。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-200">Let's look first at the less-complex scenario: deploying to simple Docker hosts (VMs or servers) in a single environment or multiple environments (QA, staging, and production).</span></span> <span data-ttu-id="f1ec3-201">このシナリオでは、図 5-6 に示すように、内部的に CD パイプラインで (Azure DevOps Services デプロイ タスクから) docker-compose を使用して、Docker アプリケーションをそれに関連する一連のコンテナーまたはサービスと共にデプロイすることができます。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-201">In this scenario, internally your CD pipeline can use docker-compose (from your Azure DevOps Services deployment tasks) to deploy the Docker applications with its related set of containers or services, as illustrated in Figure 5-6.</span></span>

![3 つの環境にデプロイする CD デプロイ手順を示す図](./media/docker-application-outer-loop-devops-workflow/deploy-app-containers-to-docker-host-environments.png)

<span data-ttu-id="f1ec3-203">**図 5-6**.</span><span class="sxs-lookup"><span data-stu-id="f1ec3-203">**Figure 5-6**.</span></span> <span data-ttu-id="f1ec3-204">シンプルな Docker ホスト環境レジストリへのアプリケーション コンテナーのデプロイ</span><span class="sxs-lookup"><span data-stu-id="f1ec3-204">Deploying application containers to simple Docker host environments registry</span></span>

<span data-ttu-id="f1ec3-205">図 5-7 では、[タスクの追加] ダイアログ ボックスで [Docker Compose] をクリックし、Azure DevOps Services を介して QA/テスト環境にビルド CI を接続する方法に焦点を当てています。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-205">Figure 5-7 highlights how you can connect your build CI to QA/test environments via Azure DevOps Services by clicking Docker Compose in the Add Task dialog box.</span></span> <span data-ttu-id="f1ec3-206">しかし、ステージングまたは運用環境にデプロイする場合は、通常、複数の環境 (QA、ステージング、および運用) を処理する Release Management 機能を使用します。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-206">However, when deploying to staging or production environments, you would usually use Release Management features handling multiple environments (like QA, staging, and production).</span></span> <span data-ttu-id="f1ec3-207">単一 Docker のホストにデプロイする場合は、Azure DevOps Services の "Docker Compose" タスク (内部での `docker-compose up` コマンドに関連する) が使用されます。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-207">If you're deploying to single Docker hosts, it is using the Azure DevOps Services "Docker Compose" task (which is invoking the `docker-compose up` command under the hood).</span></span> <span data-ttu-id="f1ec3-208">Azure Kubernetes Service (AKS) にデプロイする場合は、以降のセクションで説明されているように、Docker デプロイ タスクが使用されます。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-208">If you're deploying to Azure Kubernetes Service (AKS), it uses the Docker Deployment task, as explained in the section that follows.</span></span>

![Docker Compose タスクの [タスクの追加] ダイアログを示すスクリーンショット。](./media/docker-application-outer-loop-devops-workflow/add-tasks-docker-compose.png)

<span data-ttu-id="f1ec3-210">**図 5-7**</span><span class="sxs-lookup"><span data-stu-id="f1ec3-210">**Figure 5-7**.</span></span> <span data-ttu-id="f1ec3-211">Azure DevOps Services パイプラインでの Docker Compose タスクの追加</span><span class="sxs-lookup"><span data-stu-id="f1ec3-211">Adding a Docker Compose task in an Azure DevOps Services pipeline</span></span>

<span data-ttu-id="f1ec3-212">Azure DevOps Services でリリースを作成するときに、一連の入力成果物が取得されます。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-212">When you create a release in Azure DevOps Services, it takes a set of input artifacts.</span></span> <span data-ttu-id="f1ec3-213">これらの成果物は、すべての環境全体で、リリースの有効期間に対して不変であることが想定されます。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-213">These artifacts are intended to be immutable for the lifetime of the release, across all environments.</span></span> <span data-ttu-id="f1ec3-214">コンテナーを導入するときに、入力成果物によってデプロイするレジストリ内のイメージが識別されます。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-214">When you introduce containers, the input artifacts identify images in a registry to deploy.</span></span> <span data-ttu-id="f1ec3-215">これらのイメージの識別方法によっては、リリース期間を通して同じままであることが保証されません。これが最も明白に現れるのが、`docker-compose` ファイルから `myimage:latest` を参照する場合です。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-215">Depending on how these images are identified, they are not guaranteed to remain the same throughout the duration of the release, the most obvious case being when you reference `myimage:latest` from a `docker-compose` file.</span></span>

<span data-ttu-id="f1ec3-216">Azure DevOps Services テンプレートでは、同じイメージ バイナリを一意に識別することが保証される特定のレジストリ イメージ ダイジェストを含む、ビルド成果物を生成することができます。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-216">The Azure DevOps Services templates give you the ability to generate build artifacts that contain specific registry image digests that are guaranteed to uniquely identify the same image binary.</span></span> <span data-ttu-id="f1ec3-217">これらは、リリースへの入力として使用する必要があるものです。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-217">These are what you really want to use as input to a release.</span></span>

### <a name="managing-releases-to-docker-environments-by-using-azure-devops-services-release-management"></a><span data-ttu-id="f1ec3-218">Azure DevOps Services Release Management を使用する Docker 環境に対するリリースの管理</span><span class="sxs-lookup"><span data-stu-id="f1ec3-218">Managing releases to Docker environments by using Azure DevOps Services Release Management</span></span>

<span data-ttu-id="f1ec3-219">図 5-8 に示すように、Azure DevOps Services テンプレートを使用することで、新しいイメージをビルドし、それを Docker レジストリに公開し、Linux または Windows ホストで実行し、`docker-compose` などのコマンドを使って、複数の環境を対象とした Azure DevOps Services Release Management 機能を通じて、アプリケーション全体として複数のコンテナーをデプロイすることができます。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-219">Through the Azure DevOps Services templates, you can build a new image, publish it to a Docker registry, run it on Linux or Windows hosts, and use commands such as `docker-compose` to deploy multiple containers as an entire application, all through the Azure DevOps Services Release Management capabilities intended for multiple environments, as shown in Figure 5-8.</span></span>

![Docker Compose リリースの構成を示すスクリーンショット。](./media/docker-application-outer-loop-devops-workflow/configure-docker-compose-release.png)

<span data-ttu-id="f1ec3-221">**図 5-8**.</span><span class="sxs-lookup"><span data-stu-id="f1ec3-221">**Figure 5-8**.</span></span> <span data-ttu-id="f1ec3-222">Azure DevOps Services Release Management からの Azure DevOps Services Docker Compose タスクの構成</span><span class="sxs-lookup"><span data-stu-id="f1ec3-222">Configuring Azure DevOps Services Docker Compose tasks from Azure DevOps Services Release Management</span></span>

<span data-ttu-id="f1ec3-223">しかし、図 5-6 に示され、図 5-8 で実装されるシナリオはシンプルなものであり (単一 Docker のホストと VM にデプロイされ、コンテナーまたはインスタンスがイメージごとに 1 つとなる)、開発またはテスト シナリオでのみ使用する必要がある場合があることに注意してださい。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-223">However, keep in mind that the scenario shown in Figure 5-6 and implemented in Figure 5-8 is a simple one (it's deploying to single Docker hosts and VMs, and there will be a single container or instance per image) and probably should be used only for development or test scenarios.</span></span> <span data-ttu-id="f1ec3-224">ほとんどのエンタープライズ運用シナリオでは、複数のノード、サーバー、および VM 間で負荷を分散し、さらに "インテリジェントなフェールオーバー" により、高可用性 (HA) および管理しやすいスケーラビリティを実現する必要があります。そのため、サーバーまたはノードで障害が発生した場合、そのサービスとコンテナーは別のホスト サーバーまたは VM に移動されます。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-224">In most enterprise production scenarios, you would want to have High Availability (HA) and easy-to-manage scalability by load balancing across multiple nodes, servers, and VMs, plus "intelligent failovers" so if a server or node fails, its services and containers will be moved to another host server or VM.</span></span> <span data-ttu-id="f1ec3-225">その場合、コンテナー クラスター、オーケストレーター、スケジューラなどのより高度なテクノロジが必要になります。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-225">In that case, you need more advanced technologies such as container clusters, orchestrators, and schedulers.</span></span> <span data-ttu-id="f1ec3-226">したがって、これらのクラスターにデプロイする方法は、高度なシナリオを処理することです。これについては、次のセクションで説明します。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-226">Thus, the way to deploy to those clusters is by handling the advanced scenarios explained in the next section.</span></span>

### <a name="deploying-docker-applications-to-docker-clusters"></a><span data-ttu-id="f1ec3-227">Docker クラスターへの Docker アプリケーションのデプロイ</span><span class="sxs-lookup"><span data-stu-id="f1ec3-227">Deploying Docker applications to Docker clusters</span></span>

<span data-ttu-id="f1ec3-228">分散アプリケーションの性質上、コンピューティング リソースが必要であり、これらも分散されます。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-228">The nature of distributed applications requires compute resources that are also distributed.</span></span> <span data-ttu-id="f1ec3-229">運用スケールの機能を備えるには、プールされたリソースに基づいて高いスケーラビリティと高可用性を提供するクラスタリング機能が必要です。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-229">To have production-scale capabilities, you need to have clustering capabilities that provide high scalability and high availability based on pooled resources.</span></span>

<span data-ttu-id="f1ec3-230">CLI ツールまたは Web UI からこれらのクラスターに手動でコンテナーをデプロイすることはできますが、スケールアウトや監視などのデプロイ テストまたは管理の目的を特定するために、この種の手動による作業を予約する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-230">You could deploy containers manually to those clusters from a CLI tool or a web UI, but you should reserve that kind of manual work to spot deployment testing or management purposes like scaling-out or monitoring.</span></span>

<span data-ttu-id="f1ec3-231">図 5-9 に示すように、CD の観点から、また、Azure DevOps Services では特に、Container Service で分散クラスターにコンテナー化されたアプリケーションをデプロイする Azure DevOps Services Release Management 環境から特別に作成されたデプロイ タスクを実行できます。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-231">From a CD point of view, and Azure DevOps Services specifically, you can run specially made deployment tasks from your Azure DevOps Services Release Management environments that will deploy your containerized applications to distributed clusters in Container Service, as illustrated in Figure 5-9.</span></span>

![オーケストレーターにデプロイする CD デプロイ手順を示す図。](./media/docker-application-outer-loop-devops-workflow/cd-deploy-to-orchestrators.png)

<span data-ttu-id="f1ec3-233">**図 5-9**</span><span class="sxs-lookup"><span data-stu-id="f1ec3-233">**Figure 5-9**.</span></span> <span data-ttu-id="f1ec3-234">Container Service への分散アプリケーションのデプロイ</span><span class="sxs-lookup"><span data-stu-id="f1ec3-234">Deploying distributed applications to Container Service</span></span>

<span data-ttu-id="f1ec3-235">最初は、特定のクラスターまたはオーケストレーターにデプロイするときに、通常、`docker-compose.yml` 定義ファイルに基づくよりシンプルで使いやすい `docker-compose` ツールではなく、オーケストレーターごとに特定のデプロイ スクリプトとメカニズムを使用します (つまり、Kubernetes と Service Fabric ではデプロイ メカニズムが異なる)。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-235">Initially, when deploying to certain clusters or orchestrators, you would traditionally use specific deployment scripts and mechanisms per each orchestrator (that is, Kubernetes and Service Fabric have different deployment mechanisms) instead of the simpler and easy-to-use `docker-compose` tool based on the `docker-compose.yml` definition file.</span></span> <span data-ttu-id="f1ec3-236">しかし、図 5-10 に示すように、Azure DevOps Services Docker Deploy タスクのおかげで、現在、使い慣れた `docker-compose.yml` ファイルのみを使用して、サポートされているオーケストレーターにデプロイすることもできます。これは、ツールでユーザーに代わって、(`docker-compose.yml` ファイルから、オーケストレーターで必要な形式への) "変換" が行われるためです。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-236">However, thanks to the Azure DevOps Services Docker Deploy task, shown in Figure 5-10, now you can also deploy to the supported orchestrators by just using your familiar `docker-compose.yml` file because the tool performs that "translation" for you (from your `docker-compose.yml` file to the format needed by the orchestrator).</span></span>

![Kubernetes へのデプロイ タスクを示すスクリーンショット。](./media/docker-application-outer-loop-devops-workflow/add-deploy-to-kubernetes-task.png)

<span data-ttu-id="f1ec3-238">**図 5-10**</span><span class="sxs-lookup"><span data-stu-id="f1ec3-238">**Figure 5-10**.</span></span> <span data-ttu-id="f1ec3-239">Kubernetes へのデプロイ タスクの環境への追加</span><span class="sxs-lookup"><span data-stu-id="f1ec3-239">Adding the Deploy to Kubernetes task to your Environment</span></span>

<span data-ttu-id="f1ec3-240">図 5-11 では、構成で使用可能なセクションを使用して Kubernetes へのデプロイ タスクをどのように編集できるかを示します。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-240">Figure 5-11 demonstrates how you can edit the Deploy to Kubernetes task with the sections available for configuration.</span></span> <span data-ttu-id="f1ec3-241">これは、クラスター内のコンテナーとしてデプロイされる、すぐに使用できるカスタム Docker イメージを取得するタスクです。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-241">This is the task that will retrieve your ready-to-use custom Docker images to be deployed as containers in the cluster.</span></span>

![Kubernetes へのデプロイ タスクの構成を示すスクリーンショット。](./media/docker-application-outer-loop-devops-workflow/edit-deploy-to-kubernetes-task.png)

<span data-ttu-id="f1ec3-243">**図 5-11**</span><span class="sxs-lookup"><span data-stu-id="f1ec3-243">**Figure 5-11**.</span></span> <span data-ttu-id="f1ec3-244">ACS DC/OS にデプロイする、Docker デプロイ タスクの定義</span><span class="sxs-lookup"><span data-stu-id="f1ec3-244">Docker Deploy task definition deploying to ACS DC/OS</span></span>

> [!TIP]
> <span data-ttu-id="f1ec3-245">Azure DevOps Services と Docker を使用する CD パイプラインの詳細については、<https://azure.microsoft.com/services/devops/pipelines> にアクセスしてください。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-245">To read more about the CD pipeline with Azure DevOps Services and Docker, visit <https://azure.microsoft.com/services/devops/pipelines></span></span>

## <a name="step-5-run-and-manage"></a><span data-ttu-id="f1ec3-246">手順 5: 実行と管理</span><span class="sxs-lookup"><span data-stu-id="f1ec3-246">Step 5: Run and manage</span></span>

<span data-ttu-id="f1ec3-247">エンタープライズ運用レベルでのアプリケーションの実行と管理はそれ自体が主題であるため、また、そのレベル (IT 操作) で作業するユーザーと操作の種類およびこの領域の大きなスコープに起因し、次の章全体がこれについての説明となります。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-247">Because running and managing applications at enterprise-production level is a major subject in and of itself, and due to the type of operations and people working at that level (IT operations) as well as the large scope of this area, the entire next chapter is devoted to explaining it.</span></span>

## <a name="step-6-monitor-and-diagnose"></a><span data-ttu-id="f1ec3-248">手順 6: 監視と診断</span><span class="sxs-lookup"><span data-stu-id="f1ec3-248">Step 6: Monitor and diagnose</span></span>

<span data-ttu-id="f1ec3-249">このトピックについては、運用システムで IT 担当者によって行われるタスクの一部として次の章でも説明されています。しかし、この手順で得られた洞察を開発チームにフィードバックし、アプリケーションが常に改善されるようにする必要があることを強調することが重要です。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-249">This topic also is covered in the next chapter as part of the tasks that IT performs in production systems; however, is important to highlight that the insights obtained in this step must feed back to the development team so that the application is constantly improved.</span></span> <span data-ttu-id="f1ec3-250">その観点から、これは DevOps の一部でもありますが、タスクと操作は一般的に IT 担当者によって実行されます。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-250">From that point of view, it's also part of DevOps, although the tasks and operations are commonly performed by IT.</span></span>

<span data-ttu-id="f1ec3-251">監視と診断が DevOps の領域内で 100% である場合にのみ、テストまたはベータ環境に対して、開発チームによって監視プロセスと分析が行われます。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-251">Only when monitoring and diagnostics are 100% within the realm of DevOps are the monitoring processes and analytics performed by the development team against testing or beta environments.</span></span> <span data-ttu-id="f1ec3-252">これは、ロード テストを実行することで、あるいはベータ テスターが新しいバージョンを試す、ベータまたは QA 環境を監視することで行われます。</span><span class="sxs-lookup"><span data-stu-id="f1ec3-252">This is done either by performing load testing or by monitoring beta or QA environments, where beta testers are trying the new versions.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="f1ec3-253">[前へ](index.md)
>[次へ](create-ci-cd-pipelines-azure-devops-services-aspnetcore-kubernetes.md)</span><span class="sxs-lookup"><span data-stu-id="f1ec3-253">[Previous](index.md)
[Next](create-ci-cd-pipelines-azure-devops-services-aspnetcore-kubernetes.md)</span></span>
