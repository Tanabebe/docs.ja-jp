---
title: DevOps
description: クラウドネイティブ アプリケーションに関する DevOps の考慮事項
ms.date: 01/19/2021
ms.openlocfilehash: 089f6ac82f3ce0613c7b8e0b9527f3fa9cf7b50c
ms.sourcegitcommit: f2ab02d9a780819ca2e5310bbcf5cfe5b7993041
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/03/2021
ms.locfileid: "99506202"
---
# <a name="devops"></a><span data-ttu-id="d9e41-103">DevOps</span><span class="sxs-lookup"><span data-stu-id="d9e41-103">DevOps</span></span>

<span data-ttu-id="d9e41-104">ソフトウェア コンサルタントのお気に入りのスローガンは、尋ねられたどの質問に対しても "場合による" と回答することです。</span><span class="sxs-lookup"><span data-stu-id="d9e41-104">The favorite mantra of software consultants is to answer "It depends" to any question posed.</span></span> <span data-ttu-id="d9e41-105">これはソフトウェア コンサルタントが態度をはっきりさせたくないからではありません。</span><span class="sxs-lookup"><span data-stu-id="d9e41-105">It isn't because software consultants are fond of not taking a position.</span></span> <span data-ttu-id="d9e41-106">ソフトウェアではどの質問にも 1 つの正解が存在するわけではないからです。</span><span class="sxs-lookup"><span data-stu-id="d9e41-106">It's because there's no one true answer to any questions in software.</span></span> <span data-ttu-id="d9e41-107">絶対的な善や悪ではなく、正反対の間でのバランスです。</span><span class="sxs-lookup"><span data-stu-id="d9e41-107">There's no absolute right and wrong, but rather a balance between opposites.</span></span>

<span data-ttu-id="d9e41-108">たとえば、Web アプリケーション開発の主要な 2 つの方式として、シングル ページ アプリケーション (SPA) とサーバー側アプリケーションがあります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-108">Take, for instance, the two major schools of developing web applications: Single Page Applications (SPAs) versus server-side applications.</span></span> <span data-ttu-id="d9e41-109">一方で、ユーザー エクスペリエンスは SPA の方が優れる場合が多く、Web サーバーへのトラフィック量を最小限に抑えて、静的ホストなど単純な方法でホストすることができます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-109">On the one hand, the user experience tends to be better with SPAs and the amount of traffic to the web server can be minimized making it possible to host them on something as simple as static hosting.</span></span> <span data-ttu-id="d9e41-110">他方で、SPA は開発に時間がかかり、テストが困難になります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-110">On the other hand, SPAs tend to be slower to develop and more difficult to test.</span></span> <span data-ttu-id="d9e41-111">どちらが正しい選択でしょうか。</span><span class="sxs-lookup"><span data-stu-id="d9e41-111">Which one is the right choice?</span></span> <span data-ttu-id="d9e41-112">それは状況によって異なります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-112">Well, it depends on your situation.</span></span>

<span data-ttu-id="d9e41-113">クラウドネイティブ アプリケーションは、これと同様の二分法と無縁ではありません。</span><span class="sxs-lookup"><span data-stu-id="d9e41-113">Cloud-native applications aren't immune to that same dichotomy.</span></span> <span data-ttu-id="d9e41-114">開発の速度、安定性、スケーラビリティの面で明確な利点がありますが、管理がかなり難しくなる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-114">They have clear advantages in terms of speed of development, stability, and scalability, but managing them can be quite a bit more difficult.</span></span>

<span data-ttu-id="d9e41-115">数年前には、アプリケーションの開発環境から運用環境への移行に 1 か月あるいはそれ以上かかることは珍しくありませんでした。</span><span class="sxs-lookup"><span data-stu-id="d9e41-115">Years ago, it wasn't uncommon for the process of moving an application from development to production to take a month, or even more.</span></span> <span data-ttu-id="d9e41-116">企業は 6 か月または 1 年ごとにソフトウェアをリリースしました。</span><span class="sxs-lookup"><span data-stu-id="d9e41-116">Companies released software on a 6-month or even every year cadence.</span></span> <span data-ttu-id="d9e41-117">常に最新状態である Windows 10 以前に許容されていたリリースのペースについて調べるために、Microsoft Windows よりも前にさかのぼる必要はありません。</span><span class="sxs-lookup"><span data-stu-id="d9e41-117">One needs to look no further than Microsoft Windows to get an idea for the cadence of releases that were acceptable before the ever-green days of Windows 10.</span></span> <span data-ttu-id="d9e41-118">Windows XP から Vista までは 5 年間、Vista から Windows 7 までは 3 年以上が経過しました。</span><span class="sxs-lookup"><span data-stu-id="d9e41-118">Five years passed between Windows XP and Vista, a further 3 between Vista and Windows 7.</span></span>

<span data-ttu-id="d9e41-119">現在、ソフトウェアを迅速にリリースできることによって、動きの速い企業が、ナマケモノのような競合他社に比べて市場で優位に立てるということがかなり定着してきました。</span><span class="sxs-lookup"><span data-stu-id="d9e41-119">It's now fairly well established that being able to release software rapidly gives fast-moving companies a huge market advantage over their more sloth-like competitors.</span></span> <span data-ttu-id="d9e41-120">これが Windows 10 の重大な更新が約 6 か月おきに行われる理由です。</span><span class="sxs-lookup"><span data-stu-id="d9e41-120">It's for that reason that major updates to Windows 10 are now approximately every six months.</span></span>

<span data-ttu-id="d9e41-121">より高速で、より信頼性が高いリリースを可能にして、ビジネスに価値をもたらすパターンとプラクティスは、DevOps と総称されます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-121">The patterns and practices that enable faster, more reliable releases to deliver value to the business are collectively known as DevOps.</span></span> <span data-ttu-id="d9e41-122">これらは、アプリケーションの指定からアプリケーションのデリバリと運用まで、ソフトウェア開発ライフ サイクル全体にわたるさまざまなアイデアで構成されます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-122">They consist of a wide range of ideas spanning the entire software development life cycle from specifying an application all the way up to delivering and operating that application.</span></span>

<span data-ttu-id="d9e41-123">DevOps はマイクロサービスよりも前に登場しました。目的のサービスに合わせて、より小さくよりフィットさせるという方向への動きは、DevOps なしでは不可能だったと考えられます (DevOps のおかげで、1 つだけではなく多数のアプリケーションの運用環境でのリリースと運用がたやすくなります)。</span><span class="sxs-lookup"><span data-stu-id="d9e41-123">DevOps emerged before microservices and it's likely that the movement towards smaller, more fit to purpose services wouldn't have been possible without DevOps to make releasing and operating not just one but many applications in production easier.</span></span>

![図 10-1 マイクロサービスの成長が始まったのは、DevOps がアイデアとしてしっかりと確立された後であることが、検索トレンドからわかります。](./media/microservices-vs-devops.png)

<span data-ttu-id="d9e41-125">**図 10-1** - DevOps とマイクロサービス。</span><span class="sxs-lookup"><span data-stu-id="d9e41-125">**Figure 10-1** - DevOps and microservices.</span></span>

<span data-ttu-id="d9e41-126">優れた DevOps プラクティスを利用すれば、アプリケーションを実際に運用する山のような作業に押しつぶされなくても、クラウドネイティブ アプリケーションの利点を実現できます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-126">Through good DevOps practices, it's possible to realize the advantages of cloud-native applications without suffocating under a mountain of work actually operating the applications.</span></span>

<span data-ttu-id="d9e41-127">DevOps に関する万能のツールはありません。</span><span class="sxs-lookup"><span data-stu-id="d9e41-127">There's no golden hammer when it comes to DevOps.</span></span> <span data-ttu-id="d9e41-128">高品質のアプリケーションをリリースして運用するための、完全かつ包括的なソリューションを販売することは不可能です。</span><span class="sxs-lookup"><span data-stu-id="d9e41-128">Nobody can sell a complete and all-encompassing solution for releasing and operating high-quality applications.</span></span> <span data-ttu-id="d9e41-129">これは、アプリケーションがそれぞれ大きく異なるためです。</span><span class="sxs-lookup"><span data-stu-id="d9e41-129">This is because each application is wildly different from all others.</span></span> <span data-ttu-id="d9e41-130">しかし、DevOps にかなり取り組みやすくなるツールはあります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-130">However, there are tools that can make DevOps a far less daunting proposition.</span></span> <span data-ttu-id="d9e41-131">このようなツールの 1 つは Azure DevOps と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-131">One of these tools is known as Azure DevOps.</span></span>

## <a name="azure-devops"></a><span data-ttu-id="d9e41-132">Azure DevOps</span><span class="sxs-lookup"><span data-stu-id="d9e41-132">Azure DevOps</span></span>

<span data-ttu-id="d9e41-133">Azure DevOps には長い歴史があります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-133">Azure DevOps has a long pedigree.</span></span> <span data-ttu-id="d9e41-134">ルーツは Team Foundation Server 最初にオンラインに移行したときまでたどれます。その後、Visual Studio Online や Visual Studio Team Services といったさまざまな名前の変更が行われました。</span><span class="sxs-lookup"><span data-stu-id="d9e41-134">It can trace its roots back to when Team Foundation Server first moved online and through the various name changes: Visual Studio Online and Visual Studio Team Services.</span></span> <span data-ttu-id="d9e41-135">しかし、年を経て、以前のものよりも格段に向上しています。</span><span class="sxs-lookup"><span data-stu-id="d9e41-135">Through the years, however, it has become far more than its predecessors.</span></span>

<span data-ttu-id="d9e41-136">Azure DevOps は、次の 5 つの主要コンポーネントに分かれます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-136">Azure DevOps is divided into five major components:</span></span>

![図 10-2 Azure DevOps の 5 つの主要分野](./media/devops-components.png)

<span data-ttu-id="d9e41-138">**図 10-2** - Azure DevOps。</span><span class="sxs-lookup"><span data-stu-id="d9e41-138">**Figure 10-2** - Azure DevOps.</span></span>

<span data-ttu-id="d9e41-139">**Azure Repos** - 従来の Team Foundation バージョン管理 (TFVC) と業界の定番である [Git](https://en.wikipedia.org/wiki/Git) がサポートされるソース コード管理。</span><span class="sxs-lookup"><span data-stu-id="d9e41-139">**Azure Repos** - Source code management that supports the venerable Team Foundation Version Control (TFVC) and the industry favorite [Git](https://en.wikipedia.org/wiki/Git).</span></span> <span data-ttu-id="d9e41-140">プル要求によって、変更を行う際のディスカッションを促進しながら、ソーシャル コーディングを実現する方法が提供されます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-140">Pull requests provide a way to enable social coding by fostering discussion of changes as they're made.</span></span>

<span data-ttu-id="d9e41-141">**Azure Boards** - 問題や作業項目の追跡ツールが提供され、これによって最も適したワークフローをユーザーが選択できるようになります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-141">**Azure Boards** - Provides an issue and work item tracking tool that strives to allow users to pick the workflows that work best for them.</span></span> <span data-ttu-id="d9e41-142">スクラムやかんばんスタイルの開発をサポートするテンプレートを含め、事前構成されたテンプレートが多数用意されています。</span><span class="sxs-lookup"><span data-stu-id="d9e41-142">It comes with a number of pre-configured templates including ones to support SCRUM and Kanban styles of development.</span></span>

<span data-ttu-id="d9e41-143">**Azure Pipelines** - Azure との緊密な統合がサポートされる、ビルドおよびリリース管理システム。</span><span class="sxs-lookup"><span data-stu-id="d9e41-143">**Azure Pipelines** - A build and release management system that supports tight integration with Azure.</span></span> <span data-ttu-id="d9e41-144">ビルドは、Windows、Linux、macOS までさまざまなプラットフォームで実行できます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-144">Builds can be run on various platforms from Windows to Linux to macOS.</span></span> <span data-ttu-id="d9e41-145">ビルド エージェントは、クラウドまたはオンプレミスでプロビジョニングできます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-145">Build agents may be provisioned in the cloud or on-premises.</span></span>

<span data-ttu-id="d9e41-146">**Azure Test Plans** - Test Plans 機能によって提供されるテスト管理および探索的テスト サポートにより、QA 担当者が取り残されることはありません。</span><span class="sxs-lookup"><span data-stu-id="d9e41-146">**Azure Test Plans** - No QA person will be left behind with the test management and exploratory testing support offered by the Test Plans feature.</span></span>

<span data-ttu-id="d9e41-147">**Azure Artifacts** - 企業が独自に社内で NuGet や npm などのバージョンを作成できるようにする成果物フィード。</span><span class="sxs-lookup"><span data-stu-id="d9e41-147">**Azure Artifacts** - An artifact feed that allows companies to create their own, internal, versions of NuGet, npm, and others.</span></span> <span data-ttu-id="d9e41-148">一元管理されるリポジトリに障害が発生した場合にアップストリーム パッケージのキャッシュとして機能するという、もう 1 つの目的も果たします。</span><span class="sxs-lookup"><span data-stu-id="d9e41-148">It serves a double purpose of acting as a cache of upstream packages if there's a failure of a centralized repository.</span></span>

<span data-ttu-id="d9e41-149">Azure DevOps の最上位の組織単位は、プロジェクトと呼ばれています。</span><span class="sxs-lookup"><span data-stu-id="d9e41-149">The top-level organizational unit in Azure DevOps is known as a Project.</span></span> <span data-ttu-id="d9e41-150">各プロジェクト内で、Azure Artifacts などのさまざまなコンポーネントをオンまたはオフにできます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-150">Within each project the various components, such as Azure Artifacts, can be turned on and off.</span></span> <span data-ttu-id="d9e41-151">これらの各コンポーネントには、クラウドネイティブ アプリケーションに対してさまざまな利点があります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-151">Each of these components provides different advantages for cloud-native applications.</span></span> <span data-ttu-id="d9e41-152">最も役に立つのは、リポジトリ、ボード、パイプラインの 3 つです。</span><span class="sxs-lookup"><span data-stu-id="d9e41-152">The three most useful are repositories, boards, and pipelines.</span></span> <span data-ttu-id="d9e41-153">ユーザーがソース コードを別のリポジトリ スタック (GitHub など) で管理するが、Azure Pipelines や他のコンポーネントも利用したい場合、完全に可能です。</span><span class="sxs-lookup"><span data-stu-id="d9e41-153">If users want to manage their source code in another repository stack, such as GitHub, but still take advantage of Azure Pipelines and other components, that's perfectly possible.</span></span>

<span data-ttu-id="d9e41-154">幸運にも、開発チームにはリポジトリを選択する際に多くのオプションがあります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-154">Fortunately, development teams have many options when selecting a repository.</span></span> <span data-ttu-id="d9e41-155">そのうちの 1 つが GitHub です。</span><span class="sxs-lookup"><span data-stu-id="d9e41-155">One of them is GitHub.</span></span>

## <a name="github-actions"></a><span data-ttu-id="d9e41-156">GitHub のアクション</span><span class="sxs-lookup"><span data-stu-id="d9e41-156">GitHub Actions</span></span>

<span data-ttu-id="d9e41-157">2009 年に開設された GitHub は、プロジェクト、ドキュメント、コードをホストするための広く普及した Web ベース リポジトリです。</span><span class="sxs-lookup"><span data-stu-id="d9e41-157">Founded in 2009, GitHub is a widely popular web-based repository for hosting projects, documentation, and code.</span></span> <span data-ttu-id="d9e41-158">Apple、Amazon、Google などの大規模な技術系企業や主要企業の多くが GitHub を使用しています。</span><span class="sxs-lookup"><span data-stu-id="d9e41-158">Many large tech companies, such as Apple, Amazon, Google, and mainstream corporations use GitHub.</span></span> <span data-ttu-id="d9e41-159">GitHub では、Git という名前のオープンソースの分散型バージョン管理システムが基盤として使用されます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-159">GitHub uses the open-source, distributed version control system named Git as its foundation.</span></span> <span data-ttu-id="d9e41-160">その上に、欠陥追跡、機能およびプル要求、タスク管理、各コード ベース用の wiki など、独自の機能セットが追加されます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-160">On top, it then adds its own set of features, including defect tracking, feature and pull requests, tasks management, and wikis for each code base.</span></span>

<span data-ttu-id="d9e41-161">GitHub の進化に伴って、DevOps 機能も追加されています。</span><span class="sxs-lookup"><span data-stu-id="d9e41-161">As GitHub evolves, it too is adding DevOps features.</span></span> <span data-ttu-id="d9e41-162">たとえば、GitHub には、`GitHub Actions` と呼ばれる独自の継続的インテグレーション/継続的デリバリー (CI/CD) パイプラインがあります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-162">For example, GitHub has its own continuous integration/continuous delivery (CI/CD) pipeline, called `GitHub Actions`.</span></span> <span data-ttu-id="d9e41-163">GitHub Actions は、コミュニティを利用したワークフロー自動化ツールです。</span><span class="sxs-lookup"><span data-stu-id="d9e41-163">GitHub Actions is a community-powered workflow automation tool.</span></span> <span data-ttu-id="d9e41-164">DevOps チームはこれを既存のツールと統合し、新しい製品と適切に組み合わせて、既存の CI/CD パートナーを含むソフトウェア ライフサイクルに結び付けることができます。"</span><span class="sxs-lookup"><span data-stu-id="d9e41-164">It lets DevOps teams integrate with their existing tooling, mix and match new products, and hook into their software lifecycle, including existing CI/CD partners."</span></span>

<span data-ttu-id="d9e41-165">GitHub は 4000 万を超えるユーザーを抱える、世界最大のソース コード ホストです。</span><span class="sxs-lookup"><span data-stu-id="d9e41-165">GitHub has over 40 million users, making it the largest host of source code in the world.</span></span> <span data-ttu-id="d9e41-166">2018 年 10 月に Microsoft が GitHub を買収しました。</span><span class="sxs-lookup"><span data-stu-id="d9e41-166">In October of 2018, Microsoft purchased GitHub.</span></span> <span data-ttu-id="d9e41-167">Microsoft は、GitHub は引き続き[オープン プラットフォーム](https://techcrunch.com/2018/06/04/microsoft-promises-to-keep-github-independent-and-open/)のままであり、開発者がプラグインおよび拡張できることを保証しました。</span><span class="sxs-lookup"><span data-stu-id="d9e41-167">Microsoft has pledged that GitHub will remain an [open platform](https://techcrunch.com/2018/06/04/microsoft-promises-to-keep-github-independent-and-open/) that any developer can plug into and extend.</span></span> <span data-ttu-id="d9e41-168">独立した企業として経営が続けられます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-168">It continues to operate as an independent company.</span></span> <span data-ttu-id="d9e41-169">GitHub には、enterprise、team、professional、および free アカウントのプランが用意されています。</span><span class="sxs-lookup"><span data-stu-id="d9e41-169">GitHub offers plans for enterprise, team, professional, and free accounts.</span></span>

## <a name="source-control"></a><span data-ttu-id="d9e41-170">ソース管理</span><span class="sxs-lookup"><span data-stu-id="d9e41-170">Source control</span></span>

<span data-ttu-id="d9e41-171">クラウドネイティブ アプリケーションのコードの整理は、困難になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-171">Organizing the code for a cloud-native application can be challenging.</span></span> <span data-ttu-id="d9e41-172">クラウドネイティブ アプリケーションは、1 つの大きなアプリケーションではなく、互いにやり取りする小規模アプリケーションの組み合わせで構成される傾向があります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-172">Instead of a single giant application, the cloud-native applications tend to be made up of a web of smaller applications that talk with one another.</span></span> <span data-ttu-id="d9e41-173">あらゆることを考慮した結果、コードの最適な配置は、未解決の問題として残されます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-173">As with all things in computing, the best arrangement of code remains an open question.</span></span> <span data-ttu-id="d9e41-174">さまざまな種類のレイアウトを使用して成功を収めたアプリケーションの例がありますが、最も広く普及しているのは 2 つの種類です。</span><span class="sxs-lookup"><span data-stu-id="d9e41-174">There are examples of successful applications using different kinds of layouts, but two variants seem to have the most popularity.</span></span>

<span data-ttu-id="d9e41-175">実際のソース管理そのものに取り組む前に、適切なプロジェクトの数を決めておくことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="d9e41-175">Before getting down into the actual source control itself, it's probably worth deciding on how many projects are appropriate.</span></span> <span data-ttu-id="d9e41-176">単一プロジェクト内では、複数のリポジトリおよびビルド パイプラインがサポートされます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-176">Within a single project, there's support for multiple repositories, and build pipelines.</span></span> <span data-ttu-id="d9e41-177">ボードは少し複雑になりますが、1 つのプロジェクト内でも複数のチームに簡単にタスクを割り当てることができます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-177">Boards are a little more complicated, but there too, the tasks can easily be assigned to multiple teams within a single project.</span></span> <span data-ttu-id="d9e41-178">1 つの Azure DevOps プロジェクトで、数百人あるいは数千人の開発者をサポートすることが可能です。</span><span class="sxs-lookup"><span data-stu-id="d9e41-178">It's possible to support hundreds, even thousands of developers, out of a single Azure DevOps project.</span></span> <span data-ttu-id="d9e41-179">これがおそらく最適なアプローチです。すべての開発者が作業を行うことができる 1 つの場所が提供され、アプリケーションが含まれるプロジェクトに確信がないときにアプリケーションを探す戸惑いが軽減されるためです。</span><span class="sxs-lookup"><span data-stu-id="d9e41-179">Doing so is likely the best approach as it provides a single place for all developer to work out of and reduces the confusion of finding that one application when developers are unsure in which project in which it resides.</span></span>

<span data-ttu-id="d9e41-180">Azure DevOps プロジェクト内のマイクロサービスのコードを分割することは、多少困難な場合があります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-180">Splitting up code for microservices within the Azure DevOps project can be slightly more challenging.</span></span>

![図 10-3 単一リポジトリと複数リポジトリ](./media/single-repository-vs-multiple.png)

<span data-ttu-id="d9e41-182">**図 10-3** - 1 つのリポジトリと多数のリポジトリ。</span><span class="sxs-lookup"><span data-stu-id="d9e41-182">**Figure 10-3** - One vs. many repositories.</span></span>

### <a name="repository-per-microservice"></a><span data-ttu-id="d9e41-183">マイクロサービスごとのリポジトリ</span><span class="sxs-lookup"><span data-stu-id="d9e41-183">Repository per microservice</span></span>

<span data-ttu-id="d9e41-184">一見すると、このアプローチは、マイクロサービスのソース コードを分割するための最も論理的なアプローチのように見えます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-184">At first glance, this approach seems like the most logical approach to splitting up the source code for microservices.</span></span> <span data-ttu-id="d9e41-185">各リポジトリに、1 つのマイクロサービスを構築するために必要なコードを含めることができます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-185">Each repository can contain the code needed to build the one microservice.</span></span> <span data-ttu-id="d9e41-186">このアプローチの利点は、すぐにわかります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-186">The advantages to this approach are readily visible:</span></span>

1. <span data-ttu-id="d9e41-187">アプリケーションのビルドおよび保守の手順を、各リポジトリのルートにある README ファイルに追加できます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-187">Instructions for building and maintaining the application can be added to a README file at the root of each repository.</span></span> <span data-ttu-id="d9e41-188">リポジトリを切り替えるとき、これらの手順を簡単に見つけることができ、開発者が作業を始める際の時間が短縮されます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-188">When flipping through the repositories, it's easy to find these instructions, reducing spin-up time for developers.</span></span>
2. <span data-ttu-id="d9e41-189">すべてのサービスが論理的に配置され、サービス名がわかっていれば簡単に見つけることができます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-189">Every service is located in a logical place, easily found by knowing the name of the service.</span></span>
3. <span data-ttu-id="d9e41-190">所有するリポジトリに変更が加えられたときにのみビルドがトリガーされるように簡単に設定できます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-190">Builds can easily be set up such that they're only triggered when a change is made to the owning repository.</span></span>
4. <span data-ttu-id="d9e41-191">リポジトリに加えられる変更の数は、プロジェクトで作業する少数の開発者に限定されます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-191">The number of changes coming into a repository is limited to the small number of developers working on the project.</span></span>
5. <span data-ttu-id="d9e41-192">セキュリティは、開発者が読み取りおよび書き込みのアクセス許可を持つリポジトリを制限することで簡単に設定できます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-192">Security is easy to set up by restricting the repositories to which developers have read and write permissions.</span></span>
6. <span data-ttu-id="d9e41-193">リポジトリ レベルの設定を、所有するチームが変更でき、他のユーザーとの協議は最小限に抑えられます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-193">Repository level settings can be changed by the owning team with a minimum of discussion with others.</span></span>

<span data-ttu-id="d9e41-194">マイクロサービスの背後にある主要な考え方の 1 つは、サービスをサイロ化して分離させる必要があるということです。</span><span class="sxs-lookup"><span data-stu-id="d9e41-194">One of the key ideas behind microservices is that services should be siloed and separated from each other.</span></span> <span data-ttu-id="d9e41-195">ドメイン駆動設計を使用してサービスの境界を決定すると、サービスはトランザクションの境界として機能します。</span><span class="sxs-lookup"><span data-stu-id="d9e41-195">When using Domain Driven Design to decide on the boundaries for services the services act as transactional boundaries.</span></span> <span data-ttu-id="d9e41-196">データベースの更新が複数のサービスにまたがることはできません。</span><span class="sxs-lookup"><span data-stu-id="d9e41-196">Database updates shouldn't span multiple services.</span></span> <span data-ttu-id="d9e41-197">関連データのこのようなコレクションは、境界コンテキストと呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-197">This collection of related data is referred to as a bounded context.</span></span>  <span data-ttu-id="d9e41-198">この考え方には、データベースに対するマイクロサービス データの分離 (その他のサービスから切り離されて自律している) が反映されています。</span><span class="sxs-lookup"><span data-stu-id="d9e41-198">This idea is reflected by the isolation of microservice data to a database separate and autonomous from the rest of the services.</span></span> <span data-ttu-id="d9e41-199">この考え方をソース コードにまで適用することは、きわめて理にかなっています。</span><span class="sxs-lookup"><span data-stu-id="d9e41-199">It makes a great deal of sense to carry this idea all the way through to the source code.</span></span>

<span data-ttu-id="d9e41-200">ただし、このアプローチにも問題があります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-200">However, this approach isn't without its issues.</span></span> <span data-ttu-id="d9e41-201">現代の開発における最悪の問題の 1 つは、依存関係の管理です。</span><span class="sxs-lookup"><span data-stu-id="d9e41-201">One of the more gnarly development problems of our time is managing dependencies.</span></span> <span data-ttu-id="d9e41-202">平均的な `node_modules` ディレクトリを構成するファイル数を考えてみてください。</span><span class="sxs-lookup"><span data-stu-id="d9e41-202">Consider the number of files that make up the average `node_modules` directory.</span></span> <span data-ttu-id="d9e41-203">`create-react-app` などを新たにインストールすると、おそらく数千個のパッケージがもたらされます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-203">A fresh install of something like `create-react-app` is likely to bring with it thousands of packages.</span></span> <span data-ttu-id="d9e41-204">これらの依存関係をどのように管理するかというのは難しい質問です。</span><span class="sxs-lookup"><span data-stu-id="d9e41-204">The question of how to manage these dependencies is a difficult one.</span></span>

<span data-ttu-id="d9e41-205">依存関係が更新されると、ダウンストリーム パッケージでもこの依存関係を更新する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-205">If a dependency is updated, then downstream packages must also update this dependency.</span></span> <span data-ttu-id="d9e41-206">残念ながら、これには開発作業が必要であり、常に `node_modules` ディレクトリには、1 つのパッケージの複数のバージョンが生成されます。それぞれは、わずかに異なる間隔でバージョン管理される他のパッケージの依存関係です。</span><span class="sxs-lookup"><span data-stu-id="d9e41-206">Unfortunately, that takes development work so, invariably, the `node_modules` directory ends up with multiple versions of a single package, each one a dependency of some other package that is versioned at a slightly different cadence.</span></span> <span data-ttu-id="d9e41-207">アプリケーションを配置するとき、どのバージョンの依存関係を使用すればよいでしょうか。</span><span class="sxs-lookup"><span data-stu-id="d9e41-207">When deploying an application, which version of a dependency should be used?</span></span> <span data-ttu-id="d9e41-208">現在運用中のバージョンでしょうか。</span><span class="sxs-lookup"><span data-stu-id="d9e41-208">The version that is currently in production?</span></span> <span data-ttu-id="d9e41-209">現在ベータ版だが、いずれ運用中になるバージョンでしょうか (その時点までにコンシューマーによって運用環境に提供される可能性があります)。</span><span class="sxs-lookup"><span data-stu-id="d9e41-209">The version that is currently in Beta but is likely to be in production by the time the consumer makes it to production?</span></span> <span data-ttu-id="d9e41-210">マイクロサービスを使用するだけでは解決されない難しい質問です。</span><span class="sxs-lookup"><span data-stu-id="d9e41-210">Difficult problems that aren't resolved by just using microservices.</span></span>

<span data-ttu-id="d9e41-211">多様なプロジェクトが依存しているライブラリがあります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-211">There are libraries that are depended upon by a wide variety of projects.</span></span> <span data-ttu-id="d9e41-212">リポジトリごとに 1 つずつマイクロサービスを分割することで、内部リポジトリ Azure Artifacts を使用して、内部の依存関係を最適に解決できます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-212">By dividing the microservices up with one in each repository the internal dependencies can best be resolved by using the internal repository, Azure Artifacts.</span></span> <span data-ttu-id="d9e41-213">ライブラリのビルドにより、最新バージョンが内部使用のために Azure Artifacts にプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-213">Builds for libraries will push their latest versions into Azure Artifacts for internal consumption.</span></span> <span data-ttu-id="d9e41-214">ダウンストリーム プロジェクトは、新しく更新されたパッケージ上の依存関係を利用するように、引き続き手動で更新する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-214">The downstream project must still be manually updated to take a dependency on the newly updated packages.</span></span>

<span data-ttu-id="d9e41-215">サービス間でのコードの移動には、もう 1 つ欠点があります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-215">Another disadvantage presents itself when moving code between services.</span></span> <span data-ttu-id="d9e41-216">アプリケーションのマイクロサービスへの最初の分割が 100% 正しいと信じられればよいですが、実際には、サービス分割で間違わないと予見できることはまれです。</span><span class="sxs-lookup"><span data-stu-id="d9e41-216">Although it would be nice to believe that the first division of an application into microservices is 100% correct, the reality is that rarely we're so prescient as to make no service division mistakes.</span></span> <span data-ttu-id="d9e41-217">したがって、機能とそれを実現するコードは、サービスからサービス (リポジトリからリポジトリ) に移動する必要が生じます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-217">Thus, functionality and the code that drives it will need to move from service to service: repository to repository.</span></span> <span data-ttu-id="d9e41-218">1 つのリポジトリから別のリポジトリに移ると、コードの履歴は失われます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-218">When leaping from one repository to another, the code loses its history.</span></span> <span data-ttu-id="d9e41-219">多くのケースで、特に監査の場合には、一連のコードに関する完全な履歴が重要になります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-219">There are many cases, especially in the event of an audit, where having full history on a piece of code is invaluable.</span></span>

<span data-ttu-id="d9e41-220">最後の最も大きな欠点は、変更の調整です。</span><span class="sxs-lookup"><span data-stu-id="d9e41-220">The final and most important disadvantage is coordinating changes.</span></span> <span data-ttu-id="d9e41-221">本当のマイクロサービス アプリケーションでは、サービス間に配置の依存関係はありません。</span><span class="sxs-lookup"><span data-stu-id="d9e41-221">In a true microservices application, there should be no deployment dependencies between services.</span></span> <span data-ttu-id="d9e41-222">サービス A、B、および C は、疎結合であるため、任意の順序で配置できます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-222">It should be possible to deploy services A, B, and C in any order as they have loose coupling.</span></span> <span data-ttu-id="d9e41-223">しかし、実際には、複数のリポジトリにまたがる変更を同時に行うことが望ましい場合もあります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-223">In reality, however, there are times when it's desirable to make a change that crosses multiple repositories at the same time.</span></span> <span data-ttu-id="d9e41-224">たとえば、ライブラリを更新して、セキュリティ ホールを対策したり、すべてのサービスで使用される通信プロトコルを変更したりする場合です。</span><span class="sxs-lookup"><span data-stu-id="d9e41-224">Some examples include updating a library to close a security hole or changing a communication protocol used by all services.</span></span>

<span data-ttu-id="d9e41-225">複数リポジトリの変更を行うには、各リポジトリへのコミットが連続して行われる必要があります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-225">To do a cross-repository change requires a commit to each repository be made in succession.</span></span> <span data-ttu-id="d9e41-226">各リポジトリの各変更は、個別にプル要求されて確認される必要があります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-226">Each change in each repository will need to be pull-requested and reviewed separately.</span></span> <span data-ttu-id="d9e41-227">このアクティビティは、調整が難しい場合があります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-227">This activity can be difficult to coordinate.</span></span>

<span data-ttu-id="d9e41-228">多数のリポジトリを使用する代わりに、すべてのソース コードを、すべてを把握する巨大な 1 つのリポジトリにまとめることができます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-228">An alternative to using many repositories is to put all the source code together in a giant, all knowing, single repository.</span></span>

### <a name="single-repository"></a><span data-ttu-id="d9e41-229">1 つのリポジトリ</span><span class="sxs-lookup"><span data-stu-id="d9e41-229">Single repository</span></span>

<span data-ttu-id="d9e41-230">[monorepository](https://danluu.com/monorepo/) と呼ばれることもある、このアプローチでは、すべてのサービスのすべてのソース コードが同じリポジトリに格納されます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-230">In this approach, sometimes referred to as a [monorepository](https://danluu.com/monorepo/), all the source code for every service is put into the same repository.</span></span> <span data-ttu-id="d9e41-231">まず、このアプローチはいい考えには見えません。ソース コードが扱いづらくなりそうだからです。</span><span class="sxs-lookup"><span data-stu-id="d9e41-231">At first, this approach seems like a terrible idea likely to make dealing with source code unwieldy.</span></span> <span data-ttu-id="d9e41-232">ただし、この方法を使用すると、いくつかの利点があります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-232">There are, however, some marked advantages to working this way.</span></span>

<span data-ttu-id="d9e41-233">1 つ目の利点は、プロジェクト間の依存関係の管理が容易になることです。</span><span class="sxs-lookup"><span data-stu-id="d9e41-233">The first advantage is that it's easier to manage dependencies between projects.</span></span> <span data-ttu-id="d9e41-234">プロジェクトは、外部の成果物フィードを利用する代わりに、直接に互いをインポートできます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-234">Instead of relying on some external artifact feed, projects can directly import one another.</span></span> <span data-ttu-id="d9e41-235">つまり、更新が瞬時に行われ、競合するバージョンは、開発者のワークステーション上でコンパイル時に検出されるようになります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-235">This means that updates are instant, and conflicting versions are likely to be found at compile time on the developer's workstation.</span></span> <span data-ttu-id="d9e41-236">事実上、統合テストの一部がシフト レフトされます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-236">In effect, shifting some of the integration testing left.</span></span>

<span data-ttu-id="d9e41-237">プロジェクト間でコードを移動しても、ファイルが再書き込みではなく移動されたものとして検出されるため、履歴の保存が容易になりました。</span><span class="sxs-lookup"><span data-stu-id="d9e41-237">When moving code between projects, it's now easier to preserve the history as the files will be detected as having been moved rather than being rewritten.</span></span>

<span data-ttu-id="d9e41-238">もう 1 つの利点は、サービス境界にまたがる広範な変更を 1 回のコミットで行うことができるようになることです。</span><span class="sxs-lookup"><span data-stu-id="d9e41-238">Another advantage is that wide ranging changes that cross service boundaries can be made in a single commit.</span></span> <span data-ttu-id="d9e41-239">このアクティビティにより、多数の変更を個別に確認するオーバーヘッドが軽減されます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-239">This activity reduces the overhead of having potentially dozens of changes to review individually.</span></span>

<span data-ttu-id="d9e41-240">コードの静的分析を実行するツールが多数あり、セキュリティで保護されていないプログラミング手法または API の問題のある使用方法を検出できます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-240">There are many tools that can perform static analysis of code to detect insecure programming practices or problematic use of APIs.</span></span> <span data-ttu-id="d9e41-241">複数リポジトリの環境では、各リポジトリを繰り返し処理して、それぞれの問題を見つける必要があります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-241">In a multi-repository world, each repository will need to be iterated over to find the problems in them.</span></span> <span data-ttu-id="d9e41-242">単一のリポジトリでは、分析をすべて 1 箇所で実行できます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-242">The single repository allows running the analysis all in one place.</span></span>

<span data-ttu-id="d9e41-243">また、1 つのリポジトリのアプローチには多くの欠点もあります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-243">There are also many disadvantages to the single repository approach.</span></span> <span data-ttu-id="d9e41-244">最も懸念されるものは、リポジトリが 1 つであることでセキュリティ上の問題が発生することです。</span><span class="sxs-lookup"><span data-stu-id="d9e41-244">One of the most worrying ones is that having a single repository raises security concerns.</span></span> <span data-ttu-id="d9e41-245">サービスごとに 1 つずつのリポジトリ モデルでは、リポジトリの内容が漏洩しても、失われるコードの量は最小限です。</span><span class="sxs-lookup"><span data-stu-id="d9e41-245">If the contents of a repository are leaked in a repository per service model, the amount of code lost is minimal.</span></span> <span data-ttu-id="d9e41-246">1 つのリポジトリの場合、会社が所有するすべてが失われる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-246">With a single repository, everything the company owns could be lost.</span></span> <span data-ttu-id="d9e41-247">過去には、これが発生してゲーム開発の作業すべてが無駄になった例が多くあります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-247">There have been many examples in the past of this happening and derailing entire game development efforts.</span></span> <span data-ttu-id="d9e41-248">複数のリポジトリがあると、外部からのアクセスにさらされる部分が少なくなります。これは、ほとんどのセキュリティ プラクティスで望ましい特徴です。</span><span class="sxs-lookup"><span data-stu-id="d9e41-248">Having multiple repositories exposes less surface area, which is a desirable trait in most security practices.</span></span>

<span data-ttu-id="d9e41-249">1 つのリポジトリのサイズは、急速に、管理できないほどになる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-249">The size of the single repository is likely to become unmanageable rapidly.</span></span> <span data-ttu-id="d9e41-250">これにより、パフォーマンスに興味深いの影響がいくつか生じます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-250">This presents some interesting performance implications.</span></span> <span data-ttu-id="d9e41-251">場合によっては、[Virtual File System for Git](https://github.com/Microsoft/VFSForGit) など特別なツールの使用が必要になります。これは、本来、Windows チームの開発者のエクスペリエンスを向上させるために設計されたものです。</span><span class="sxs-lookup"><span data-stu-id="d9e41-251">It may become necessary to use specialized tools such as [Virtual File System for Git](https://github.com/Microsoft/VFSForGit), which was originally designed to improve the experience for developers on the Windows team.</span></span>

<span data-ttu-id="d9e41-252">1 つのリポジトリの使用に関する議論が、Facebook や Google がソース コードの配置にこの方法を使用しているという結論でまとめられることがよくあります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-252">Frequently the argument for using a single repository boils down to an argument that Facebook or Google use this method for source code arrangement.</span></span> <span data-ttu-id="d9e41-253">このアプローチがこれらの会社にとって十分であるのであれば、すべての会社にとって正しいアプローチであるというわけです。</span><span class="sxs-lookup"><span data-stu-id="d9e41-253">If the approach is good enough for these companies, then, surely, it's the correct approach for all companies.</span></span> <span data-ttu-id="d9e41-254">実際のところ、Facebook や Google のような規模で運用している企業はわずかです。</span><span class="sxs-lookup"><span data-stu-id="d9e41-254">The truth of the matter is that few companies operate on anything like the scale of Facebook or Google.</span></span> <span data-ttu-id="d9e41-255">それらの規模で発生する問題は、ほとんどの開発者が直面する問題とは異なります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-255">The problems that occur at those scales are different from those most developers will face.</span></span> <span data-ttu-id="d9e41-256">片方に適しているからといって、もう一方にも適しているとは限りません。</span><span class="sxs-lookup"><span data-stu-id="d9e41-256">What is good for the goose may not be good for the gander.</span></span>

<span data-ttu-id="d9e41-257">最終的には、いずれかのソリューションを使用して、マイクロサービスのソース コードをホストできます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-257">In the end, either solution can be used to host the source code for microservices.</span></span> <span data-ttu-id="d9e41-258">ただし、ほとんどのケースで、1 つのリポジトリで運用する際の管理とエンジニアリングのオーバーヘッドは、わずかなメリットには値しません。</span><span class="sxs-lookup"><span data-stu-id="d9e41-258">However, in most cases, the management, and engineering overhead of operating in a single repository isn't worth the meager advantages.</span></span> <span data-ttu-id="d9e41-259">複数のリポジトリにコードを分割すると、問題が適切に分離されるようになり、開発チームの自律性が促進されます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-259">Splitting code up over multiple repositories encourages better separation of concerns and encourages autonomy among development teams.</span></span>

### <a name="standard-directory-structure"></a><span data-ttu-id="d9e41-260">標準のディレクトリ構造</span><span class="sxs-lookup"><span data-stu-id="d9e41-260">Standard directory structure</span></span>

<span data-ttu-id="d9e41-261">1 つのリポジトリか複数のリポジトリかという議論に関係なく、サービスごとに独自のディレクトリがあります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-261">Regardless of the single versus multiple repositories debate each service will have its own directory.</span></span> <span data-ttu-id="d9e41-262">開発者がプロジェクト間を迅速に行きかうようにする優れた最適化の 1 つは、標準のディレクトリ構造を維持することです。</span><span class="sxs-lookup"><span data-stu-id="d9e41-262">One of the best optimizations to allow developers to cross between projects quickly is to maintain a standard directory structure.</span></span>

![図 10-4 電子メールとサインイン サービス両方の標準ディレクトリ構造](./media/dir-struct.png)

<span data-ttu-id="d9e41-264">**図 10-4** - 標準のディレクトリ構造。</span><span class="sxs-lookup"><span data-stu-id="d9e41-264">**Figure 10-4** - Standard directory structure.</span></span>

<span data-ttu-id="d9e41-265">新しいプロジェクトを作成するときは常に、適切な構造を配置するテンプレートを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-265">Whenever a new project is created, a template that puts in place the correct structure should be used.</span></span> <span data-ttu-id="d9e41-266">このテンプレートには、スケルトンの README ファイルや `azure-pipelines.yml` などの便利な項目を含めることもできます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-266">This template can also include such useful items as a skeleton README file and an `azure-pipelines.yml`.</span></span> <span data-ttu-id="d9e41-267">どのマイクロサービス アーキテクチャでも、プロジェクト間の相違が大きい、サービスに対する一括操作がさらに困難になります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-267">In any microservice architecture, a high degree of variance between projects makes bulk operations against the services more difficult.</span></span>

<span data-ttu-id="d9e41-268">複数のソース コード ディレクトリを含むディレクトリ全体のテンプレートを提供できるツールが多数あります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-268">There are many tools that can provide templating for an entire directory, containing several source code directories.</span></span> <span data-ttu-id="d9e41-269">[Yeoman](https://yeoman.io/) は JavaScript 環境で普及しています。また、GitHub で最近リリースされた [Repository Templates](https://github.blog/2019-06-06-generate-new-repositories-with-repository-templates/) では、ほぼ同じ機能が提供されます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-269">[Yeoman](https://yeoman.io/) is popular in the JavaScript world and GitHub have recently released [Repository Templates](https://github.blog/2019-06-06-generate-new-repositories-with-repository-templates/), which provide much of the same functionality.</span></span>

## <a name="task-management"></a><span data-ttu-id="d9e41-270">タスク管理</span><span class="sxs-lookup"><span data-stu-id="d9e41-270">Task management</span></span>

<span data-ttu-id="d9e41-271">タスク管理はどのプロジェクトでも困難な場合があります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-271">Managing tasks in any project can be difficult.</span></span> <span data-ttu-id="d9e41-272">最初に、最適な開発者の生産性を保証するために設定するワークフローの種類に関して、よく寄せられる質問に答えます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-272">Up front there are countless questions to be answered about the sort of workflows to set up to ensure optimal developer productivity.</span></span>

<span data-ttu-id="d9e41-273">クラウドネイティブ アプリケーションは、従来のソフトウェア製品よりも小さくなる傾向があります。または、少なくとも小さいサービスに分割されています。</span><span class="sxs-lookup"><span data-stu-id="d9e41-273">Cloud-native applications tend to be smaller than traditional software products or at least they're divided into smaller services.</span></span> <span data-ttu-id="d9e41-274">これらのサービスに関連する問題またはタスクの追跡は、他のソフトウェア プロジェクトの場合と同様に重要です。</span><span class="sxs-lookup"><span data-stu-id="d9e41-274">Tracking of issues or tasks related to these services remains as important as with any other software project.</span></span> <span data-ttu-id="d9e41-275">作業項目を追跡できなくなったり、問題が適切に記録されなかったことを顧客に説明したりすることは、だれも望みません。</span><span class="sxs-lookup"><span data-stu-id="d9e41-275">Nobody wants to lose track of some work item or explain to a customer that their issue wasn't properly logged.</span></span> <span data-ttu-id="d9e41-276">ボードはプロジェクト レベルで構成されますが、各プロジェクト内で区分を定義できます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-276">Boards are configured at the project level but within each project, areas can be defined.</span></span> <span data-ttu-id="d9e41-277">これによって、問題をいくつかのコンポーネントに分解できます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-277">These allow breaking down issues across several components.</span></span> <span data-ttu-id="d9e41-278">アプリケーション全体のすべての作業を 1 箇所で保持する利点は、作業項目を、あるチームから、それについてよく理解している別のチームに簡単に移動できることです。</span><span class="sxs-lookup"><span data-stu-id="d9e41-278">The advantage to keeping all the work for the entire application in one place is that it's easy to move work items from one team to another as they're understood better.</span></span>

<span data-ttu-id="d9e41-279">Azure DevOps では、多くの一般的なテンプレートが事前構成されています。</span><span class="sxs-lookup"><span data-stu-id="d9e41-279">Azure DevOps comes with a number of popular templates pre-configured.</span></span> <span data-ttu-id="d9e41-280">最も基本的な構成では、把握しておく必要があるのは、バックログの内容、担当者が作業している内容、および終了した作業です。</span><span class="sxs-lookup"><span data-stu-id="d9e41-280">In the most basic configuration, all that is needed to know is what's in the backlog, what people are working on, and what's done.</span></span> <span data-ttu-id="d9e41-281">重要なのは、ソフトウェアのビルド プロセスをこのように可視化することです。これにより、作業に優先順位を付けることができ、完了したタスクを顧客に報告できます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-281">It's important to have this visibility into the process of building software, so that work can be prioritized and completed tasks reported to the customer.</span></span> <span data-ttu-id="d9e41-282">もちろん、`to do`、`doing`、`done` という単純なプロセスに当てはまるソフトウェア プロジェクトはほとんどありません。</span><span class="sxs-lookup"><span data-stu-id="d9e41-282">Of course, few software projects stick to a process as simple as `to do`, `doing`, and `done`.</span></span> <span data-ttu-id="d9e41-283">`QA` または `Detailed Specification` というステップがプロセスに追加されるようになるまで時間はかかりません。</span><span class="sxs-lookup"><span data-stu-id="d9e41-283">It doesn't take long for people to start adding steps like `QA` or `Detailed Specification` to the process.</span></span>

<span data-ttu-id="d9e41-284">アジャイル手法の重要な部分の 1 つは、定期的な自己イントロスペクションです。</span><span class="sxs-lookup"><span data-stu-id="d9e41-284">One of the more important parts of Agile methodologies is self-introspection at regular intervals.</span></span> <span data-ttu-id="d9e41-285">このようなレビューは、チームが直面している問題とその改善方法についての分析情報を得ることを目的としています。</span><span class="sxs-lookup"><span data-stu-id="d9e41-285">These reviews are meant to provide insight into what problems the team is facing and how they can be improved.</span></span> <span data-ttu-id="d9e41-286">これは、多くの場合、開発プロセス全体で問題と機能のフローを変更することを意味します。</span><span class="sxs-lookup"><span data-stu-id="d9e41-286">Frequently, this means changing the flow of issues and features through the development process.</span></span> <span data-ttu-id="d9e41-287">そのため、ステージを追加してボードのレイアウトを拡張するのが非常に健全です。</span><span class="sxs-lookup"><span data-stu-id="d9e41-287">So, it's perfectly healthy to expand the layouts of the boards with additional stages.</span></span>

<span data-ttu-id="d9e41-288">ボードのステージのみが編成のツールではありません。</span><span class="sxs-lookup"><span data-stu-id="d9e41-288">The stages in the boards aren't the only organizational tool.</span></span> <span data-ttu-id="d9e41-289">ボードの構成によって、作業項目の階層が存在します。</span><span class="sxs-lookup"><span data-stu-id="d9e41-289">Depending on the configuration of the board, there's a hierarchy of work items.</span></span> <span data-ttu-id="d9e41-290">ボードに表示できる最小の項目はタスクです。</span><span class="sxs-lookup"><span data-stu-id="d9e41-290">The most granular item that can appear on a board is a task.</span></span> <span data-ttu-id="d9e41-291">既定では、タスクに含まれるのは、タイトル、説明、優先順位、残りの推定作業量のフィールド、および他の作業項目や開発項目 (分岐、コミット、プル要求、ビルドなど) へのリンク機能です。</span><span class="sxs-lookup"><span data-stu-id="d9e41-291">Out of the box a task contains fields for a title, description, a priority, an estimate of the amount of work remaining and the ability to link to other work items or development items (branches, commits, pull requests, builds, and so forth).</span></span> <span data-ttu-id="d9e41-292">作業項目は、アプリケーションのさまざまな領域や、さまざまなイテレーション (スプリント) に分類でき、簡単に見つけることができます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-292">Work items can be classified into different areas of the application and different iterations (sprints) to make finding them easier.</span></span>

![図 10-5 Azure DevOps のタスク例](./media/task-details.png)

<span data-ttu-id="d9e41-294">**図 10-5** - Azure DevOps のタスク。</span><span class="sxs-lookup"><span data-stu-id="d9e41-294">**Figure 10-5** - Task in Azure DevOps.</span></span>

<span data-ttu-id="d9e41-295">[説明] フィールドでは、期待される標準スタイル (太字、斜体、アンダースコア、取り消し線)、および画像を挿入する機能がサポートされます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-295">The description field supports the normal styles you'd expect (bold, italic underscore and strike through) and the ability to insert images.</span></span> <span data-ttu-id="d9e41-296">このために、作業またはバグを指定するときに使用できる強力なツールになります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-296">This makes it a powerful tool for use when specifying work or bugs.</span></span>

<span data-ttu-id="d9e41-297">タスクをまとめたものがフィーチャーで、これによって、より大きな作業単位が定義されます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-297">Tasks can be rolled up into features, which define a larger unit of work.</span></span> <span data-ttu-id="d9e41-298">さらに、機能を[まとめたものがエピック](/azure/devops/boards/backlogs/define-features-epics?view=azure-devops)です。</span><span class="sxs-lookup"><span data-stu-id="d9e41-298">Features, in turn, can be [rolled up into epics](/azure/devops/boards/backlogs/define-features-epics?view=azure-devops).</span></span> <span data-ttu-id="d9e41-299">このような階層でタスクを分類することで、大きな機能のロールアウトにどれくらい近づいているかがわかりやすくなります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-299">Classifying tasks in this hierarchy makes it much easier to understand how close a large feature is to rolling out.</span></span>

![図 10-6 基本プロセス テンプレートに既定で構成されている作業項目の種類](./media/board-issue-types.png)

<span data-ttu-id="d9e41-301">**図 10-6** - Azure DevOps の作業項目。</span><span class="sxs-lookup"><span data-stu-id="d9e41-301">**Figure 10-6** - Work item in Azure DevOps.</span></span>

<span data-ttu-id="d9e41-302">Azure Boards には、問題のさまざまな種類のビューがあります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-302">There are different kinds of views into the issues in Azure Boards.</span></span> <span data-ttu-id="d9e41-303">まだスケジュールされていない項目はバックログに表示されます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-303">Items that aren't yet scheduled appear in the backlog.</span></span> <span data-ttu-id="d9e41-304">そこから、スプリントに割り当てることができます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-304">From there, they can be assigned to a sprint.</span></span> <span data-ttu-id="d9e41-305">スプリントとは、作業の一定量が完了すると予想される時間ボックスです。</span><span class="sxs-lookup"><span data-stu-id="d9e41-305">A sprint is a time box during which it's expected some quantity of work will be completed.</span></span> <span data-ttu-id="d9e41-306">この作業には、タスクだけでなく、チケットの解決も含まれます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-306">This work can include tasks but also the resolution of tickets.</span></span> <span data-ttu-id="d9e41-307">その後、スプリント全体を、スプリント ボード セクションから管理できます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-307">Once there, the entire sprint can be managed from the Sprint board section.</span></span> <span data-ttu-id="d9e41-308">このビューには、作業の進行状況が表示されます。また、スプリントが成功するかどうかをについて最新の推定情報がわかるバーン ダウン チャートも含まれています。</span><span class="sxs-lookup"><span data-stu-id="d9e41-308">This view shows how work is progressing and includes a burn down chart to give an ever-updating estimate of if the sprint will be successful.</span></span>

![図 10-7 スプリントが定義されているボード](./media/sprint-board.png)

<span data-ttu-id="d9e41-310">**図 10-7** - Azure DevOps のボード。</span><span class="sxs-lookup"><span data-stu-id="d9e41-310">**Figure 10-7** - Board in Azure DevOps.</span></span>

<span data-ttu-id="d9e41-311">これまでに、Azure DevOps のボードには非常に優れた機能があることが明らかになりました。</span><span class="sxs-lookup"><span data-stu-id="d9e41-311">By now, it should be apparent that there's a great deal of power in the Boards in Azure DevOps.</span></span> <span data-ttu-id="d9e41-312">開発者にとっては、何の作業が行われているかを簡単に把握できます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-312">For developers, there are easy views of what is being worked on.</span></span> <span data-ttu-id="d9e41-313">プロジェクト マネージャーにとっては、今後の作業と既存の作業を確認できます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-313">For project managers views into upcoming work as well as an overview of existing work.</span></span> <span data-ttu-id="d9e41-314">マネージャーにとっては、リソースや容量に関する豊富なレポートがあります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-314">For managers, there are plenty of reports about resourcing and capacity.</span></span> <span data-ttu-id="d9e41-315">残念ながら、クラウドネイティブ アプリケーションに関して作業を追跡する必要がなくなるといった夢のようなことはありません。</span><span class="sxs-lookup"><span data-stu-id="d9e41-315">Unfortunately, there's nothing magical about cloud-native applications that eliminate the need to track work.</span></span> <span data-ttu-id="d9e41-316">しかし、作業を追跡する必要がある場合、Azure DevOps よりもエクスペリエンスが優れているものがいくつかあります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-316">But if you must track work, there are a few places where the experience is better than in Azure DevOps.</span></span>

## <a name="cicd-pipelines"></a><span data-ttu-id="d9e41-317">CI/CD パイプライン</span><span class="sxs-lookup"><span data-stu-id="d9e41-317">CI/CD pipelines</span></span>

<span data-ttu-id="d9e41-318">ソフトウェア開発ライフ サイクルにとって、継続的インテグレーション (CI) と継続的デリバリー (CD) の登場ほど革新的な変化はありませんでした。</span><span class="sxs-lookup"><span data-stu-id="d9e41-318">Almost no change in the software development life cycle has been so revolutionary as the advent of continuous integration (CI) and continuous delivery (CD).</span></span> <span data-ttu-id="d9e41-319">変更がチェックインされるとすぐに、プロジェクトのソース コードに対して自動テストをビルドして実行することで、エラーを早く検出できます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-319">Building and running automated tests against the source code of a project as soon as a change is checked in catches mistakes early.</span></span> <span data-ttu-id="d9e41-320">継続的インテグレーション ビルドが登場する前は、リポジトリからコードをプルしてから、テストに合格しないことやビルドさえできないことがわかるのも珍しくありませんでした。</span><span class="sxs-lookup"><span data-stu-id="d9e41-320">Prior to the advent of continuous integration builds, it wouldn't be uncommon to pull code from the repository and find that it didn't pass tests or couldn't even be built.</span></span> <span data-ttu-id="d9e41-321">この場合、不具合の原因を見つけ出すことになります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-321">This resulted in tracking down the source of the breakage.</span></span>

<span data-ttu-id="d9e41-322">従来、運用環境にソフトウェアを配布するには、大量のドキュメントと手順一覧が必要でした。</span><span class="sxs-lookup"><span data-stu-id="d9e41-322">Traditionally shipping software to the production environment required extensive documentation and a list of steps.</span></span> <span data-ttu-id="d9e41-323">これらの手順それぞれを、エラーが発生しやすいプロセスで手動で完了する必要がありました。</span><span class="sxs-lookup"><span data-stu-id="d9e41-323">Each one of these steps needed to be manually completed in a very error prone process.</span></span>

![図 10-8 チェックリスト](./media/checklist.png)

<span data-ttu-id="d9e41-325">**図 10-8** - チェックリスト。</span><span class="sxs-lookup"><span data-stu-id="d9e41-325">**Figure 10-8** - Checklist.</span></span>

<span data-ttu-id="d9e41-326">継続的インテグレーションと関係が深い継続的デリバリーでは、ビルトされたばかりのパッケージが環境に配置されます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-326">The sister of continuous integration is continuous delivery in which the freshly built packages are deployed to an environment.</span></span> <span data-ttu-id="d9e41-327">手動プロセスは開発の速さに合わせられないため、自動化がより重要になります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-327">The manual process can't scale to match the speed of development so automation becomes more important.</span></span> <span data-ttu-id="d9e41-328">チェックリストはスクリプトに置き換えられ、同じタスクが人間よりも速く、より正確に実行されます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-328">Checklists are replaced by scripts that can execute the same tasks faster and more accurately than any human.</span></span>

<span data-ttu-id="d9e41-329">継続的デリバリーの対象となる環境は、テスト環境の場合もあれば、多くの主要なテクノロジ企業によって行われているように、運用環境の場合もあります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-329">The environment to which continuous delivery delivers might be a test environment or, as is being done by many major technology companies, it could be the production environment.</span></span> <span data-ttu-id="d9e41-330">後者では、高品質のテストに投資して、ユーザーのために運用が中断されないという確信を得る必要があります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-330">The latter requires an investment in high-quality tests that can give confidence that a change isn't going to break production for users.</span></span> <span data-ttu-id="d9e41-331">継続的インテグレーションでは早期にコードの問題が検出されるのと同様に、継続的デリバリーでは配置プロセスの問題が早期にわかります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-331">In the same way that continuous integration caught issues in the code early continuous delivery catches issues in the deployment process early.</span></span>

<span data-ttu-id="d9e41-332">ビルドおよびデリバリー プロセスを自動化する重要性は、クラウドネイティブ アプリケーションによってさらに際立ちます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-332">The importance of automating the build and delivery process is accentuated by cloud-native applications.</span></span> <span data-ttu-id="d9e41-333">配置は、より頻繁に、より多くの環境に行われるため、手動での配置はほとんど不可能です。</span><span class="sxs-lookup"><span data-stu-id="d9e41-333">Deployments happen more frequently and to more environments so manually deploying borders on impossible.</span></span>

### <a name="azure-builds"></a><span data-ttu-id="d9e41-334">Azure Builds</span><span class="sxs-lookup"><span data-stu-id="d9e41-334">Azure Builds</span></span>

<span data-ttu-id="d9e41-335">Azure DevOps によって一連のツールが提供され、継続的インテグレーションと継続的配置がかつてないほど容易になります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-335">Azure DevOps provides a set of tools to make continuous integration and deployment easier than ever.</span></span> <span data-ttu-id="d9e41-336">これらのツールは Azure Pipelines にあります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-336">These tools are located under Azure Pipelines.</span></span> <span data-ttu-id="d9e41-337">1 つ目は、Azure Builds です。これは、大規模に YAML ベースのビルド定義を実行するためのツールです。</span><span class="sxs-lookup"><span data-stu-id="d9e41-337">The first of them is Azure Builds, which is a tool for running YAML-based build definitions at scale.</span></span> <span data-ttu-id="d9e41-338">ユーザーは、自らのビルド用マシンを持ち込むことも (正確に設定された環境がビルドに必要な場合に最適)、Azure でホストされた、常に更新されている仮想マシンのプールからマシンを利用することもできます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-338">Users can either bring their own build machines (great for if the build requires a meticulously set up environment) or use a machine from a constantly refreshed pool of Azure hosted virtual machines.</span></span> <span data-ttu-id="d9e41-339">これらのホスト ビルド エージェントには、.NET 開発だけでなく、Java や Python から iPhone 開発まで、さまざまな開発ツールが事前にインストールされています。</span><span class="sxs-lookup"><span data-stu-id="d9e41-339">These hosted build agents come pre-installed with a wide range of development tools for not just .NET development but for everything from Java to Python to iPhone development.</span></span>

<span data-ttu-id="d9e41-340">DevOps には、すぐに使用できる多様なビルド定義が含まれており、あらゆるビルドに対してカスタマイズできます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-340">DevOps includes a wide range of out of the box build definitions that can be customized for any build.</span></span> <span data-ttu-id="d9e41-341">ビルド定義は、`azure-pipelines.yml` と呼ばれるファイルに定義されて、リポジトリにチェックインされるため、ソース コードと共にバージョン管理できます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-341">The build definitions are defined in a file called `azure-pipelines.yml` and checked into the repository so they can be versioned along with the source code.</span></span> <span data-ttu-id="d9e41-342">これにより、分岐内のビルド パイプラインに変更を行うのが非常に容易になります。変更はその分岐のみにチェックインされるためです。</span><span class="sxs-lookup"><span data-stu-id="d9e41-342">This makes it much easier to make changes to the build pipeline in a branch as the changes can be checked into just that branch.</span></span> <span data-ttu-id="d9e41-343">完全なフレームワークで ASP.NET Web アプリケーションをビルドする `azure-pipelines.yml` のサンプルを図 10-9 に示します。</span><span class="sxs-lookup"><span data-stu-id="d9e41-343">An example `azure-pipelines.yml` for building an ASP.NET web application on full framework is show in Figure 10-9.</span></span>

```yml
name: $(rev:r)

variables:
  version: 9.2.0.$(Build.BuildNumber)
  solution: Portals.sln
  artifactName: drop
  buildPlatform: any cpu
  buildConfiguration: release

pool:
  name: Hosted VS2017
  demands:
  - msbuild
  - visualstudio
  - vstest

steps:
- task: NuGetToolInstaller@0
  displayName: 'Use NuGet 4.4.1'
  inputs:
    versionSpec: 4.4.1

- task: NuGetCommand@2
  displayName: 'NuGet restore'
  inputs:
    restoreSolution: '$(solution)'

- task: VSBuild@1
  displayName: 'Build solution'
  inputs:
    solution: '$(solution)'
    msbuildArgs: '-p:DeployOnBuild=true -p:WebPublishMethod=Package -p:PackageAsSingleFile=true -p:SkipInvalidConfigurations=true -p:PackageLocation="$(build.artifactstagingdirectory)\\"'
    platform: '$(buildPlatform)'
    configuration: '$(buildConfiguration)'

- task: VSTest@2
  displayName: 'Test Assemblies'
  inputs:
    testAssemblyVer2: |
     **\$(buildConfiguration)\**\*test*.dll
     !**\obj\**
     !**\*testadapter.dll
    platform: '$(buildPlatform)'
    configuration: '$(buildConfiguration)'

- task: CopyFiles@2
  displayName: 'Copy UI Test Files to: $(build.artifactstagingdirectory)'
  inputs:
    SourceFolder: UITests
    TargetFolder: '$(build.artifactstagingdirectory)/uitests'

- task: PublishBuildArtifacts@1
  displayName: 'Publish Artifact'
  inputs:
    PathtoPublish: '$(build.artifactstagingdirectory)'
    ArtifactName: '$(artifactName)'
  condition: succeededOrFailed()
```

<span data-ttu-id="d9e41-344">**図 10-9** - サンプル azure-pipelines.yml</span><span class="sxs-lookup"><span data-stu-id="d9e41-344">**Figure 10-9** - A sample azure-pipelines.yml</span></span>

<span data-ttu-id="d9e41-345">このビルド定義では、いくつもの組み込みタスクが使用されており、ビルドの作成はレゴ ブロックのセットを組み立てるのと同じくらい簡単です (巨大なミレニアム ファルコン号よりも簡単です)。</span><span class="sxs-lookup"><span data-stu-id="d9e41-345">This build definition uses a number of built-in tasks that make creating builds as simple as building a Lego set (simpler than the giant Millennium Falcon).</span></span> <span data-ttu-id="d9e41-346">たとえば、NuGet タスクによって NuGet パッケージが復元される一方で、VSBuild タスクが Visual Studio ビルド ツールを呼び出して、実際のコンパイルを実行します。</span><span class="sxs-lookup"><span data-stu-id="d9e41-346">For instance, the NuGet task restores NuGet packages, while the VSBuild task calls the Visual Studio build tools to perform the actual compilation.</span></span> <span data-ttu-id="d9e41-347">Azure DevOps には何百ものさまざまなタスクが用意されており、コミュニティではさらに数千個が管理されています。</span><span class="sxs-lookup"><span data-stu-id="d9e41-347">There are hundreds of different tasks available in Azure DevOps, with thousands more that are maintained by the community.</span></span> <span data-ttu-id="d9e41-348">どのようなビルド タスクを実行しようとしていても、だれかが既にそれをビルドしている可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-348">It's likely that no matter what build tasks you're looking to run, somebody has built one already.</span></span>

<span data-ttu-id="d9e41-349">ビルドのトリガーは、手動で、チェックインによって、スケジュールに基づいて、または別のビルドの完了によって、行うことができます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-349">Builds can be triggered manually, by a check-in, on a schedule, or by the completion of another build.</span></span> <span data-ttu-id="d9e41-350">ほとんどのケースでは、チェックインのたびにビルドすることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="d9e41-350">In most cases, building on every check-in is desirable.</span></span> <span data-ttu-id="d9e41-351">ビルドをフィルター処理して、リポジトリのさまざまな部分、またはさまざまな分岐に対して、異なるビルドが実行されるようにできます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-351">Builds can be filtered so that different builds run against different parts of the repository or against different branches.</span></span> <span data-ttu-id="d9e41-352">これにより、プル要求時にテストを減らした高速ビルドを実行したり、毎晩トランクに対して完全な回帰スイートを実行したりするといったシナリオが実現できます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-352">This allows for scenarios like running fast builds with reduced testing on pull requests and running a full regression suite against the trunk on a nightly basis.</span></span>

<span data-ttu-id="d9e41-353">ビルドの最終的な結果は、ビルド成果物と呼ばれるファイルのコレクションです。</span><span class="sxs-lookup"><span data-stu-id="d9e41-353">The end result of a build is a collection of files known as build artifacts.</span></span> <span data-ttu-id="d9e41-354">これらの成果物は、ビルド プロセスの次のステップに渡すことも、Azure 成果物フィードに追加して、他のビルドで使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-354">These artifacts can be passed along to the next step in the build process or added to an Azure Artifact feed, so they can be consumed by other builds.</span></span>

### <a name="azure-devops-releases"></a><span data-ttu-id="d9e41-355">Azure DevOps リリース</span><span class="sxs-lookup"><span data-stu-id="d9e41-355">Azure DevOps releases</span></span>

<span data-ttu-id="d9e41-356">ビルドによって、ソフトウェアが配布可能なパッケージにコンパイルされます。ただし、継続的デリバリーを完了するために、引き続き成果物をテスト環境にプッシュする必要があります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-356">Builds take care of compiling the software into a shippable package, but the artifacts still need to be pushed out to a testing environment to complete continuous delivery.</span></span> <span data-ttu-id="d9e41-357">このため、Azure DevOps はリリースと呼ばれる別のツールを使用します。</span><span class="sxs-lookup"><span data-stu-id="d9e41-357">For this, Azure DevOps uses a separate tool called Releases.</span></span> <span data-ttu-id="d9e41-358">リリース ツールでは、ビルドで使用した同じタスクのライブラリを使用しますが、"ステージ" という概念が導入されています。</span><span class="sxs-lookup"><span data-stu-id="d9e41-358">The Releases tool makes use of the same tasks' library that were available to the Build but introduce a concept of "stages".</span></span> <span data-ttu-id="d9e41-359">ステージは、分離された環境であり、そこにパッケージがインストールされます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-359">A stage is an isolated environment into which the package is installed.</span></span> <span data-ttu-id="d9e41-360">たとえば、ある製品では、開発、QA、および運用環境が使用されます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-360">For instance, a product might make use of a development, a QA, and a production environment.</span></span> <span data-ttu-id="d9e41-361">コードが継続的に開発環境に提供され、そこで自動テストを実行できます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-361">Code is continuously delivered into the development environment where automated tests can be run against it.</span></span> <span data-ttu-id="d9e41-362">これらのテストに合格すると、リリースが手動テストのために QA 環境に移動します。</span><span class="sxs-lookup"><span data-stu-id="d9e41-362">Once those tests pass the release moves onto the QA environment for manual testing.</span></span> <span data-ttu-id="d9e41-363">最終的に、コードが運用環境にプッシュされ、だれでも見えるようになります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-363">Finally, the code is pushed to production where it's visible to everybody.</span></span>

![図 10-10 開発、QA、および運用フェーズを含むリリース パイプラインの例](./media/release-pipeline.png)

<span data-ttu-id="d9e41-365">**図 10-10** - リリース パイプライン</span><span class="sxs-lookup"><span data-stu-id="d9e41-365">**Figure 10-10** - Release pipeline</span></span>

<span data-ttu-id="d9e41-366">ビルドの各ステージは、前のフェーズの完了によって自動的にトリガーされます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-366">Each stage in the build can be automatically triggered by the completion of the previous phase.</span></span> <span data-ttu-id="d9e41-367">ただし、多くの場合、これは望ましくありません。</span><span class="sxs-lookup"><span data-stu-id="d9e41-367">In many cases, however, this isn't desirable.</span></span> <span data-ttu-id="d9e41-368">コードの運用環境への移行には、だれかの承認が必要です。</span><span class="sxs-lookup"><span data-stu-id="d9e41-368">Moving code into production might require approval from somebody.</span></span> <span data-ttu-id="d9e41-369">リリース ツールでは、リリース パイプラインの各ステップに承認者を設定することができ、これがサポートされます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-369">The Releases tool supports this by allowing approvers at each step of the release pipeline.</span></span> <span data-ttu-id="d9e41-370">リリースを運用環境に移す前に、特定のユーザーまたはユーザー グループがサインオフする必要があるように、ルールを設定できます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-370">Rules can be set up such that a specific person or group of people must sign off on a release before it makes into production.</span></span> <span data-ttu-id="d9e41-371">このようなゲートによって、手動による品質チェックが実現し、関連する規制要件に準拠して、運用環境に移す内容を制御することもできます。</span><span class="sxs-lookup"><span data-stu-id="d9e41-371">These gates allow for manual quality checks and also for compliance with any regulatory requirements related to control what goes into production.</span></span>

### <a name="everybody-gets-a-build-pipeline"></a><span data-ttu-id="d9e41-372">だれでもビルド パイプラインを取得</span><span class="sxs-lookup"><span data-stu-id="d9e41-372">Everybody gets a build pipeline</span></span>

<span data-ttu-id="d9e41-373">多数のビルド パイプラインを構成してもコストがかかりません。そのため、マイクロサービスごとに少なくとも 1 つのビルドパイプラインを用意することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="d9e41-373">There's no cost to configuring many build pipelines, so it's advantageous to have at least one build pipeline per microservice.</span></span> <span data-ttu-id="d9e41-374">マイクロサービスはどのような環境にも独立して配置できるため、それぞれを独自のパイプラインを通じてリリースでき、関連しない大量のコードをリリースせずに済むことは理想的です。</span><span class="sxs-lookup"><span data-stu-id="d9e41-374">Ideally, microservices are independently deployable to any environment so having each one able to be released via its own pipeline without releasing a mass of unrelated code is perfect.</span></span> <span data-ttu-id="d9e41-375">各パイプラインには、独自の承認セットを設定でき、各サービス用にビルド プロセスのバリエーションが可能になります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-375">Each pipeline can have its own set of approvals allowing for variations in build process for each service.</span></span>

### <a name="versioning-releases"></a><span data-ttu-id="d9e41-376">バージョン管理されたリリース</span><span class="sxs-lookup"><span data-stu-id="d9e41-376">Versioning releases</span></span>

<span data-ttu-id="d9e41-377">リリース機能を使用する 1 つの欠点は、チェックインされる `azure-pipelines.yml` ファイル内に定義できないことです。</span><span class="sxs-lookup"><span data-stu-id="d9e41-377">One drawback to using the Releases functionality is that it can't be defined in a checked-in `azure-pipelines.yml` file.</span></span> <span data-ttu-id="d9e41-378">分岐ごとにリリース定義を行ったり、リリースのスケルトンをプロジェクト テンプレートに含めたりなど、これを望む理由は多数あります。</span><span class="sxs-lookup"><span data-stu-id="d9e41-378">There are many reasons you might want to do that from having per-branch release definitions to including a release skeleton in your project template.</span></span> <span data-ttu-id="d9e41-379">幸いにも、いくつかのステージのサポートをビルド コンポーネントに移行する作業が進行中です。</span><span class="sxs-lookup"><span data-stu-id="d9e41-379">Fortunately, work is ongoing to shift some of the stages support into the Build component.</span></span> <span data-ttu-id="d9e41-380">これは、マルチステージ ビルドと呼ばれるようになります。[最初のバージョンが使用可能になりました](https://devblogs.microsoft.com/devops/whats-new-with-azure-pipelines/)。</span><span class="sxs-lookup"><span data-stu-id="d9e41-380">This will be known as multi-stage build and the [first version is available now](https://devblogs.microsoft.com/devops/whats-new-with-azure-pipelines/)!</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="d9e41-381">[前へ](azure-security.md)
>[次へ](feature-flags.md)</span><span class="sxs-lookup"><span data-stu-id="d9e41-381">[Previous](azure-security.md)
[Next](feature-flags.md)</span></span>
