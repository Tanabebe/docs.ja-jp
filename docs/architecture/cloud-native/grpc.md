---
title: gRPC
description: gRPC について、クラウドネイティブ アプリケーションにおけるその役割、HTTP RESTful 通信との違いを説明します。
author: robvet
no-loc:
- Blazor
- Blazor WebAssembly
ms.date: 01/19/2021
ms.openlocfilehash: 8667f2d3a7a19aa6dffdd8ce8bef103eab5cc54f
ms.sourcegitcommit: f2ab02d9a780819ca2e5310bbcf5cfe5b7993041
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/03/2021
ms.locfileid: "99505701"
---
# <a name="grpc"></a><span data-ttu-id="90b9e-103">gRPC</span><span class="sxs-lookup"><span data-stu-id="90b9e-103">gRPC</span></span>

<span data-ttu-id="90b9e-104">本書では、これまで [REST ベース](/azure/architecture/best-practices/api-design)の通信に焦点を当ててきました。</span><span class="sxs-lookup"><span data-stu-id="90b9e-104">So far in this book, we've focused on [REST-based](/azure/architecture/best-practices/api-design) communication.</span></span> <span data-ttu-id="90b9e-105">REST は、エンティティ リソースに対する CRUD ベースの操作を定義する柔軟なアーキテクチャ スタイルであることを見てきました。</span><span class="sxs-lookup"><span data-stu-id="90b9e-105">We've seen that REST is a flexible architectural style that defines CRUD-based operations against entity resources.</span></span> <span data-ttu-id="90b9e-106">クライアントは、HTTP を介して要求と応答の通信モデルでリソースと対話します。</span><span class="sxs-lookup"><span data-stu-id="90b9e-106">Clients interact with resources across HTTP with a request/response communication model.</span></span> <span data-ttu-id="90b9e-107">REST は広く実装されていますが、新しい通信テクノロジである gRPC には、クラウドネイティブ コミュニティ全体で大きな勢いがあります。</span><span class="sxs-lookup"><span data-stu-id="90b9e-107">While REST is widely implemented, a newer communication technology, gRPC, has gained tremendous momentum across the cloud-native community.</span></span>

## <a name="what-is-grpc"></a><span data-ttu-id="90b9e-108">gRPC とは</span><span class="sxs-lookup"><span data-stu-id="90b9e-108">What is gRPC?</span></span>

<span data-ttu-id="90b9e-109">gRPC は、古い[リモート プロシージャ コール (RPC)](https://en.wikipedia.org/wiki/Remote_procedure_call) プロトコルを進化させる最新のハイパフォーマンス フレームワークです。</span><span class="sxs-lookup"><span data-stu-id="90b9e-109">gRPC is a modern, high-performance framework that evolves the age-old [remote procedure call (RPC)](https://en.wikipedia.org/wiki/Remote_procedure_call) protocol.</span></span> <span data-ttu-id="90b9e-110">アプリケーション レベルでは、gRPC により、クライアントとバックエンド サービス間のメッセージングが合理化されます。</span><span class="sxs-lookup"><span data-stu-id="90b9e-110">At the application level, gRPC streamlines messaging between clients and back-end services.</span></span> <span data-ttu-id="90b9e-111">Google から提供されている gRPC はオープンソースであり、クラウドネイティブ オファリングの [Cloud Native Computing Foundation (CNCF)](https://www.cncf.io/) エコシステムの一部です。</span><span class="sxs-lookup"><span data-stu-id="90b9e-111">Originating from Google, gRPC is open source and part of the  [Cloud Native Computing Foundation (CNCF)](https://www.cncf.io/) ecosystem of cloud-native offerings.</span></span> <span data-ttu-id="90b9e-112">CNCF は、gRPC を [Incubating (発展中) プロジェクト](https://github.com/cncf/toc/blob/master/process/graduation_criteria.adoc)と見なしています。</span><span class="sxs-lookup"><span data-stu-id="90b9e-112">CNCF considers gRPC an [incubating project](https://github.com/cncf/toc/blob/master/process/graduation_criteria.adoc).</span></span> <span data-ttu-id="90b9e-113">Incubating とは、エンドユーザーが運用アプリケーションでそのテクノロジを使用しており、プロジェクトには多数の貢献者がいることを意味します。</span><span class="sxs-lookup"><span data-stu-id="90b9e-113">Incubating means end users are using the technology in production applications, and the project has a healthy number of contributors.</span></span>

<span data-ttu-id="90b9e-114">一般的な gRPC クライアント アプリの場合、ビジネス操作を実装するローカルなインプロセス関数が公開されます。</span><span class="sxs-lookup"><span data-stu-id="90b9e-114">A typical gRPC client app will expose a local, in-process function that implements a business operation.</span></span> <span data-ttu-id="90b9e-115">内部的には、そのローカル関数により、リモート マシン上の別の関数が呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="90b9e-115">Under the covers, that local function invokes another function on a remote machine.</span></span> <span data-ttu-id="90b9e-116">ローカルの呼び出しのように見えますが、本質的には、リモート サービスへの透過的なアウトプロセス呼び出しです。</span><span class="sxs-lookup"><span data-stu-id="90b9e-116">What appears to be a local call essentially becomes a transparent out-of-process call to a remote service.</span></span> <span data-ttu-id="90b9e-117">RPC のプラミングにより、コンピューター間のポイントツーポイント ネットワーク通信、シリアル化、および実行が抽象化されます。</span><span class="sxs-lookup"><span data-stu-id="90b9e-117">The RPC plumbing abstracts the point-to-point networking communication, serialization, and execution between computers.</span></span>

<span data-ttu-id="90b9e-118">クラウドネイティブ アプリケーションの場合、開発者は複数のプログラミング言語、フレームワーク、テクノロジにまたがって作業することがよくあります。</span><span class="sxs-lookup"><span data-stu-id="90b9e-118">In cloud-native applications, developers often work across programming languages, frameworks, and technologies.</span></span> <span data-ttu-id="90b9e-119">この "*相互運用性*" により、クロスプラットフォームの通信に必要なメッセージ コントラクトとプラミングが複雑になります。</span><span class="sxs-lookup"><span data-stu-id="90b9e-119">This *interoperability* complicates message contracts and the plumbing required for cross-platform communication.</span></span>  <span data-ttu-id="90b9e-120">gRPC には、このような懸案事項を抽象化する "均一な水平レイヤー" が用意されています。</span><span class="sxs-lookup"><span data-stu-id="90b9e-120">gRPC provides a "uniform horizontal layer" that abstracts these concerns.</span></span> <span data-ttu-id="90b9e-121">開発者は、ビジネス機能に集中して、ネイティブ プラットフォームでコードを書き、通信のプラミングは gRPC で処理します。</span><span class="sxs-lookup"><span data-stu-id="90b9e-121">Developers code in their native platform focused on business functionality, while gRPC handles communication plumbing.</span></span>

<span data-ttu-id="90b9e-122">gRPC は、Java、JavaScript、C#、Go、Swift、NodeJS など、ほとんどの一般的な開発スタックを包括的にサポートしています。</span><span class="sxs-lookup"><span data-stu-id="90b9e-122">gRPC offers comprehensive support across most popular development stacks, including Java, JavaScript, C#, Go, Swift, and NodeJS.</span></span>

## <a name="grpc-benefits"></a><span data-ttu-id="90b9e-123">gRPC の利点</span><span class="sxs-lookup"><span data-stu-id="90b9e-123">gRPC Benefits</span></span>

<span data-ttu-id="90b9e-124">gRPC では、トランスポート プロトコルとして HTTP/2 が使用されます。</span><span class="sxs-lookup"><span data-stu-id="90b9e-124">gRPC uses HTTP/2 for its transport protocol.</span></span> <span data-ttu-id="90b9e-125">HTTP/2 は、HTTP 1.1 との互換性を持ちながら、多くの先進的な機能を備えています。</span><span class="sxs-lookup"><span data-stu-id="90b9e-125">While compatible with HTTP 1.1, HTTP/2 features many advanced capabilities:</span></span>

- <span data-ttu-id="90b9e-126">データ転送のためのバイナリ フレーミング プロトコルです。テキストベースの HTTP 1.1 とは異なります。</span><span class="sxs-lookup"><span data-stu-id="90b9e-126">A binary framing protocol for data transport - unlike HTTP 1.1, which is text based.</span></span>
- <span data-ttu-id="90b9e-127">同じ接続を介して複数の並列要求を送信するための多重化のサポート。HTTP 1.1 の場合、処理が一度に 1 つの要求および応答メッセージに制限されています。</span><span class="sxs-lookup"><span data-stu-id="90b9e-127">Multiplexing support for sending multiple parallel requests over the same connection - HTTP 1.1 limits processing to one request/response message at a time.</span></span>
- <span data-ttu-id="90b9e-128">クライアント要求とサーバー応答の両方を同時に送信するための双方向全二重通信。</span><span class="sxs-lookup"><span data-stu-id="90b9e-128">Bidirectional full-duplex communication for sending both client requests and server responses simultaneously.</span></span>
- <span data-ttu-id="90b9e-129">大規模なデータセットを非同期にストリーミングするための要求と応答を可能にする組み込みのストリーミング。</span><span class="sxs-lookup"><span data-stu-id="90b9e-129">Built-in streaming enabling requests and responses to asynchronously stream large data sets.</span></span>
- <span data-ttu-id="90b9e-130">ネットワークの使用量を減らすヘッダー圧縮。</span><span class="sxs-lookup"><span data-stu-id="90b9e-130">Header compression that reduces network usage.</span></span>

<span data-ttu-id="90b9e-131">gRPC は軽量でハイ パフォーマンスです。</span><span class="sxs-lookup"><span data-stu-id="90b9e-131">gRPC is lightweight and highly performant.</span></span> <span data-ttu-id="90b9e-132">メッセージが 60-80% 小さいので JSON シリアル化よりも最大 8 倍高速になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="90b9e-132">It can be up to 8x faster than JSON serialization with messages 60-80% smaller.</span></span> <span data-ttu-id="90b9e-133">Microsoft [Windows Communication Foundation (WCF)](../../framework/wcf/whats-wcf.md) によると、gRPC のパフォーマンスは、高度に最適化された [NetTCP バインディング](/dotnet/api/system.servicemodel.nettcpbinding?view=netframework-4.8)の速度と効率を上回っています。</span><span class="sxs-lookup"><span data-stu-id="90b9e-133">In Microsoft [Windows Communication Foundation (WCF)](../../framework/wcf/whats-wcf.md) parlance, gRPC performance exceeds the speed and efficiency of the highly optimized [NetTCP bindings](/dotnet/api/system.servicemodel.nettcpbinding?view=netframework-4.8).</span></span> <span data-ttu-id="90b9e-134">Microsoft スタックを優先する NetTCP とは異なり、gRPC はクロスプラットフォームです。</span><span class="sxs-lookup"><span data-stu-id="90b9e-134">Unlike NetTCP, which favors the Microsoft stack, gRPC is cross-platform.</span></span>

## <a name="protocol-buffers"></a><span data-ttu-id="90b9e-135">プロトコル バッファー</span><span class="sxs-lookup"><span data-stu-id="90b9e-135">Protocol Buffers</span></span>

<span data-ttu-id="90b9e-136">gRPC は[プロトコル バッファー](https://developers.google.com/protocol-buffers/docs/overview)というオープンソースのテクノロジを採用しています。</span><span class="sxs-lookup"><span data-stu-id="90b9e-136">gRPC embraces an open-source technology called [Protocol Buffers](https://developers.google.com/protocol-buffers/docs/overview).</span></span> <span data-ttu-id="90b9e-137">サービスが相互に送信する構造化メッセージをシリアル化するための、非常に効率的でプラットフォームに依存しないシリアル化形式が用意されています。</span><span class="sxs-lookup"><span data-stu-id="90b9e-137">They provide a highly efficient and platform-neutral serialization format for serializing structured messages that services send to each other.</span></span> <span data-ttu-id="90b9e-138">開発者は、クロスプラットフォームの インターフェイス定義言語 (IDL) を使用して、各マイクロサービスのサービスのサービス コントラクトを定義します。</span><span class="sxs-lookup"><span data-stu-id="90b9e-138">Using a cross-platform Interface Definition Language (IDL), developers define a service contract for each microservice.</span></span> <span data-ttu-id="90b9e-139">コントラクトはテキストベースの `.proto` ファイルとして実装され、各サービスのメソッド、入力、出力が記述されます。</span><span class="sxs-lookup"><span data-stu-id="90b9e-139">The contract, implemented as a text-based `.proto` file, describes the methods, inputs, and outputs for each service.</span></span> <span data-ttu-id="90b9e-140">同じコントラクト ファイルを、異なる開発プラットフォームで構築された gRPC クライアントやサービスに使用することができます。</span><span class="sxs-lookup"><span data-stu-id="90b9e-140">The same contract file can be used for gRPC clients and services built on different development platforms.</span></span>

<span data-ttu-id="90b9e-141">proto ファイルを使用すると、Protobuf コンパイラ `protoc` によってターゲット プラットフォーム用のクライアントとサービスの両方のコードが生成されます。</span><span class="sxs-lookup"><span data-stu-id="90b9e-141">Using the proto file, the Protobuf compiler, `protoc`, generates both client and service code for your target platform.</span></span> <span data-ttu-id="90b9e-142">このコードには次のコンポーネントが含まれています。</span><span class="sxs-lookup"><span data-stu-id="90b9e-142">The code includes the following components:</span></span>

- <span data-ttu-id="90b9e-143">クライアントとサービスによって共有される厳密に型指定されたオブジェクト。メッセージのサービス操作とデータ要素を表します。</span><span class="sxs-lookup"><span data-stu-id="90b9e-143">Strongly typed objects, shared by the client and service, that represent the service operations and data elements for a message.</span></span>
- <span data-ttu-id="90b9e-144">リモート gRPC サービスによって継承および拡張できる、必要なネットワーク プラミングを備えた厳密に型指定された基底クラス。</span><span class="sxs-lookup"><span data-stu-id="90b9e-144">A strongly typed base class with the required network plumbing that the remote gRPC service can inherit and extend.</span></span>
- <span data-ttu-id="90b9e-145">リモート gRPC サービスを呼び出すための必要なプラミングを含むクライアント スタブ。</span><span class="sxs-lookup"><span data-stu-id="90b9e-145">A client stub that contains the required plumbing to invoke the remote gRPC service.</span></span>

<span data-ttu-id="90b9e-146">ランタイムには、各メッセージは標準的な Protobuf 表現としてシリアル化され、クライアントとリモート サービスの間で交換されます。</span><span class="sxs-lookup"><span data-stu-id="90b9e-146">At runtime, each message is serialized as a standard Protobuf representation and exchanged between the client and remote service.</span></span> <span data-ttu-id="90b9e-147">JSON や XML とは異なり、Protobuf メッセージはコンパイルされたバイナリ バイトとしてシリアル化されます。</span><span class="sxs-lookup"><span data-stu-id="90b9e-147">Unlike JSON or XML, Protobuf messages are serialized as compiled binary bytes.</span></span>

<span data-ttu-id="90b9e-148">Microsoft アーキテクチャのサイトから入手できるドキュメント「[WCF 開発者向け gRPC](../grpc-for-wcf-developers/index.md)」には、gRPC とプロトコル バッファーについて詳しく説明されています。</span><span class="sxs-lookup"><span data-stu-id="90b9e-148">The book, [gRPC for WCF Developers](../grpc-for-wcf-developers/index.md), available from the Microsoft Architecture site, provides in-depth coverage of gRPC and Protocol Buffers.</span></span>

## <a name="grpc-support-in-net"></a><span data-ttu-id="90b9e-149">.NET での gRPC のサポート</span><span class="sxs-lookup"><span data-stu-id="90b9e-149">gRPC support in .NET</span></span>

<span data-ttu-id="90b9e-150">gRPC は、.NET Core 3.0 SDK 以降に統合されています。</span><span class="sxs-lookup"><span data-stu-id="90b9e-150">gRPC is integrated into .NET Core 3.0 SDK and later.</span></span> <span data-ttu-id="90b9e-151">次のツールでサポートされています。</span><span class="sxs-lookup"><span data-stu-id="90b9e-151">The following tools support it:</span></span>

- <span data-ttu-id="90b9e-152">Web 開発ワークロードがインストールされた Visual Studio 2019 (バージョン 16.3 以降)。</span><span class="sxs-lookup"><span data-stu-id="90b9e-152">Visual Studio 2019, version 16.3 or later, with the web development workload installed.</span></span>
- <span data-ttu-id="90b9e-153">Visual Studio Code</span><span class="sxs-lookup"><span data-stu-id="90b9e-153">Visual Studio Code</span></span>
- <span data-ttu-id="90b9e-154">dotnet CLI</span><span class="sxs-lookup"><span data-stu-id="90b9e-154">the dotnet CLI</span></span>

<span data-ttu-id="90b9e-155">SDK には、エンドポイントのルート指定、組み込みの IoC、およびログのためのツールが含まれています。</span><span class="sxs-lookup"><span data-stu-id="90b9e-155">The SDK includes tooling for endpoint routing, built-in IoC, and logging.</span></span> <span data-ttu-id="90b9e-156">オープンソースの Kestrel Web サーバーは、HTTP/2 接続をサポートしています。</span><span class="sxs-lookup"><span data-stu-id="90b9e-156">The open-source Kestrel web server supports HTTP/2 connections.</span></span> <span data-ttu-id="90b9e-157">図 4-20 は、gRPC サービスのスケルトン プロジェクトをスキャフォールディングした Visual Studio 2019 テンプレートを示しています。</span><span class="sxs-lookup"><span data-stu-id="90b9e-157">Figure 4-20 shows a Visual Studio 2019 template that scaffolds a skeleton project for a gRPC service.</span></span> <span data-ttu-id="90b9e-158">.NET が Windows、Linux、および macOS を完全にサポートしていることに注目してください。</span><span class="sxs-lookup"><span data-stu-id="90b9e-158">Note how .NET fully supports Windows, Linux, and macOS.</span></span>

![Visual Studio 2019 での gRPC のサポート](./media/visual-studio-2019-grpc-template.png)

<span data-ttu-id="90b9e-160">**図 4-20**</span><span class="sxs-lookup"><span data-stu-id="90b9e-160">**Figure 4-20**.</span></span> <span data-ttu-id="90b9e-161">Visual Studio 2019 での gRPC のサポート</span><span class="sxs-lookup"><span data-stu-id="90b9e-161">gRPC support in Visual Studio 2019</span></span>
  
<span data-ttu-id="90b9e-162">図 4-21 は、Visual Studio 2019 に含まれる組み込みのスキャフォールディングから生成されたスケルトン gRPC サービスを示しています。</span><span class="sxs-lookup"><span data-stu-id="90b9e-162">Figure 4-21 shows the skeleton gRPC service generated from the built-in scaffolding included in Visual Studio 2019.</span></span>  

![Visual Studio 2019 での gRPC プロジェクト](./media/grpc-project.png  )

<span data-ttu-id="90b9e-164">**図 4-21**</span><span class="sxs-lookup"><span data-stu-id="90b9e-164">**Figure 4-21**.</span></span> <span data-ttu-id="90b9e-165">Visual Studio 2019 での gRPC プロジェクト</span><span class="sxs-lookup"><span data-stu-id="90b9e-165">gRPC project in Visual Studio 2019</span></span>

<span data-ttu-id="90b9e-166">前の図の proto 記述ファイルとサービス コードに注目してください。</span><span class="sxs-lookup"><span data-stu-id="90b9e-166">In the previous figure, note the proto description file and service code.</span></span> <span data-ttu-id="90b9e-167">すぐに分かるように、Visual Studio により、Startup クラスと基礎となるプロジェクト ファイルの両方に追加の構成が生成されます。</span><span class="sxs-lookup"><span data-stu-id="90b9e-167">As you'll see shortly, Visual Studio generates additional configuration in both the Startup class and underlying project file.</span></span>

## <a name="grpc-usage"></a><span data-ttu-id="90b9e-168">gRPC の使用</span><span class="sxs-lookup"><span data-stu-id="90b9e-168">gRPC usage</span></span>

<span data-ttu-id="90b9e-169">次のようなシナリオでは、gRPC を優先します。</span><span class="sxs-lookup"><span data-stu-id="90b9e-169">Favor gRPC for the following scenarios:</span></span>

- <span data-ttu-id="90b9e-170">バックエンドのマイクロサービス間の同期通信で、処理を継続するために即時の応答が必要な場合。</span><span class="sxs-lookup"><span data-stu-id="90b9e-170">Synchronous backend microservice-to-microservice communication where an immediate response is required to continue processing.</span></span>
- <span data-ttu-id="90b9e-171">プログラミング プラットフォームが混在するポリグロット環境。</span><span class="sxs-lookup"><span data-stu-id="90b9e-171">Polyglot environments that need to support mixed programming platforms.</span></span>
- <span data-ttu-id="90b9e-172">パフォーマンスが重要な低待機時間および高スループットの通信。</span><span class="sxs-lookup"><span data-stu-id="90b9e-172">Low latency and high throughput communication where performance is critical.</span></span>
- <span data-ttu-id="90b9e-173">ポイントツーポイントのリアルタイム通信。gRPC により、ポーリングを行わずにリアルタイムでメッセージをプッシュすることができ、双方向のストリーミングにも優れた対応をしています。</span><span class="sxs-lookup"><span data-stu-id="90b9e-173">Point-to-point real-time communication - gRPC can push messages in real time without polling and has excellent support for bi-directional streaming.</span></span>
- <span data-ttu-id="90b9e-174">ネットワークに制約のある環境。バイナリ gRPC メッセージは、同等のテキストベースの JSON メッセージよりも常に小さくなります。</span><span class="sxs-lookup"><span data-stu-id="90b9e-174">Network constrained environments – binary gRPC messages are always smaller than an equivalent text-based JSON message.</span></span>

<span data-ttu-id="90b9e-175">この記事の執筆時点では、gRPC は主にバックエンド サービスで使用されています。</span><span class="sxs-lookup"><span data-stu-id="90b9e-175">At the time, of this writing, gRPC is primarily used with backend services.</span></span> <span data-ttu-id="90b9e-176">最新のブラウザーには、フロントエンドの gRPC クライアントをサポートするために必要なレベルの HTTP/2 制御機能がありません。</span><span class="sxs-lookup"><span data-stu-id="90b9e-176">Modern browsers can't provide the level of HTTP/2 control required to support a front-end gRPC client.</span></span> <span data-ttu-id="90b9e-177">とはいえ、JavaScript や Blazor WebAssembly テクノロジを使用して構築されたブラウザーベースのアプリからの gRPC 通信を可能にする [gRPC-Web with .NET](https://devblogs.microsoft.com/aspnet/grpc-web-for-net-now-available/) がサポートされています。</span><span class="sxs-lookup"><span data-stu-id="90b9e-177">That said, there's support for [gRPC-Web with .NET](https://devblogs.microsoft.com/aspnet/grpc-web-for-net-now-available/) that enables gRPC communication from browser-based apps built with JavaScript or Blazor WebAssembly technologies.</span></span> <span data-ttu-id="90b9e-178">[gRPC-Web](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md) を使用すると、ASP.NET Core gRPC アプリがブラウザー アプリで gRPC 機能をサポートできるようになります。</span><span class="sxs-lookup"><span data-stu-id="90b9e-178">[gRPC-Web](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md) enables an ASP.NET Core gRPC app to support gRPC features in browser apps:</span></span>

- <span data-ttu-id="90b9e-179">厳密に型指定されたコード生成クライアント</span><span class="sxs-lookup"><span data-stu-id="90b9e-179">Strongly typed, code-generated clients</span></span>
- <span data-ttu-id="90b9e-180">コンパクトな Protobuf メッセージ</span><span class="sxs-lookup"><span data-stu-id="90b9e-180">Compact Protobuf messages</span></span>
- <span data-ttu-id="90b9e-181">サーバー ストリーミング。</span><span class="sxs-lookup"><span data-stu-id="90b9e-181">Server streaming</span></span>

## <a name="grpc-implementation"></a><span data-ttu-id="90b9e-182">gRPC の実装</span><span class="sxs-lookup"><span data-stu-id="90b9e-182">gRPC implementation</span></span>

<span data-ttu-id="90b9e-183">Microsoft のマイクロサービス リファレンス アーキテクチャ [eShop on Containers](https://github.com/dotnet-architecture/eShopOnContainers) は、.NET アプリケーションに gRPC サービスを実装する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="90b9e-183">The microservice reference architecture, [eShop on Containers](https://github.com/dotnet-architecture/eShopOnContainers), from Microsoft, shows how to implement gRPC services in .NET applications.</span></span> <span data-ttu-id="90b9e-184">図 4-22 は、バックエンド アーキテクチャを示しています。</span><span class="sxs-lookup"><span data-stu-id="90b9e-184">Figure 4-22 presents the back-end architecture.</span></span>

![eShop on Containers のバックエンド アーキテクチャ](./media/eshop-with-aggregators.png)

<span data-ttu-id="90b9e-186">**図 4-22**</span><span class="sxs-lookup"><span data-stu-id="90b9e-186">**Figure 4-22**.</span></span> <span data-ttu-id="90b9e-187">eShop on Containers のバックエンド アーキテクチャ</span><span class="sxs-lookup"><span data-stu-id="90b9e-187">Backend architecture for eShop on Containers</span></span>

<span data-ttu-id="90b9e-188">前の図では、eShop が、複数の API ゲートウェイを公開することより、[Backend for Frontends パターン](/azure/architecture/patterns/backends-for-frontends) (BFF) を採用していることに注目してください。</span><span class="sxs-lookup"><span data-stu-id="90b9e-188">In the previous figure, note how eShop embraces the [Backend for Frontends pattern](/azure/architecture/patterns/backends-for-frontends) (BFF) by exposing multiple API gateways.</span></span> <span data-ttu-id="90b9e-189">BFF パターンについては、この章の前半で説明しました。</span><span class="sxs-lookup"><span data-stu-id="90b9e-189">We discussed the BFF pattern earlier in this chapter.</span></span> <span data-ttu-id="90b9e-190">Web-Shopping API Gateway とバックエンドのショッピング マイクロサービスの間に位置するアグリゲーター マイクロサービス (灰色) に注目してください。</span><span class="sxs-lookup"><span data-stu-id="90b9e-190">Pay close attention to the Aggregator microservice (in gray) that sits between the Web-Shopping API Gateway and backend Shopping microservices.</span></span> <span data-ttu-id="90b9e-191">アグリゲーターによって、クライアントから 1 つの要求が受信され、それがさまざまなマイクロサービスにディスパッチされ、結果が集計され、要求元のクライアントに返送されます。</span><span class="sxs-lookup"><span data-stu-id="90b9e-191">The Aggregator receives a single request from a client, dispatches it to various microservices, aggregates the results, and sends them back to the requesting client.</span></span> <span data-ttu-id="90b9e-192">このような操作には、通常、即時応答を生成するために同期通信が必要です。</span><span class="sxs-lookup"><span data-stu-id="90b9e-192">Such operations typically require synchronous communication as to produce an immediate response.</span></span> <span data-ttu-id="90b9e-193">eShop では、図 4-23 に示すように、アグリゲーターからのバックエンド呼び出しは、gRPC を使用して実行されます。</span><span class="sxs-lookup"><span data-stu-id="90b9e-193">In eShop, backend calls from the Aggregator are performed using gRPC as shown in Figure 4-23.</span></span>

![コンテナー上の eShop の gRPC](./media/grpc-implementation.png)

<span data-ttu-id="90b9e-195">**図 4-23**.</span><span class="sxs-lookup"><span data-stu-id="90b9e-195">**Figure 4-23**.</span></span> <span data-ttu-id="90b9e-196">コンテナー上の eShop の gRPC</span><span class="sxs-lookup"><span data-stu-id="90b9e-196">gRPC in eShop on Containers</span></span>

<span data-ttu-id="90b9e-197">gRPC 通信には、クライアントとサーバーの両方のコンポーネントが必要です。</span><span class="sxs-lookup"><span data-stu-id="90b9e-197">gRPC communication requires both client and server components.</span></span> <span data-ttu-id="90b9e-198">前の図では、ショッピング アグリゲーターにどのように gRPC クライアントが実装されているかに注目してください。</span><span class="sxs-lookup"><span data-stu-id="90b9e-198">In the previous figure, note how the Shopping Aggregator implements a gRPC client.</span></span> <span data-ttu-id="90b9e-199">クライアント側では、バックエンド マイクロサービスへの同期 gRPC 呼び出し (赤色) が行われます。このそれぞれに gRPC サーバーが実装されています。</span><span class="sxs-lookup"><span data-stu-id="90b9e-199">The client makes synchronous gRPC calls (in red) to backend microservices, each of which implement a gRPC server.</span></span> <span data-ttu-id="90b9e-200">クライアントとサーバーの両方に、.NET SDK の組み込みの gRPC プラミングが利用されます。</span><span class="sxs-lookup"><span data-stu-id="90b9e-200">Both the client and server take advantage of the built-in gRPC plumbing from the .NET SDK.</span></span> <span data-ttu-id="90b9e-201">クライアント側の "*スタブ*" には、リモート gRPC 呼び出しを起動するためのプラミングが用意されています。</span><span class="sxs-lookup"><span data-stu-id="90b9e-201">Client-side *stubs* provide the plumbing to invoke remote gRPC calls.</span></span> <span data-ttu-id="90b9e-202">サーバー側コンポーネントには、カスタム サービス クラスが継承して使用できる gRPC プラミングが用意されています。</span><span class="sxs-lookup"><span data-stu-id="90b9e-202">Server-side components provide gRPC plumbing that custom service classes can inherit and consume.</span></span>

<span data-ttu-id="90b9e-203">RESTful API と gRPC 通信の両方を公開しているマイクロサービスでは、トラフィックを管理するために複数のエンドポイントが必要です。</span><span class="sxs-lookup"><span data-stu-id="90b9e-203">Microservices that expose both a RESTful API and gRPC communication require multiple endpoints to manage traffic.</span></span> <span data-ttu-id="90b9e-204">RESTful 呼び出しのために HTTP トラフィックをリッスンするエンドポイントと、gRPC 呼び出しのための別のエンドポイントを開くことになります。</span><span class="sxs-lookup"><span data-stu-id="90b9e-204">You would open an endpoint that listens for HTTP traffic for the RESTful calls and another for gRPC calls.</span></span> <span data-ttu-id="90b9e-205">gRPC エンドポイントは、gRPC 通信に必要な HTTP/2 プロトコル用に構成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="90b9e-205">The gRPC endpoint must be configured for the HTTP/2 protocol that is required for gRPC communication.</span></span>

<span data-ttu-id="90b9e-206">Microsoft では非同期通信パターンでマイクロサービスを切り離すように努めていますが、一部の操作には直接呼び出しが必要です。</span><span class="sxs-lookup"><span data-stu-id="90b9e-206">While we strive to decouple microservices with asynchronous communication patterns, some operations require direct calls.</span></span> <span data-ttu-id="90b9e-207">マイクロサービス間の直接的な同期通信には、gRPC を最優先の選択肢にすべきです。</span><span class="sxs-lookup"><span data-stu-id="90b9e-207">gRPC should be the primary choice for direct synchronous communication between microservices.</span></span> <span data-ttu-id="90b9e-208">HTTP/2 とプロトコル バッファーをベースにしたハイ パフォーマンスな通信プロトコルを採用しているため、最適な選択肢です。</span><span class="sxs-lookup"><span data-stu-id="90b9e-208">Its high-performance communication protocol, based on HTTP/2 and protocol buffers, make it a perfect choice.</span></span>

## <a name="looking-ahead"></a><span data-ttu-id="90b9e-209">今後の予定</span><span class="sxs-lookup"><span data-stu-id="90b9e-209">Looking ahead</span></span>

<span data-ttu-id="90b9e-210">クラウドネイティブ システムのために、今後も gRPC の勢いを増していくでしょう。</span><span class="sxs-lookup"><span data-stu-id="90b9e-210">Looking ahead, gRPC will continue to gain traction for cloud-native systems.</span></span> <span data-ttu-id="90b9e-211">パフォーマンス上の利点と開発の容易さは魅力的です。</span><span class="sxs-lookup"><span data-stu-id="90b9e-211">The performance benefits and ease of development are compelling.</span></span> <span data-ttu-id="90b9e-212">ただし、REST は長い間残る可能性があります。</span><span class="sxs-lookup"><span data-stu-id="90b9e-212">However, REST will likely be around for a long time.</span></span> <span data-ttu-id="90b9e-213">これは公開されている API と後方互換性の観点から優れています。</span><span class="sxs-lookup"><span data-stu-id="90b9e-213">It excels for publicly exposed APIs and for backward compatibility reasons.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="90b9e-214">[前へ](service-to-service-communication.md)
>[次へ](service-mesh-communication-infrastructure.md)</span><span class="sxs-lookup"><span data-stu-id="90b9e-214">[Previous](service-to-service-communication.md)
[Next](service-mesh-communication-infrastructure.md)</span></span>
