---
title: 分散データ
description: モノリシック アプリケーションとクラウドネイティブ アプリケーションのデータ ストレージを比較します。
author: robvet
ms.date: 01/19/2021
ms.openlocfilehash: c83ac5dc973ff4c7a4626746472a74cfc6bf54bb
ms.sourcegitcommit: f2ab02d9a780819ca2e5310bbcf5cfe5b7993041
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/03/2021
ms.locfileid: "99505870"
---
# <a name="distributed-data"></a><span data-ttu-id="bdb63-103">分散データ</span><span class="sxs-lookup"><span data-stu-id="bdb63-103">Distributed data</span></span>

<span data-ttu-id="bdb63-104">本書で見てきたように、クラウドネイティブ アプローチによって、アプリケーションの設計、デプロイ、管理の方法が変わります。</span><span class="sxs-lookup"><span data-stu-id="bdb63-104">As we've seen throughout this book, a cloud-native approach changes the way you design, deploy, and manage applications.</span></span> <span data-ttu-id="bdb63-105">また、データの管理や格納の方法も変わります。</span><span class="sxs-lookup"><span data-stu-id="bdb63-105">It also changes the way you manage and store data.</span></span>

<span data-ttu-id="bdb63-106">図 5-1 は、その違いを比較したものです。</span><span class="sxs-lookup"><span data-stu-id="bdb63-106">Figure 5-1 contrasts the differences.</span></span>

![クラウドネイティブ アプリケーションのデータ ストレージ](./media/distributed-data.png)

<span data-ttu-id="bdb63-108">**図 5-1**.</span><span class="sxs-lookup"><span data-stu-id="bdb63-108">**Figure 5-1**.</span></span> <span data-ttu-id="bdb63-109">クラウドネイティブ アプリケーションでのデータ管理</span><span class="sxs-lookup"><span data-stu-id="bdb63-109">Data management in cloud-native applications</span></span>

<span data-ttu-id="bdb63-110">経験豊富な開発者であれば、図 5-1 の左側のアーキテクチャをすぐに理解できるでしょう。</span><span class="sxs-lookup"><span data-stu-id="bdb63-110">Experienced developers will easily recognize the architecture on the left-side of figure 5-1.</span></span> <span data-ttu-id="bdb63-111">この "*モノリシック アプリケーション*" では、ビジネス サービス コンポーネントが共有サービス レベルに併置され、1 つのリレーショナル データベースからデータが共有されています。</span><span class="sxs-lookup"><span data-stu-id="bdb63-111">In this *monolithic application*, business service components collocate together in a shared services tier, sharing data from a single relational database.</span></span>

<span data-ttu-id="bdb63-112">データベースを 1 つにすると、多くの点でデータ管理をシンプルに保つことができます。</span><span class="sxs-lookup"><span data-stu-id="bdb63-112">In many ways, a single database keeps data management simple.</span></span> <span data-ttu-id="bdb63-113">複数のテーブルにまたがるデータのクエリも簡単です。</span><span class="sxs-lookup"><span data-stu-id="bdb63-113">Querying data across multiple tables is straightforward.</span></span> <span data-ttu-id="bdb63-114">データを変更すると、一緒に更新されるか、すべてがロールバックされます。</span><span class="sxs-lookup"><span data-stu-id="bdb63-114">Changes to data update together or they all rollback.</span></span> <span data-ttu-id="bdb63-115">[ACID トランザクション](/windows/desktop/cossdk/acid-properties)により、強力な即時の整合性が保証されます。</span><span class="sxs-lookup"><span data-stu-id="bdb63-115">[ACID transactions](/windows/desktop/cossdk/acid-properties) guarantee strong and immediate consistency.</span></span>

<span data-ttu-id="bdb63-116">クラウドネイティブの設計では、異なるアプローチを採用します。</span><span class="sxs-lookup"><span data-stu-id="bdb63-116">Designing for cloud-native, we take a different approach.</span></span> <span data-ttu-id="bdb63-117">図 5-1 の右側では、ビジネス機能が小さな独立したマイクロサービスにどのように分離されているかに注目してください。</span><span class="sxs-lookup"><span data-stu-id="bdb63-117">On the right-side of Figure 5-1, note how business functionality segregates into small, independent microservices.</span></span> <span data-ttu-id="bdb63-118">各マイクロサービスにより、特定のビジネス機能と独自のデータがカプセル化されています。</span><span class="sxs-lookup"><span data-stu-id="bdb63-118">Each microservice encapsulates a specific business capability and its own data.</span></span> <span data-ttu-id="bdb63-119">モノリシック データベースは、それぞれがマイクロサービスと連携する多数の小さなデータベースを持つ分散データ モデルに分解されます。</span><span class="sxs-lookup"><span data-stu-id="bdb63-119">The monolithic database decomposes into a distributed data model with many smaller databases, each aligning with a microservice.</span></span> <span data-ttu-id="bdb63-120">このようにして、"*マイクロサービスごとのデータベース*" を公開する設計が完成します。</span><span class="sxs-lookup"><span data-stu-id="bdb63-120">When the smoke clears, we emerge with a design that exposes a *database per microservice*.</span></span>

## <a name="database-per-microservice-why"></a><span data-ttu-id="bdb63-121">なぜマイクロサービスごとのデータベースなのでしょうか。</span><span class="sxs-lookup"><span data-stu-id="bdb63-121">Database-per-microservice, why?</span></span>

<span data-ttu-id="bdb63-122">このマイクロサービスごとのデータベースは、特に急速に進化し、大規模なスケールをサポートしなければならないシステムに多くのメリットがあります。</span><span class="sxs-lookup"><span data-stu-id="bdb63-122">This database per microservice provides many benefits, especially for systems that must evolve rapidly and support massive scale.</span></span> <span data-ttu-id="bdb63-123">このモデルでは次のようになります。</span><span class="sxs-lookup"><span data-stu-id="bdb63-123">With this model...</span></span>

- <span data-ttu-id="bdb63-124">ドメイン データはサービス内にカプセル化されます</span><span class="sxs-lookup"><span data-stu-id="bdb63-124">Domain data is encapsulated within the service</span></span>
- <span data-ttu-id="bdb63-125">データ スキーマは、他のサービスに直接影響することなく進化できます</span><span class="sxs-lookup"><span data-stu-id="bdb63-125">Data schema can evolve without directly impacting other services</span></span>
- <span data-ttu-id="bdb63-126">各データ ストアは独立してスケーリングできます</span><span class="sxs-lookup"><span data-stu-id="bdb63-126">Each data store can independently scale</span></span>
- <span data-ttu-id="bdb63-127">あるサービスのデータ ストアの障害は、他のサービスには直接影響しません</span><span class="sxs-lookup"><span data-stu-id="bdb63-127">A data store failure in one service won't directly impact other services</span></span>

<span data-ttu-id="bdb63-128">データを分離することで、マイクロサービスごとに、ワークロード、ストレージのニーズ、読み取りおよび書き込みパターンに最適化されたデータ ストアの種類を実装できます。</span><span class="sxs-lookup"><span data-stu-id="bdb63-128">Segregating data also enables each microservice to implement the data store type that is best optimized for its workload, storage needs, and read/write patterns.</span></span> <span data-ttu-id="bdb63-129">選択肢には、リレーショナル、ドキュメント、キー値、グラフベースのデータ ストアがあります。</span><span class="sxs-lookup"><span data-stu-id="bdb63-129">Choices include relational, document, key-value, and even graph-based data stores.</span></span>

<span data-ttu-id="bdb63-130">図 5-2 は、クラウドネイティブ システムにおけるポリグロットな永続化の原則を示しています。</span><span class="sxs-lookup"><span data-stu-id="bdb63-130">Figure 5-2 presents the principle of polyglot persistence in a cloud-native system.</span></span>

![ポリグロットなデータ永続化](./media/polyglot-data-persistence.png)

<span data-ttu-id="bdb63-132">**図 5-2**</span><span class="sxs-lookup"><span data-stu-id="bdb63-132">**Figure 5-2**.</span></span> <span data-ttu-id="bdb63-133">ポリグロットなデータ永続化</span><span class="sxs-lookup"><span data-stu-id="bdb63-133">Polyglot data persistence</span></span>

<span data-ttu-id="bdb63-134">前の図では、各マイクロサービスが異なる種類のデータ ストアをサポートしていることに注目してください。</span><span class="sxs-lookup"><span data-stu-id="bdb63-134">Note in the previous figure how each microservice supports a different type of data store.</span></span>

- <span data-ttu-id="bdb63-135">製品カタログ マイクロサービスには、基礎となるデータの豊富なリレーショナル構造に対応するため、リレーショナル データベースが使用されています。</span><span class="sxs-lookup"><span data-stu-id="bdb63-135">The product catalog microservice consumes a relational database to accommodate the rich relational structure of its underlying data.</span></span>
- <span data-ttu-id="bdb63-136">ショッピング カート マイクロサービスには、シンプルなキー値データ ストアをサポートする分散キャッシュが使用されています。</span><span class="sxs-lookup"><span data-stu-id="bdb63-136">The shopping cart microservice consumes a distributed cache that supports its simple, key-value data store.</span></span>
- <span data-ttu-id="bdb63-137">注文マイクロサービスには、大量の読み取り操作に対応するために、書き込み操作用の NoSql ドキュメント データベースと、高度に非正規化されたキー/値ストアの両方が使用されています。</span><span class="sxs-lookup"><span data-stu-id="bdb63-137">The ordering microservice consumes both a NoSql document database for write operations along with a highly denormalized key/value store to accommodate high-volumes of read operations.</span></span>
  
<span data-ttu-id="bdb63-138">複雑なデータを扱うマイクロサービスにはリレーショナル データベースが適していますが、NoSQL データベースは非常に人気があります。</span><span class="sxs-lookup"><span data-stu-id="bdb63-138">While relational databases remain relevant for microservices with complex data, NoSQL databases have gained considerable popularity.</span></span> <span data-ttu-id="bdb63-139">これには大規模なスケールと高い可用性が備わっています。</span><span class="sxs-lookup"><span data-stu-id="bdb63-139">They provide massive scale and high availability.</span></span> <span data-ttu-id="bdb63-140">そのスキーマレスという性質により、開発者は、変更にコストも時間もかかる型指定されたデータ クラスや ORM などのアーキテクチャから解放されます。</span><span class="sxs-lookup"><span data-stu-id="bdb63-140">Their schemaless nature allows developers to move away from an architecture of typed data classes and ORMs that make change expensive and time-consuming.</span></span> <span data-ttu-id="bdb63-141">NoSQL データベースについては、この章で後述します。</span><span class="sxs-lookup"><span data-stu-id="bdb63-141">We cover NoSQL databases later in this chapter.</span></span>

 <span data-ttu-id="bdb63-142">データを個別のマイクロサービスにカプセル化することで、機敏性、パフォーマンス、スケーラビリティを向上させることができますが、同時に多くの課題もあります。</span><span class="sxs-lookup"><span data-stu-id="bdb63-142">While encapsulating  data into separate microservices can increase agility, performance, and scalability, it also presents many challenges.</span></span> <span data-ttu-id="bdb63-143">次のセクションでは、これらの課題と、課題を克服するためのパターンと手法について説明します。</span><span class="sxs-lookup"><span data-stu-id="bdb63-143">In the next section, we discuss these challenges along with patterns and practices to help overcome them.</span></span>  

## <a name="cross-service-queries"></a><span data-ttu-id="bdb63-144">サービスをまたぐクエリ</span><span class="sxs-lookup"><span data-stu-id="bdb63-144">Cross-service queries</span></span>

<span data-ttu-id="bdb63-145">マイクロサービスは独立しており、在庫、出荷、注文などの特定の機能に特化していますが、他のマイクロサービスとの統合が必要になることがよくあります。</span><span class="sxs-lookup"><span data-stu-id="bdb63-145">While microservices are independent and focus on specific functional capabilities, like inventory, shipping, or ordering, they frequently require integration with other microservices.</span></span> <span data-ttu-id="bdb63-146">多くの場合、統合には、あるマイクロサービスが他のマイクロサービスに対してデータの "*クエリを実行する処理*" を伴います。</span><span class="sxs-lookup"><span data-stu-id="bdb63-146">Often the integration involves one microservice *querying* another for data.</span></span> <span data-ttu-id="bdb63-147">図 5-3 は、このシナリオを示しています。</span><span class="sxs-lookup"><span data-stu-id="bdb63-147">Figure 5-3 shows the scenario.</span></span>

![マイクロサービスをまたがるクエリ](./media/cross-service-query.png)

<span data-ttu-id="bdb63-149">**図 5-3**</span><span class="sxs-lookup"><span data-stu-id="bdb63-149">**Figure 5-3**.</span></span> <span data-ttu-id="bdb63-150">マイクロサービスをまたがるクエリ</span><span class="sxs-lookup"><span data-stu-id="bdb63-150">Querying across microservices</span></span>

<span data-ttu-id="bdb63-151">前の図は、ユーザーの買い物かごに項目を追加する買い物かごマイクロサービスを示しています。</span><span class="sxs-lookup"><span data-stu-id="bdb63-151">In the preceding figure, we see a shopping basket microservice that adds an item to a user's shopping basket.</span></span> <span data-ttu-id="bdb63-152">このマイクロサービスのデータ ストアには、バスケットと品目のデータが含まれていますが、製品や価格設定のデータは保持されていません。</span><span class="sxs-lookup"><span data-stu-id="bdb63-152">While the data store for this microservice contains basket and line item data, it doesn't maintain product or pricing data.</span></span> <span data-ttu-id="bdb63-153">代わりに、これらのデータ項目はカタログと価格設定のマイクロサービスによって所有されています。</span><span class="sxs-lookup"><span data-stu-id="bdb63-153">Instead, those data items are owned by the catalog and pricing microservices.</span></span> <span data-ttu-id="bdb63-154">この側面が問題となります。</span><span class="sxs-lookup"><span data-stu-id="bdb63-154">This aspect presents a problem.</span></span> <span data-ttu-id="bdb63-155">どうすれば買い物かごマイクロサービスからユーザーの買い物かごに製品を追加する際に、そのデータベース内に製品や価格設定のデータがない場合はどうすればよいでしょうか。</span><span class="sxs-lookup"><span data-stu-id="bdb63-155">How can the shopping basket microservice add a product to the user's shopping basket when it doesn't have product nor pricing data in its database?</span></span>

<span data-ttu-id="bdb63-156">第 4 章で説明されている選択肢の 1 つは、買い物かごからカタログと価格設定のマイクロサービスに対する[直接 HTTP 呼び出し](service-to-service-communication.md#queries)です。</span><span class="sxs-lookup"><span data-stu-id="bdb63-156">One option discussed in Chapter 4 is a [direct HTTP call](service-to-service-communication.md#queries) from the shopping basket to the catalog and pricing microservices.</span></span> <span data-ttu-id="bdb63-157">ただし、第 4 章では、同期 HTTP 呼び出しを使用すると、複数のマイクロサービスがまとめて "*カップル*" にされ、マイクロサービスの自律性が低下し、アーキテクチャ上の利点を減ると説明しました。</span><span class="sxs-lookup"><span data-stu-id="bdb63-157">However, in chapter 4, we said synchronous HTTP calls *couple* microservices together, reducing their autonomy and diminishing their architectural benefits.</span></span>

<span data-ttu-id="bdb63-158">また、サービスごとに受信と送信のキューを分けて、要求と応答のパターンを実装することもできます。</span><span class="sxs-lookup"><span data-stu-id="bdb63-158">We could also implement a request-reply pattern with separate inbound and outbound queues for each service.</span></span> <span data-ttu-id="bdb63-159">ただし、このパターンは複雑であり、要求と応答のメッセージを関連付けるためのプラミングが必要になります。</span><span class="sxs-lookup"><span data-stu-id="bdb63-159">However, this pattern is complicated and requires plumbing to correlate request and response messages.</span></span>
<span data-ttu-id="bdb63-160">バックエンド マイクロサービスの呼び出しは分離されますが、呼び出し元のサービスは、呼び出しが完了するまで同期的に待機する必要があります。</span><span class="sxs-lookup"><span data-stu-id="bdb63-160">While it does decouple the backend microservice calls, the calling service must still synchronously wait for the call to complete.</span></span> <span data-ttu-id="bdb63-161">ネットワークの輻輳、一時的な障害、マイクロサービスの過負荷により、処理が長引いたり、失敗したりすることがあります。</span><span class="sxs-lookup"><span data-stu-id="bdb63-161">Network congestion, transient faults, or an overloaded microservice and can result in long-running and even failed operations.</span></span>

<span data-ttu-id="bdb63-162">その代わりに、サービスをまたぐサービスの依存関係を取り除くためのパターンとして広く受け入れられているのは、図 5-4 に示す[具体化されたビュー パターン](/azure/architecture/patterns/materialized-view)です。</span><span class="sxs-lookup"><span data-stu-id="bdb63-162">Instead, a widely accepted pattern for removing cross-service dependencies is the [Materialized View Pattern](/azure/architecture/patterns/materialized-view), shown in Figure 5-4.</span></span>

![具体化されたビュー パターン](./media/materialized-view-pattern.png)

<span data-ttu-id="bdb63-164">**図 5-4**</span><span class="sxs-lookup"><span data-stu-id="bdb63-164">**Figure 5-4**.</span></span> <span data-ttu-id="bdb63-165">具体化されたビュー パターン</span><span class="sxs-lookup"><span data-stu-id="bdb63-165">Materialized View Pattern</span></span>

<span data-ttu-id="bdb63-166">このパターンでは、ローカル データ テーブル ("*読み取りモデル*" と呼ばれます) を買い物かごサービスに配置します。</span><span class="sxs-lookup"><span data-stu-id="bdb63-166">With this pattern, you place a local data table (known as a *read model*) in the shopping basket service.</span></span> <span data-ttu-id="bdb63-167">このテーブルには、製品と価格設定のマイクロサービスの必要なデータの非正規化されたコピーが含まれています。</span><span class="sxs-lookup"><span data-stu-id="bdb63-167">This table contains a denormalized copy of the data needed from the product and pricing microservices.</span></span> <span data-ttu-id="bdb63-168">データを買い物かごマイクロサービスに直接コピーすることで、コストのかかるサービスをまたぐ呼び出しが不要になります。</span><span class="sxs-lookup"><span data-stu-id="bdb63-168">Copying the data directly into the shopping basket microservice eliminates the need for expensive cross-service calls.</span></span> <span data-ttu-id="bdb63-169">データがサービスのローカルにあるので、サービスの応答時間と信頼性が向上します。</span><span class="sxs-lookup"><span data-stu-id="bdb63-169">With the data local to the service, you improve the service's response time and reliability.</span></span> <span data-ttu-id="bdb63-170">さらに、データの独自のコピーがあるので、買い物かごサービスの回復性が高まります。</span><span class="sxs-lookup"><span data-stu-id="bdb63-170">Additionally, having its own copy of the data makes the shopping basket service more resilient.</span></span> <span data-ttu-id="bdb63-171">万が一、カタログ サービスが使用できなくなった場合でも、買い物かごサービスには直接影響しません。</span><span class="sxs-lookup"><span data-stu-id="bdb63-171">If the catalog service should become unavailable, it wouldn't directly impact the shopping basket service.</span></span> <span data-ttu-id="bdb63-172">独自のストアのデータを使用して、買い物かごの運用を続けることができます。</span><span class="sxs-lookup"><span data-stu-id="bdb63-172">The shopping basket can continue operating with the data from its own store.</span></span>

<span data-ttu-id="bdb63-173">このアプローチの問題点は、システム内に重複するデータが存在することです。</span><span class="sxs-lookup"><span data-stu-id="bdb63-173">The catch with this approach is that you now have duplicate data in your system.</span></span> <span data-ttu-id="bdb63-174">ただし、"*戦略的に*" クラウドネイティブ システムでデータを重複させることは確立された手法であり、アンチパターンや悪い慣習とは考えられていません。</span><span class="sxs-lookup"><span data-stu-id="bdb63-174">However, *strategically* duplicating data in cloud-native systems is an established practice and not considered an anti-pattern, or bad practice.</span></span> <span data-ttu-id="bdb63-175">"*1 つのサービスのみ*" がデータ セットを所有し、それに対する権限を持つことができることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="bdb63-175">Keep in mind that *one and only one service* can own a data set and have authority over it.</span></span> <span data-ttu-id="bdb63-176">レコードのシステムが更新されたら、読み取りモデルを同期する必要があります。</span><span class="sxs-lookup"><span data-stu-id="bdb63-176">You'll need to synchronize the read models when the system of record is updated.</span></span> <span data-ttu-id="bdb63-177">通常、同期は、図 5.4 に示すように[発行とサブスクライブ パターン](service-to-service-communication.md#events)を使用した非同期メッセージングによって実装されます。</span><span class="sxs-lookup"><span data-stu-id="bdb63-177">Synchronization is typically implemented via asynchronous messaging with a [publish/subscribe pattern](service-to-service-communication.md#events), as shown in Figure 5.4.</span></span>

## <a name="distributed-transactions"></a><span data-ttu-id="bdb63-178">分散トランザクション</span><span class="sxs-lookup"><span data-stu-id="bdb63-178">Distributed transactions</span></span>

<span data-ttu-id="bdb63-179">マイクロサービスをまたいでデータのクエリを実行することは困難ですが、複数のマイクロサービスをまたぐトランザクションを実装することはさらに複雑です。</span><span class="sxs-lookup"><span data-stu-id="bdb63-179">While querying data across microservices is difficult, implementing a transaction across several microservices is even more complex.</span></span> <span data-ttu-id="bdb63-180">異なるマイクロサービスの独立したデータ ソース全体でデータの整合性を維持する場合に固有の課題を軽視することはできません。</span><span class="sxs-lookup"><span data-stu-id="bdb63-180">The inherent challenge of maintaining data consistency across independent data sources in different microservices can't be understated.</span></span> <span data-ttu-id="bdb63-181">クラウドネイティブ アプリケーションに分散トランザクションがないということは、分散トランザクションをプログラムで管理する必要があることを意味します。</span><span class="sxs-lookup"><span data-stu-id="bdb63-181">The lack of distributed transactions in cloud-native applications means that you must manage distributed transactions programmatically.</span></span> <span data-ttu-id="bdb63-182">"*即時の整合性*" の世界から、"*最終的な整合性*" の世界へと引っ越すことになります。</span><span class="sxs-lookup"><span data-stu-id="bdb63-182">You move from a world of *immediate consistency* to that of *eventual consistency*.</span></span>

<span data-ttu-id="bdb63-183">図 5-5 は、この問題を示しています。</span><span class="sxs-lookup"><span data-stu-id="bdb63-183">Figure 5-5 shows the problem.</span></span>

![saga パターンのトランザクション](./media/saga-transaction-operation.png)

<span data-ttu-id="bdb63-185">**図 5-5**</span><span class="sxs-lookup"><span data-stu-id="bdb63-185">**Figure 5-5**.</span></span> <span data-ttu-id="bdb63-186">マイクロサービスをまたぐトランザクションの実装</span><span class="sxs-lookup"><span data-stu-id="bdb63-186">Implementing a transaction across microservices</span></span>

<span data-ttu-id="bdb63-187">前の図では、5 つの独立したマイクロサービスが、注文を作成する分散トランザクションに参加しています。</span><span class="sxs-lookup"><span data-stu-id="bdb63-187">In the preceding figure, five independent microservices participate in a distributed transaction that creates an order.</span></span> <span data-ttu-id="bdb63-188">各マイクロサービスには独自のデータ ストアが維持され、そのストアのローカル トランザクションが実装されています。</span><span class="sxs-lookup"><span data-stu-id="bdb63-188">Each microservice maintains its own data store and implements a local transaction for its store.</span></span> <span data-ttu-id="bdb63-189">注文を作成するには、個々のマイクロサービスの "*それぞれ*" のローカル トランザクションが成功する必要があります。それ以外の場合は、"*すべて*" が中止され、操作がロールバックされる必要があります。</span><span class="sxs-lookup"><span data-stu-id="bdb63-189">To create the order, the local transaction for *each* individual microservice must succeed, or *all* must abort and roll back the operation.</span></span> <span data-ttu-id="bdb63-190">各マイクロサービスの内部では組み込みのトランザクションがサポートされていますが、データの整合性を維持するための 5 つのサービスすべてにまたがる分散トランザクションはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="bdb63-190">While built-in transactional support is available inside each of the microservices, there's no support for a distributed transaction that would span across all five services to keep data consistent.</span></span>

<span data-ttu-id="bdb63-191">代わりに、この分散トランザクションを "*プログラムで*" 構築する必要があります。</span><span class="sxs-lookup"><span data-stu-id="bdb63-191">Instead, you must construct this distributed transaction *programmatically*.</span></span>

<span data-ttu-id="bdb63-192">分散トランザクションのサポートを追加するための一般的なパターンは Saga パターンです。</span><span class="sxs-lookup"><span data-stu-id="bdb63-192">A popular pattern for adding distributed transactional support is the Saga pattern.</span></span> <span data-ttu-id="bdb63-193">これを実装するには、ローカル トランザクションをプログラムでグループ化し、1 つずつ順番に呼び出します。</span><span class="sxs-lookup"><span data-stu-id="bdb63-193">It's implemented by grouping local transactions together programmatically and sequentially invoking each one.</span></span> <span data-ttu-id="bdb63-194">ローカル トランザクションのいずれかが失敗すると、Saga により操作は中止され、一連の[補償トランザクション](/azure/architecture/patterns/compensating-transaction)が呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="bdb63-194">If any of the local transactions fail, the Saga aborts the operation and invokes a set of [compensating transactions](/azure/architecture/patterns/compensating-transaction).</span></span> <span data-ttu-id="bdb63-195">補償トランザクションは、先行するローカル トランザクションによって行われた変更を元に戻し、データの整合性を復元するものです。</span><span class="sxs-lookup"><span data-stu-id="bdb63-195">The compensating transactions undo the changes made by the preceding local transactions and restore data consistency.</span></span> <span data-ttu-id="bdb63-196">図 5-6 は、Saga パターンで失敗したトランザクションを示しています。</span><span class="sxs-lookup"><span data-stu-id="bdb63-196">Figure 5-6 shows a failed transaction with the Saga pattern.</span></span>

![saga パターンでロールバックする](./media/saga-rollback-operation.png)

<span data-ttu-id="bdb63-198">**図 5-6**.</span><span class="sxs-lookup"><span data-stu-id="bdb63-198">**Figure 5-6**.</span></span> <span data-ttu-id="bdb63-199">トランザクションのロールバック</span><span class="sxs-lookup"><span data-stu-id="bdb63-199">Rolling back a transaction</span></span>

<span data-ttu-id="bdb63-200">前の図では、在庫マイクロサービスで "*在庫の更新*" 操作が失敗しています。</span><span class="sxs-lookup"><span data-stu-id="bdb63-200">In the previous figure, the *Update Inventory* operation has failed in the Inventory microservice.</span></span> <span data-ttu-id="bdb63-201">Saga により、一連の補償トランザクション (赤色) が呼び出され、在庫数が調整され、支払いと注文が取り消され、各マイクロサービスのデータが一貫した状態に戻されます。</span><span class="sxs-lookup"><span data-stu-id="bdb63-201">The Saga invokes a set of compensating transactions (in red) to adjust the inventory counts, cancel the payment and the order, and return the data for each microservice back to a consistent state.</span></span>

<span data-ttu-id="bdb63-202">通常、Saga パターンは、関連する一連のイベントとして振り付けられるか、関連する一連のコマンドとして編成されます。</span><span class="sxs-lookup"><span data-stu-id="bdb63-202">Saga patterns are typically choreographed as a series of related events, or orchestrated as a set of related commands.</span></span> <span data-ttu-id="bdb63-203">第 4 章では、編成された saga 実装の基盤となるサービス アグリゲーター パターンについて説明しました。</span><span class="sxs-lookup"><span data-stu-id="bdb63-203">In Chapter 4, we discussed the service aggregator pattern that would be the foundation for an orchestrated saga implementation.</span></span> <span data-ttu-id="bdb63-204">また、Azure Service Bus と Azure Event Grid のトピックに沿って、振り付けられた saga の実装の基盤となるイベントについても説明しました。</span><span class="sxs-lookup"><span data-stu-id="bdb63-204">We also discussed eventing along with Azure Service Bus and Azure Event Grid topics that would be a foundation for a choreographed saga implementation.</span></span>

## <a name="high-volume-data"></a><span data-ttu-id="bdb63-205">大量のデータ</span><span class="sxs-lookup"><span data-stu-id="bdb63-205">High volume data</span></span>

<span data-ttu-id="bdb63-206">大規模なクラウドネイティブ アプリケーションは、多くの場合、大量のデータ要件をサポートします。</span><span class="sxs-lookup"><span data-stu-id="bdb63-206">Large cloud-native applications often support high-volume data requirements.</span></span> <span data-ttu-id="bdb63-207">このようなシナリオでは、従来のデータ ストレージ テクノロジがボトルネックになることがあります。</span><span class="sxs-lookup"><span data-stu-id="bdb63-207">In these scenarios, traditional data storage techniques can cause bottlenecks.</span></span> <span data-ttu-id="bdb63-208">大規模にデプロイする複雑なシステムの場合、コマンド クエリ責務分離 (CQRS) とイベント ソーシングの両方によってアプリケーションのパフォーマンスが向上する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="bdb63-208">For complex systems that deploy on a large scale, both Command and Query Responsibility Segregation (CQRS) and Event Sourcing may improve application performance.</span></span>  

### <a name="cqrs"></a><span data-ttu-id="bdb63-209">CQRS</span><span class="sxs-lookup"><span data-stu-id="bdb63-209">CQRS</span></span>

<span data-ttu-id="bdb63-210">[CQRS](/azure/architecture/patterns/cqrs) は、パフォーマンス、スケーラビリティ、およびセキュリティを最大化するのに役立つアーキテクチャ パターンです。</span><span class="sxs-lookup"><span data-stu-id="bdb63-210">[CQRS](/azure/architecture/patterns/cqrs), is an architectural pattern that can help maximize performance, scalability, and security.</span></span> <span data-ttu-id="bdb63-211">このパターンにより、データを読み取る操作とデータを書き込む操作が分離されます。</span><span class="sxs-lookup"><span data-stu-id="bdb63-211">The pattern separates operations that read data from those operations that write data.</span></span>

<span data-ttu-id="bdb63-212">通常のシナリオでは、読み取りと書き込みの "*両方*" の操作に、同じエンティティ モデルとデータ リポジトリ オブジェクトが使用されます。</span><span class="sxs-lookup"><span data-stu-id="bdb63-212">For normal scenarios, the same entity model and data repository object are used for *both* read and write operations.</span></span>

<span data-ttu-id="bdb63-213">ただし、大量のデータを扱うシナリオでは、読み取り用と書き込み用にモデルとデータ テーブルを分けることが有効です。</span><span class="sxs-lookup"><span data-stu-id="bdb63-213">However, a high volume data scenario can benefit from separate models and data tables for reads and writes.</span></span> <span data-ttu-id="bdb63-214">パフォーマンスを向上させるために、読み取り操作では、データの高度に非正規化された表現に対してクエリを実行し、コストの高い反復的なテーブル結合とテーブルのロックを回避できます。</span><span class="sxs-lookup"><span data-stu-id="bdb63-214">To improve performance, the read operation could query against a highly denormalized representation of the data to avoid expensive repetitive table joins and table locks.</span></span> <span data-ttu-id="bdb63-215">"*コマンド*" と呼ばれる "*書き込み*" 操作は、整合性を保証する完全に正規化されたデータ表現に対して更新されます。</span><span class="sxs-lookup"><span data-stu-id="bdb63-215">The *write* operation, known as a *command*, would update against a fully normalized representation of the data that would guarantee consistency.</span></span> <span data-ttu-id="bdb63-216">次に、両方の表現の同期状態を維持するメカニズムを実装する必要があります。通常、書き込みテーブルが変更されるたびに、読み取りテーブルに変更をレプリケートするイベントが発行されます。</span><span class="sxs-lookup"><span data-stu-id="bdb63-216">You then need to implement a mechanism to keep both representations in sync. Typically, whenever the write table is modified, it publishes an event that replicates the modification to the read table.</span></span>

<span data-ttu-id="bdb63-217">図 5-7 は、CQRS パターンの実装を示しています。</span><span class="sxs-lookup"><span data-stu-id="bdb63-217">Figure 5-7 shows an implementation of the CQRS pattern.</span></span>

![コマンド クエリ責務分離](./media/cqrs-implementation.png)

<span data-ttu-id="bdb63-219">**図 5-7**</span><span class="sxs-lookup"><span data-stu-id="bdb63-219">**Figure 5-7**.</span></span> <span data-ttu-id="bdb63-220">CQRS の実装</span><span class="sxs-lookup"><span data-stu-id="bdb63-220">CQRS implementation</span></span>

<span data-ttu-id="bdb63-221">前の図では、コマンドとクエリのモデルが別々に実装されています。</span><span class="sxs-lookup"><span data-stu-id="bdb63-221">In the previous figure, separate command and query models are implemented.</span></span> <span data-ttu-id="bdb63-222">各データ書き込み操作は、書き込みストアに格納されてから、読み取りストアに反映されます。</span><span class="sxs-lookup"><span data-stu-id="bdb63-222">Each data write operation is saved to the write store and then propagated to the read store.</span></span> <span data-ttu-id="bdb63-223">[最終的な整合性](https://www.cloudcomputingpatterns.org/eventual_consistency/)の原則に基づいてデータが反映されていることに注目してください。</span><span class="sxs-lookup"><span data-stu-id="bdb63-223">Pay close attention to how the data propagation process operates on the principle of [eventual consistency](https://www.cloudcomputingpatterns.org/eventual_consistency/).</span></span> <span data-ttu-id="bdb63-224">読み取りモデルは最終的に書き込みモデルと同期されますが、その過程で多少の遅れが生じる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="bdb63-224">The read model eventually synchronizes with the write model, but there may be some lag in the process.</span></span> <span data-ttu-id="bdb63-225">最終的な整合性については次のセクションで説明します。</span><span class="sxs-lookup"><span data-stu-id="bdb63-225">We discuss eventual consistency in the next section.</span></span>

<span data-ttu-id="bdb63-226">このように分離することで、読み取りと書き込みを独立してスケーリングすることができます。</span><span class="sxs-lookup"><span data-stu-id="bdb63-226">This separation enables reads and writes to scale independently.</span></span> <span data-ttu-id="bdb63-227">読み取り操作には、クエリに最適化されたスキーマが使用され、書き込みには、更新に最適化されたスキーマが使用されます。</span><span class="sxs-lookup"><span data-stu-id="bdb63-227">Read operations use a schema optimized for queries, while the writes use a schema optimized for updates.</span></span> <span data-ttu-id="bdb63-228">読み込みクエリを非正規化されたデータに対して実行し、書き込みモデルには複雑なビジネス ロジックを適用することができます。</span><span class="sxs-lookup"><span data-stu-id="bdb63-228">Read queries go against denormalized data, while complex business logic can be applied to the write model.</span></span> <span data-ttu-id="bdb63-229">また、書き込み操作の方に、読み取りを公開する場合よりも厳しいセキュリティを課すことができます。</span><span class="sxs-lookup"><span data-stu-id="bdb63-229">As well, you might impose tighter security on write operations than those exposing reads.</span></span>

<span data-ttu-id="bdb63-230">CQRS を実装すると、クラウドネイティブ サービスのアプリケーション パフォーマンスを向上させることができます。</span><span class="sxs-lookup"><span data-stu-id="bdb63-230">Implementing CQRS can improve application performance for cloud-native services.</span></span> <span data-ttu-id="bdb63-231">ただし、設計はより複雑になります。</span><span class="sxs-lookup"><span data-stu-id="bdb63-231">However, it does result in a more complex design.</span></span> <span data-ttu-id="bdb63-232">この原則は、クラウドネイティブ アプリケーションのうち、メリットがあるセクションに、慎重かつ戦略的に適用してください。</span><span class="sxs-lookup"><span data-stu-id="bdb63-232">Apply this principle carefully and strategically to those sections of your cloud-native application that will benefit from it.</span></span> <span data-ttu-id="bdb63-233">CQRS の詳細については、Microsoft のドキュメント「[.NET マイクロサービス: コンテナー化された .NET アプリケーションのアーキテクチャ](../microservices/microservice-ddd-cqrs-patterns/apply-simplified-microservice-cqrs-ddd-patterns.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="bdb63-233">For more on CQRS, see the Microsoft book [.NET Microservices: Architecture for Containerized .NET Applications](../microservices/microservice-ddd-cqrs-patterns/apply-simplified-microservice-cqrs-ddd-patterns.md).</span></span>

### <a name="event-sourcing"></a><span data-ttu-id="bdb63-234">イベント ソーシング</span><span class="sxs-lookup"><span data-stu-id="bdb63-234">Event sourcing</span></span>

<span data-ttu-id="bdb63-235">大量のデータのシナリオを最適化するもう 1 つのアプローチとして、[イベント ソーシング](/azure/architecture/patterns/event-sourcing)があります。</span><span class="sxs-lookup"><span data-stu-id="bdb63-235">Another approach to optimizing high volume data scenarios involves [Event Sourcing](/azure/architecture/patterns/event-sourcing).</span></span>

<span data-ttu-id="bdb63-236">通常、システムによって、データ エンティティの現在の状態が格納されます。</span><span class="sxs-lookup"><span data-stu-id="bdb63-236">A system typically stores the current state of a data entity.</span></span> <span data-ttu-id="bdb63-237">たとえば、ユーザーが電話番号を変更した場合、顧客レコードは新しい番号で更新されます。</span><span class="sxs-lookup"><span data-stu-id="bdb63-237">If a user changes their phone number, for example, the customer record is updated with the new number.</span></span> <span data-ttu-id="bdb63-238">データ エンティティの現在の状態は常にわかりますが、更新のたびに以前の状態が上書きされます。</span><span class="sxs-lookup"><span data-stu-id="bdb63-238">We always know the current state of a data entity, but each update overwrites the previous state.</span></span>

<span data-ttu-id="bdb63-239">ほとんどの場合、このモデルはうまく機能します。</span><span class="sxs-lookup"><span data-stu-id="bdb63-239">In most cases, this model works fine.</span></span> <span data-ttu-id="bdb63-240">ただし、大量のシステムでは、トランザクションのロックや頻繁な更新操作によるオーバーヘッドが、データベースのパフォーマンスや応答性に影響し、スケーラビリティが制限される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="bdb63-240">In high volume systems, however, overhead from transactional locking and frequent update operations can impact database performance, responsiveness, and limit scalability.</span></span>

<span data-ttu-id="bdb63-241">イベント ソーシングは、データをキャプチャするアプローチが異なります。</span><span class="sxs-lookup"><span data-stu-id="bdb63-241">Event Sourcing takes a different approach to capturing data.</span></span> <span data-ttu-id="bdb63-242">データに影響する各操作は、イベント ストアに保存されます。</span><span class="sxs-lookup"><span data-stu-id="bdb63-242">Each operation that affects data is persisted to an event store.</span></span> <span data-ttu-id="bdb63-243">データ レコードの状態を更新するのではなく、過去のイベントの連続した一覧に各変更を追加します。これは会計士の台帳と似ています。</span><span class="sxs-lookup"><span data-stu-id="bdb63-243">Instead of updating the state of a data record, we append each change to a sequential list of past events - similar to an accountant's ledger.</span></span> <span data-ttu-id="bdb63-244">イベント ストアは、データの記録システムになります。</span><span class="sxs-lookup"><span data-stu-id="bdb63-244">The Event Store becomes the system of record for the data.</span></span> <span data-ttu-id="bdb63-245">これは、マイクロサービスの限界のあるコンテキスト内で、さまざまな具体化されたビューを反映するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="bdb63-245">It's used to propagate various materialized views within the bounded context of a microservice.</span></span> <span data-ttu-id="bdb63-246">図 5.8 は、そのパターンを示しています。</span><span class="sxs-lookup"><span data-stu-id="bdb63-246">Figure 5.8 shows the pattern.</span></span>

![イベント ソーシング](./media/event-sourcing.png)

<span data-ttu-id="bdb63-248">**図 5-8**.</span><span class="sxs-lookup"><span data-stu-id="bdb63-248">**Figure 5-8**.</span></span> <span data-ttu-id="bdb63-249">イベント ソーシング</span><span class="sxs-lookup"><span data-stu-id="bdb63-249">Event Sourcing</span></span>

<span data-ttu-id="bdb63-250">前の図では、ユーザーのショッピング カートの各エントリ (青色) が、基礎となるイベント ストアにどのように追加されているかに注目してください。</span><span class="sxs-lookup"><span data-stu-id="bdb63-250">In the previous figure, note how each entry (in blue) for a user's shopping cart is appended to an underlying event store.</span></span> <span data-ttu-id="bdb63-251">隣接する具体化されたビューでは、各ショッピング カートに関連するすべてのイベントを再生することで、システムによって現在の状態が投影されています。</span><span class="sxs-lookup"><span data-stu-id="bdb63-251">In the adjoining materialized view, the system projects the current state by replaying all the events associated with each shopping cart.</span></span> <span data-ttu-id="bdb63-252">このビュー、つまり読み取りモデルは、UI に公開されます。</span><span class="sxs-lookup"><span data-stu-id="bdb63-252">This view, or read model, is then exposed back to the UI.</span></span> <span data-ttu-id="bdb63-253">イベントを外部のシステムやアプリケーションと統合することや、エンティティの現在の状態を調べるためにクエリを実行することができます。</span><span class="sxs-lookup"><span data-stu-id="bdb63-253">Events can also be integrated with external systems and applications or queried to determine the current state of an entity.</span></span> <span data-ttu-id="bdb63-254">このアプローチでは、履歴を維持します。</span><span class="sxs-lookup"><span data-stu-id="bdb63-254">With this approach, you maintain history.</span></span> <span data-ttu-id="bdb63-255">エンティティの現在の状態だけでなく、どのようにしてその状態に至ったかも把握できます。</span><span class="sxs-lookup"><span data-stu-id="bdb63-255">You know not only the current state of an entity, but also how you reached this state.</span></span>

<span data-ttu-id="bdb63-256">メカニズム的に言えば、イベント ソーシングによって書き込みモデルは単純になります。</span><span class="sxs-lookup"><span data-stu-id="bdb63-256">Mechanically speaking, event sourcing simplifies the write model.</span></span> <span data-ttu-id="bdb63-257">更新も削除もありません。</span><span class="sxs-lookup"><span data-stu-id="bdb63-257">There are no updates or deletes.</span></span> <span data-ttu-id="bdb63-258">各データ エントリを不変のイベントとして追加することで、リレーショナル データベースに関連する競合、ロック、同時実行の競合を最小限に抑えることができます。</span><span class="sxs-lookup"><span data-stu-id="bdb63-258">Appending each data entry as an immutable event minimizes contention, locking, and concurrency conflicts associated with relational databases.</span></span> <span data-ttu-id="bdb63-259">具体化されたビュー パターンで読み取りモデルを構築すると、書き込みモデルからビューを切り離し、アプリケーション UI のニーズに合わせて最適なデータ ストアを選択することができます。</span><span class="sxs-lookup"><span data-stu-id="bdb63-259">Building read models with the materialized view pattern enables you to decouple the view from the write model and choose the best data store to optimize the needs of your application UI.</span></span>

<span data-ttu-id="bdb63-260">このパターンでは、イベント ソーシングを直接サポートするデータ ストアを検討してください。</span><span class="sxs-lookup"><span data-stu-id="bdb63-260">For this pattern, consider a data store that directly supports event sourcing.</span></span> <span data-ttu-id="bdb63-261">Azure Cosmos DB、MongoDB、Cassandra、CouchDB、RavenDB が候補として挙げられます。</span><span class="sxs-lookup"><span data-stu-id="bdb63-261">Azure Cosmos DB, MongoDB, Cassandra, CouchDB, and RavenDB are good candidates.</span></span>

<span data-ttu-id="bdb63-262">すべてのパターンやテクノロジと同様に、戦略的に必要なときに実装してください。</span><span class="sxs-lookup"><span data-stu-id="bdb63-262">As with all patterns and technologies, implement strategically and when needed.</span></span> <span data-ttu-id="bdb63-263">イベント ソーシングにより、パフォーマンスとスケーラビリティを向上させることはできますが、複雑さと学習曲線を犠牲にすることになります。</span><span class="sxs-lookup"><span data-stu-id="bdb63-263">While event sourcing can provide increased performance and scalability, it comes at the expense of complexity and a learning curve.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="bdb63-264">[前へ](service-mesh-communication-infrastructure.md)
>[次へ](relational-vs-nosql-data.md)</span><span class="sxs-lookup"><span data-stu-id="bdb63-264">[Previous](service-mesh-communication-infrastructure.md)
[Next](relational-vs-nosql-data.md)</span></span>
