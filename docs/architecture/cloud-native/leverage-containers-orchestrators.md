---
title: コンテナーとコンテナー オーケストレーターの活用
description: Azure での Docker コンテナーと Kubernetes オーケストレーターの活用
ms.date: 01/19/2021
ms.openlocfilehash: 63ac91b05a88dc13b7c62e6e04eecb0550cd4652
ms.sourcegitcommit: f2ab02d9a780819ca2e5310bbcf5cfe5b7993041
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/03/2021
ms.locfileid: "99505754"
---
# <a name="leveraging-containers-and-orchestrators"></a><span data-ttu-id="3b2bc-103">コンテナーとコンテナー オーケストレーターの活用</span><span class="sxs-lookup"><span data-stu-id="3b2bc-103">Leveraging containers and orchestrators</span></span>

<span data-ttu-id="3b2bc-104">コンテナーとオーケストレーターは、モノリシック デプロイ アプローチに共通する問題を解決するように設計されています。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-104">Containers and orchestrators are designed to solve problems common to monolithic deployment approaches.</span></span>

## <a name="challenges-with-monolithic-deployments"></a><span data-ttu-id="3b2bc-105">モノリシック デプロイに関する課題</span><span class="sxs-lookup"><span data-stu-id="3b2bc-105">Challenges with monolithic deployments</span></span>

<span data-ttu-id="3b2bc-106">従来、ほとんどのアプリケーションは 1 つのユニットとしてデプロイされてきました。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-106">Traditionally, most applications have been deployed as a single unit.</span></span> <span data-ttu-id="3b2bc-107">このようなアプリケーションは、モノリスと呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-107">Such applications are referred to as a monolith.</span></span> <span data-ttu-id="3b2bc-108">図 3-1 に示すように、複数のモジュールやアセンブリで構成されている場合でも、アプリケーションを 1 つのユニットとしてデプロイする一般的なアプローチをモノリシック アーキテクチャと呼びます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-108">This general approach of deploying applications as single units even if they're composed of multiple modules or assemblies is known as monolithic architecture, as shown in Figure 3-1.</span></span>

![モノリシック アーキテクチャ。](./media/monolithic-design.png)

<span data-ttu-id="3b2bc-110">**図 3-1**.</span><span class="sxs-lookup"><span data-stu-id="3b2bc-110">**Figure 3-1**.</span></span> <span data-ttu-id="3b2bc-111">モノリシック アーキテクチャ。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-111">Monolithic architecture.</span></span>

<span data-ttu-id="3b2bc-112">モノリシック アーキテクチャには、シンプルであるという利点がある一方で、いくつかの課題があります。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-112">Although they have the benefit of simplicity, monolithic architectures face a number of challenges:</span></span>

### <a name="deployment"></a><span data-ttu-id="3b2bc-113">デプロイ</span><span class="sxs-lookup"><span data-stu-id="3b2bc-113">Deployment</span></span>

<span data-ttu-id="3b2bc-114">さらに、アプリケーションの再起動が必要であり、デプロイ時にダウンタイムなしのテクノロジを適用しないと、一時的に可用性に影響する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-114">Additionally, they require a restart of the application, which may temporarily impact availability if zero-downtime techniques are not applied while deploying.</span></span>

### <a name="scaling"></a><span data-ttu-id="3b2bc-115">スケーリング</span><span class="sxs-lookup"><span data-stu-id="3b2bc-115">Scaling</span></span>

<span data-ttu-id="3b2bc-116">モノリシック アプリケーションは、1 台のマシン インスタンス上で完全にホストされており、多くの場合、高機能なハードウェアが必要です。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-116">A monolithic application is hosted entirely on a single machine instance, often requiring high-capability hardware.</span></span> <span data-ttu-id="3b2bc-117">モノリスの一部にスケーリングが必要になった場合、アプリケーション全体の別のコピーを別のマシンに展開する必要があります。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-117">If any part of the monolith requires scaling, another copy of the entire application must be deployed to another machine.</span></span> <span data-ttu-id="3b2bc-118">モノリスでは、アプリケーション コンポーネントを個別にスケーリングすることはできません。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-118">With a monolith, you can't scale application components individually - it's all or nothing.</span></span> <span data-ttu-id="3b2bc-119">スケーリングを必要としないコンポーネントをスケーリングすると、リソースの使用効率が低下し、コストがかかります。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-119">Scaling components that don't require scaling results in inefficient and costly resource usage.</span></span>

### <a name="environment"></a><span data-ttu-id="3b2bc-120">環境</span><span class="sxs-lookup"><span data-stu-id="3b2bc-120">Environment</span></span>

<span data-ttu-id="3b2bc-121">モノリシック アプリケーションは、通常、OS、ランタイム、ライブラリがプリインストールされたホスティング環境にデプロイされます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-121">Monolithic applications are typically deployed to a hosting environment with a pre-installed operating system, runtime, and library dependencies.</span></span> <span data-ttu-id="3b2bc-122">この環境は、アプリケーションが開発またはテストされた環境とは異なる場合があります。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-122">This environment may not match that upon which the application was developed or tested.</span></span> <span data-ttu-id="3b2bc-123">アプリケーション環境間の不整合は、モノリシック デプロイの一般的な問題の原因となります。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-123">Inconsistencies across application environments are a common source of problems for monolithic deployments.</span></span>

### <a name="coupling"></a><span data-ttu-id="3b2bc-124">結合</span><span class="sxs-lookup"><span data-stu-id="3b2bc-124">Coupling</span></span>

<span data-ttu-id="3b2bc-125">モノリシック アプリケーションは、その機能コンポーネント間の結合度が高くなりがちです。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-125">A monolithic application is likely to experience high coupling across its functional components.</span></span> <span data-ttu-id="3b2bc-126">厳しい境界線がないと、システムの変更により、意図しないコストのかかる副作用が発生することがよくあります。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-126">Without hard boundaries, system changes often result in unintended and costly side effects.</span></span> <span data-ttu-id="3b2bc-127">新しい機能や修正を実装するのは、厄介で時間がかかり、コストもかかります。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-127">New features/fixes become tricky, time-consuming, and expensive to implement.</span></span> <span data-ttu-id="3b2bc-128">更新には広範なテストが必要です。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-128">Updates require extensive testing.</span></span> <span data-ttu-id="3b2bc-129">また、結合があると、コンポーネントのリファクターや代替実装での入れ替えも困難になります。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-129">Coupling also makes it difficult to refactor components or swap in alternative implementations.</span></span> <span data-ttu-id="3b2bc-130">懸案事項を厳密に分離して構築したとしても、終わりのない "特殊なケース" でモノリシック コード ベースが劣化するため、アーキテクチャの侵食が起こります。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-130">Even when constructed with a strict separation of concerns, architectural erosion sets in as the monolithic code base deteriorates with never-ending "special cases."</span></span>

### <a name="platform-lock-in"></a><span data-ttu-id="3b2bc-131">プラットフォームのロックイン</span><span class="sxs-lookup"><span data-stu-id="3b2bc-131">Platform lock-in</span></span>

<span data-ttu-id="3b2bc-132">モノリシック アプリケーションは、1 つのテクノロジ スタックで構築されます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-132">A monolithic application is constructed with a single technology stack.</span></span> <span data-ttu-id="3b2bc-133">統一性がある一方で、このこだわりがイノベーションの妨げになることもあります。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-133">While offering uniformity, this commitment can become a barrier to innovation.</span></span> <span data-ttu-id="3b2bc-134">新しい機能とコンポーネントは、たとえ、より最新のテクノロジを使用した方が良い場合でも、アプリケーションの現行スタックを使用して構築されます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-134">New features and components will be built using the application's current stack - even when more modern technologies may be a better choice.</span></span> <span data-ttu-id="3b2bc-135">さらに長期的なリスクとして、テクノロジ スタックが時代遅れになり、陳腐化することが挙げられます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-135">A longer-term risk is your technology stack becoming outdated and obsolete.</span></span> <span data-ttu-id="3b2bc-136">アプリケーション全体を新しい最新のプラットフォームに再構築するのは、最善を尽くしてもコストとリスクを伴います。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-136">Rearchitecting an entire application to a new, more modern platform is at best expensive and risky.</span></span>

## <a name="what-are-the-benefits-of-containers-and-orchestrators"></a><span data-ttu-id="3b2bc-137">コンテナーとオーケストレーターの利点</span><span class="sxs-lookup"><span data-stu-id="3b2bc-137">What are the benefits of containers and orchestrators?</span></span>

<span data-ttu-id="3b2bc-138">第 1 章ではコンテナーを紹介しました。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-138">We introduced containers in Chapter 1.</span></span> <span data-ttu-id="3b2bc-139">Cloud Native Computing Foundation (CNCF) により、マイクロサービスのコンテナー化が[クラウドネイティブ トレイル マップ](https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png) (クラウドネイティブ体験を始める企業向けのガイダンス) の最初のステップと優先順位が付けられていることを取り上げました。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-139">We highlighted how the Cloud Native Computing Foundation (CNCF) ranks containerization as the first step in their [Cloud-Native Trail Map](https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png) - guidance for enterprises beginning their cloud-native journey.</span></span> <span data-ttu-id="3b2bc-140">このセクションでは、コンテナーの利点について説明します。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-140">In this section, we discuss the benefits of containers.</span></span>

<span data-ttu-id="3b2bc-141">Docker は、最も人気のあるコンテナー管理プラットフォームです。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-141">Docker is the most popular container management platform.</span></span> <span data-ttu-id="3b2bc-142">Linux または Windows の両方のコンテナーで動作します。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-142">It works with containers on both Linux or Windows.</span></span> <span data-ttu-id="3b2bc-143">コンテナーにより、どのシステムでも同じように動作する、分離していながら再現可能なアプリケーション環境を用意できます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-143">Containers provide separate but reproducible application environments that run the same way on any system.</span></span> <span data-ttu-id="3b2bc-144">この側面があるので、クラウドネイティブ サービスの開発やホスティングに最適です。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-144">This aspect makes them perfect for developing and hosting cloud-native services.</span></span> <span data-ttu-id="3b2bc-145">コンテナーは互いに分離されています。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-145">Containers are isolated from one another.</span></span> <span data-ttu-id="3b2bc-146">同じホスト ハードウェア上の 2 つのコンテナーは、ソフトウェアのバージョンが異なっていても、競合を引き起こすことはありません。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-146">Two containers on the same host hardware can have different versions of software, without causing conflicts.</span></span>

<span data-ttu-id="3b2bc-147">コンテナーは、プロジェクトの成果物となるシンプルなテキストベースのファイルで定義され、ソース管理にチェックインされます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-147">Containers are defined by simple text-based files that become project artifacts and are checked into source control.</span></span> <span data-ttu-id="3b2bc-148">完全なサーバーと仮想マシンの更新には手作業が必要ですが、コンテナーは簡単にバージョン管理ができます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-148">While full servers and virtual machines require manual effort to update, containers are easily version-controlled.</span></span> <span data-ttu-id="3b2bc-149">コンテナーで実行するために構築されたアプリは、ビルド パイプラインの一部として自動化ツールを使用して開発、テスト、デプロイすることができます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-149">Apps built to run in containers can be developed, tested, and deployed using automated tools as part of a build pipeline.</span></span>

<span data-ttu-id="3b2bc-150">コンテナーは不変です。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-150">Containers are immutable.</span></span> <span data-ttu-id="3b2bc-151">一度コンテナーを定義すると、まったく同じ方法で再作成し、実行することができます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-151">Once you define a container, you can recreate and run it exactly the same way.</span></span> <span data-ttu-id="3b2bc-152">この不変性は、コンポーネントベースの設計に適しています。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-152">This immutability lends itself to component-based design.</span></span> <span data-ttu-id="3b2bc-153">アプリケーションの一部が他の部分とは異なる方法で進化する場合、最も頻繁に変更される部分をデプロイすればよいのであれば、アプリ全体を再デプロイする必要はありません。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-153">If some parts of an application evolve differently than others, why redeploy the entire app when you can just deploy the parts that change most frequently?</span></span> <span data-ttu-id="3b2bc-154">アプリの異なる機能や横断的な懸案事項は、別々のユニットに分割することができます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-154">Different features and cross-cutting concerns of an app can be broken up into separate units.</span></span> <span data-ttu-id="3b2bc-155">図 3-2 は、モノリシック アプリが、特定の機能や特徴を委任することにより、コンテナーとマイクロサービスをどのように使用できるかを示しています。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-155">Figure 3-2 shows how a monolithic app can take advantage of containers and microservices by delegating certain features or functionality.</span></span> <span data-ttu-id="3b2bc-156">アプリ自体の残りの機能もコンテナー化されています。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-156">The remaining functionality in the app itself has also been containerized.</span></span>

![モノリシック アプリを分解してバックエンドにマイクロサービスを使用する。](./media/cloud-native-design.png)

<span data-ttu-id="3b2bc-158">**図 3-2**.</span><span class="sxs-lookup"><span data-stu-id="3b2bc-158">**Figure 3-2**.</span></span> <span data-ttu-id="3b2bc-159">モノリシック アプリを分解してマイクロサービスを利用する。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-159">Decomposing a monolithic app to embrace microservices.</span></span>

<span data-ttu-id="3b2bc-160">クラウドネイティブ サービスは、個別のコンテナーに構築してデプロイします。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-160">Each cloud-native service is built and deployed in a separate container.</span></span> <span data-ttu-id="3b2bc-161">必要に応じてそれぞれを更新できます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-161">Each can update as needed.</span></span> <span data-ttu-id="3b2bc-162">個々のサービスは、それぞれのサービスに適したリソースを持つノードでホストすることができます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-162">Individual services can be hosted on nodes with resources appropriate to each service.</span></span> <span data-ttu-id="3b2bc-163">各サービスが実行される環境は不変であり、開発、テスト、運用の環境全体で共有し、簡単にバージョン管理できます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-163">The environment each service runs in is immutable, shared across dev, test, and production environments, and easily versioned.</span></span> <span data-ttu-id="3b2bc-164">アプリケーションの異なる領域間の結合は、モノリス内でのコンパイル時の依存関係ではなく、サービス間の呼び出しやメッセージとして明示的に行われます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-164">Coupling between different areas of the application occurs explicitly as calls or messages between services, not compile-time dependencies within the monolith.</span></span> <span data-ttu-id="3b2bc-165">また、アプリの他の部分に変更を加えることなく、特定の機能に最適なテクノロジを選択することもできます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-165">You can also choose the technology that best suites a given capability without requiring changes to the rest of the app.</span></span>

<span data-ttu-id="3b2bc-166">コンテナー化されたサービスには、自動管理が必要です。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-166">Containerized services require automated management.</span></span> <span data-ttu-id="3b2bc-167">独立してデプロイされた膨大な数のコンテナーを手動で管理するのは不可能です。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-167">It wouldn't be feasible to manually administer a large set of independently deployed containers.</span></span> <span data-ttu-id="3b2bc-168">たとえば、次のようなタスクについて考えてみましょう。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-168">For example, consider the following tasks:</span></span>

- <span data-ttu-id="3b2bc-169">多数のマシンで構成されるクラスター内で、コンテナー インスタンスをプロビジョニングするにはどうすればよいですか。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-169">How will container instances be provisioned across a cluster of many machines?</span></span>
- <span data-ttu-id="3b2bc-170">デプロイ後、コンテナーから相互を発見し、通信するにはどうすればよいですか。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-170">Once deployed, how will containers discover and communicate with each other?</span></span>
- <span data-ttu-id="3b2bc-171">オンデマンドでコンテナーをスケールインまたはスケールアウトするにはどうすればよいですか。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-171">How can containers scale in or out on-demand?</span></span>
- <span data-ttu-id="3b2bc-172">各コンテナーの正常性を監視するにはどうすればよいですか。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-172">How do you monitor the health of each container?</span></span>
- <span data-ttu-id="3b2bc-173">ハードウェアとソフトウェアの障害からコンテナーを保護するにはどうすればよいですか。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-173">How do you protect a container against hardware and software failures?</span></span>
- <span data-ttu-id="3b2bc-174">ライブのアプリケーションのコンテナーをダウンタイムなしでアップグレードするにはどうすればよいですか。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-174">How do upgrade containers for a live application with zero downtime?</span></span>

<span data-ttu-id="3b2bc-175">コンテナー オーケストレーターを使用すると、このような懸案事項に対処し、自動化することができます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-175">Container orchestrators address and automate these and other concerns.</span></span>

<span data-ttu-id="3b2bc-176">クラウドネイティブ エコシステムでは、Kubernetes が事実上のコンテナー オーケストレーターになりました。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-176">In the cloud-native eco-system, Kubernetes has become the de facto container orchestrator.</span></span> <span data-ttu-id="3b2bc-177">これは、Cloud Native Computing Foundation (CNCF) によって管理されるオープンソースのプラットフォームです。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-177">It's an open-source platform managed by the Cloud Native Computing Foundation (CNCF).</span></span> <span data-ttu-id="3b2bc-178">Kubernetes を使用すると、マシン クラスター全体でコンテナー化されたワークロードのデプロイ、スケーリング、運用上の懸案事項を自動化できます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-178">Kubernetes automates the deployment, scaling, and operational concerns of containerized workloads across a machine cluster.</span></span> <span data-ttu-id="3b2bc-179">ただし、Kubernetes のインストールと管理は非常に複雑です。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-179">However, installing and managing Kubernetes is notoriously complex.</span></span>

<span data-ttu-id="3b2bc-180">クラウド ベンダーのマネージド サービスとして Kubernetes を使用する方が、はるかに優れたアプローチです。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-180">A much better approach is to leverage Kubernetes as a managed service from a cloud vendor.</span></span> <span data-ttu-id="3b2bc-181">Azure クラウドには、[Azure Kubernetes Service (AKS)](https://azure.microsoft.com/services/kubernetes-service/) というフル マネージド Kubernetes プラットフォームがあります。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-181">The Azure cloud features a fully managed Kubernetes platform entitled [Azure Kubernetes Service (AKS)](https://azure.microsoft.com/services/kubernetes-service/).</span></span> <span data-ttu-id="3b2bc-182">AKS により、Kubernetes を管理するための複雑さや運用上のオーバーヘッドは抽象化されます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-182">AKS abstracts the complexity and operational overhead of managing Kubernetes.</span></span> <span data-ttu-id="3b2bc-183">ユーザーは Kubernetes をクラウド サービスとして使用し、その管理とサポートは Microsoft が担当します。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-183">You consume Kubernetes as a cloud service; Microsoft takes responsibility for managing and supporting it.</span></span> <span data-ttu-id="3b2bc-184">また、AKS は、他の Azure サービスや開発ツールと緊密に統合されています。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-184">AKS also tightly integrates with other Azure services and dev tools.</span></span>

<span data-ttu-id="3b2bc-185">AKS はクラスターベースのテクノロジです。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-185">AKS is a cluster-based technology.</span></span> <span data-ttu-id="3b2bc-186">フェデレーション仮想マシン (ノード) のプールが Azure クラウドにデプロイされます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-186">A pool of federated virtual machines, or nodes, is deployed to the Azure cloud.</span></span> <span data-ttu-id="3b2bc-187">このようなノードを組み合わせることで、可用性の高い環境、つまりクラスターが形成されます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-187">Together they form a highly available environment, or cluster.</span></span> <span data-ttu-id="3b2bc-188">クラウドネイティブ アプリケーションからは、クラスターはシームレスな 1 つのエンティティのように見えます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-188">The cluster appears as a seamless, single entity to your cloud-native application.</span></span> <span data-ttu-id="3b2bc-189">内部的には、負荷を均等に分散する定義済みの戦略に従って、AKS により、コンテナー化されたサービスがこれらのノード全体にデプロイされます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-189">Under the hood, AKS deploys your containerized services across these nodes following a predefined strategy that evenly distributes the load.</span></span>

## <a name="what-are-the-scaling-benefits"></a><span data-ttu-id="3b2bc-190">スケーリングの利点</span><span class="sxs-lookup"><span data-stu-id="3b2bc-190">What are the scaling benefits?</span></span>

<span data-ttu-id="3b2bc-191">コンテナー上に構築されたサービスからは、Kubernetes のようなオーケストレーション ツールによって提供されるスケーリングの利点を活用できます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-191">Services built on containers can leverage scaling benefits provided by orchestration tools like Kubernetes.</span></span> <span data-ttu-id="3b2bc-192">設計上、コンテナーによって認識されるのは、それ自体のみです。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-192">By design containers only know about themselves.</span></span> <span data-ttu-id="3b2bc-193">複数のコンテナーを連携させる必要がある場合は、より高いレベルでそれらを整理する必要があります。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-193">Once you have multiple containers that need to work together, you should organize them at a higher level.</span></span> <span data-ttu-id="3b2bc-194">多数のコンテナーと、それらの共有される依存関係 (ネットワーク構成など) を整理するには、オーケストレーション ツールを利用すると時間を節約できます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-194">Organizing large numbers of containers and their shared dependencies, such as network configuration, is where orchestration tools come in to save the day!</span></span> <span data-ttu-id="3b2bc-195">Kubernetes により、コンテナー グループに対して抽象化レイヤーが作成され、それらが "*ポッド*" に整理されます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-195">Kubernetes creates an abstraction layer over groups of containers and organizes them into *pods*.</span></span> <span data-ttu-id="3b2bc-196">ポッドは、"*ノード*" と呼ばれるワーカー マシン上で実行されます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-196">Pods run on worker machines referred to as *nodes*.</span></span> <span data-ttu-id="3b2bc-197">この体系化された構造は "*クラスター*" と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-197">This organized structure is referred to as a *cluster*.</span></span> <span data-ttu-id="3b2bc-198">図 3-3 は、Kubernetes クラスターのさまざまなコンポーネントを示しています。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-198">Figure 3-3 shows the different components of a Kubernetes cluster.</span></span>

<span data-ttu-id="3b2bc-199">![Kubernetes クラスターのコンポーネント](./media/kubernetes-cluster-components.png)
**図 3-3**.</span><span class="sxs-lookup"><span data-stu-id="3b2bc-199">![Kubernetes cluster components.](./media/kubernetes-cluster-components.png)
**Figure 3-3**.</span></span> <span data-ttu-id="3b2bc-200">Kubernetes クラスターのコンポーネント。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-200">Kubernetes cluster components.</span></span>

<span data-ttu-id="3b2bc-201">コンテナー化されたワークロードのスケーリングは、コンテナー オーケストレーターの主要な機能です。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-201">Scaling containerized workloads is a key feature of container orchestrators.</span></span> <span data-ttu-id="3b2bc-202">AKS は、コンテナー インスタンスとコンピューティング ノードという 2 つのディメンションにまたがる自動スケーリングをサポートしています。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-202">AKS supports automatic scaling across two dimensions: Container instances and compute nodes.</span></span> <span data-ttu-id="3b2bc-203">これらを組み合わせることで、AKS で需要の急増に迅速かつ効率的に対応し、リソースを追加できるようになります。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-203">Together they give AKS the ability to quickly and efficiently respond to spikes in demand and add additional resources.</span></span> <span data-ttu-id="3b2bc-204">AKS のスケーリングについては、この章で後ほど説明します。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-204">We discuss scaling in AKS later in this chapter.</span></span>

### <a name="declarative-versus-imperative"></a><span data-ttu-id="3b2bc-205">宣言型と命令型</span><span class="sxs-lookup"><span data-stu-id="3b2bc-205">Declarative versus imperative</span></span>

<span data-ttu-id="3b2bc-206">Kubernetes は、宣言型と命令型の両方の構成をサポートしています。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-206">Kubernetes supports both declarative and imperative configuration.</span></span> <span data-ttu-id="3b2bc-207">命令型のアプローチには、各手順の実行方法を Kubernetes に指示するさまざまなコマンドの実行が含まれています。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-207">The imperative approach involves running various commands that tell Kubernetes what to do each step of the way.</span></span> <span data-ttu-id="3b2bc-208">このイメージを実行する。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-208">Run this image.</span></span> <span data-ttu-id="3b2bc-209">このポッドを削除する。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-209">Delete this pod.</span></span> <span data-ttu-id="3b2bc-210">このポートを公開する。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-210">Expose this port.</span></span> <span data-ttu-id="3b2bc-211">宣言型のアプローチの場合、マニフェストと呼ばれる構成ファイルを作成し、何を実行するかではなく、何をしたいかを記述します。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-211">With the declarative approach, you create a configuration file, called a manifest, to describe what you want instead of what to do.</span></span> <span data-ttu-id="3b2bc-212">Kubernetes により、マニフェストが読み込まれ、望ましい最終状態が実際の最終状態に変換されます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-212">Kubernetes reads the manifest and transforms your desired end state into actual end state.</span></span>

<span data-ttu-id="3b2bc-213">命令型コマンドは、学習や対話型の実験に最適です。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-213">Imperative commands are great for learning and interactive experimentation.</span></span> <span data-ttu-id="3b2bc-214">それでも、Kubernetes のマニフェスト ファイルを宣言型で作成し、コードとしてのインフラストラクチャ アプローチを採用して、信頼性と反復可能なデプロイを実現したくなるものです。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-214">However, you'll want to declaratively create Kubernetes manifest files to embrace an infrastructure as code approach, providing for reliable and repeatable deployments.</span></span> <span data-ttu-id="3b2bc-215">マニフェスト ファイルはプロジェクトの成果物となり、Kubernetes のデプロイを自動化するための CI/CD パイプラインで使用されます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-215">The manifest file becomes a project artifact and is used in your CI/CD pipeline for automating Kubernetes deployments.</span></span>

<span data-ttu-id="3b2bc-216">既に命令型コマンドを使用してクラスターを構成している場合は、`kubectl get svc SERVICENAME -o yaml > service.yaml` を使用して宣言型マニフェストをエクスポートすることができます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-216">If you've already configured your cluster using imperative commands, you can export a declarative manifest by using `kubectl get svc SERVICENAME -o yaml > service.yaml`.</span></span> <span data-ttu-id="3b2bc-217">このコマンドを実行すると、次のようなマニフェストが生成されます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-217">This command produces a manifest similar to one shown below:</span></span>

```yaml
apiVersion: v1
kind: Service
metadata:
  creationTimestamp: "2019-09-13T13:58:47Z"
  labels:
    component: apiserver
    provider: kubernetes
  name: kubernetes
  namespace: default
  resourceVersion: "153"
  selfLink: /api/v1/namespaces/default/services/kubernetes
  uid: 9b1fac62-d62e-11e9-8968-00155d38010d
spec:
  clusterIP: 10.96.0.1
  ports:
  - name: https
    port: 443
    protocol: TCP
    targetPort: 6443
  sessionAffinity: None
  type: ClusterIP
status:
  loadBalancer: {}
```

<span data-ttu-id="3b2bc-218">宣言型構成を使用する場合、構成ファイルが置かれているフォルダーに対して `kubectl diff -f FOLDERNAME` を使用することで、コミットする前に変更内容をプレビューすることができます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-218">When using declarative configuration, you can preview the changes that will be made before committing them by using `kubectl diff -f FOLDERNAME` against the folder where your configuration files are located.</span></span> <span data-ttu-id="3b2bc-219">変更を適用することを確認したら、`kubectl apply -f FOLDERNAME` を実行します。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-219">Once you're sure you want to apply the changes, run `kubectl apply -f FOLDERNAME`.</span></span> <span data-ttu-id="3b2bc-220">`-R` を追加すると、フォルダー階層を再帰的に処理できます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-220">Add `-R` to recursively process a folder hierarchy.</span></span>

<span data-ttu-id="3b2bc-221">また、宣言型構成を他の Kubernetes の機能と一緒に使用することもできます。その 1 つがデプロイです。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-221">You can also use declarative configuration with other Kubernetes features, one of which being deployments.</span></span> <span data-ttu-id="3b2bc-222">宣言型デプロイは、リリース、更新、スケーリングの管理に役立ちます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-222">Declarative deployments help manage releases, updates, and scaling.</span></span> <span data-ttu-id="3b2bc-223">宣言型デプロイにより、新しい変更のデプロイ、負荷のスケールアウト、以前のリビジョンへのロールバックなどの方法が Kubernetes のデプロイ コントローラーに指示されます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-223">They instruct the Kubernetes deployment controller on how to deploy new changes, scale out load, or roll back to a previous revision.</span></span> <span data-ttu-id="3b2bc-224">クラスターが不安定な場合、宣言型デプロイによってクラスターは自動的に望ましい状態に戻されます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-224">If a cluster is unstable, a declarative deployment will automatically return the cluster back to a desired state.</span></span> <span data-ttu-id="3b2bc-225">たとえば、ノードがクラッシュした場合、デプロイ メカニズムによって代わりのノードが再デプロイされ、望ましい状態になります。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-225">For example, if a node should crash, the deployment mechanism will redeploy a replacement to achieve your desired state</span></span>

<span data-ttu-id="3b2bc-226">宣言型構成を使用すると、インフラストラクチャをアプリケーション コードと一緒にチェックインすることや、バージョン管理することができるコードとして表すことができます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-226">Using declarative configuration allows infrastructure to be represented as code that can be checked in and versioned alongside the application code.</span></span> <span data-ttu-id="3b2bc-227">これにより、変更管理が改善され、ビルドとデプロイのパイプラインを使用した継続的配置のサポートが向上します。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-227">It provides improved change control and better support for continuous deployment using a build and deploy pipeline.</span></span>

## <a name="what-scenarios-are-ideal-for-containers-and-orchestrators"></a><span data-ttu-id="3b2bc-228">コンテナーとオーケストレーターに最適なシナリオ</span><span class="sxs-lookup"><span data-stu-id="3b2bc-228">What scenarios are ideal for containers and orchestrators?</span></span>

<span data-ttu-id="3b2bc-229">次のようなシナリオは、コンテナーとオーケストレーターを使用するのに最適です。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-229">The following scenarios are ideal for using containers and orchestrators.</span></span>

### <a name="applications-requiring-high-uptime-and-scalability"></a><span data-ttu-id="3b2bc-230">高いアップタイムとスケーラビリティを必要とするアプリケーション</span><span class="sxs-lookup"><span data-stu-id="3b2bc-230">Applications requiring high uptime and scalability</span></span>

<span data-ttu-id="3b2bc-231">個々のアプリケーションのアップタイムとスケーラビリティの要件が高い場合、マイクロサービス、コンテナー、およびオーケストレーター使用するクラウドネイティブ アーキテクチャに最適です。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-231">Individual applications that have high uptime and scalability requirements are ideal candidates for cloud-native architectures using microservices, containers, and orchestrators.</span></span> <span data-ttu-id="3b2bc-232">これらをコンテナー内で開発し、バージョン管理された環境全体でテストし、ダウンタイムなしで運用環境にデプロイすることができます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-232">They can be developed in containers, tested across versioned environments, and deployed into production with zero downtime.</span></span> <span data-ttu-id="3b2bc-233">Kubernetes クラスターを使用することで、必要に応じてアプリをスケーリングし、ノードの障害から自動的に回復することができます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-233">The use of Kubernetes clusters ensures such apps can also scale on demand and recover automatically from node failures.</span></span>

### <a name="large-numbers-of-applications"></a><span data-ttu-id="3b2bc-234">多数のアプリケーション</span><span class="sxs-lookup"><span data-stu-id="3b2bc-234">Large numbers of applications</span></span>

<span data-ttu-id="3b2bc-235">多数のアプリケーションをデプロイし、管理する組織は、コンテナーとオーケストレーターの恩恵を受けます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-235">Organizations that deploy and maintain large numbers of applications benefit from containers and orchestrators.</span></span> <span data-ttu-id="3b2bc-236">コンテナー化された環境や Kubernetes クラスターを設定するための先行作業は、主に固定費です。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-236">The up front effort of setting up containerized environments and Kubernetes clusters is primarily a fixed cost.</span></span> <span data-ttu-id="3b2bc-237">個々のアプリケーションのデプロイ、保守、および更新にかかるコストは、アプリケーション数に応じて異なります。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-237">Deploying, maintaining, and updating individual applications has a cost that varies with the number of applications.</span></span> <span data-ttu-id="3b2bc-238">アプリケーション数が少なくても、カスタム アプリケーションを手動で保守する複雑さは、コンテナーとオーケストレーターを使用したソリューションを実装するコストを上回ります。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-238">Beyond a small number of applications, the complexity of maintaining custom applications manually exceeds the cost of implementing a solution using containers and orchestrators.</span></span>

## <a name="when-should-you-avoid-using-containers-and-orchestrators"></a><span data-ttu-id="3b2bc-239">コンテナーとオーケストレーターの使用を避けるべき場合</span><span class="sxs-lookup"><span data-stu-id="3b2bc-239">When should you avoid using containers and orchestrators?</span></span>

<span data-ttu-id="3b2bc-240">Twelve-Factor App (12 要素アプリ) の原則に従ってアプリを構築できない場合は、コンテナーとオーケストレーターの使用を避けることを検討する必要があります。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-240">If you're unable to build your application following the Twelve-Factor App principles, you should consider avoiding containers and orchestrators.</span></span> <span data-ttu-id="3b2bc-241">このような場合には、VM ベースのホスティング プラットフォーム、または何らかのハイブリッド システムを検討してください。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-241">In these cases, consider a VM-based hosting platform, or possibly some hybrid system.</span></span> <span data-ttu-id="3b2bc-242">それがあれば、いつでも特定の機能の一部を個別のコンテナーまたはサーバーレス機能に切り離すことができます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-242">With it, you can always spin off certain pieces of functionality into separate containers or even serverless functions.</span></span>

## <a name="development-resources"></a><span data-ttu-id="3b2bc-243">開発リソース</span><span class="sxs-lookup"><span data-stu-id="3b2bc-243">Development resources</span></span>

<span data-ttu-id="3b2bc-244">このセクションでは、次回のアプリケーションでコンテナーとオーケストレーターを使い始める場合に役立つ開発リソースの一覧を簡単に紹介します。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-244">This section shows a short list of development resources that may help you get started using containers and orchestrators for your next application.</span></span> <span data-ttu-id="3b2bc-245">クラウドネイティブ マイクロサービス アーキテクチャのアプリケーションを設計する方法のガイダンスについては、本書の手引書である「[.NET のマイクロサービス: コンテナー化された .NET アプリケーションのアーキテクチャ](https://dotnet.microsoft.com/download/thank-you/microservices-architecture-ebook)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-245">If you're looking for guidance on how to design your cloud-native microservices architecture app, read this book's companion, [.NET Microservices: Architecture for Containerized .NET Applications](https://dotnet.microsoft.com/download/thank-you/microservices-architecture-ebook).</span></span>

### <a name="local-kubernetes-development"></a><span data-ttu-id="3b2bc-246">ローカル Kubernetes の開発</span><span class="sxs-lookup"><span data-stu-id="3b2bc-246">Local Kubernetes Development</span></span>

<span data-ttu-id="3b2bc-247">Kubernetes のデプロイは運用環境で本領を発揮しますが、開発マシンのローカルで実行することもできます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-247">Kubernetes deployments provide great value in production environments, but can also run locally on your development machine.</span></span> <span data-ttu-id="3b2bc-248">個々のマイクロサービスを独立して開発することもできますが、運用環境にデプロイされたときと同じように、システム全体をローカルで実行しなければならない場合があります。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-248">While you may work on individual microservices independently, there may be times when you'll need to run the entire system locally - just as it will run when deployed to production.</span></span> <span data-ttu-id="3b2bc-249">そのようなときに役立つツールがいくつかあります。Minikube と Docker Desktop です。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-249">There are several tools that can help: Minikube and Docker Desktop.</span></span> <span data-ttu-id="3b2bc-250">また、Visual Studio にも Docker 開発用のツールが用意されています。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-250">Visual Studio also provides tooling for Docker development.</span></span>

### <a name="minikube"></a><span data-ttu-id="3b2bc-251">Minikube</span><span class="sxs-lookup"><span data-stu-id="3b2bc-251">Minikube</span></span>

<span data-ttu-id="3b2bc-252">Minikube とは</span><span class="sxs-lookup"><span data-stu-id="3b2bc-252">What is Minikube?</span></span> <span data-ttu-id="3b2bc-253">Minikube プロジェクトによると、"Minikube を使用すると、macOS、Linux、Windows 上にローカルの Kubernetes クラスターを実装できます"。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-253">The Minikube project says "Minikube implements a local Kubernetes cluster on macOS, Linux, and Windows."</span></span> <span data-ttu-id="3b2bc-254">その主な目標は、"ローカルの Kubernetes アプリケーション開発のための最良のツールとなり、適合するすべての Kubernetes 機能をサポートすること" です。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-254">Its primary goals are "to be the best tool for local Kubernetes application development and to support all Kubernetes features that fit."</span></span> <span data-ttu-id="3b2bc-255">Minikube のインストールは Docker とは別ですが、Minikube は、Docker Desktop のサポートするハイパーバイザーとは異なるハイパーバイザーをサポートしています。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-255">Installing Minikube is separate from Docker, but Minikube supports different hypervisors than Docker Desktop supports.</span></span> <span data-ttu-id="3b2bc-256">現在、Minikube がサポートしている Kubernetes 機能は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-256">The following Kubernetes features are currently supported by Minikube:</span></span>

- <span data-ttu-id="3b2bc-257">DNS</span><span class="sxs-lookup"><span data-stu-id="3b2bc-257">DNS</span></span>
- <span data-ttu-id="3b2bc-258">NodePorts</span><span class="sxs-lookup"><span data-stu-id="3b2bc-258">NodePorts</span></span>
- <span data-ttu-id="3b2bc-259">ConfigMaps とシークレット</span><span class="sxs-lookup"><span data-stu-id="3b2bc-259">ConfigMaps and secrets</span></span>
- <span data-ttu-id="3b2bc-260">ダッシュボード</span><span class="sxs-lookup"><span data-stu-id="3b2bc-260">Dashboards</span></span>
- <span data-ttu-id="3b2bc-261">コンテナー ランタイム: Docker、rkt、CRI、containerd</span><span class="sxs-lookup"><span data-stu-id="3b2bc-261">Container runtimes: Docker, rkt, CRI-O, and containerd</span></span>
- <span data-ttu-id="3b2bc-262">Container Network Interface (CNI) の有効化</span><span class="sxs-lookup"><span data-stu-id="3b2bc-262">Enabling Container Network Interface (CNI)</span></span>
- <span data-ttu-id="3b2bc-263">イングレス</span><span class="sxs-lookup"><span data-stu-id="3b2bc-263">Ingress</span></span>

<span data-ttu-id="3b2bc-264">Minikube をインストールしたら、`minikube start` コマンドを実行してイメージをダウンロードし、ローカルの Kubernetes クラスターを起動することで、すぐに使い始めることができます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-264">After installing Minikube, you can quickly start using it by running the `minikube start` command, which downloads an image and start the local Kubernetes cluster.</span></span> <span data-ttu-id="3b2bc-265">クラスターが起動したら、標準の Kubernetes の `kubectl` コマンドを使用してクラスターを操作します。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-265">Once the cluster is started, you interact with it using the standard Kubernetes `kubectl` commands.</span></span>

### <a name="docker-desktop"></a><span data-ttu-id="3b2bc-266">Docker Desktop</span><span class="sxs-lookup"><span data-stu-id="3b2bc-266">Docker Desktop</span></span>

<span data-ttu-id="3b2bc-267">Windows 上では、Docker Desktop から直接 Kubernetes を操作することもできます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-267">You can also work with Kubernetes directly from Docker Desktop on Windows.</span></span> <span data-ttu-id="3b2bc-268">これは Windows コンテナーを使用している場合の唯一の選択肢であり、Windows 以外のコンテナーの場合にも素晴らしい選択肢です。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-268">It is your only option if you're using Windows Containers, and is a great choice for non-Windows containers as well.</span></span> <span data-ttu-id="3b2bc-269">図 3-4 は、Docker Desktop の実行時にローカルの Kubernetes サポートを有効にする方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-269">Figure 3-4 shows how to enable local Kubernetes support when running Docker Desktop.</span></span>

![Docker Desktop での Kubernetes の構成](./media/docker-desktop-kubernetes.png)

<span data-ttu-id="3b2bc-271">**図 3-4**.</span><span class="sxs-lookup"><span data-stu-id="3b2bc-271">**Figure 3-4**.</span></span> <span data-ttu-id="3b2bc-272">Docker Desktop での Kubernetes の構成</span><span class="sxs-lookup"><span data-stu-id="3b2bc-272">Configuring Kubernetes in Docker Desktop.</span></span>

<span data-ttu-id="3b2bc-273">Docker Desktop は、コンテナー化されたアプリをローカルで構成および実行するための最も一般的なツールです。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-273">Docker Desktop is the most popular tool for configuring and running containerized apps locally.</span></span> <span data-ttu-id="3b2bc-274">Docker Desktop を使用すると、運用環境にデプロイするのとまったく同じ Docker コンテナー イメージのセットに対してローカルで開発することができます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-274">When you work with Docker Desktop, you can develop locally against the exact same set of Docker container images that you'll deploy to production.</span></span> <span data-ttu-id="3b2bc-275">Docker Desktop は、コンテナー化されたアプリをローカルで "構築、テスト、リリース" するために設計されています。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-275">Docker Desktop is designed to "build, test, and ship" containerized apps locally.</span></span> <span data-ttu-id="3b2bc-276">Linux と Windows の両方のコンテナーがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-276">It supports both Linux and Windows containers.</span></span> <span data-ttu-id="3b2bc-277">イメージを Azure Container Registry や Docker Hub などのイメージ レジストリにプッシュすると、AKS によりそれらがプルされ、運用環境にデプロイされます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-277">Once you push your images to an image registry, like Azure Container Registry or Docker Hub, AKS can pull and deploy them to production.</span></span>

### <a name="visual-studio-docker-tooling"></a><span data-ttu-id="3b2bc-278">Visual Studio の Docker ツール</span><span class="sxs-lookup"><span data-stu-id="3b2bc-278">Visual Studio Docker Tooling</span></span>

<span data-ttu-id="3b2bc-279">Visual Studio は、Web ベースのアプリケーションの Docker 開発をサポートしています。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-279">Visual Studio supports Docker development for web-based applications.</span></span> <span data-ttu-id="3b2bc-280">新しい ASP.NET Core アプリケーションを作成する場合には、図 3-5 に示すように、Docker サポートを使用して構成する選択肢があります。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-280">When you create a new ASP.NET Core application, you have an option to configure it with Docker support, as shown in Figure 3-5.</span></span>

![Visual Studio で Docker サポートを有効にする](./media/visual-studio-enable-docker-support.png)

<span data-ttu-id="3b2bc-282">**図 3-5**.</span><span class="sxs-lookup"><span data-stu-id="3b2bc-282">**Figure 3-5**.</span></span> <span data-ttu-id="3b2bc-283">Visual Studio で Docker サポートを有効にする</span><span class="sxs-lookup"><span data-stu-id="3b2bc-283">Visual Studio Enable Docker Support</span></span>

<span data-ttu-id="3b2bc-284">この選択肢を選ぶと、プロジェクトのルートに `Dockerfile` が作成されます。これを使用して、アプリをビルドして Docker コンテナーでホストすることができます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-284">When this option is selected, the project is created with a `Dockerfile` in its root, which can be used to build and host the app in a Docker container.</span></span> <span data-ttu-id="3b2bc-285">図 3-6 に Dockerfile の例を示します。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-285">An example Dockerfile is shown in Figure 3-6.git</span></span>

```dockerfile
FROM mcr.microsoft.com/dotnet/aspnet:5.0-buster-slim AS base
WORKDIR /app
EXPOSE 80
EXPOSE 443

FROM mcr.microsoft.com/dotnet/sdk:5.0-buster-slim AS build
WORKDIR /src
COPY ["eShopWeb/eShopWeb.csproj", "eShopWeb/"]
RUN dotnet restore "eShopWeb/eShopWeb.csproj"
COPY . .
WORKDIR "/src/eShopWeb"
RUN dotnet build "eShopWeb.csproj" -c Release -o /app/build

FROM build AS publish
RUN dotnet publish "eShopWeb.csproj" -c Release -o /app/publish

FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENTRYPOINT ["dotnet", "eShopWeb.dll"]
```

<span data-ttu-id="3b2bc-286">**図 3-6**.</span><span class="sxs-lookup"><span data-stu-id="3b2bc-286">**Figure 3-6**.</span></span> <span data-ttu-id="3b2bc-287">Visual Studio で生成された Dockerfile</span><span class="sxs-lookup"><span data-stu-id="3b2bc-287">Visual Studio generated Dockerfile</span></span>

<span data-ttu-id="3b2bc-288">アプリが実行されるときの既定の動作は、Docker も使用するように構成されています。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-288">The default behavior when the app runs is configured to use Docker as well.</span></span> <span data-ttu-id="3b2bc-289">図 3-7 は、Docker サポートを追加して作成した新しい ASP.NET Core プロジェクトから使用できるさまざまな実行オプションを示しています。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-289">Figure 3-7 shows the different run options available from a new ASP.NET Core project created with Docker support added.</span></span>

![Visual Studio の Docker 実行オプション](./media/visual-studio-docker-run-options.png)

<span data-ttu-id="3b2bc-291">**図 3-7**.</span><span class="sxs-lookup"><span data-stu-id="3b2bc-291">**Figure 3-7**.</span></span> <span data-ttu-id="3b2bc-292">Visual Studio の Docker 実行オプション</span><span class="sxs-lookup"><span data-stu-id="3b2bc-292">Visual Studio Docker Run Options</span></span>

<span data-ttu-id="3b2bc-293">ローカルの開発に加え、[Azure Dev Spaces](/azure/dev-spaces/) には、複数の開発者が Azure 内で独自の Kubernetes 構成で作業するための便利な方法が用意されています。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-293">In addition to local development, [Azure Dev Spaces](/azure/dev-spaces/) provides a convenient way for multiple developers to work with their own Kubernetes configurations within Azure.</span></span> <span data-ttu-id="3b2bc-294">図 3-7 に示すように、Azure Dev Spaces でアプリケーションを実行することもできます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-294">As you can see in Figure 3-7, you can also run the application in Azure Dev Spaces.</span></span>

<span data-ttu-id="3b2bc-295">また、いつでも既存の ASP.NET Core アプリケーションに Docker サポートを追加することができます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-295">Also, at any time you can add Docker support to an existing ASP.NET Core application.</span></span> <span data-ttu-id="3b2bc-296">図 3-8 に示すように、Visual Studio ソリューション エクスプローラーからプロジェクトを右クリックし、 **[追加]**  >  **[Docker サポート]** を選択します。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-296">From the Visual Studio Solution Explorer, right-click on the project and select **Add** > **Docker Support**, as shown in Figure 3-8.</span></span>

![Visual Studio の Docker サポートの追加](./media/visual-studio-add-docker-support.png)

<span data-ttu-id="3b2bc-298">**図 3-8**.</span><span class="sxs-lookup"><span data-stu-id="3b2bc-298">**Figure 3-8**.</span></span> <span data-ttu-id="3b2bc-299">Visual Studio への Docker サポートの追加</span><span class="sxs-lookup"><span data-stu-id="3b2bc-299">Adding Docker support to Visual Studio</span></span>

<span data-ttu-id="3b2bc-300">図 3-8 に示すように、コンテナー オーケストレーション サポートを追加することもできます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-300">You can also add Container Orchestration Support, also shown in Figure 3-8.</span></span> <span data-ttu-id="3b2bc-301">既定では、オーケストレーターには Kubernetes と Helm が使用されます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-301">By default, the orchestrator uses Kubernetes and Helm.</span></span> <span data-ttu-id="3b2bc-302">オーケストレーターを選択すると、プロジェクト ルートに `azds.yaml` ファイルが追加され、Kubernetes へのアプリケーションの構成とデプロイに使用する Helm chart を含む `charts` フォルダーが追加されます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-302">Once you've chosen the orchestrator, a `azds.yaml` file is added to the project root and a `charts` folder is added containing the Helm charts used to configure and deploy the application to Kubernetes.</span></span> <span data-ttu-id="3b2bc-303">図 3-9 は、新しいプロジェクトの結果のファイルを示しています。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-303">Figure 3-9 shows the resulting files in a new project.</span></span>

![Visual Studio のオーケストレーター サポートの追加](./media/visual-studio-add-orchestrator-support.png)

<span data-ttu-id="3b2bc-305">**図 3-9**.</span><span class="sxs-lookup"><span data-stu-id="3b2bc-305">**Figure 3-9**.</span></span> <span data-ttu-id="3b2bc-306">Visual Studio へのオーケストレーション サポートの追加</span><span class="sxs-lookup"><span data-stu-id="3b2bc-306">Adding orchestration support to Visual Studio</span></span>

### <a name="visual-studio-code-docker-tooling"></a><span data-ttu-id="3b2bc-307">Visual Studio Code の Docker ツール</span><span class="sxs-lookup"><span data-stu-id="3b2bc-307">Visual Studio Code Docker Tooling</span></span>

<span data-ttu-id="3b2bc-308">Visual Studio Code には、Docker 開発をサポートする拡張機能がいくつか用意されています。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-308">There are a number of extensions available for Visual Studio Code that support Docker development.</span></span>

<span data-ttu-id="3b2bc-309">Microsoft は、[Docker for Visual Studio Code 拡張機能](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-docker)を提供しています。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-309">Microsoft provides the [Docker for Visual Studio Code extension](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-docker).</span></span> <span data-ttu-id="3b2bc-310">この拡張機能を使用すると、アプリケーションにコンテナー サポートを追加するプロセスが簡単になります。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-310">This extension simplifies the process of adding container support to applications.</span></span> <span data-ttu-id="3b2bc-311">必要なファイルがスキャフォールディングされ、Docker イメージがビルドされ、コンテナー内でアプリをデバッグできるようになります。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-311">It scaffolds required files, builds Docker images, and enables you to debug your app inside a container.</span></span> <span data-ttu-id="3b2bc-312">この拡張機能は、開始、停止、検査、削除など、コンテナーやイメージに対するアクションを簡単に実行できるビジュアル エクスプローラーを備えています。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-312">The extension features a visual explorer that makes it easy to take actions on containers and images such as start, stop, inspect, remove, and more.</span></span> <span data-ttu-id="3b2bc-313">また、Docker Compose にも対応しているので、実行中の複数のコンテナーを 1 つのユニットとして管理することができます。</span><span class="sxs-lookup"><span data-stu-id="3b2bc-313">The extension also supports Docker Compose enabling you to manage multiple running containers as a single unit.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="3b2bc-314">[前へ](scale-applications.md)
>[次へ](leverage-serverless-functions.md)</span><span class="sxs-lookup"><span data-stu-id="3b2bc-314">[Previous](scale-applications.md)
[Next](leverage-serverless-functions.md)</span></span>
