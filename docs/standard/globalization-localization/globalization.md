---
description: '詳細情報: グローバリゼーション'
title: グローバリゼーション
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- globalization [.NET], about globalization
- global applications, globalization
- international applications [.NET], globalization
- world-ready applications, globalization
- application development [.NET], globalization
- culture, globalization
ms.assetid: 4e919934-6b19-42f2-b770-275a4fae87c9
ms.openlocfilehash: 3a95660624f116ca5600d71ee633ba0f14a72588
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/06/2021
ms.locfileid: "99675859"
---
# <a name="globalization"></a><span data-ttu-id="87787-103">グローバリゼーション</span><span class="sxs-lookup"><span data-stu-id="87787-103">Globalization</span></span>

<span data-ttu-id="87787-104">グローバリゼーションとは、さまざまな文化圏 (カルチャ) のユーザー向けに、ローカライズされたインターフェイスと、その地域に合ったデータをサポートするような、国際対応アプリの設計と開発をいいます。</span><span class="sxs-lookup"><span data-stu-id="87787-104">Globalization involves designing and developing a world-ready app that supports localized interfaces and regional data for users in multiple cultures.</span></span> <span data-ttu-id="87787-105">設計フェーズに着手する前に、アプリでサポートするカルチャを決定してください。</span><span class="sxs-lookup"><span data-stu-id="87787-105">Before beginning the design phase, you should determine which cultures your app will support.</span></span> <span data-ttu-id="87787-106">アプリは既定値として 1 つのカルチャまたは地域を対象としますが、別のカルチャまたは地域のユーザーに簡単に拡張できるようにアプリを設計および作成できます。</span><span class="sxs-lookup"><span data-stu-id="87787-106">Although an app targets a single culture or region as its default, you can design and write it so that it can easily be extended to users in other cultures or regions.</span></span>

<span data-ttu-id="87787-107">開発者には、自分のカルチャによって形成されるユーザー インターフェイスとデータに関する前提があります。</span><span class="sxs-lookup"><span data-stu-id="87787-107">As developers, we all have assumptions about user interfaces and data that are formed by our cultures.</span></span> <span data-ttu-id="87787-108">たとえば、米国の英語圏の開発者は、日付と時刻のデータを形式 `MM/dd/yyyy hh:mm:ss` の文字列としてシリアル化することは、十分理にかなっていると考えます。</span><span class="sxs-lookup"><span data-stu-id="87787-108">For example, for an English-speaking developer in the United States, serializing date and time data as a string in the format `MM/dd/yyyy hh:mm:ss` seems perfectly reasonable.</span></span> <span data-ttu-id="87787-109">ただし、別のカルチャのシステムでその文字列を逆シリアル化すると、<xref:System.FormatException> 例外がスローされるか、正しくないデータが生成される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="87787-109">However, deserializing that string on a system in a different culture is likely to throw a <xref:System.FormatException> exception or produce inaccurate data.</span></span> <span data-ttu-id="87787-110">グローバリゼーションにより、このようなカルチャ固有の前提を識別し、それがアプリの設計またはコードに影響しないようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="87787-110">Globalization enables us to identify such culture-specific assumptions and ensure that they do not affect our app's design or code.</span></span>

<span data-ttu-id="87787-111">この記事では、グローバライズされたアプリで文字列、日付と時刻の値、および数値を処理するときに考慮する必要がある重要な問題および使用できるベスト プラクティスについて説明します。</span><span class="sxs-lookup"><span data-stu-id="87787-111">This article discusses some of the major issues you should consider and the best practices you can follow when handling strings, date and time values, and numeric values in a globalized app.</span></span>

## <a name="strings"></a><span data-ttu-id="87787-112">文字列</span><span class="sxs-lookup"><span data-stu-id="87787-112">Strings</span></span>

<span data-ttu-id="87787-113">カルチャまたは地域ごとに異なる文字と文字セットを使用し、異なる方法で並べ替える可能性があるため、文字と文字列の処理は、グローバリゼーションで主な焦点となります。</span><span class="sxs-lookup"><span data-stu-id="87787-113">The handling of characters and strings is a central focus of globalization, because each culture or region may use different characters and character sets and sort them differently.</span></span> <span data-ttu-id="87787-114">このセクションでは、グローバライズされたアプリで文字列を使用するための推奨事項について説明します。</span><span class="sxs-lookup"><span data-stu-id="87787-114">This section provides recommendations for using strings in globalized apps.</span></span>

### <a name="use-unicode-internally"></a><span data-ttu-id="87787-115">Unicode を内部で使用する</span><span class="sxs-lookup"><span data-stu-id="87787-115">Use Unicode internally</span></span>

<span data-ttu-id="87787-116">既定では、.NET は Unicode 文字列を使用します。</span><span class="sxs-lookup"><span data-stu-id="87787-116">By default, .NET uses Unicode strings.</span></span> <span data-ttu-id="87787-117">Unicode 文字列は、ゼロ個以上の <xref:System.Char> オブジェクトで構成され、それぞれが UTF-16 コード単位を表します。</span><span class="sxs-lookup"><span data-stu-id="87787-117">A Unicode string consists of zero, one, or more <xref:System.Char> objects, each of which represents a UTF-16 code unit.</span></span> <span data-ttu-id="87787-118">世界中で使用されているすべての文字セットのほとんどすべての文字に対して、Unicode 表現があります。</span><span class="sxs-lookup"><span data-stu-id="87787-118">There is a Unicode representation for almost every character in every character set in use throughout the world.</span></span>

<span data-ttu-id="87787-119">また、Windows オペレーティング システムを含む、多くのアプリケーションとオペレーティング システムでは、文字セットを表すためにコード ページを使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="87787-119">Many applications and operating systems, including the Windows operating system, can also use code pages to represent character sets.</span></span> <span data-ttu-id="87787-120">コード ページには、通常、0x00 から 0x7F までの標準 ASCII 値が含まれ、0x80 から 0xFF までの残りの値に他の文字をマップします。</span><span class="sxs-lookup"><span data-stu-id="87787-120">Code pages typically contain the standard ASCII values from 0x00 through 0x7F and map other characters to the remaining values from 0x80 through 0xFF.</span></span> <span data-ttu-id="87787-121">0x80 から 0xFF までの値の解釈は特定のコード ページによって異なります。</span><span class="sxs-lookup"><span data-stu-id="87787-121">The interpretation of values from 0x80 through 0xFF depends on the specific code page.</span></span> <span data-ttu-id="87787-122">このため、可能な場合は、グローバライズされたアプリでコード ページを使用しないようにします。</span><span class="sxs-lookup"><span data-stu-id="87787-122">Because of this, you should avoid using code pages in a globalized app if possible.</span></span>

<span data-ttu-id="87787-123">次の例では、システムの既定のコード ページとデータが保存されたコード ページとが異なる場合にコード ページのデータを解釈する危険性を示しています</span><span class="sxs-lookup"><span data-stu-id="87787-123">The following example illustrates the dangers of interpreting code page data when the default code page on a system is different from the code page on which the data was saved.</span></span> <span data-ttu-id="87787-124">(このシナリオをシミュレートするため、例では、異なるコード ページを明示的に指定します)。最初に、ギリシャ文字の大文字で構成される配列を定義します。</span><span class="sxs-lookup"><span data-stu-id="87787-124">(To simulate this scenario, the example explicitly specifies different code pages.) First, the example defines an array that consists of the uppercase characters of the Greek alphabet.</span></span> <span data-ttu-id="87787-125">コード ページ 737 (MS-DOS ギリシャ語とも呼ばれます) を使用してそれらをバイト配列にエンコードし、バイト配列をファイルに保存します。</span><span class="sxs-lookup"><span data-stu-id="87787-125">It encodes them into a byte array by using code page 737 (also known as MS-DOS Greek) and saves the byte array to a file.</span></span> <span data-ttu-id="87787-126">ファイルを取得し、そのバイト配列をコード ページ 737 を使用してデコードした場合、元の文字が復元されます。</span><span class="sxs-lookup"><span data-stu-id="87787-126">If the file is retrieved and its byte array is decoded by using code page 737, the original characters are restored.</span></span> <span data-ttu-id="87787-127">ただし、ファイルを取得して、そのバイト配列をコード ページ 1252 (または Windows-1252。ラテン語アルファベットの文字を表します) を使用してデコードした場合、元の文字は失われます。</span><span class="sxs-lookup"><span data-stu-id="87787-127">However, if the file is retrieved and its byte array is decoded by using code page 1252 (or Windows-1252, which represents characters in the Latin alphabet), the original characters are lost.</span></span>

[!code-csharp[Conceptual.Globalization#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/codepages1.cs#1)]
[!code-vb[Conceptual.Globalization#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/codepages1.vb#1)]

<span data-ttu-id="87787-128">Unicode を使用することで、同じコード単位を必ず同じ文字にマップでき、同じ文字を必ず同じバイト配列にマップできます。</span><span class="sxs-lookup"><span data-stu-id="87787-128">The use of Unicode ensures that the same code units always map to the same characters, and that the same characters always map to the same byte arrays.</span></span>

### <a name="use-resource-files"></a><span data-ttu-id="87787-129">リソース ファイルを使用する</span><span class="sxs-lookup"><span data-stu-id="87787-129">Use resource files</span></span>

<span data-ttu-id="87787-130">単一のカルチャまたは地域を対象とするアプリを開発する場合でも、ユーザー インターフェイスに表示される文字列などのリソースを格納するためにリソース ファイルを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="87787-130">Even if you are developing an app that targets a single culture or region, you should use resource files to store strings and other resources that are displayed in the user interface.</span></span> <span data-ttu-id="87787-131">リソースを直接コードに追加しないでください。</span><span class="sxs-lookup"><span data-stu-id="87787-131">You should never add them directly to your code.</span></span> <span data-ttu-id="87787-132">リソース ファイルの使用には、次の利点があります。</span><span class="sxs-lookup"><span data-stu-id="87787-132">Using resource files has a number of advantages:</span></span>

- <span data-ttu-id="87787-133">すべての文字列が単一の場所に存在します。</span><span class="sxs-lookup"><span data-stu-id="87787-133">All the strings are in a single location.</span></span> <span data-ttu-id="87787-134">ソース コード全体を検索して、特定の言語またはカルチャに合わせて変更する文字列を特定する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="87787-134">You don't have to search throughout your source code to identify strings to modify for a specific language or culture.</span></span>

- <span data-ttu-id="87787-135">文字列を複製する必要がありません。</span><span class="sxs-lookup"><span data-stu-id="87787-135">There is no need to duplicate strings.</span></span> <span data-ttu-id="87787-136">リソース ファイルを使用しない開発者は、多くの場合、複数のソース コード ファイルで同じ文字列を定義します。</span><span class="sxs-lookup"><span data-stu-id="87787-136">Developers who don't use resource files often define the same string in multiple source code files.</span></span> <span data-ttu-id="87787-137">この重複により、文字列を変更するときに 1 つ以上のインスタンスを見落とす可能性が高くなります。</span><span class="sxs-lookup"><span data-stu-id="87787-137">This duplication increases the probability that one or more instances will be overlooked when a string is modified.</span></span>

- <span data-ttu-id="87787-138">イメージ、バイナリ データなどの文字列以外のリソースを個別のスタンドアロン ファイルに格納するのではなく、リソース ファイルに格納できるので、それらが簡単に取得できます。</span><span class="sxs-lookup"><span data-stu-id="87787-138">You can include non-string resources, such as images or binary data, in the resource file instead of storing them in a separate standalone file, so they can be retrieved easily.</span></span>

<span data-ttu-id="87787-139">ローカライズされたアプリを作成する場合、リソース ファイルを使用することには特に利点があります。</span><span class="sxs-lookup"><span data-stu-id="87787-139">Using resource files has particular advantages if you are creating a localized app.</span></span> <span data-ttu-id="87787-140">サテライト アセンブリにリソースを配置すると <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> プロパティで定義されているユーザーの現在の UI カルチャに基づいて、共通言語ランタイムが自動的にカルチャに応じたリソースを選択します。</span><span class="sxs-lookup"><span data-stu-id="87787-140">When you deploy resources in satellite assemblies, the common language runtime automatically selects a culture-appropriate resource based on the user's current UI culture as defined by the <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="87787-141">適切なカルチャ固有のリソースを提供し、<xref:System.Resources.ResourceManager> オブジェクトを正しくインスタンス化するか、厳密に型指定されたリソース クラスを使用すると、ランタイムは適切なリソースの取得の詳細を処理します。</span><span class="sxs-lookup"><span data-stu-id="87787-141">As long as you provide an appropriate culture-specific resource and correctly instantiate a <xref:System.Resources.ResourceManager> object or use a strongly typed resource class, the runtime handles the details of retrieving the appropriate resources.</span></span>

<span data-ttu-id="87787-142">リソース ファイルの作成の詳細については、[リソース ファイルの作成](../../framework/resources/creating-resource-files-for-desktop-apps.md)に関する記事を参照してください。</span><span class="sxs-lookup"><span data-stu-id="87787-142">For more information about creating resource files, see [Creating Resource Files](../../framework/resources/creating-resource-files-for-desktop-apps.md).</span></span> <span data-ttu-id="87787-143">サテライト アセンブリの作成と展開の詳細については、[サテライト アセンブリの作成](../../framework/resources/creating-satellite-assemblies-for-desktop-apps.md)と[リソースのパッケージ化と展開](../../framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)に関するページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="87787-143">For information about creating and deploying satellite assemblies, see [Creating Satellite Assemblies](../../framework/resources/creating-satellite-assemblies-for-desktop-apps.md) and [Packaging and Deploying Resources](../../framework/resources/packaging-and-deploying-resources-in-desktop-apps.md).</span></span>

### <a name="search-and-compare-strings"></a><span data-ttu-id="87787-144">文字列の検索と比較を行う</span><span class="sxs-lookup"><span data-stu-id="87787-144">Search and compare strings</span></span>

<span data-ttu-id="87787-145">文字列は、できるだけ全体を 1 つのまとまりとして扱い、個々の文字の連続として処理しない必要があります。</span><span class="sxs-lookup"><span data-stu-id="87787-145">Whenever possible, you should handle strings as entire strings instead of handling them as a series of individual characters.</span></span> <span data-ttu-id="87787-146">これは、部分文字列を並べ替えたり、検索したりするときに、組み合わせ文字の解析に関する問題を防ぐうえで特に重要です。</span><span class="sxs-lookup"><span data-stu-id="87787-146">This is especially important when you sort or search for substrings, to prevent problems associated with parsing combined characters.</span></span>

> [!TIP]
> <span data-ttu-id="87787-147"><xref:System.Globalization.StringInfo> クラスを使用して、文字列の個別の文字ではなく、テキスト要素を操作できます。</span><span class="sxs-lookup"><span data-stu-id="87787-147">You can use the <xref:System.Globalization.StringInfo> class to work with the text elements rather than the individual characters in a string.</span></span>

<span data-ttu-id="87787-148">文字列の検索と比較でよくある間違いは、それぞれが <xref:System.Char> オブジェクトによって表される文字のコレクションとして文字列を処理することです。</span><span class="sxs-lookup"><span data-stu-id="87787-148">In string searches and comparisons, a common mistake is to treat the string as a collection of characters, each of which is represented by a <xref:System.Char> object.</span></span> <span data-ttu-id="87787-149">実際に、1 つの文字が 1 つ、2 つ、またはそれ以上の <xref:System.Char> オブジェクトによって形成される場合があります。</span><span class="sxs-lookup"><span data-stu-id="87787-149">In fact, a single character may be formed by one, two, or more <xref:System.Char> objects.</span></span> <span data-ttu-id="87787-150">このような文字は、アルファベットが、Unicode 基本ラテン文字の範囲 (U+0021 ～ U+007E) 外にある文字で構成されるカルチャの文字列に最もよくみられます。</span><span class="sxs-lookup"><span data-stu-id="87787-150">Such characters are found most frequently in strings from cultures whose alphabets consist of characters outside the Unicode Basic Latin character range (U+0021 through U+007E).</span></span> <span data-ttu-id="87787-151">次の例では、文字列で LATIN CAPITAL LETTER A WITH GRAVE 文字 (U+00C0) のインデックスを検索します。</span><span class="sxs-lookup"><span data-stu-id="87787-151">The following example tries to find the index of the LATIN CAPITAL LETTER A WITH GRAVE character (U+00C0) in a string.</span></span> <span data-ttu-id="87787-152">ただし、この文字は、1 つのコード単位 (U+00C0) または複合文字 (2 つのコード単位:U+0041 および U+0300)。</span><span class="sxs-lookup"><span data-stu-id="87787-152">However, this character can be represented in two different ways: as a single code unit (U+00C0) or as a composite character (two code units: U+0041 and U+0300).</span></span> <span data-ttu-id="87787-153">この場合、この文字は、文字列インスタンスで 2 つの <xref:System.Char> オブジェクト (U+0041 と U+0300) によって表されます。</span><span class="sxs-lookup"><span data-stu-id="87787-153">In this case, the character is represented in the string instance by two <xref:System.Char> objects, U+0041 and U+0300.</span></span> <span data-ttu-id="87787-154">このコード例では、<xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType> オーバーロードと <xref:System.String.IndexOf%28System.String%29?displayProperty=nameWithType> オーバーロードを呼び出して、文字列インスタンスでのこの文字の位置を検索しますが、この 2 つは異なる結果を返します。</span><span class="sxs-lookup"><span data-stu-id="87787-154">The example code calls the <xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType> and <xref:System.String.IndexOf%28System.String%29?displayProperty=nameWithType> overloads to find the position of this character in the string instance, but these return different results.</span></span> <span data-ttu-id="87787-155">最初のメソッド呼び出しでは <xref:System.Char> 引数を指定しているので、序数に基づく比較が実行され、一致を見つけることができません。</span><span class="sxs-lookup"><span data-stu-id="87787-155">The first method call has a <xref:System.Char> argument; it performs an ordinal comparison and therefore cannot find a match.</span></span> <span data-ttu-id="87787-156">2 番目の呼び出しでは <xref:System.String> 引数を指定しているので、カルチャに依存した比較が実行され、一致が見つかります。</span><span class="sxs-lookup"><span data-stu-id="87787-156">The second call has a <xref:System.String> argument; it performs a culture-sensitive comparison and therefore finds a match.</span></span>

[!code-csharp[Conceptual.Globalization#18](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/search1.cs#18)]
[!code-vb[Conceptual.Globalization#18](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/search1.vb#18)]

<span data-ttu-id="87787-157"><xref:System.StringComparison> メソッド、<xref:System.String.IndexOf%28System.String%2CSystem.StringComparison%29?displayProperty=nameWithType> メソッドなど <xref:System.String.LastIndexOf%28System.String%2CSystem.StringComparison%29?displayProperty=nameWithType> パラメーターを含むオーバーロードを呼び出して、この例のあいまいさ (異なる結果を返すメソッドの 2 つの類似オーバーロードの呼び出し) の一部を回避できます。</span><span class="sxs-lookup"><span data-stu-id="87787-157">You can avoid some of the ambiguity of this example (calls to two similar overloads of a method returning different results) by calling an overload that includes a <xref:System.StringComparison> parameter, such as the <xref:System.String.IndexOf%28System.String%2CSystem.StringComparison%29?displayProperty=nameWithType> or <xref:System.String.LastIndexOf%28System.String%2CSystem.StringComparison%29?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="87787-158">ただし、検索が常にカルチャに依存しているとは限りません。</span><span class="sxs-lookup"><span data-stu-id="87787-158">However, searches are not always culture-sensitive.</span></span> <span data-ttu-id="87787-159">検索の目的がセキュリティ上の決定をするか、またはリソースへのアクセスを許可または拒否することである場合、次のセクションで説明するように序数に基づく比較を実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="87787-159">If the purpose of the search is to make a security decision or to allow or disallow access to some resource, the comparison should be ordinal, as discussed in the next section.</span></span>

### <a name="test-strings-for-equality"></a><span data-ttu-id="87787-160">文字列の等価性をテストする</span><span class="sxs-lookup"><span data-stu-id="87787-160">Test strings for equality</span></span>

<span data-ttu-id="87787-161">2 つの文字列が並べ替え順序で並ぶ方法を確認するのではなく、2 つの文字列の等価性をテストする場合は、<xref:System.String.Compare%2A?displayProperty=nameWithType>、<xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType> などの文字列比較メソッドの代わりに <xref:System.String.Equals%2A?displayProperty=nameWithType> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="87787-161">If you want to test two strings for equality rather than determine how they compare in the sort order, use the <xref:System.String.Equals%2A?displayProperty=nameWithType> method instead of a string comparison method such as <xref:System.String.Compare%2A?displayProperty=nameWithType> or <xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="87787-162">等価性の比較は、通常、条件付きでリソースにアクセスするために実行します。</span><span class="sxs-lookup"><span data-stu-id="87787-162">Comparisons for equality are typically performed to access some resource conditionally.</span></span> <span data-ttu-id="87787-163">たとえば、パスワードを確認したり、ファイルがあることを確認したりするために等価性の比較を実行する場合があります。</span><span class="sxs-lookup"><span data-stu-id="87787-163">For example, you might perform a comparison for equality to verify a password or to confirm that a file exists.</span></span> <span data-ttu-id="87787-164">このような非言語的な比較は、カルチャに依存するのではなく、常に序数に基づいて実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="87787-164">Such non-linguistic comparisons should always be ordinal rather than culture-sensitive.</span></span> <span data-ttu-id="87787-165">一般に、パスワードなどの文字列の場合は <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29?displayProperty=nameWithType> の値を使用して、ファイル名、URI などの文字列の場合は <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> の値を使用して、インスタンス <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> メソッドまたは静的 <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> メソッドを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="87787-165">In general, you should call the instance <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29?displayProperty=nameWithType> method or the static <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> method with a value of <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> for strings such as passwords, and a value of <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> for strings such as file names or URIs.</span></span>

<span data-ttu-id="87787-166">等価性の比較では、<xref:System.String.Equals%2A?displayProperty=nameWithType> メソッドを呼び出すのではなく、検索したり、部分文字列を比較したりすることがあります。</span><span class="sxs-lookup"><span data-stu-id="87787-166">Comparisons for equality sometimes involve searches or substring comparisons rather than calls to the <xref:System.String.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="87787-167">場合によっては、部分文字列検索を使用して、その部分文字列が別の文字列と等しいかどうかを確認できます。</span><span class="sxs-lookup"><span data-stu-id="87787-167">In some cases, you may use a substring search to determine whether that substring equals another string.</span></span> <span data-ttu-id="87787-168">この比較の目的が非言語的である場合、検索はカルチャに依存するのではなく、序数に基づいて実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="87787-168">If the purpose of this comparison is non-linguistic, the search should also be ordinal rather than culture-sensitive.</span></span>

<span data-ttu-id="87787-169">次の例は、非言語的なデータに対してカルチャに依存した検索を実行することの危険性を示しています。</span><span class="sxs-lookup"><span data-stu-id="87787-169">The following example illustrates the danger of a culture-sensitive search on non-linguistic data.</span></span> <span data-ttu-id="87787-170">`AccessesFileSystem` メソッドは、部分文字列 "FILE" で始まる URI のファイル システムのアクセスを禁止するように設計されています。</span><span class="sxs-lookup"><span data-stu-id="87787-170">The `AccessesFileSystem` method is designed to prohibit file system access for URIs that begin with the substring "FILE".</span></span> <span data-ttu-id="87787-171">これを実行するため、カルチャに依存し、大文字と小文字を区別しない比較を実行して、URI の先頭と文字列 "FILE" を比較します。</span><span class="sxs-lookup"><span data-stu-id="87787-171">To do this, it performs a culture-sensitive, case-insensitive comparison of the beginning of the URI with the string "FILE".</span></span> <span data-ttu-id="87787-172">ファイル システムにアクセスする URI は "FILE:" または "file:" で始まる可能性があるため、"i" (U+0069) は常に "I" (U+0049) と等価の小文字表現であるという暗黙の前提があります。</span><span class="sxs-lookup"><span data-stu-id="87787-172">Because a URI that accesses the file system can begin with either "FILE:" or "file:", the implicit assumption is that "i" (U+0069) is always the lowercase equivalent of "I" (U+0049).</span></span> <span data-ttu-id="87787-173">ただし、トルコ語およびアゼルバイジャン語には、"i" の大文字として "İ" (U+0130) があります。</span><span class="sxs-lookup"><span data-stu-id="87787-173">However, in Turkish and Azerbaijani, the uppercase version of "i" is "İ" (U+0130).</span></span> <span data-ttu-id="87787-174">このような相違があるため、カルチャに依存した比較を使用すると、ファイル システムのアクセスを禁止する必要がある場合でもそのアクセスが許可されます。</span><span class="sxs-lookup"><span data-stu-id="87787-174">Because of this discrepancy, the culture-sensitive comparison allows file system access when it should be prohibited.</span></span>

[!code-csharp[Conceptual.Globalization#12](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/equals1.cs#12)]
[!code-vb[Conceptual.Globalization#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/equals1.vb#12)]

<span data-ttu-id="87787-175">次の例に示すように、大文字と小文字を無視する序数に基づく比較を実行して、この問題を回避できます。</span><span class="sxs-lookup"><span data-stu-id="87787-175">You can avoid this problem by performing an ordinal comparison that ignores case, as the following example shows.</span></span>

[!code-csharp[Conceptual.Globalization#13](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/equals2.cs#13)]
[!code-vb[Conceptual.Globalization#13](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/equals2.vb#13)]

### <a name="order-and-sort-strings"></a><span data-ttu-id="87787-176">文字列の順序と並べ替え</span><span class="sxs-lookup"><span data-stu-id="87787-176">Order and sort strings</span></span>

<span data-ttu-id="87787-177">通常、ユーザー インターフェイスの表示順序が指定された文字列は、カルチャに基づいて並べ替える必要があります。</span><span class="sxs-lookup"><span data-stu-id="87787-177">Typically, ordered strings that are to be displayed in the user interface should be sorted based on culture.</span></span> <span data-ttu-id="87787-178">ほとんどの場合、このような文字列比較は、文字列を並べ替える <xref:System.Array.Sort%2A?displayProperty=nameWithType>、<xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType> などのメソッドを呼び出すと、.NET によって暗黙的に処理されます。</span><span class="sxs-lookup"><span data-stu-id="87787-178">For the most part, such string comparisons are handled implicitly by .NET when you call a method that sorts strings, such as <xref:System.Array.Sort%2A?displayProperty=nameWithType> or <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="87787-179">既定では、文字列は、現在のカルチャの並べ替え規則を使用して並べ替えられます。</span><span class="sxs-lookup"><span data-stu-id="87787-179">By default, strings are sorted by using the sorting conventions of the current culture.</span></span> <span data-ttu-id="87787-180">次の例では、文字列の配列を英語 (米国) カルチャとスウェーデン語 (スウェーデン) カルチャの規則を使用して並べ替えたときの違いを示しています。</span><span class="sxs-lookup"><span data-stu-id="87787-180">The following example illustrates the difference when an array of strings is sorted by using the conventions of the English (United States) culture and the Swedish (Sweden) culture.</span></span>

[!code-csharp[Conceptual.Globalization#14](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/sort1.cs#14)]
[!code-vb[Conceptual.Globalization#14](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/sort1.vb#14)]

<span data-ttu-id="87787-181">カルチャに依存した文字列比較は、各カルチャの <xref:System.Globalization.CompareInfo> プロパティによって返される <xref:System.Globalization.CultureInfo.CompareInfo%2A?displayProperty=nameWithType> オブジェクトによって定義されます。</span><span class="sxs-lookup"><span data-stu-id="87787-181">Culture-sensitive string comparison is defined by the <xref:System.Globalization.CompareInfo> object, which is returned by each culture's <xref:System.Globalization.CultureInfo.CompareInfo%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="87787-182"><xref:System.String.Compare%2A?displayProperty=nameWithType> メソッド オーバーロードを使用するカルチャに依存した文字列比較では、<xref:System.Globalization.CompareInfo> オブジェクトも使用します。</span><span class="sxs-lookup"><span data-stu-id="87787-182">Culture-sensitive string comparisons that use the <xref:System.String.Compare%2A?displayProperty=nameWithType> method overloads also use the <xref:System.Globalization.CompareInfo> object.</span></span>

<span data-ttu-id="87787-183">.NET は、文字列データのカルチャに依存した並べ替えを実行するためにテーブルを使用します。</span><span class="sxs-lookup"><span data-stu-id="87787-183">.NET uses tables to perform culture-sensitive sorts on string data.</span></span> <span data-ttu-id="87787-184">並べ替えのウェイトと文字列の正規化に関するデータが入ったこれらのテーブルの内容は、特定のバージョンの .NET によって実装される Unicode 標準のバージョンによって決まります。</span><span class="sxs-lookup"><span data-stu-id="87787-184">The content of these tables, which contain data on sort weights and string normalization, is determined by the version of the Unicode standard implemented by a particular version of .NET.</span></span> <span data-ttu-id="87787-185">次の表は、特定のバージョンの .NET によって実装される Unicode のバージョンです。</span><span class="sxs-lookup"><span data-stu-id="87787-185">The following table lists the versions of Unicode implemented by the specified versions of .NET.</span></span> <span data-ttu-id="87787-186">サポートされている Unicode バージョンの一覧は、文字の比較と並べ替えに対してのみ適用されます。カテゴリ別での Unicode 文字の分類には適用されません。</span><span class="sxs-lookup"><span data-stu-id="87787-186">This list of supported Unicode versions applies to character comparison and sorting only; it does not apply to classification of Unicode characters by category.</span></span> <span data-ttu-id="87787-187">詳細については、記事「<xref:System.String>」 の「Strings and The Unicode Standard」 (文字列と Unicode 標準) セクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="87787-187">For more information, see the "Strings and The Unicode Standard" section in the <xref:System.String> article.</span></span>

|<span data-ttu-id="87787-188">.NET Framework のバージョン</span><span class="sxs-lookup"><span data-stu-id="87787-188">.NET Framework version</span></span>|<span data-ttu-id="87787-189">オペレーティング システム</span><span class="sxs-lookup"><span data-stu-id="87787-189">Operating system</span></span>|<span data-ttu-id="87787-190">Unicode バージョン</span><span class="sxs-lookup"><span data-stu-id="87787-190">Unicode version</span></span>|
|----------------------------|----------------------|---------------------|
|<span data-ttu-id="87787-191">.NET Framework 2.0</span><span class="sxs-lookup"><span data-stu-id="87787-191">.NET Framework 2.0</span></span>|<span data-ttu-id="87787-192">すべてのオペレーティング システム</span><span class="sxs-lookup"><span data-stu-id="87787-192">All operating systems</span></span>|<span data-ttu-id="87787-193">Unicode 4.1</span><span class="sxs-lookup"><span data-stu-id="87787-193">Unicode 4.1</span></span>|
|<span data-ttu-id="87787-194">.NET Framework 3.0</span><span class="sxs-lookup"><span data-stu-id="87787-194">.NET Framework 3.0</span></span>|<span data-ttu-id="87787-195">すべてのオペレーティング システム</span><span class="sxs-lookup"><span data-stu-id="87787-195">All operating systems</span></span>|<span data-ttu-id="87787-196">Unicode 4.1</span><span class="sxs-lookup"><span data-stu-id="87787-196">Unicode 4.1</span></span>|
|<span data-ttu-id="87787-197">.NET Framework 3.5</span><span class="sxs-lookup"><span data-stu-id="87787-197">.NET Framework 3.5</span></span>|<span data-ttu-id="87787-198">すべてのオペレーティング システム</span><span class="sxs-lookup"><span data-stu-id="87787-198">All operating systems</span></span>|<span data-ttu-id="87787-199">Unicode 4.1</span><span class="sxs-lookup"><span data-stu-id="87787-199">Unicode 4.1</span></span>|
|<span data-ttu-id="87787-200">.NET Framework 4</span><span class="sxs-lookup"><span data-stu-id="87787-200">.NET Framework 4</span></span>|<span data-ttu-id="87787-201">すべてのオペレーティング システム</span><span class="sxs-lookup"><span data-stu-id="87787-201">All operating systems</span></span>|<span data-ttu-id="87787-202">Unicode 5.0</span><span class="sxs-lookup"><span data-stu-id="87787-202">Unicode 5.0</span></span>|
|<span data-ttu-id="87787-203">Windows 7 の .NET Framework 4.5 以降</span><span class="sxs-lookup"><span data-stu-id="87787-203">.NET Framework 4.5 and later on Windows 7</span></span>|<span data-ttu-id="87787-204">Unicode 5.0</span><span class="sxs-lookup"><span data-stu-id="87787-204">Unicode 5.0</span></span>|
|<span data-ttu-id="87787-205">Windows 8 以降のオペレーティング システムの .NET Framework 4.5 以降</span><span class="sxs-lookup"><span data-stu-id="87787-205">.NET Framework 4.5 and later on Windows 8 and later operating systems</span></span>|<span data-ttu-id="87787-206">Unicode 6.3.0</span><span class="sxs-lookup"><span data-stu-id="87787-206">Unicode 6.3.0</span></span>|
|<span data-ttu-id="87787-207">.NET Core および .NET 5+</span><span class="sxs-lookup"><span data-stu-id="87787-207">.NET Core and .NET 5+</span></span>|<span data-ttu-id="87787-208">基になるオペレーティング システムでサポートされている Unicode 標準のバージョンによって異なります。</span><span class="sxs-lookup"><span data-stu-id="87787-208">Depends on the version of the Unicode Standard supported by the underlying operating system.</span></span>|

<span data-ttu-id="87787-209">.NET Framework 4.5 以降と .NET Core および .NET 5+ のすべてのバージョンでは、文字列の比較と並べ替えはオペレーティング システムによって異なります。</span><span class="sxs-lookup"><span data-stu-id="87787-209">Starting with .NET Framework 4.5 and in all versions of .NET Core and .NET 5+, string comparison and sorting depends on the operating system.</span></span> <span data-ttu-id="87787-210">Windows 7 で実行される NET Framework 4.5 以降は、Unicode 5.0 を実装する独自のテーブルからデータを取得します。</span><span class="sxs-lookup"><span data-stu-id="87787-210">.NET Framework 4.5 and later running on Windows 7 retrieves data from its own tables that implement Unicode 5.0.</span></span> <span data-ttu-id="87787-211">Windows 8 以降で実行される NET Framework 4.5 以降は、Unicode 6.3 を実装するオペレーティング システムのテーブルからデータを取得します。</span><span class="sxs-lookup"><span data-stu-id="87787-211">.NET Framework 4.5 and later running on Windows 8 and later retrieves data from operating system tables that implement Unicode 6.3.</span></span> <span data-ttu-id="87787-212">.NET Core と .NET 5+ では、サポートされている Unicode のバージョンは基になるオペレーティング システムによって異なります。</span><span class="sxs-lookup"><span data-stu-id="87787-212">On .NET Core and .NET 5+, the supported version of Unicode depends on the underlying operating system.</span></span> <span data-ttu-id="87787-213">カルチャに依存した並べ替えが実行されたデータをシリアル化する場合は、<xref:System.Globalization.SortVersion> クラスを使用して、.NET およびオペレーティング システムの並べ替え順序と一致するように、シリアル化されたデータをいつ並べ替える必要があるかを判断できます。</span><span class="sxs-lookup"><span data-stu-id="87787-213">If you serialize culture-sensitive sorted data, you can use the <xref:System.Globalization.SortVersion> class to determine when your serialized data needs to be sorted so that it is consistent with .NET and the operating system's sort order.</span></span> <span data-ttu-id="87787-214">例については、<xref:System.Globalization.SortVersion> クラスに関するトピックを参照してください。</span><span class="sxs-lookup"><span data-stu-id="87787-214">For an example, see the <xref:System.Globalization.SortVersion> class topic.</span></span>

<span data-ttu-id="87787-215">広範なカルチャ固有の並べ替えを文字列データに対して実行するアプリの場合、<xref:System.Globalization.SortKey> クラスを使用して文字列を比較できます。</span><span class="sxs-lookup"><span data-stu-id="87787-215">If your app performs extensive culture-specific sorts of string data, you can work with the <xref:System.Globalization.SortKey> class to compare strings.</span></span> <span data-ttu-id="87787-216">並べ替えキーは、特定の文字列のアルファベット順、大文字と小文字の区別、発音の区別など、カルチャ固有の並べ替えウェイトを反映しています。</span><span class="sxs-lookup"><span data-stu-id="87787-216">A sort key reflects the culture-specific sort weights, including the alphabetic, case, and diacritic weights of a particular string.</span></span> <span data-ttu-id="87787-217">並べ替えキーを使用した比較はバイナリであるため、<xref:System.Globalization.CompareInfo> オブジェクトを暗黙的または明示的に使用する比較よりも高速です。</span><span class="sxs-lookup"><span data-stu-id="87787-217">Because comparisons using sort keys are binary, they are faster than comparisons that use a <xref:System.Globalization.CompareInfo> object either implicitly or explicitly.</span></span> <span data-ttu-id="87787-218"><xref:System.Globalization.CompareInfo.GetSortKey%2A?displayProperty=nameWithType> メソッドに文字列を渡すことによって、特定の文字列のカルチャ固有の並べ替えキーを作成します。</span><span class="sxs-lookup"><span data-stu-id="87787-218">You create a culture-specific sort key for a particular string by passing the string to the <xref:System.Globalization.CompareInfo.GetSortKey%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="87787-219">次の例は、前の例と似ています。</span><span class="sxs-lookup"><span data-stu-id="87787-219">The following example is similar to the previous example.</span></span> <span data-ttu-id="87787-220">ただし、暗黙的に <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> メソッドを呼び出す <xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType> メソッドを呼び出すのではなく、インスタンス化して、<xref:System.Collections.Generic.IComparer%601?displayProperty=nameWithType> メソッドに渡す、並べ替えキーを比較する <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> 実装を定義しています。</span><span class="sxs-lookup"><span data-stu-id="87787-220">However, instead of calling the <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> method, which implicitly calls the <xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType> method, it defines an <xref:System.Collections.Generic.IComparer%601?displayProperty=nameWithType> implementation that compares sort keys, which it instantiates and passes to the <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> method.</span></span>

[!code-csharp[Conceptual.Globalization#15](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/sortkey1.cs#15)]
[!code-vb[Conceptual.Globalization#15](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/sortkey1.vb#15)]

### <a name="avoid-string-concatenation"></a><span data-ttu-id="87787-221">文字列の連結を回避する</span><span class="sxs-lookup"><span data-stu-id="87787-221">Avoid string concatenation</span></span>

<span data-ttu-id="87787-222">可能な限り、文字列を実行時に連結して使う方法は避けてください。</span><span class="sxs-lookup"><span data-stu-id="87787-222">If at all possible, avoid using composite strings that are built at run time from concatenated phrases.</span></span> <span data-ttu-id="87787-223">連結される文字列は、他のローカライズ言語には当てはまらない、アプリの元の言語の語順に依存することが多く、ローカライズ作業が困難になります。</span><span class="sxs-lookup"><span data-stu-id="87787-223">Composite strings are difficult to localize, because they often assume a grammatical order in the app's original language that does not apply to other localized languages.</span></span>

## <a name="handle-dates-and-times"></a><span data-ttu-id="87787-224">日付と時刻を処理する</span><span class="sxs-lookup"><span data-stu-id="87787-224">Handle dates and times</span></span>

<span data-ttu-id="87787-225">日付と時刻の値を処理する方法は、その値をユーザー インターフェイスに表示するのか、保持するのかによって異なります。</span><span class="sxs-lookup"><span data-stu-id="87787-225">How you handle date and time values depends on whether they are displayed in the user interface or persisted.</span></span> <span data-ttu-id="87787-226">このセクションでは、両方の使用を検討します。</span><span class="sxs-lookup"><span data-stu-id="87787-226">This section examines both usages.</span></span> <span data-ttu-id="87787-227">また、日付と時刻を操作するときにタイム ゾーンの相違と算術演算を処理する方法についても説明します。</span><span class="sxs-lookup"><span data-stu-id="87787-227">It also discusses how you can handle time zone differences and arithmetic operations when working with dates and times.</span></span>

### <a name="display-dates-and-times"></a><span data-ttu-id="87787-228">日付と時刻を表示する</span><span class="sxs-lookup"><span data-stu-id="87787-228">Display dates and times</span></span>

<span data-ttu-id="87787-229">通常、日付と時刻をユーザー インターフェイスに表示するときには、<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> プロパティと、<xref:System.Globalization.DateTimeFormatInfo> プロパティによって返される `CultureInfo.CurrentCulture.DateTimeFormat` オブジェクトで定義されているユーザーのカルチャの書式指定規則を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="87787-229">Typically, when dates and times are displayed in the user interface, you should use the formatting conventions of the user's culture, which is defined by the <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> property and by the <xref:System.Globalization.DateTimeFormatInfo> object returned by the `CultureInfo.CurrentCulture.DateTimeFormat` property.</span></span> <span data-ttu-id="87787-230">次のメソッドのいずれかを使用して日付の書式を設定すると、現在のカルチャの書式指定規則が自動的に使用されます。</span><span class="sxs-lookup"><span data-stu-id="87787-230">The formatting conventions of the current culture are automatically used when you format a date by using any of these methods:</span></span>

- <span data-ttu-id="87787-231">パラメーターなしの <xref:System.DateTime.ToString?displayProperty=nameWithType> メソッド</span><span class="sxs-lookup"><span data-stu-id="87787-231">The parameterless <xref:System.DateTime.ToString?displayProperty=nameWithType> method</span></span>

- <span data-ttu-id="87787-232">書式指定文字列を含む <xref:System.DateTime.ToString%28System.String%29?displayProperty=nameWithType> メソッド</span><span class="sxs-lookup"><span data-stu-id="87787-232">The <xref:System.DateTime.ToString%28System.String%29?displayProperty=nameWithType> method, which includes a format string</span></span>

- <span data-ttu-id="87787-233">パラメーターなしの <xref:System.DateTimeOffset.ToString?displayProperty=nameWithType> メソッド</span><span class="sxs-lookup"><span data-stu-id="87787-233">The parameterless <xref:System.DateTimeOffset.ToString?displayProperty=nameWithType> method</span></span>

- <span data-ttu-id="87787-234">書式指定文字列を含む <xref:System.DateTimeOffset.ToString%28System.String%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="87787-234">The <xref:System.DateTimeOffset.ToString%28System.String%29?displayProperty=nameWithType>, which includes a format string</span></span>

- <span data-ttu-id="87787-235">[複合書式指定](../base-types/composite-formatting.md)機能 (日付と共に使用する場合)</span><span class="sxs-lookup"><span data-stu-id="87787-235">The [composite formatting](../base-types/composite-formatting.md) feature, when it is used with dates</span></span>

<span data-ttu-id="87787-236">次の例では、2012 年 10 月 11 日の日の出と日没のデータを 2 回表示します。</span><span class="sxs-lookup"><span data-stu-id="87787-236">The following example displays sunrise and sunset data twice for October 11, 2012.</span></span> <span data-ttu-id="87787-237">最初に、現在のカルチャをクロアチア語 (クロアチア) に設定し、次に英語 (英国) に設定します。</span><span class="sxs-lookup"><span data-stu-id="87787-237">It first sets the current culture to Croatian (Croatia), and then to English (Great Britain).</span></span> <span data-ttu-id="87787-238">どちらの場合も、日付と時刻はそのカルチャに適した書式で表示されます。</span><span class="sxs-lookup"><span data-stu-id="87787-238">In each case, the dates and times are displayed in the format that is appropriate for that culture.</span></span>

[!code-csharp[Conceptual.Globalization#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/dates1.cs#2)]
[!code-vb[Conceptual.Globalization#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/dates1.vb#2)]

### <a name="persist-dates-and-times"></a><span data-ttu-id="87787-239">日付と時刻を保持する</span><span class="sxs-lookup"><span data-stu-id="87787-239">Persist dates and times</span></span>

<span data-ttu-id="87787-240">日付と時刻のデータはカルチャによって異なる可能性がある書式で保持しないでください。</span><span class="sxs-lookup"><span data-stu-id="87787-240">You should never persist date and time data in a format that can vary by culture.</span></span> <span data-ttu-id="87787-241">これは、データの破損または実行時例外が発生する一般的なプログラミング エラーです。</span><span class="sxs-lookup"><span data-stu-id="87787-241">This is a common programming error that results in either corrupted data or a run-time exception.</span></span> <span data-ttu-id="87787-242">次の例では、英語 (米国) カルチャの書式指定規則を使用して文字列として 2 つの日付 (2013 年 1 月 9 日と 2013 年 8 月 18 日) をシリアル化します。</span><span class="sxs-lookup"><span data-stu-id="87787-242">The following example serializes two dates, January 9, 2013 and August 18, 2013, as strings by using the formatting conventions of the English (United States) culture.</span></span> <span data-ttu-id="87787-243">データが英語 (米国) カルチャの規則を使用して取得および解析されると、正常に復元されます。</span><span class="sxs-lookup"><span data-stu-id="87787-243">When the data is retrieved and parsed by using the conventions of the English (United States) culture, it is successfully restored.</span></span> <span data-ttu-id="87787-244">ただし、英語 (イギリス) カルチャの規則を使用して取得および解析されると、最初の日付は 9 月 1 日と間違って解釈され、グレゴリオ暦には 18 番目の月がないため 2 番目の日付は解析されません。</span><span class="sxs-lookup"><span data-stu-id="87787-244">However, when it is retrieved and parsed by using the conventions of the English (United Kingdom) culture, the first date is wrongly interpreted as September 1, and the second fails to parse because the Gregorian calendar does not have an eighteenth month.</span></span>

[!code-csharp[Conceptual.Globalization#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/dates2.cs#3)]
[!code-vb[Conceptual.Globalization#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/dates2.vb#3)]

<span data-ttu-id="87787-245">この問題は、次の 3 つのうちいずれかの方法で回避できます。</span><span class="sxs-lookup"><span data-stu-id="87787-245">You can avoid this problem in any of three ways:</span></span>

- <span data-ttu-id="87787-246">文字列ではなくバイナリ形式で日付と時刻をシリアル化します。</span><span class="sxs-lookup"><span data-stu-id="87787-246">Serialize the date and time in binary format rather than as a string.</span></span>

- <span data-ttu-id="87787-247">ユーザーのカルチャに関係なく同じであるカスタム書式指定文字列を使用して日付と時刻の文字列表現を保存および解析します。</span><span class="sxs-lookup"><span data-stu-id="87787-247">Save and parse the string representation of the date and time by using a custom format string that is the same regardless of the user's culture.</span></span>

- <span data-ttu-id="87787-248">インバリアント カルチャの書式指定規則を使用して文字列を保存します。</span><span class="sxs-lookup"><span data-stu-id="87787-248">Save the string by using the formatting conventions of the invariant culture.</span></span>

<span data-ttu-id="87787-249">次の例では、最後のアプローチを示します。</span><span class="sxs-lookup"><span data-stu-id="87787-249">The following example illustrates the last approach.</span></span> <span data-ttu-id="87787-250">この例では、静的 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> プロパティによって返されるインバリアント カルチャの書式指定規則を使用します。</span><span class="sxs-lookup"><span data-stu-id="87787-250">It uses the formatting conventions of the invariant culture returned by the static <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> property.</span></span>

[!code-csharp[Conceptual.Globalization#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/dates3.cs#4)]
[!code-vb[Conceptual.Globalization#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/dates3.vb#4)]

### <a name="serialization-and-time-zone-awareness"></a><span data-ttu-id="87787-251">シリアル化とタイム ゾーンへの対応</span><span class="sxs-lookup"><span data-stu-id="87787-251">Serialization and time zone awareness</span></span>

<span data-ttu-id="87787-252">日付と時刻の値は、一般的な時刻 ("店舗は 2013 年 1 月 2 日の午前 9 時に開店します") から特定の時点 ("生年月日:2013 年 1 月 2 日午前 6 時 32 分 00 秒") まで、多様に解釈できます。</span><span class="sxs-lookup"><span data-stu-id="87787-252">A date and time value can have multiple interpretations, ranging from a general time ("The stores open on January 2, 2013, at 9:00 A.M.") to a specific moment in time ("Date of birth: January 2, 2013 6:32:00 A.M.").</span></span> <span data-ttu-id="87787-253">時刻の値が特定の時点を表し、それをシリアル化された値から復元する場合、ユーザーの地理的場所またはタイム ゾーンに関係なく同じ特定の時点を表すことを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="87787-253">When a time value represents a specific moment in time and you restore it from a serialized value, you should ensure that it represents the same moment in time regardless of the user's geographical location or time zone.</span></span>

<span data-ttu-id="87787-254">この問題を説明する例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="87787-254">The following example illustrates this problem.</span></span> <span data-ttu-id="87787-255">この例では、1 つのローカル日付と時刻の値を、3 つの[標準書式](../base-types/standard-date-and-time-format-strings.md) (一般の日付と長い形式の時刻の "G"、並べ替え可能な日付と時刻の "s"、およびラウンド トリップする日付と時刻の "o") の文字列として、およびバイナリ形式で保存します。</span><span class="sxs-lookup"><span data-stu-id="87787-255">It saves a single local date and time value as a string in three [standard formats](../base-types/standard-date-and-time-format-strings.md) ("G" for general date long time, "s" for sortable date/time, and "o" for round-trip date/time) as well as in binary format.</span></span>

[!code-csharp[Conceptual.Globalization#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/dates4.cs#10)]
[!code-vb[Conceptual.Globalization#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/dates4.vb#10)]

<span data-ttu-id="87787-256">シリアル化されたシステムと同じタイム ゾーンのシステムでデータを復元すると、出力に示すように、逆シリアル化された日付と時刻の値は正確に元の値を反映しています。</span><span class="sxs-lookup"><span data-stu-id="87787-256">When the data is restored on a system in the same time zone as the system on which it was serialized, the deserialized date and time values accurately reflect the original value, as the output shows:</span></span>

```console
'3/30/2013 6:00:00 PM' --> 3/30/2013 6:00:00 PM Unspecified
'2013-03-30T18:00:00' --> 3/30/2013 6:00:00 PM Unspecified
'2013-03-30T18:00:00.0000000-07:00' --> 3/30/2013 6:00:00 PM Local

3/30/2013 6:00:00 PM Local
```

<span data-ttu-id="87787-257">ただし、別のタイム ゾーンのシステムでデータを復元する場合は、"o" (ラウンド トリップ) 標準書式指定文字列を使用して書式設定された日付と時刻の値だけがタイム ゾーン情報を維持して、同じ時点を表します。</span><span class="sxs-lookup"><span data-stu-id="87787-257">However, if you restore the data on a system in a different time zone, only the date and time value that was formatted with the "o" (round-trip) standard format string preserves time zone information and therefore represents the same instant in time.</span></span> <span data-ttu-id="87787-258">日付と時刻のデータがロマンス標準時ゾーンのシステムで復元されたときの出力を次に示します。</span><span class="sxs-lookup"><span data-stu-id="87787-258">Here's the output when the date and time data is restored on a system in the Romance Standard Time zone:</span></span>

```console
'3/30/2013 6:00:00 PM' --> 3/30/2013 6:00:00 PM Unspecified
'2013-03-30T18:00:00' --> 3/30/2013 6:00:00 PM Unspecified
'2013-03-30T18:00:00.0000000-07:00' --> 3/31/2013 3:00:00 AM Local

3/30/2013 6:00:00 PM Local
```

<span data-ttu-id="87787-259">データが逆シリアル化されるシステムのタイム ゾーンに関係なく 1 つの時点を表す日付と時刻の値を正確に反映するには、次のいずれかの方法を使用できます。</span><span class="sxs-lookup"><span data-stu-id="87787-259">To accurately reflect a date and time value that represents a single moment of time regardless of the time zone of the system on which the data is deserialized, you can do any of the following:</span></span>

- <span data-ttu-id="87787-260">"o" (ラウンド トリップ) 標準書式指定文字列を使用して値を文字列として保存します。</span><span class="sxs-lookup"><span data-stu-id="87787-260">Save the value as a string by using the "o" (round-trip) standard format string.</span></span> <span data-ttu-id="87787-261">その後、ターゲット システムで逆シリアル化します。</span><span class="sxs-lookup"><span data-stu-id="87787-261">Then deserialize it on the target system.</span></span>

- <span data-ttu-id="87787-262">値を UTC に変換し、"r" (RFC1123) 標準書式指定文字列を使用して文字列として保存します。</span><span class="sxs-lookup"><span data-stu-id="87787-262">Convert it to UTC and save it as a string by using the "r" (RFC1123) standard format string.</span></span> <span data-ttu-id="87787-263">その後、ターゲット システムで逆シリアル化し、現地時刻に変換します。</span><span class="sxs-lookup"><span data-stu-id="87787-263">Then deserialize it on the target system and convert it to local time.</span></span>

- <span data-ttu-id="87787-264">値を UTC に変換し、"u" (世界共通の並べ替え可能な日付と時刻) 標準書式指定文字列を使用して文字列として保存します。</span><span class="sxs-lookup"><span data-stu-id="87787-264">Convert it to UTC and save it as a string by using the "u" (universal sortable) standard format string.</span></span> <span data-ttu-id="87787-265">その後、ターゲット システムで逆シリアル化し、現地時刻に変換します。</span><span class="sxs-lookup"><span data-stu-id="87787-265">Then deserialize it on the target system and convert it to local time.</span></span>

- <span data-ttu-id="87787-266">値を UTC に変換し、バイナリ形式で保存します。</span><span class="sxs-lookup"><span data-stu-id="87787-266">Convert it to UTC and save it in binary format.</span></span> <span data-ttu-id="87787-267">その後、ターゲット システムで逆シリアル化し、現地時刻に変換します。</span><span class="sxs-lookup"><span data-stu-id="87787-267">Then deserialize it on the target system and convert it to local time.</span></span>

<span data-ttu-id="87787-268">各方法の例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="87787-268">The following example illustrates each technique.</span></span>

[!code-csharp[Conceptual.Globalization#11](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/dates8.cs#11)]
[!code-vb[Conceptual.Globalization#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/dates8.vb#11)]

<span data-ttu-id="87787-269">データを太平洋標準時ゾーンのシステムでシリアル化し、ロマンス標準時ゾーンのシステムで逆シリアル化すると、次の出力が表示されます。</span><span class="sxs-lookup"><span data-stu-id="87787-269">When the data is serialized on a system in the Pacific Standard Time zone and deserialized on a system in the Romance Standard Time zone, the example displays the following output:</span></span>

```console
'2013-03-30T18:00:00.0000000-07:00' --> 3/31/2013 3:00:00 AM Local
'Sun, 31 Mar 2013 01:00:00 GMT' --> 3/31/2013 3:00:00 AM Local
'2013-03-31 01:00:00Z' --> 3/31/2013 3:00:00 AM Local

3/31/2013 3:00:00 AM Local
```

<span data-ttu-id="87787-270">詳細については、「[タイム ゾーン間での時刻の変換](../datetime/converting-between-time-zones.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="87787-270">For more information, see [Converting Times Between Time Zones](../datetime/converting-between-time-zones.md).</span></span>

### <a name="perform-date-and-time-arithmetic"></a><span data-ttu-id="87787-271">日付と時刻の演算を実行する</span><span class="sxs-lookup"><span data-stu-id="87787-271">Perform date and time arithmetic</span></span>

<span data-ttu-id="87787-272"><xref:System.DateTime> 型と <xref:System.DateTimeOffset> 型は、算術演算をサポートします。</span><span class="sxs-lookup"><span data-stu-id="87787-272">Both the <xref:System.DateTime> and <xref:System.DateTimeOffset> types support arithmetic operations.</span></span> <span data-ttu-id="87787-273">2 つの日付の値の差を計算したり、日付の値に特定の時間間隔を加算または減算したりできます。</span><span class="sxs-lookup"><span data-stu-id="87787-273">You can calculate the difference between two date values, or you can add or subtract particular time intervals to or from a date value.</span></span> <span data-ttu-id="87787-274">ただし、日付と時刻の値に対する算術演算では、タイム ゾーンとタイム ゾーン調整規則が考慮されません。</span><span class="sxs-lookup"><span data-stu-id="87787-274">However, arithmetic operations on date and time values do not take time zones and time zone adjustment rules into account.</span></span> <span data-ttu-id="87787-275">このため、時点を表す値に対して日付と時刻の算術を実行すると、不正確な結果が返されることがあります。</span><span class="sxs-lookup"><span data-stu-id="87787-275">Because of this, date and time arithmetic on values that represent moments in time can return inaccurate results.</span></span>

<span data-ttu-id="87787-276">たとえば、太平洋標準時から太平洋夏時間への切り替えは、3 月の第 2 日曜日、2013 年の場合は 3 月 10 日に行われます。</span><span class="sxs-lookup"><span data-stu-id="87787-276">For example, the transition from Pacific Standard Time to Pacific Daylight Time occurs on the second Sunday of March, which is March 10 for the year 2013.</span></span> <span data-ttu-id="87787-277">次の例に示すように、太平洋標準時ゾーンのシステムで 2013 年 3 月 9 日午前 10 時 30 分の 48 時間後の日時を計算すると、</span><span class="sxs-lookup"><span data-stu-id="87787-277">As the following example shows, if you calculate the date and time that is 48 hours after March 9, 2013 at 10:30 A.M.</span></span> <span data-ttu-id="87787-278">結果は 2013 年 3 月 11 日午前 10 時 30 分となり、その間の時間調整は考慮されません。</span><span class="sxs-lookup"><span data-stu-id="87787-278">on a system in the Pacific Standard Time zone, the result, March 11, 2013 at 10:30 A.M., does not take the intervening time adjustment into account.</span></span>

[!code-csharp[Conceptual.Globalization#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/dates5.cs#8)]
[!code-vb[Conceptual.Globalization#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/dates5.vb#8)]

<span data-ttu-id="87787-279">日付と時刻の値に対する算術演算によって正確な結果を生成するには、次の手順を実行します。</span><span class="sxs-lookup"><span data-stu-id="87787-279">To ensure that an arithmetic operation on date and time values produces accurate results, follow these steps:</span></span>

1. <span data-ttu-id="87787-280">ソース タイム ゾーンの時刻を UTC に変換します。</span><span class="sxs-lookup"><span data-stu-id="87787-280">Convert the time in the source time zone to UTC.</span></span>

2. <span data-ttu-id="87787-281">算術演算を実行します。</span><span class="sxs-lookup"><span data-stu-id="87787-281">Perform the arithmetic operation.</span></span>

3. <span data-ttu-id="87787-282">結果が日付と時刻の値である場合、UTC からソース タイム ゾーンの時刻に変換します。</span><span class="sxs-lookup"><span data-stu-id="87787-282">If the result is a date and time value, convert it from UTC to the time in the source time zone.</span></span>

<span data-ttu-id="87787-283">次の例は前の例と似ていますが、この 3 つの手順を実行することで、2013 年 3 月 9 日午前 10 時 30 分に 48 時間が正しく追加されています。</span><span class="sxs-lookup"><span data-stu-id="87787-283">The following example is similar to the previous example, except that it follows these three steps to correctly add 48 hours to March 9, 2013 at 10:30 A.M.</span></span>

[!code-csharp[Conceptual.Globalization#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/dates6.cs#9)]
[!code-vb[Conceptual.Globalization#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/dates6.vb#9)]

<span data-ttu-id="87787-284">詳細については、「[日付と時刻を使用した算術演算の実行](../datetime/performing-arithmetic-operations.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="87787-284">For more information, see [Performing Arithmetic Operations with Dates and Times](../datetime/performing-arithmetic-operations.md).</span></span>

### <a name="use-culture-sensitive-names-for-date-elements"></a><span data-ttu-id="87787-285">日付要素にカルチャに依存した名前を使用する</span><span class="sxs-lookup"><span data-stu-id="87787-285">Use culture-sensitive names for date elements</span></span>

<span data-ttu-id="87787-286">アプリによっては、月または曜日の名前を表示することが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="87787-286">Your app may need to display the name of the month or the day of the week.</span></span> <span data-ttu-id="87787-287">これを実行するために、次のようなコードが一般に使用されます。</span><span class="sxs-lookup"><span data-stu-id="87787-287">To do this, code such as the following is common.</span></span>

[!code-csharp[Conceptual.Globalization#19](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/monthname1.cs#19)]
[!code-vb[Conceptual.Globalization#19](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/monthname1.vb#19)]

<span data-ttu-id="87787-288">ただし、このコードは曜日の名前を必ず英語で返します。</span><span class="sxs-lookup"><span data-stu-id="87787-288">However, this code always returns the names of the days of the week in English.</span></span> <span data-ttu-id="87787-289">多くの場合、月の名前を抽出するコードには、さらに柔軟性がありません。</span><span class="sxs-lookup"><span data-stu-id="87787-289">Code that extracts the name of the month is often even more inflexible.</span></span> <span data-ttu-id="87787-290">一般に、このようなコードでは特定の言語の月の名前を使用した 12 か月の暦を前提としています。</span><span class="sxs-lookup"><span data-stu-id="87787-290">It frequently assumes a twelve-month calendar with names of months in a specific language.</span></span>

<span data-ttu-id="87787-291">次の例に示すように、[カスタム日時書式指定文字列](../base-types/custom-date-and-time-format-strings.md)または <xref:System.Globalization.DateTimeFormatInfo> オブジェクトのプロパティを使用すると、ユーザーのカルチャの曜日または月の名前を反映する文字列を簡単に抽出できます。</span><span class="sxs-lookup"><span data-stu-id="87787-291">By using [custom date and time format strings](../base-types/custom-date-and-time-format-strings.md) or the properties of the <xref:System.Globalization.DateTimeFormatInfo> object, it is easy to extract strings that reflect the names of days of the week or months in the user's culture, as the following example illustrates.</span></span> <span data-ttu-id="87787-292">この例では、現在のカルチャをフランス語 (フランス) に変更し、2013 年 7 月 1 日の曜日の名前と月の名前を表示します。</span><span class="sxs-lookup"><span data-stu-id="87787-292">It changes the current culture to French (France) and displays the name of the day of the week and the name of the month for July 1, 2013.</span></span>

[!code-csharp[Conceptual.Globalization#20](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/monthname2.cs#20)]
[!code-vb[Conceptual.Globalization#20](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/monthname2.vb#20)]

## <a name="numeric-values"></a><span data-ttu-id="87787-293">数値</span><span class="sxs-lookup"><span data-stu-id="87787-293">Numeric values</span></span>

<span data-ttu-id="87787-294">数値の処理は、数値をユーザー インターフェイスに表示するのか、保持するのかによって異なります。</span><span class="sxs-lookup"><span data-stu-id="87787-294">The handling of numbers depends on whether they are displayed in the user interface or persisted.</span></span> <span data-ttu-id="87787-295">このセクションでは、両方の使用を検討します。</span><span class="sxs-lookup"><span data-stu-id="87787-295">This section examines both usages.</span></span>

> [!NOTE]
> <span data-ttu-id="87787-296">解析操作と書式設定操作では、.NET は基本ラテン文字 0 から 9 (U+0030 から U+0039) だけを数字として認識します。</span><span class="sxs-lookup"><span data-stu-id="87787-296">In parsing and formatting operations, .NET recognizes only the Basic Latin characters 0 through 9 (U+0030 through U+0039) as numeric digits.</span></span>

### <a name="display-numeric-values"></a><span data-ttu-id="87787-297">数値を表示する</span><span class="sxs-lookup"><span data-stu-id="87787-297">Display numeric values</span></span>

<span data-ttu-id="87787-298">通常、数値をユーザー インターフェイスに表示するときには、<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> プロパティと、<xref:System.Globalization.NumberFormatInfo> プロパティによって返される `CultureInfo.CurrentCulture.NumberFormat` オブジェクトで定義されているユーザーのカルチャの書式指定規則を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="87787-298">Typically, when numbers are displayed in the user interface, you should use the formatting conventions of the user's culture, which is defined by the <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> property and by the <xref:System.Globalization.NumberFormatInfo> object returned by the `CultureInfo.CurrentCulture.NumberFormat` property.</span></span> <span data-ttu-id="87787-299">次のメソッドのいずれかを使用して日付の書式を設定すると、現在のカルチャの書式指定規則が自動的に使用されます。</span><span class="sxs-lookup"><span data-stu-id="87787-299">The formatting conventions of the current culture are automatically used when you format a date by using any of the following methods:</span></span>

- <span data-ttu-id="87787-300">任意の数値型のパラメーターなしの `ToString` メソッド</span><span class="sxs-lookup"><span data-stu-id="87787-300">The parameterless `ToString` method of any numeric type</span></span>

- <span data-ttu-id="87787-301">書式指定文字列を引数として含む任意の数値型の `ToString(String)` メソッド</span><span class="sxs-lookup"><span data-stu-id="87787-301">The `ToString(String)` method of any numeric type, which includes a format string as an argument</span></span>

- <span data-ttu-id="87787-302">[複合書式指定](../base-types/composite-formatting.md)機能 (数値と共に使用する場合)</span><span class="sxs-lookup"><span data-stu-id="87787-302">The [composite formatting](../base-types/composite-formatting.md) feature, when it is used with numeric values</span></span>

<span data-ttu-id="87787-303">次の例では、パリ (フランス) の毎月の平均気温を表示します。</span><span class="sxs-lookup"><span data-stu-id="87787-303">The following example displays the average temperature per month in Paris, France.</span></span> <span data-ttu-id="87787-304">この例では、最初にデータを表示する前に現在のカルチャをフランス語 (フランス) に設定し、次に英語 (米国) に設定します。</span><span class="sxs-lookup"><span data-stu-id="87787-304">It first sets the current culture to French (France) before displaying the data, and then sets it to English (United States).</span></span> <span data-ttu-id="87787-305">どちらの場合も、月の名前と気温はそのカルチャに適した形式で表示されます。</span><span class="sxs-lookup"><span data-stu-id="87787-305">In each case, the month names and temperatures are displayed in the format that is appropriate for that culture.</span></span> <span data-ttu-id="87787-306">この 2 つのカルチャでは、気温の値に使用する小数点記号が異なります。</span><span class="sxs-lookup"><span data-stu-id="87787-306">Note that the two cultures use different decimal separators in the temperature value.</span></span> <span data-ttu-id="87787-307">また、この例では、"MMMM" カスタム日時書式指定文字列を使用して月の正式名を表示し、<xref:System.Globalization.DateTimeFormatInfo.MonthNames%2A?displayProperty=nameWithType> 配列で最も長い月の名前の長さを確認することで、結果の文字列の月の名前に適切な領域を割り当てます。</span><span class="sxs-lookup"><span data-stu-id="87787-307">Also note that the example uses the "MMMM" custom date and time format string to display the full month name, and that it allocates the appropriate amount of space for the month name in the result string by determining the length of the longest month name in the <xref:System.Globalization.DateTimeFormatInfo.MonthNames%2A?displayProperty=nameWithType> array.</span></span>

[!code-csharp[Conceptual.Globalization#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/numbers1.cs#5)]
[!code-vb[Conceptual.Globalization#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/numbers1.vb#5)]

### <a name="persist-numeric-values"></a><span data-ttu-id="87787-308">数値を保持する</span><span class="sxs-lookup"><span data-stu-id="87787-308">Persist numeric values</span></span>

<span data-ttu-id="87787-309">数値データはカルチャ固有の書式で保持しないでください。</span><span class="sxs-lookup"><span data-stu-id="87787-309">You should never persist numeric data in a culture-specific format.</span></span> <span data-ttu-id="87787-310">これは、データの破損または実行時例外が発生する一般的なプログラミング エラーです。</span><span class="sxs-lookup"><span data-stu-id="87787-310">This is a common programming error that results in either corrupted data or a run-time exception.</span></span> <span data-ttu-id="87787-311">次の例では、10 個のランダムな浮動小数点数を生成し、英語 (米国) カルチャの書式指定規則を使用して文字列としてシリアル化します。</span><span class="sxs-lookup"><span data-stu-id="87787-311">The following example generates ten random floating-point numbers, and then serializes them as strings by using the formatting conventions of the English (United States) culture.</span></span> <span data-ttu-id="87787-312">データが英語 (米国) カルチャの規則を使用して取得および解析されると、正常に復元されます。</span><span class="sxs-lookup"><span data-stu-id="87787-312">When the data is retrieved and parsed by using the conventions of the English (United States) culture, it is successfully restored.</span></span> <span data-ttu-id="87787-313">ただし、この数値をフランス語 (フランス) カルチャの規則を使用して取得および解析すると、使用する小数点記号が異なるため、数値はいずれも解析できません。</span><span class="sxs-lookup"><span data-stu-id="87787-313">However, when it is retrieved and parsed by using the conventions of the French (France) culture, none of the numbers can be parsed because the cultures use different decimal separators.</span></span>

[!code-csharp[Conceptual.Globalization#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/numbers2.cs#6)]
[!code-vb[Conceptual.Globalization#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/numbers2.vb#6)]

<span data-ttu-id="87787-314">この問題を回避するには、次の方法のいずれかを使用します。</span><span class="sxs-lookup"><span data-stu-id="87787-314">To avoid this problem, you can use one of these techniques:</span></span>

- <span data-ttu-id="87787-315">ユーザーのカルチャに関係なく同じであるカスタム書式指定文字列を使用して数値の文字列表現を保存および解析します。</span><span class="sxs-lookup"><span data-stu-id="87787-315">Save and parse the string representation of the number by using a custom format string that is the same regardless of the user's culture.</span></span>

- <span data-ttu-id="87787-316"><xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> プロパティによって返されるインバリアント カルチャの書式指定規則を使用して文字列として数値を保存します。</span><span class="sxs-lookup"><span data-stu-id="87787-316">Save the number as a string by using the formatting conventions of the invariant culture, which is returned by the <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> property.</span></span>

- <span data-ttu-id="87787-317">文字列形式ではなく、バイナリで数値をシリアル化します。</span><span class="sxs-lookup"><span data-stu-id="87787-317">Serialize the number in binary instead of string format.</span></span>

<span data-ttu-id="87787-318">次の例では、最後のアプローチを示します。</span><span class="sxs-lookup"><span data-stu-id="87787-318">The following example illustrates the last approach.</span></span> <span data-ttu-id="87787-319">この例では、<xref:System.Double> 値の配列をシリアル化し、英語 (米国) カルチャとフランス語 (フランス) カルチャの書式指定規則を使用して逆シリアル化して、表示します。</span><span class="sxs-lookup"><span data-stu-id="87787-319">It serializes the array of <xref:System.Double> values, and then deserializes and displays them by using the formatting conventions of the English (United States) and French (France) cultures.</span></span>

[!code-csharp[Conceptual.Globalization#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/numbers3.cs#7)]
[!code-vb[Conceptual.Globalization#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/numbers3.vb#7)]

<span data-ttu-id="87787-320">通貨値のシリアル化は特殊なケースです。</span><span class="sxs-lookup"><span data-stu-id="87787-320">Serializing currency values is a special case.</span></span> <span data-ttu-id="87787-321">通貨値は、それが表現されている通貨の単位に依存するため、独立した数値として扱う意味はほとんどありません。</span><span class="sxs-lookup"><span data-stu-id="87787-321">Because a currency value depends on the unit of currency in which it is expressed; it makes little sense to treat it as an independent numeric value.</span></span> <span data-ttu-id="87787-322">ただし、通貨値を、通貨記号を含んだ書式設定された文字列として保存する場合、次の例に示すように、既定のカルチャが異なる通貨記号を使用するシステムで逆シリアル化できません。</span><span class="sxs-lookup"><span data-stu-id="87787-322">However, if you save a currency value as a formatted string that includes a currency symbol, it cannot be deserialized on a system whose default culture uses a different currency symbol, as the following example shows.</span></span>

[!code-csharp[Conceptual.Globalization#16](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/currency1.cs#16)]
[!code-vb[Conceptual.Globalization#16](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/currency1.vb#16)]

<span data-ttu-id="87787-323">代わりに、カルチャの名前など、カルチャに関する情報と共に数値をシリアル化して、値とその通貨記号が現在のカルチャと関係なく逆シリアル化できるようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="87787-323">Instead, you should serialize the numeric value along with some cultural information, such as the name of the culture, so that the value and its currency symbol can be deserialized independently of the current culture.</span></span> <span data-ttu-id="87787-324">次の例では、2 つメンバーを使用して `CurrencyValue` 構造体を定義することでこれを実行しています。2 つのメンバーは、<xref:System.Decimal> 値とその値が属するカルチャの名前です。</span><span class="sxs-lookup"><span data-stu-id="87787-324">The following example does that by defining a `CurrencyValue` structure with two members: the <xref:System.Decimal> value and the name of the culture to which the value belongs.</span></span>

[!code-csharp[Conceptual.Globalization#17](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/currency2.cs#17)]
[!code-vb[Conceptual.Globalization#17](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/currency2.vb#17)]

## <a name="work-with-culture-specific-settings"></a><span data-ttu-id="87787-325">カルチャ固有の設定を使用する</span><span class="sxs-lookup"><span data-stu-id="87787-325">Work with culture-specific settings</span></span>

<span data-ttu-id="87787-326">.NET では、特定のカルチャまたは地域は <xref:System.Globalization.CultureInfo> クラスによって表されます。</span><span class="sxs-lookup"><span data-stu-id="87787-326">In .NET, the <xref:System.Globalization.CultureInfo> class represents a particular culture or region.</span></span> <span data-ttu-id="87787-327">そのプロパティの一部は、カルチャのある側面に関する特定の情報を提供するオブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="87787-327">Some of its properties return objects that provide specific information about some aspect of a culture:</span></span>

- <span data-ttu-id="87787-328"><xref:System.Globalization.CultureInfo.CompareInfo%2A?displayProperty=nameWithType> プロパティは、カルチャによる文字列の比較方法および並べ替え方法に関する情報を含んだ <xref:System.Globalization.CompareInfo> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="87787-328">The <xref:System.Globalization.CultureInfo.CompareInfo%2A?displayProperty=nameWithType> property returns a <xref:System.Globalization.CompareInfo> object that contains information about how the culture compares and orders strings.</span></span>

- <span data-ttu-id="87787-329"><xref:System.Globalization.CultureInfo.DateTimeFormat%2A?displayProperty=nameWithType> プロパティは、日付と時刻のデータの書式設定で使用されるカルチャ固有の情報を提供する <xref:System.Globalization.DateTimeFormatInfo> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="87787-329">The <xref:System.Globalization.CultureInfo.DateTimeFormat%2A?displayProperty=nameWithType> property returns a <xref:System.Globalization.DateTimeFormatInfo> object that provides culture-specific information used in formatting date and time data.</span></span>

- <span data-ttu-id="87787-330"><xref:System.Globalization.CultureInfo.NumberFormat%2A?displayProperty=nameWithType> プロパティは、数値データの書式設定で使用されるカルチャ固有の情報を提供する <xref:System.Globalization.NumberFormatInfo> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="87787-330">The <xref:System.Globalization.CultureInfo.NumberFormat%2A?displayProperty=nameWithType> property returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information used in formatting numeric data.</span></span>

- <span data-ttu-id="87787-331"><xref:System.Globalization.CultureInfo.TextInfo%2A?displayProperty=nameWithType> プロパティは、カルチャの書記体系に関する情報を提供する <xref:System.Globalization.TextInfo> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="87787-331">The <xref:System.Globalization.CultureInfo.TextInfo%2A?displayProperty=nameWithType> property returns a <xref:System.Globalization.TextInfo> object that provides information about the culture's writing system.</span></span>

<span data-ttu-id="87787-332">一般に、特定の <xref:System.Globalization.CultureInfo> プロパティおよび関連するオブジェクトの値について何も想定しないでください。</span><span class="sxs-lookup"><span data-stu-id="87787-332">In general, do not make any assumptions about the values of specific <xref:System.Globalization.CultureInfo> properties and their related objects.</span></span> <span data-ttu-id="87787-333">代わりに、次の理由により、カルチャ固有のデータは変更される可能性があると考える必要があります。</span><span class="sxs-lookup"><span data-stu-id="87787-333">Instead, you should view culture-specific data as subject to change, for these reasons:</span></span>

- <span data-ttu-id="87787-334">個々のプロパティ値は、データが修正された、より優れたデータが使用可能になった、カルチャ固有の規則が変更されたなどの理由で、時間と共に変更または修正される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="87787-334">Individual property values are subject to change and revision over time, as data is corrected, better data becomes available, or culture-specific conventions change.</span></span>

- <span data-ttu-id="87787-335">個々のプロパティ値は、.NET のバージョンまたはオペレーティング システムのバージョン間で異なる場合があります。</span><span class="sxs-lookup"><span data-stu-id="87787-335">Individual property values may vary across versions of .NET or operating system versions.</span></span>

- <span data-ttu-id="87787-336">.NET では置換カルチャをサポートしています。</span><span class="sxs-lookup"><span data-stu-id="87787-336">.NET supports replacement cultures.</span></span> <span data-ttu-id="87787-337">これにより、既存の標準カルチャを補足または既存の標準カルチャを完全に置き換える新しいカスタム カルチャを定義できます。</span><span class="sxs-lookup"><span data-stu-id="87787-337">This makes it possible to define a new custom culture that either supplements existing standard cultures or completely replaces an existing standard culture.</span></span>

- <span data-ttu-id="87787-338">Windows システムのユーザーは、コントロール パネルの **[地域と言語]** アプリを使用してカルチャ固有の設定をカスタマイズできます。</span><span class="sxs-lookup"><span data-stu-id="87787-338">On Windows systems, the user can customize culture-specific settings by using the **Region and Language** app in Control Panel.</span></span> <span data-ttu-id="87787-339"><xref:System.Globalization.CultureInfo> オブジェクトをインスタンス化するときに、<xref:System.Globalization.CultureInfo.%23ctor%28System.String%2CSystem.Boolean%29> コンストラクターを呼び出すことでこのようなユーザーによるカスタマイズを反映するかどうかを決定できます。</span><span class="sxs-lookup"><span data-stu-id="87787-339">When you instantiate a <xref:System.Globalization.CultureInfo> object, you can determine whether it reflects these user customizations by calling the <xref:System.Globalization.CultureInfo.%23ctor%28System.String%2CSystem.Boolean%29> constructor.</span></span> <span data-ttu-id="87787-340">通常は、エンド ユーザーのアプリでは、ユーザー設定を尊重して、ユーザー自身が予期する形式でデータを表示する必要があります。</span><span class="sxs-lookup"><span data-stu-id="87787-340">Typically, for end-user apps, you should respect user preferences so that the user is presented with data in a format that they expect.</span></span>

## <a name="see-also"></a><span data-ttu-id="87787-341">関連項目</span><span class="sxs-lookup"><span data-stu-id="87787-341">See also</span></span>

- [<span data-ttu-id="87787-342">グローバライズとローカライズ</span><span class="sxs-lookup"><span data-stu-id="87787-342">Globalization and Localization</span></span>](index.md)
- [<span data-ttu-id="87787-343">文字列を使用するためのベスト プラクティス</span><span class="sxs-lookup"><span data-stu-id="87787-343">Best Practices for Using Strings</span></span>](../base-types/best-practices-strings.md)
