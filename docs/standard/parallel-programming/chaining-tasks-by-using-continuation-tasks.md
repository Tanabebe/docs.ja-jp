---
title: 継続タスクを使用したタスクの連結
description: .NET の継続タスクを使用してタスクを連鎖させる方法について説明します。 継続タスクは、別のタスクによって呼び出される非同期タスクです。
ms.date: 01/06/2021
dev_langs:
- csharp
- vb
helpviewer_keywords:
- tasks, continuations
ms.assetid: 0b45e9a2-de28-46ce-8212-1817280ed42d
ms.openlocfilehash: c42b6ef7b72cec1846517c700ab6ed34046ed7de
ms.sourcegitcommit: 5d9cee27d9ffe8f5670e5f663434511e81b8ac38
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/08/2021
ms.locfileid: "98025421"
---
# <a name="chaining-tasks-using-continuation-tasks"></a><span data-ttu-id="a7d02-104">継続タスクを使用したタスクの連結</span><span class="sxs-lookup"><span data-stu-id="a7d02-104">Chaining tasks using continuation tasks</span></span>

<span data-ttu-id="a7d02-105">非同期プログラミングでは、非同期操作の完了時に 2 番目の操作を呼び出すのが一般的です。</span><span class="sxs-lookup"><span data-stu-id="a7d02-105">In asynchronous programming, it's common for one asynchronous operation, on completion, to invoke a second operation.</span></span> <span data-ttu-id="a7d02-106">継続によって、相続する操作で最初の操作の結果を使用できるようになります。</span><span class="sxs-lookup"><span data-stu-id="a7d02-106">Continuations allow decedent operations to consume the results of the first operation.</span></span> <span data-ttu-id="a7d02-107">これまで、継続はコールバック メソッドを使用して行っていました。</span><span class="sxs-lookup"><span data-stu-id="a7d02-107">Traditionally, continuations have been done by using callback methods.</span></span> <span data-ttu-id="a7d02-108">タスク並列ライブラリでは、 _継続タスク_ に同じ機能が用意されています。</span><span class="sxs-lookup"><span data-stu-id="a7d02-108">In the Task Parallel Library, the same functionality is provided by _continuation tasks_.</span></span> <span data-ttu-id="a7d02-109">継続タスク (単に "継続" とも呼ばれます) とは、別のタスク (" _継続元_" と呼ばれます) が終了したときに、そのタスクによって呼び出される非同期タスクのことです。</span><span class="sxs-lookup"><span data-stu-id="a7d02-109">A continuation task (also known just as a continuation) is an asynchronous task that's invoked by another task, known as the _antecedent_, when the antecedent finishes.</span></span>

<span data-ttu-id="a7d02-110">継続は比較的簡単に使用できますが、強力な機能と柔軟性を備えています。</span><span class="sxs-lookup"><span data-stu-id="a7d02-110">Continuations are relatively easy to use, but are nevertheless powerful and flexible.</span></span> <span data-ttu-id="a7d02-111">たとえば、次のように操作できます。</span><span class="sxs-lookup"><span data-stu-id="a7d02-111">For example, you can:</span></span>

- <span data-ttu-id="a7d02-112">継続元のデータを継続に渡します。</span><span class="sxs-lookup"><span data-stu-id="a7d02-112">Pass data from the antecedent to the continuation.</span></span>
- <span data-ttu-id="a7d02-113">継続を呼び出す場合、呼び出さない場合についての正確な条件を指定します。</span><span class="sxs-lookup"><span data-stu-id="a7d02-113">Specify the precise conditions under which the continuation will be invoked or not invoked.</span></span>
- <span data-ttu-id="a7d02-114">継続が開始される前、または継続の実行中に継続を取り消します。</span><span class="sxs-lookup"><span data-stu-id="a7d02-114">Cancel a continuation either before it starts or cooperatively as it is running.</span></span>
- <span data-ttu-id="a7d02-115">継続をスケジュールする方法についてのヒントを提供します。</span><span class="sxs-lookup"><span data-stu-id="a7d02-115">Provide hints about how the continuation should be scheduled.</span></span>
- <span data-ttu-id="a7d02-116">同じ継続元から複数の継続を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="a7d02-116">Invoke multiple continuations from the same antecedent.</span></span>
- <span data-ttu-id="a7d02-117">複数の継続元のすべてまたはいずれか 1 つが完了したときに 1 つの継続を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="a7d02-117">Invoke one continuation when all or any one of multiple antecedents complete.</span></span>
- <span data-ttu-id="a7d02-118">任意の長さで連続して継続を実行します。</span><span class="sxs-lookup"><span data-stu-id="a7d02-118">Chain continuations one after another to any arbitrary length.</span></span>
- <span data-ttu-id="a7d02-119">継続元によってスローされた例外を処理するために継続を使用します。</span><span class="sxs-lookup"><span data-stu-id="a7d02-119">Use a continuation to handle exceptions thrown by the antecedent.</span></span>

## <a name="about-continuations"></a><span data-ttu-id="a7d02-120">継続について</span><span class="sxs-lookup"><span data-stu-id="a7d02-120">About continuations</span></span>

<span data-ttu-id="a7d02-121">継続とは、 <xref:System.Threading.Tasks.TaskStatus.WaitingForActivation> 状態で作成されるタスクです。</span><span class="sxs-lookup"><span data-stu-id="a7d02-121">A continuation is a task that is created in the <xref:System.Threading.Tasks.TaskStatus.WaitingForActivation> state.</span></span> <span data-ttu-id="a7d02-122">継続は、その継続元タスクが完了すると自動的に開始されます。</span><span class="sxs-lookup"><span data-stu-id="a7d02-122">It is activated automatically when its antecedent task or tasks complete.</span></span> <span data-ttu-id="a7d02-123">ユーザー コード内の継続で <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> を呼び出すと、 <xref:System.InvalidOperationException?displayProperty=nameWithType> 例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="a7d02-123">Calling <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> on a continuation in user code throws an <xref:System.InvalidOperationException?displayProperty=nameWithType> exception.</span></span>

<span data-ttu-id="a7d02-124">継続はそれ自体が <xref:System.Threading.Tasks.Task> であり、継続が開始されたスレッドをブロックするわけではありません。</span><span class="sxs-lookup"><span data-stu-id="a7d02-124">A continuation is itself a <xref:System.Threading.Tasks.Task> and does not block the thread on which it is started.</span></span> <span data-ttu-id="a7d02-125">継続タスクが終了するまでブロックするには、 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="a7d02-125">Call the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method to block until the continuation task finishes.</span></span>

## <a name="create-a-continuation-for-a-single-antecedent"></a><span data-ttu-id="a7d02-126">1 つの継続元に対する継続を作成する</span><span class="sxs-lookup"><span data-stu-id="a7d02-126">Create a continuation for a single antecedent</span></span>

<span data-ttu-id="a7d02-127"><xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> メソッドを呼び出して、継続元が完了した時点で実行される継続を作成します。</span><span class="sxs-lookup"><span data-stu-id="a7d02-127">You create a continuation that executes when its antecedent has completed by calling the <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="a7d02-128">次の例は、基本的なパターンを示しています (わかりやすくするために、例外処理は省略されています)。</span><span class="sxs-lookup"><span data-stu-id="a7d02-128">The following example shows the basic pattern (for clarity, exception handling is omitted).</span></span> <span data-ttu-id="a7d02-129">現在の曜日の名前を示す `taskA`オブジェクトを返す継続元タスク <xref:System.DayOfWeek> が実行されます。</span><span class="sxs-lookup"><span data-stu-id="a7d02-129">It executes an antecedent task, `taskA`, that returns a <xref:System.DayOfWeek> object that indicates the name of the current day of the week.</span></span> <span data-ttu-id="a7d02-130">継続元が完了すると、継続タスク `continuation` に継続元が渡され、その結果を示す文字列が表示されます。</span><span class="sxs-lookup"><span data-stu-id="a7d02-130">When the antecedent completes, the continuation task, `continuation`, is passed the antecedent and displays a string that includes its result.</span></span>

> [!NOTE]
> <span data-ttu-id="a7d02-131">この記事の C# サンプルでは、`Main` メソッド上で `async` 修飾子が利用されています。</span><span class="sxs-lookup"><span data-stu-id="a7d02-131">The C# samples in this article make use of the `async` modifier on the `Main` method.</span></span> <span data-ttu-id="a7d02-132">この機能は C# 7.1 以降で使用できます。</span><span class="sxs-lookup"><span data-stu-id="a7d02-132">That feature is available in C# 7.1 and later.</span></span> <span data-ttu-id="a7d02-133">以前のバージョンでは、このサンプル コードをコンパイルすると、[`CS5001`](../../csharp/misc/cs5001.md) が生成されます。</span><span class="sxs-lookup"><span data-stu-id="a7d02-133">Previous versions generate [`CS5001`](../../csharp/misc/cs5001.md) when compiling this sample code.</span></span> <span data-ttu-id="a7d02-134">言語バージョンを C# 7.1 以降に設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="a7d02-134">You'll need to set the language version to C# 7.1 or newer.</span></span> <span data-ttu-id="a7d02-135">言語バージョンの構成方法については、[言語バージョンの構成](../../csharp/language-reference/configure-language-version.md)に関する記事を参照してください。</span><span class="sxs-lookup"><span data-stu-id="a7d02-135">You can learn how to configure the language version in the article on [configure language version](../../csharp/language-reference/configure-language-version.md).</span></span>

:::code language="csharp" source="snippets/cs/simple1.cs":::

[!code-vb[TPL_Continuations#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/simple1.vb#1)]

## <a name="create-a-continuation-for-multiple-antecedents"></a><span data-ttu-id="a7d02-136">複数の継続元に対する継続を作成する</span><span class="sxs-lookup"><span data-stu-id="a7d02-136">Create a continuation for multiple antecedents</span></span>

<span data-ttu-id="a7d02-137">タスク グループの一部または全部のタスクが完了したときに実行される継続を作成することもできます。</span><span class="sxs-lookup"><span data-stu-id="a7d02-137">You can also create a continuation that will run when any or all of a group of tasks has completed.</span></span> <span data-ttu-id="a7d02-138">すべての継続元タスクが完了した時点で継続を実行するには、静的 (Visual Basic では`Shared` ) <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> メソッドまたはインスタンス <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="a7d02-138">To execute a continuation when all antecedent tasks have completed, you call the static (`Shared` in Visual Basic) <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> method or the instance <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="a7d02-139">いずれかの継続元タスクが完了した時点で継続を実行するには、静的 (Visual Basic では`Shared` ) <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> メソッドまたはインスタンス <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="a7d02-139">To execute a continuation when any of the antecedent tasks has completed, you call the static (`Shared` in Visual Basic) <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> method or the instance <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="a7d02-140"><xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> および <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> オーバーロードの呼び出しによって、呼び出しスレッドがブロックされることはありません。</span><span class="sxs-lookup"><span data-stu-id="a7d02-140">Calls to the <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> overloads do not block the calling thread.</span></span> <span data-ttu-id="a7d02-141">ただし、通常、返された <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> プロパティを取得するために <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType> メソッドと <xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29?displayProperty=nameWithType> メソッドを除いたすべてを呼び出しますが、そうした場合は呼び出しスレッドがブロックされます。</span><span class="sxs-lookup"><span data-stu-id="a7d02-141">However, you typically call all but the <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29?displayProperty=nameWithType> methods to retrieve the returned <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property, which does block the calling thread.</span></span>

<span data-ttu-id="a7d02-142">次の例では、<xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType> メソッドを呼び出して、10 個の継続元タスクの結果を反映する継続タスクを作成します。</span><span class="sxs-lookup"><span data-stu-id="a7d02-142">The following example calls the <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType> method to create a continuation task that reflects the results of its 10 antecedent tasks.</span></span> <span data-ttu-id="a7d02-143">各継続元タスクでは、1 から 10 までの範囲内のインデックス値が二乗されます。</span><span class="sxs-lookup"><span data-stu-id="a7d02-143">Each antecedent task squares an index value that ranges from one to 10.</span></span> <span data-ttu-id="a7d02-144">継続元が正常に完了すると (その <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> プロパティが <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=nameWithType>)、継続の <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> プロパティは、各継続元から返される <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 値の配列になります。</span><span class="sxs-lookup"><span data-stu-id="a7d02-144">If the antecedents complete successfully (their <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property is <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=nameWithType>), the <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property of the continuation is an array of the <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> values returned by each antecedent.</span></span> <span data-ttu-id="a7d02-145">この例では、1 から 10 までのすべての数値の二乗の合計を計算するため、これらを追加します。</span><span class="sxs-lookup"><span data-stu-id="a7d02-145">The example adds them to compute the sum of squares for all numbers between one and 10.</span></span>

:::code language="csharp" source="snippets/cs/whenall1.cs":::

[!code-vb[TPL_Continuations#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/whenall1.vb#5)]

## <a name="continuation-options"></a><span data-ttu-id="a7d02-146">継続のオプション</span><span class="sxs-lookup"><span data-stu-id="a7d02-146">Continuation options</span></span>

<span data-ttu-id="a7d02-147">単一タスクの継続を作成する場合、 <xref:System.Threading.Tasks.Task.ContinueWith%2A> 列挙体の値を取得する <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> オーバーロードを使用して、継続の開始条件を指定できます。</span><span class="sxs-lookup"><span data-stu-id="a7d02-147">When you create a single-task continuation, you can use a <xref:System.Threading.Tasks.Task.ContinueWith%2A> overload that takes a <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> enumeration value to specify the conditions under which the continuation starts.</span></span> <span data-ttu-id="a7d02-148">たとえば、継続元が正常に完了した場合のみ、または違反状態で完了した場合にのみ継続を実行するように指定できます。</span><span class="sxs-lookup"><span data-stu-id="a7d02-148">For example, you can specify that the continuation is to run only if the antecedent completes successfully, or only if it completes in a faulted state.</span></span> <span data-ttu-id="a7d02-149">継続元で継続を呼び出す準備ができているときに条件が true でない場合、継続は直接 <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> 状態に遷移し、それ以降は継続タスクを開始できません。</span><span class="sxs-lookup"><span data-stu-id="a7d02-149">If the condition is not true when the antecedent is ready to invoke the continuation, the continuation transitions directly to the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> state and subsequently cannot be started.</span></span>

<span data-ttu-id="a7d02-150">複数タスク継続メソッド ( <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> メソッドのオーバーロードなど) の多くには、 <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> パラメーターも含まれています。</span><span class="sxs-lookup"><span data-stu-id="a7d02-150">A number of multi-task continuation methods, such as overloads of the <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> method, also include a <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> parameter.</span></span> <span data-ttu-id="a7d02-151">ただし、すべての <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> 列挙体メンバーのサブセットだけが有効です。</span><span class="sxs-lookup"><span data-stu-id="a7d02-151">Only a subset of all <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> enumeration members are valid, however.</span></span> <span data-ttu-id="a7d02-152"><xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> 列挙体に対応する値がある <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> 値を指定できます ( <xref:System.Threading.Tasks.TaskContinuationOptions.AttachedToParent?displayProperty=nameWithType>、 <xref:System.Threading.Tasks.TaskContinuationOptions.LongRunning?displayProperty=nameWithType>、 <xref:System.Threading.Tasks.TaskContinuationOptions.PreferFairness?displayProperty=nameWithType>など)。</span><span class="sxs-lookup"><span data-stu-id="a7d02-152">You can specify <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> values that have counterparts in the <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> enumeration, such as <xref:System.Threading.Tasks.TaskContinuationOptions.AttachedToParent?displayProperty=nameWithType>, <xref:System.Threading.Tasks.TaskContinuationOptions.LongRunning?displayProperty=nameWithType>, and <xref:System.Threading.Tasks.TaskContinuationOptions.PreferFairness?displayProperty=nameWithType>.</span></span> <span data-ttu-id="a7d02-153">複数タスクの継続で `NotOn` または `OnlyOn` オプションのいずれかを指定すると、実行時に <xref:System.ArgumentOutOfRangeException> 例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="a7d02-153">If you specify any of the `NotOn` or `OnlyOn` options with a multi-task continuation, an <xref:System.ArgumentOutOfRangeException> exception will be thrown at run time.</span></span>

<span data-ttu-id="a7d02-154">タスクの継続のオプションの詳細については、「 <xref:System.Threading.Tasks.TaskContinuationOptions> 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="a7d02-154">For more information on task continuation options, see the <xref:System.Threading.Tasks.TaskContinuationOptions> topic.</span></span>

## <a name="pass-data-to-a-continuation"></a><span data-ttu-id="a7d02-155">継続にデータを渡す</span><span class="sxs-lookup"><span data-stu-id="a7d02-155">Pass data to a continuation</span></span>

<span data-ttu-id="a7d02-156"><xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> メソッドは、継続元への参照を、継続のユーザー デリゲートに引数として渡します。</span><span class="sxs-lookup"><span data-stu-id="a7d02-156">The <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method passes a reference to the antecedent to the user delegate of the continuation as an argument.</span></span> <span data-ttu-id="a7d02-157">継続元が <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> オブジェクトで、そのタスクが完了まで実行された場合、継続はそのタスクの <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> プロパティにアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="a7d02-157">If the antecedent is a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> object, and the task ran until it was completed, then the continuation can access the <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property of the task.</span></span>

<span data-ttu-id="a7d02-158"><xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> プロパティは、タスクが完了するまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="a7d02-158">The <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property blocks until the task has completed.</span></span> <span data-ttu-id="a7d02-159">ただし、タスクがキャンセルまたは違反になった場合は、 <xref:System.Threading.Tasks.Task%601.Result%2A> プロパティにアクセスしようとすると <xref:System.AggregateException> 例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="a7d02-159">However, if the task was canceled or faulted, attempting to access the <xref:System.Threading.Tasks.Task%601.Result%2A> property throws an <xref:System.AggregateException> exception.</span></span> <span data-ttu-id="a7d02-160">この問題を回避するには、次の例で示すように <xref:System.Threading.Tasks.TaskContinuationOptions.OnlyOnRanToCompletion> オプションを使用します。</span><span class="sxs-lookup"><span data-stu-id="a7d02-160">You can avoid this problem by using the <xref:System.Threading.Tasks.TaskContinuationOptions.OnlyOnRanToCompletion> option, as shown in the following example.</span></span>

:::code language="csharp" source="snippets/cs/result1.cs":::

[!code-vb[TPL_Continuations#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/result1.vb#2)]

<span data-ttu-id="a7d02-161">継続元が正常に完了するまで実行されなかった場合でも継続を実行する場合は、例外を防ぐ必要があります。</span><span class="sxs-lookup"><span data-stu-id="a7d02-161">If you want the continuation to run even if the antecedent did not run to successful completion, you must guard against the exception.</span></span> <span data-ttu-id="a7d02-162">1 つの方法として、継続元の <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> プロパティをテストし、状態が <xref:System.Threading.Tasks.Task%601.Result%2A> でも <xref:System.Threading.Tasks.TaskStatus.Faulted> でもない場合にのみ <xref:System.Threading.Tasks.TaskStatus.Canceled>プロパティへのアクセスを試みるようにします。</span><span class="sxs-lookup"><span data-stu-id="a7d02-162">One approach is to test the <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property of the antecedent, and only attempt to access the <xref:System.Threading.Tasks.Task%601.Result%2A> property if the status is not <xref:System.Threading.Tasks.TaskStatus.Faulted> or <xref:System.Threading.Tasks.TaskStatus.Canceled>.</span></span> <span data-ttu-id="a7d02-163">また、継続元の <xref:System.Threading.Tasks.Task.Exception%2A> プロパティを調べることもできます。</span><span class="sxs-lookup"><span data-stu-id="a7d02-163">You can also examine the <xref:System.Threading.Tasks.Task.Exception%2A> property of the antecedent.</span></span> <span data-ttu-id="a7d02-164">詳細については、「[例外処理](exception-handling-task-parallel-library.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="a7d02-164">For more information, see [Exception Handling](exception-handling-task-parallel-library.md).</span></span> <span data-ttu-id="a7d02-165">次の例では、前の例を変更して、状態が <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> の場合にだけ継続元の <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=nameWithType>プロパティにアクセスするようにします。</span><span class="sxs-lookup"><span data-stu-id="a7d02-165">The following example modifies the previous example to access antecedent's <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property only if its status is <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=nameWithType>.</span></span>

:::code language="csharp" source="snippets/cs/result2.cs":::

[!code-vb[TPL_Continuations#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/result2.vb#7)]

## <a name="cancel-a-continuation"></a><span data-ttu-id="a7d02-166">継続をキャンセルする</span><span class="sxs-lookup"><span data-stu-id="a7d02-166">Cancel a continuation</span></span>

<span data-ttu-id="a7d02-167">継続の <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> プロパティが <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> 状態になるのは、次のような場合です。</span><span class="sxs-lookup"><span data-stu-id="a7d02-167">The <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property of a continuation is set to <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> in the following situations:</span></span>

- <span data-ttu-id="a7d02-168">キャンセル要求への応答として <xref:System.OperationCanceledException> 例外をスローした場合。</span><span class="sxs-lookup"><span data-stu-id="a7d02-168">It throws an <xref:System.OperationCanceledException> exception in response to a cancellation request.</span></span> <span data-ttu-id="a7d02-169">他のタスクと同様に、例外には継続に渡されたのと同じトークンが含まれ、連携によるキャンセルの受信確認として扱われます。</span><span class="sxs-lookup"><span data-stu-id="a7d02-169">As with any task, if the exception contains the same token that was passed to the continuation, it is treated as an acknowledgment of cooperative cancellation.</span></span>
- <span data-ttu-id="a7d02-170"><xref:System.Threading.CancellationToken?displayProperty=nameWithType> プロパティが <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> である `true`が継続に渡された場合。</span><span class="sxs-lookup"><span data-stu-id="a7d02-170">The continuation is passed a <xref:System.Threading.CancellationToken?displayProperty=nameWithType> whose <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property is `true`.</span></span> <span data-ttu-id="a7d02-171">この場合、継続は開始されずに、 <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> 状態に遷移します。</span><span class="sxs-lookup"><span data-stu-id="a7d02-171">In this case, the continuation does not start, and it transitions to the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> state.</span></span>
- <span data-ttu-id="a7d02-172">継続の <xref:System.Threading.Tasks.TaskContinuationOptions> 引数により設定された条件が満たされないために、継続が実行されない場合。</span><span class="sxs-lookup"><span data-stu-id="a7d02-172">The continuation never runs because the condition set by its <xref:System.Threading.Tasks.TaskContinuationOptions> argument was not met.</span></span> <span data-ttu-id="a7d02-173">たとえば、継続元が <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> 状態になった場合、 <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnFaulted?displayProperty=nameWithType> オプションが渡された継続は <xref:System.Threading.Tasks.TaskStatus.Canceled> 状態に遷移し、実行されません。</span><span class="sxs-lookup"><span data-stu-id="a7d02-173">For example, if an antecedent goes into a <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> state, its continuation that was passed the <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnFaulted?displayProperty=nameWithType> option will not run but will transition to the <xref:System.Threading.Tasks.TaskStatus.Canceled> state.</span></span>

<span data-ttu-id="a7d02-174">タスクとその継続が同じ論理的操作の 2 つの部分を表す場合は、次の例に示すように、同じキャンセル トークンを両方のタスクに渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="a7d02-174">If a task and its continuation represent two parts of the same logical operation, you can pass the same cancellation token to both tasks, as shown in the following example.</span></span> <span data-ttu-id="a7d02-175">これは、33 で割り切れる整数のリストを生成する継続元からなります。このリストは継続に渡されます。</span><span class="sxs-lookup"><span data-stu-id="a7d02-175">It consists of an antecedent that generates a list of integers that are divisible by 33, which it passes to the continuation.</span></span> <span data-ttu-id="a7d02-176">次に継続により、このリストが表示されます。</span><span class="sxs-lookup"><span data-stu-id="a7d02-176">The continuation in turn displays the list.</span></span> <span data-ttu-id="a7d02-177">継続元と継続の両方は、ランダムな間隔で定期的に一時停止します。</span><span class="sxs-lookup"><span data-stu-id="a7d02-177">Both the antecedent and the continuation pause regularly for random intervals.</span></span> <span data-ttu-id="a7d02-178">さらに、 <xref:System.Threading.Timer?displayProperty=nameWithType> オブジェクトを使用して、5 秒のタイムアウト間隔の経過後に `Elapsed` メソッドが実行されます。</span><span class="sxs-lookup"><span data-stu-id="a7d02-178">In addition, a <xref:System.Threading.Timer?displayProperty=nameWithType> object is used to execute the `Elapsed` method after a five-second timeout interval.</span></span> <span data-ttu-id="a7d02-179">この例では、<xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> メソッドが呼び出され、これにより現在実行中のタスクが <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="a7d02-179">This example calls the <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> method, which causes the currently executing task to call the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="a7d02-180">継続元またはその継続の実行時に <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> メソッドが呼び出されるかどうかは、ランダムに生成される一時停止の期間に基づきます。</span><span class="sxs-lookup"><span data-stu-id="a7d02-180">Whether the <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> method is called when the antecedent or its continuation is executing depends on the duration of the randomly generated pauses.</span></span> <span data-ttu-id="a7d02-181">継続元が取り消された場合、継続は開始されません。</span><span class="sxs-lookup"><span data-stu-id="a7d02-181">If the antecedent is canceled, the continuation will not start.</span></span> <span data-ttu-id="a7d02-182">継続元が取り消されない場合は、継続を取り消すためにそのトークンを引き続き使用できます。</span><span class="sxs-lookup"><span data-stu-id="a7d02-182">If the antecedent is not canceled, the token can still be used to cancel the continuation.</span></span>

:::code language="csharp" source="snippets/cs/cancellation1.cs":::

[!code-vb[TPL_Continuations#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/cancellation1.vb#3)]

<span data-ttu-id="a7d02-183">また、継続の作成時に <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled?displayProperty=nameWithType> オプションを指定することで、キャンセル トークンを継続に指定せずに、継続元が取り消された場合に継続を実行しないようにできます。</span><span class="sxs-lookup"><span data-stu-id="a7d02-183">You can also prevent a continuation from executing if its antecedent is canceled without supplying the continuation a cancellation token by specifying the <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled?displayProperty=nameWithType> option when you create the continuation.</span></span> <span data-ttu-id="a7d02-184">単純な例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="a7d02-184">The following is a simple example.</span></span>

:::code language="csharp" source="snippets/cs/cancellation2.cs":::

[!code-vb[TPL_Continuations#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/cancellation2.vb#8)]

<span data-ttu-id="a7d02-185">継続が <xref:System.Threading.Tasks.TaskStatus.Canceled> 状態になると、それらの継続に指定された <xref:System.Threading.Tasks.TaskContinuationOptions> によっては後続の継続に影響を与える場合があります。</span><span class="sxs-lookup"><span data-stu-id="a7d02-185">After a continuation goes into the <xref:System.Threading.Tasks.TaskStatus.Canceled> state, it may affect continuations that follow, depending on the <xref:System.Threading.Tasks.TaskContinuationOptions> that were specified for those continuations.</span></span>

<span data-ttu-id="a7d02-186">破棄された継続は開始されません。</span><span class="sxs-lookup"><span data-stu-id="a7d02-186">Continuations that are disposed will not start.</span></span>

## <a name="continuations-and-child-tasks"></a><span data-ttu-id="a7d02-187">継続と子タスク</span><span class="sxs-lookup"><span data-stu-id="a7d02-187">Continuations and child tasks</span></span>

<span data-ttu-id="a7d02-188">継続は、継続元とアタッチされたすべての子タスクが完了するまでは実行されません。</span><span class="sxs-lookup"><span data-stu-id="a7d02-188">A continuation does not run until the antecedent and all of its attached child tasks have completed.</span></span> <span data-ttu-id="a7d02-189">継続は、デタッチされた子タスクの終了は待機しません。</span><span class="sxs-lookup"><span data-stu-id="a7d02-189">The continuation does not wait for detached child tasks to finish.</span></span> <span data-ttu-id="a7d02-190">次の 2 つの例に、継続を作成する継続元にアタッチされる子タスクと、継続元からデタッチされる子タスクを示します。</span><span class="sxs-lookup"><span data-stu-id="a7d02-190">The following two examples illustrate child tasks that are attached to and detached from an antecedent that creates a continuation.</span></span> <span data-ttu-id="a7d02-191">次の例では、すべての子タスクの完了後にのみ継続が実行されます。この例を複数回実行する場合、出力は毎回同一になります。</span><span class="sxs-lookup"><span data-stu-id="a7d02-191">In the following example, the continuation runs only after all child tasks have completed, and running the example multiple times produces identical output each time.</span></span> <span data-ttu-id="a7d02-192">この例では、<xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> メソッドを呼び出して継続元を起動しています。この理由としては、既定では、<xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> メソッドによって、<xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> を既定のタスク作成オプションとする親タスクが作成されることが挙げられます。</span><span class="sxs-lookup"><span data-stu-id="a7d02-192">The example launches the antecedent by calling the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method, since by default the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> method creates a parent task whose default task creation option is <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.</span></span>

:::code language="csharp" source="snippets/cs/attached1.cs":::

[!code-vb[TPL_Continuations#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/attached1.vb#9)]

<span data-ttu-id="a7d02-193">ただし子タスクが継続元からデタッチされると、子タスクの状態に関係なく、継続元が終了するとただちに継続が実行されます。</span><span class="sxs-lookup"><span data-stu-id="a7d02-193">If child tasks are detached from the antecedent, however, the continuation runs as soon as the antecedent has terminated, regardless of the state of the child tasks.</span></span> <span data-ttu-id="a7d02-194">その結果、次の例を複数回実行すると、タスク スケジューラによる子タスクの処理方法に応じて、異なる出力が生成されることがあります。</span><span class="sxs-lookup"><span data-stu-id="a7d02-194">As a result, multiple runs of the following example can produce variable output that depends on how the task scheduler handled each child task.</span></span>

:::code language="csharp" source="snippets/cs/detached1.cs":::

[!code-vb[TPL_Continuations#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/detached1.vb#10)]

<span data-ttu-id="a7d02-195">継続元の最終的な状態は、アタッチされた子タスクの最終的な状態に依存します。</span><span class="sxs-lookup"><span data-stu-id="a7d02-195">The final status of the antecedent task depends on the final status of any attached child tasks.</span></span> <span data-ttu-id="a7d02-196">デタッチされた子タスクの状態は、親には影響しません。</span><span class="sxs-lookup"><span data-stu-id="a7d02-196">The status of detached child tasks does not affect the parent.</span></span> <span data-ttu-id="a7d02-197">詳細については、「[アタッチされた子タスクとデタッチされた子タスク](attached-and-detached-child-tasks.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="a7d02-197">For more information, see [Attached and Detached Child Tasks](attached-and-detached-child-tasks.md).</span></span>

## <a name="associate-state-with-continuations"></a><span data-ttu-id="a7d02-198">状態と継続を関連付ける</span><span class="sxs-lookup"><span data-stu-id="a7d02-198">Associate state with continuations</span></span>

<span data-ttu-id="a7d02-199">任意の状態とタスクの継続を関連付けることができます。</span><span class="sxs-lookup"><span data-stu-id="a7d02-199">You can associate arbitrary state with a task continuation.</span></span> <span data-ttu-id="a7d02-200"><xref:System.Threading.Tasks.Task.ContinueWith%2A> メソッドは、それぞれが継続の状態を表す <xref:System.Object> 値を受け取る、オーバーロードされたバージョンを提供します。</span><span class="sxs-lookup"><span data-stu-id="a7d02-200">The <xref:System.Threading.Tasks.Task.ContinueWith%2A> method provides overloaded versions that each take an <xref:System.Object> value that represents the state of the continuation.</span></span> <span data-ttu-id="a7d02-201">後でこの状態オブジェクトにアクセスするには、 <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType> プロパティを使用します。</span><span class="sxs-lookup"><span data-stu-id="a7d02-201">You can later access this state object by using the <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="a7d02-202">値を指定しない場合、この状態オブジェクトは `null` です。</span><span class="sxs-lookup"><span data-stu-id="a7d02-202">This state object is `null` if you do not provide a value.</span></span>

<span data-ttu-id="a7d02-203">継続の状態は、TPL を使用するために、 [非同期プログラミング モデル (APM)](../asynchronous-programming-patterns/asynchronous-programming-model-apm.md) を使った既存のコードを変換する場合に有用です。</span><span class="sxs-lookup"><span data-stu-id="a7d02-203">Continuation state is useful when you convert existing code that uses the [Asynchronous Programming Model (APM)](../asynchronous-programming-patterns/asynchronous-programming-model-apm.md) to use the TPL.</span></span> <span data-ttu-id="a7d02-204">APM では通常、**Begin**_Method_ メソッドでオブジェクト状態を指定し、後から <xref:System.IAsyncResult.AsyncState%2A?displayProperty=nameWithType> プロパティを使って、その状態にアクセスします。</span><span class="sxs-lookup"><span data-stu-id="a7d02-204">In the APM, you typically provide object state in the **Begin**_Method_ method and later access that state by using the <xref:System.IAsyncResult.AsyncState%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="a7d02-205"><xref:System.Threading.Tasks.Task.ContinueWith%2A> メソッドを使用すると、APM を使用するコードを TPL を使用するように変換するときに、この状態を維持できます。</span><span class="sxs-lookup"><span data-stu-id="a7d02-205">By using the <xref:System.Threading.Tasks.Task.ContinueWith%2A> method, you can preserve this state when you convert code that uses the APM to use the TPL.</span></span>

<span data-ttu-id="a7d02-206">継続の状態は、Visual Studio デバッガーで <xref:System.Threading.Tasks.Task> オブジェクトを使用するときにも有用です。</span><span class="sxs-lookup"><span data-stu-id="a7d02-206">Continuation state can also be useful when you work with <xref:System.Threading.Tasks.Task> objects in the Visual Studio debugger.</span></span> <span data-ttu-id="a7d02-207">たとえば、 **[並列タスク]** ウィンドウの **[タスク]** の列に、各タスクの状態オブジェクトの文字列表現が表示されます。</span><span class="sxs-lookup"><span data-stu-id="a7d02-207">For example, in the **Parallel Tasks** window, the **Task** column displays the string representation of the state object for each task.</span></span> <span data-ttu-id="a7d02-208">**[並列タスク]** ウィンドウの詳細については、「[[タスク] ウィンドウの使用](/visualstudio/debugger/using-the-tasks-window)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="a7d02-208">For more information about the **Parallel Tasks** window, see [Using the Tasks Window](/visualstudio/debugger/using-the-tasks-window).</span></span>

<span data-ttu-id="a7d02-209">継続の状態の使用方法を次の例に示します。</span><span class="sxs-lookup"><span data-stu-id="a7d02-209">The following example shows how to use continuation state.</span></span> <span data-ttu-id="a7d02-210">この例では、継続タスクのチェーンを作成します。</span><span class="sxs-lookup"><span data-stu-id="a7d02-210">It creates a chain of continuation tasks.</span></span> <span data-ttu-id="a7d02-211">各タスクは <xref:System.DateTime> メソッドの `state` パラメーターの現在時刻である、 <xref:System.Threading.Tasks.Task.ContinueWith%2A> オブジェクトを提供します。</span><span class="sxs-lookup"><span data-stu-id="a7d02-211">Each task provides the current time, a <xref:System.DateTime> object, for the `state` parameter of the <xref:System.Threading.Tasks.Task.ContinueWith%2A> method.</span></span> <span data-ttu-id="a7d02-212"><xref:System.DateTime> の各オブジェクトは継続タスクが作成された時刻を表します。</span><span class="sxs-lookup"><span data-stu-id="a7d02-212">Each <xref:System.DateTime> object represents the time at which the continuation task is created.</span></span> <span data-ttu-id="a7d02-213">各タスクは、結果として、タスクが終了する時刻を表す秒の <xref:System.DateTime> オブジェクトを生成します。</span><span class="sxs-lookup"><span data-stu-id="a7d02-213">Each task produces as its result a second <xref:System.DateTime> object that represents the time at which the task finishes.</span></span> <span data-ttu-id="a7d02-214">この例では、すべてのタスクが終了した後に、作成時刻および各継続タスクの終了時刻が表示されます。</span><span class="sxs-lookup"><span data-stu-id="a7d02-214">After all tasks finish, this example displays the creation time and the time at which each continuation task finishes.</span></span>

:::code language="csharp" source="snippets/cs/continuationstate.cs":::

[!code-vb[TPL_ContinuationState#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuationstate/vb/continuationstate.vb#1)]

## <a name="continuations-that-return-task-types"></a><span data-ttu-id="a7d02-215">Task 型を返す継続</span><span class="sxs-lookup"><span data-stu-id="a7d02-215">Continuations that return Task types</span></span>

<span data-ttu-id="a7d02-216">場合によっては、<xref:System.Threading.Tasks.Task> 型を返す継続の連結が必要になることがあります。</span><span class="sxs-lookup"><span data-stu-id="a7d02-216">Sometimes you may need to chain a continuation that returns a <xref:System.Threading.Tasks.Task> type.</span></span> <span data-ttu-id="a7d02-217">それらは入れ子のタスクと呼ばれ、一般的なものです。</span><span class="sxs-lookup"><span data-stu-id="a7d02-217">These are referred to as nested tasks, and they are common.</span></span> <span data-ttu-id="a7d02-218">親タスクによって <xref:System.Threading.Tasks.Task%601.ContinueWith%2A?displayProperty=nameWithType> が呼び出され、タスクを返す `continuationFunction` が提供される場合は、<xref:System.Threading.Tasks.TaskExtensions.Unwrap%2A> を呼び出して、`<Task<Task<T>>>` または `Task(Of Task(Of T))` (Visual Basic) の非同期操作を表すプロキシ タスクを作成します。</span><span class="sxs-lookup"><span data-stu-id="a7d02-218">When a parent task calls <xref:System.Threading.Tasks.Task%601.ContinueWith%2A?displayProperty=nameWithType>, and provides a `continuationFunction` that is task returning you call <xref:System.Threading.Tasks.TaskExtensions.Unwrap%2A> to create a proxy task that represents the asynchronous operation of the `<Task<Task<T>>>` or `Task(Of Task(Of T))` (Visual Basic).</span></span>

<span data-ttu-id="a7d02-219">次の例では、タスクを返す追加の関数をラップする継続を使用する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="a7d02-219">The following example shows how to use continuations that wrap additional task returning functions.</span></span> <span data-ttu-id="a7d02-220">各継続をラップ解除し、ラップされていた内部タスクを取り出すことができます。</span><span class="sxs-lookup"><span data-stu-id="a7d02-220">Each continuation can be unwrapped, exposing the inner task that was wrapped.</span></span>

:::code language="csharp" source="snippets/cs/unwrap.cs":::
:::code language="vb" source="snippets/vb/unwrap.vb":::

<span data-ttu-id="a7d02-221"><xref:System.Threading.Tasks.TaskExtensions.Unwrap%2A> の使用に関する詳細については、「[方法: 入れ子のタスクのラップを解除する](how-to-unwrap-a-nested-task.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="a7d02-221">For more information on using <xref:System.Threading.Tasks.TaskExtensions.Unwrap%2A>, see [How to: Unwrap a nested Task](how-to-unwrap-a-nested-task.md).</span></span>

## <a name="handle-exceptions-thrown-from-continuations"></a><span data-ttu-id="a7d02-222">継続からスローされた例外を処理する</span><span class="sxs-lookup"><span data-stu-id="a7d02-222">Handle exceptions thrown from continuations</span></span>

<span data-ttu-id="a7d02-223">継続元と継続の関係は、親と子の関係とは異なります。</span><span class="sxs-lookup"><span data-stu-id="a7d02-223">An antecedent-continuation relationship is not a parent-child relationship.</span></span> <span data-ttu-id="a7d02-224">継続によってスローされた例外は継続元へは反映されません。</span><span class="sxs-lookup"><span data-stu-id="a7d02-224">Exceptions thrown by continuations are not propagated to the antecedent.</span></span> <span data-ttu-id="a7d02-225">したがって、継続によってスローされた例外は、他のタスクでの処理と同様、次のように処理します。</span><span class="sxs-lookup"><span data-stu-id="a7d02-225">Therefore, handle exceptions thrown by continuations as you would handle them in any other task, as follows:</span></span>

- <span data-ttu-id="a7d02-226"><xref:System.Threading.Tasks.Task.Wait%2A>メソッド、 <xref:System.Threading.Tasks.Task.WaitAll%2A>メソッド、または <xref:System.Threading.Tasks.Task.WaitAny%2A> メソッドを使用するか、ジェネリック メソッドを使用して、継続での待機を指定します。</span><span class="sxs-lookup"><span data-stu-id="a7d02-226">You can use the <xref:System.Threading.Tasks.Task.Wait%2A>, <xref:System.Threading.Tasks.Task.WaitAll%2A>, or <xref:System.Threading.Tasks.Task.WaitAny%2A> method, or its generic counterpart, to wait on the continuation.</span></span> <span data-ttu-id="a7d02-227">次の例に示すように、継続元とその継続は、同じ `try` ステートメントで待機できます。</span><span class="sxs-lookup"><span data-stu-id="a7d02-227">You can wait for an antecedent and its continuations in the same `try` statement, as shown in the following example.</span></span>

:::code language="csharp" source="snippets/cs/exception1.cs":::

[!code-vb[TPL_Continuations#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/exception1.vb#6)]

- <span data-ttu-id="a7d02-228">最初の継続の <xref:System.Threading.Tasks.Task.Exception%2A> プロパティを確認するには、2 番目の継続を使用します。</span><span class="sxs-lookup"><span data-stu-id="a7d02-228">You can use a second continuation to observe the <xref:System.Threading.Tasks.Task.Exception%2A> property of the first continuation.</span></span> <span data-ttu-id="a7d02-229">次の例でタスクは、存在しないファイルからの読み取りを試行します。</span><span class="sxs-lookup"><span data-stu-id="a7d02-229">In the following example, a task attempts to read from a non-existent file.</span></span> <span data-ttu-id="a7d02-230">その後、継続により、継続元タスクの例外に関する情報が表示されます。</span><span class="sxs-lookup"><span data-stu-id="a7d02-230">The continuation then displays information about the exception in the antecedent task.</span></span>

:::code language="csharp" source="snippets/cs/exception2.cs" id="example":::

[!code-vb[TPL_Continuations#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/exception2.vb#4)]

<span data-ttu-id="a7d02-231"><xref:System.Threading.Tasks.TaskContinuationOptions.OnlyOnFaulted?displayProperty=nameWithType> オプションを指定して実行されたため、継続が実行されるのは、継続元で例外が発生し、継続元の <xref:System.Threading.Tasks.Task.Exception%2A> プロパティが `null`ではないと推測できる場合だけです。</span><span class="sxs-lookup"><span data-stu-id="a7d02-231">Because it was run with the <xref:System.Threading.Tasks.TaskContinuationOptions.OnlyOnFaulted?displayProperty=nameWithType> option, the continuation executes only if an exception occurs in the antecedent, and therefore it can assume that the antecedent's <xref:System.Threading.Tasks.Task.Exception%2A> property is not `null`.</span></span> <span data-ttu-id="a7d02-232">継続元で例外がスローされたかどうかに関係なく継続が実行される場合は、次のコード フラグメントに示すように、例外処理を試行する前に、継続元の <xref:System.Threading.Tasks.Task.Exception%2A> プロパティが `null` ではないことを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="a7d02-232">If the continuation executes whether or not an exception is thrown in the antecedent, it would have to check whether the antecedent's <xref:System.Threading.Tasks.Task.Exception%2A> property is not `null` before attempting to handle the exception, as the following code fragment shows.</span></span>

:::code language="csharp" source="snippets/cs/exception2.cs" id="exception":::

[!code-vb[TPL_Continuations#11](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/exception2.vb#11)]

<span data-ttu-id="a7d02-233">詳細については、「[例外処理](exception-handling-task-parallel-library.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="a7d02-233">For more information, see [Exception Handling](exception-handling-task-parallel-library.md).</span></span>

- <span data-ttu-id="a7d02-234">アタッチされた子タスクで、 <xref:System.Threading.Tasks.TaskContinuationOptions.AttachedToParent?displayProperty=nameWithType> オプションを使用して継続が作成された場合、アタッチされているその他の子と同様、その例外は親によって呼び出し元のスレッドに反映されます。</span><span class="sxs-lookup"><span data-stu-id="a7d02-234">If the continuation is an attached child task that was created by using the <xref:System.Threading.Tasks.TaskContinuationOptions.AttachedToParent?displayProperty=nameWithType> option, its exceptions will be propagated by the parent back to the calling thread, as is the case in any other attached child.</span></span> <span data-ttu-id="a7d02-235">詳細については、「[アタッチされた子タスクとデタッチされた子タスク](attached-and-detached-child-tasks.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="a7d02-235">For more information, see [Attached and Detached Child Tasks](attached-and-detached-child-tasks.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="a7d02-236">関連項目</span><span class="sxs-lookup"><span data-stu-id="a7d02-236">See also</span></span>

- [<span data-ttu-id="a7d02-237">タスク並列ライブラリ (TPL)</span><span class="sxs-lookup"><span data-stu-id="a7d02-237">Task Parallel Library (TPL)</span></span>](task-parallel-library-tpl.md)
