---
description: '詳細情報: 並列プログラミング向けのデータ構造'
title: 並列プログラミング向けのデータ構造
ms.date: 03/30/2017
helpviewer_keywords:
- data structures, multi-threading
ms.assetid: bdc82f2f-4754-45a1-a81e-fe2e9c30cef9
ms.openlocfilehash: 4ab1f551c18f093ee007a38b7186921468d70be3
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/06/2021
ms.locfileid: "99675612"
---
# <a name="data-structures-for-parallel-programming"></a><span data-ttu-id="306a4-103">並列プログラミング向けのデータ構造</span><span class="sxs-lookup"><span data-stu-id="306a4-103">Data Structures for Parallel Programming</span></span>

<span data-ttu-id="306a4-104">.NET には、同時実行コレクション クラスのセット、軽量な同期プリミティブ、遅延初期化用の型など、並列プログラミングに役立つ型がいくつかあります。</span><span class="sxs-lookup"><span data-stu-id="306a4-104">.NET provides several types that are useful in parallel programming, including a set of concurrent collection classes, lightweight synchronization primitives, and types for lazy initialization.</span></span> <span data-ttu-id="306a4-105">これらの型は、タスク並列ライブラリや PLINQ などの任意のマルチスレッド アプリケーション コードで使うことができます。</span><span class="sxs-lookup"><span data-stu-id="306a4-105">You can use these types with any multithreaded application code, including the Task Parallel Library and PLINQ.</span></span>  
  
## <a name="concurrent-collection-classes"></a><span data-ttu-id="306a4-106">同時実行コレクション クラス</span><span class="sxs-lookup"><span data-stu-id="306a4-106">Concurrent Collection Classes</span></span>  

 <span data-ttu-id="306a4-107"><xref:System.Collections.Concurrent?displayProperty=nameWithType> 名前空間のコレクション クラスは、できる限りロックを回避するスレッドセーフな追加と削除の操作を提供し、ロックが必要なときは粒度の細かいロックを使います。</span><span class="sxs-lookup"><span data-stu-id="306a4-107">The collection classes in the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace provide thread-safe add and remove operations that avoid locks wherever possible and use fine-grained locking where locks are necessary.</span></span> <span data-ttu-id="306a4-108">同時実行コレクション クラスでは、項目にアクセスするときにロックを取得するユーザー コードが不要です。</span><span class="sxs-lookup"><span data-stu-id="306a4-108">A concurrent collection class does not require user code to take any locks when it accesses items.</span></span> <span data-ttu-id="306a4-109">複数のスレッドがコレクションの項目を追加および削除するシナリオでは、同時実行コレクション クラスを使うと、<xref:System.Collections.ArrayList?displayProperty=nameWithType> や <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> (ユーザー実装のロックを使用) などの型に対するパフォーマンスが大幅に向上します。</span><span class="sxs-lookup"><span data-stu-id="306a4-109">The concurrent collection classes can significantly improve performance over types such as <xref:System.Collections.ArrayList?displayProperty=nameWithType> and <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> (with user-implemented locking) in scenarios where multiple threads add and remove items from a collection.</span></span>  
  
 <span data-ttu-id="306a4-110">次の表は、同時実行コレクション クラスの一覧です。</span><span class="sxs-lookup"><span data-stu-id="306a4-110">The following table lists the concurrent collection classes:</span></span>  
  
|<span data-ttu-id="306a4-111">[種類]</span><span class="sxs-lookup"><span data-stu-id="306a4-111">Type</span></span>|<span data-ttu-id="306a4-112">[説明]</span><span class="sxs-lookup"><span data-stu-id="306a4-112">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType>|<span data-ttu-id="306a4-113"><xref:System.Collections.Concurrent.IProducerConsumerCollection%601?displayProperty=nameWithType> を実装するスレッド セーフなコレクションに、ブロッキングと範囲指定の機能を提供します。</span><span class="sxs-lookup"><span data-stu-id="306a4-113">Provides blocking and bounding capabilities for thread-safe collections that implement <xref:System.Collections.Concurrent.IProducerConsumerCollection%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="306a4-114">利用できるスロットがない場合、またはコレクションがいっぱいの場合は、プロデューサー スレッドがブロックします。</span><span class="sxs-lookup"><span data-stu-id="306a4-114">Producer threads block if no slots are available or if the collection is full.</span></span> <span data-ttu-id="306a4-115">コレクションが空の場合は、コンシューマー スレッドがブロックします。</span><span class="sxs-lookup"><span data-stu-id="306a4-115">Consumer threads block if the collection is empty.</span></span> <span data-ttu-id="306a4-116">この型は、コンシューマーとプロデューサーによる非ブロッキング アクセスもサポートします。</span><span class="sxs-lookup"><span data-stu-id="306a4-116">This type also supports non-blocking access by consumers and producers.</span></span> <span data-ttu-id="306a4-117"><xref:System.Collections.Concurrent.BlockingCollection%601> は、基底クラスとして、または <xref:System.Collections.Generic.IEnumerable%601> をサポートする任意のコレクション クラスにブロッキングと範囲指定を提供するバッキング ストアとして、使うことができます。</span><span class="sxs-lookup"><span data-stu-id="306a4-117"><xref:System.Collections.Concurrent.BlockingCollection%601> can be used as a base class or backing store to provide blocking and bounding for any collection class that supports <xref:System.Collections.Generic.IEnumerable%601>.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType>|<span data-ttu-id="306a4-118">スケーラブルな追加と取得の操作を提供するスレッドセーフなバッグの実装です。</span><span class="sxs-lookup"><span data-stu-id="306a4-118">A thread-safe bag implementation that provides scalable add and get operations.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType>|<span data-ttu-id="306a4-119">同時実行のスケーラブルなディクショナリ型です。</span><span class="sxs-lookup"><span data-stu-id="306a4-119">A concurrent and scalable dictionary type.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType>|<span data-ttu-id="306a4-120">同時実行のスケーラブルな FIFO キューです。</span><span class="sxs-lookup"><span data-stu-id="306a4-120">A concurrent and scalable FIFO queue.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType>|<span data-ttu-id="306a4-121">同時実行のスケーラブルな LIFO スタックです。</span><span class="sxs-lookup"><span data-stu-id="306a4-121">A concurrent and scalable LIFO stack.</span></span>|  
  
 <span data-ttu-id="306a4-122">詳しくは、「[スレッド セーフなコレクション](../collections/thread-safe/index.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="306a4-122">For more information, see [Thread-Safe Collections](../collections/thread-safe/index.md).</span></span>  
  
## <a name="synchronization-primitives"></a><span data-ttu-id="306a4-123">同期プリミティブ</span><span class="sxs-lookup"><span data-stu-id="306a4-123">Synchronization Primitives</span></span>  

 <span data-ttu-id="306a4-124"><xref:System.Threading?displayProperty=nameWithType> 名前空間の同期プリミティブを使うと、従来のマルチスレッド コードに見られるような高コストのロック メカニズムを回避することで、細かいコンカレンシーを設定でき、高速のパフォーマンスが提供されます。</span><span class="sxs-lookup"><span data-stu-id="306a4-124">The synchronization primitives in the <xref:System.Threading?displayProperty=nameWithType> namespace enable fine-grained concurrency and faster performance by avoiding expensive locking mechanisms found in legacy multithreading code.</span></span>
  
 <span data-ttu-id="306a4-125">次の表は、同期型の一覧です。</span><span class="sxs-lookup"><span data-stu-id="306a4-125">The following table lists the synchronization types:</span></span>  
  
|<span data-ttu-id="306a4-126">Type</span><span class="sxs-lookup"><span data-stu-id="306a4-126">Type</span></span>|<span data-ttu-id="306a4-127">説明</span><span class="sxs-lookup"><span data-stu-id="306a4-127">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Threading.Barrier?displayProperty=nameWithType>|<span data-ttu-id="306a4-128">各タスクが到着を通知し、一部または全部のタスクが到着するまでブロックすることができるポイントを提供することにより、複数のスレッドが 1 つのアルゴリズムで並列に動作できるようにします。</span><span class="sxs-lookup"><span data-stu-id="306a4-128">Enables multiple threads to work on an algorithm in parallel by providing a point at which each task can signal its arrival and then block until some or all tasks have arrived.</span></span> <span data-ttu-id="306a4-129">詳細については、「[バリア](../threading/barrier.md)」を参照してください</span><span class="sxs-lookup"><span data-stu-id="306a4-129">For more information, see [Barrier](../threading/barrier.md).</span></span>|  
|<xref:System.Threading.CountdownEvent?displayProperty=nameWithType>|<span data-ttu-id="306a4-130">簡単なランデブー メカニズムを提供することにより、フォークと結合のシナリオを簡略化します。</span><span class="sxs-lookup"><span data-stu-id="306a4-130">Simplifies fork and join scenarios by providing an easy rendezvous mechanism.</span></span> <span data-ttu-id="306a4-131">詳しくは、「[CountdownEvent](../threading/countdownevent.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="306a4-131">For more information, see [CountdownEvent](../threading/countdownevent.md).</span></span>|  
|<xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType>|<span data-ttu-id="306a4-132"><xref:System.Threading.ManualResetEvent?displayProperty=nameWithType> と同様の同期プリミティブです。</span><span class="sxs-lookup"><span data-stu-id="306a4-132">A synchronization primitive similar to <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>.</span></span> <span data-ttu-id="306a4-133"><xref:System.Threading.ManualResetEventSlim> の方が軽量ですが、プロセス内通信にしか使えません。</span><span class="sxs-lookup"><span data-stu-id="306a4-133"><xref:System.Threading.ManualResetEventSlim> is lighter-weight but can only be used for intra-process communication.</span></span>|  
|<xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType>|<span data-ttu-id="306a4-134">リソースまたはリソースのプールに同時にアクセスできるスレッドの数を制限する同期プリミティブです。</span><span class="sxs-lookup"><span data-stu-id="306a4-134">A synchronization primitive that limits the number of threads that can concurrently access a resource or a pool of resources.</span></span> <span data-ttu-id="306a4-135">詳しくは、「[Semaphore と SemaphoreSlim](../threading/semaphore-and-semaphoreslim.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="306a4-135">For more information, see [Semaphore and SemaphoreSlim](../threading/semaphore-and-semaphoreslim.md).</span></span>|  
|<xref:System.Threading.SpinLock?displayProperty=nameWithType>|<span data-ttu-id="306a4-136">ロックを取得しようとしているスレッドがクォンタムを生成する前にしばらくループ ("*スピン*") で待機するようになる、相互排他ロック プリミティブです。</span><span class="sxs-lookup"><span data-stu-id="306a4-136">A mutual exclusion lock primitive that causes the thread that is trying to acquire the lock to wait in a loop, or *spin*, for a period of time before yielding its quantum.</span></span> <span data-ttu-id="306a4-137">ロックの待機が短いと予想されるシナリオでは、他のロック形式より <xref:System.Threading.SpinLock> の方がよいパフォーマンスを提供します。</span><span class="sxs-lookup"><span data-stu-id="306a4-137">In scenarios where the wait for the lock is expected to be short, <xref:System.Threading.SpinLock> offers better performance than other forms of locking.</span></span> <span data-ttu-id="306a4-138">詳しくは、「[SpinLock](../threading/spinlock.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="306a4-138">For more information, see [SpinLock](../threading/spinlock.md).</span></span>|  
|<xref:System.Threading.SpinWait?displayProperty=nameWithType>|<span data-ttu-id="306a4-139">指定された時間だけスピンし、スピン カウントを超過した場合は最終的にスレッドを待機状態にする、小型で軽量の型です。</span><span class="sxs-lookup"><span data-stu-id="306a4-139">A small, lightweight type that will spin for a specified time and eventually put the thread into a wait state if the spin count is exceeded.</span></span>  <span data-ttu-id="306a4-140">詳しくは、「[SpinWait](../threading/spinwait.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="306a4-140">For more information, see [SpinWait](../threading/spinwait.md).</span></span>|  
  
 <span data-ttu-id="306a4-141">詳細については、次を参照してください。</span><span class="sxs-lookup"><span data-stu-id="306a4-141">For more information, see:</span></span>  
  
- [<span data-ttu-id="306a4-142">方法: 下位レベルの同期に SpinLock を使用する</span><span class="sxs-lookup"><span data-stu-id="306a4-142">How to: Use SpinLock for Low-Level Synchronization</span></span>](../threading/how-to-use-spinlock-for-low-level-synchronization.md)  
  
- <span data-ttu-id="306a4-143">[方法:バリアを使用して同時実行操作を同期する](../threading/how-to-synchronize-concurrent-operations-with-a-barrier.md)。</span><span class="sxs-lookup"><span data-stu-id="306a4-143">[How to: Synchronize Concurrent Operations with a Barrier](../threading/how-to-synchronize-concurrent-operations-with-a-barrier.md).</span></span>  
  
## <a name="lazy-initialization-classes"></a><span data-ttu-id="306a4-144">遅延初期化クラス</span><span class="sxs-lookup"><span data-stu-id="306a4-144">Lazy Initialization Classes</span></span>  

 <span data-ttu-id="306a4-145">遅延初期化では、オブジェクトのメモリは必要になるまで割り当てられません。</span><span class="sxs-lookup"><span data-stu-id="306a4-145">With lazy initialization, the memory for an object is not allocated until it is needed.</span></span> <span data-ttu-id="306a4-146">遅延初期化を使うと、オブジェクトの割り当てがプログラムの有効期間全体に均等に分散されるので、パフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="306a4-146">Lazy initialization can improve performance by spreading object allocations evenly across the lifetime of a program.</span></span> <span data-ttu-id="306a4-147"><xref:System.Lazy%601> 型をラッピングすることにより、任意のカスタム型で遅延初期化を有効にできます。</span><span class="sxs-lookup"><span data-stu-id="306a4-147">You can enable lazy initialization for any custom type by wrapping the type <xref:System.Lazy%601>.</span></span>  
  
 <span data-ttu-id="306a4-148">次の表は、遅延初期化型の一覧です。</span><span class="sxs-lookup"><span data-stu-id="306a4-148">The following table lists the lazy initialization types:</span></span>  
  
|<span data-ttu-id="306a4-149">Type</span><span class="sxs-lookup"><span data-stu-id="306a4-149">Type</span></span>|<span data-ttu-id="306a4-150">説明</span><span class="sxs-lookup"><span data-stu-id="306a4-150">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Lazy%601?displayProperty=nameWithType>|<span data-ttu-id="306a4-151">軽量でスレッドセーフの遅延初期化を提供します。</span><span class="sxs-lookup"><span data-stu-id="306a4-151">Provides lightweight, thread-safe lazy-initialization.</span></span>|  
|<xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType>|<span data-ttu-id="306a4-152">スレッドごとに遅延初期化された値を提供し、各スレッドは初期化関数を遅延して呼び出します。</span><span class="sxs-lookup"><span data-stu-id="306a4-152">Provides a lazily-initialized value on a per-thread basis, with each thread lazily-invoking the initialization function.</span></span>|  
|<xref:System.Threading.LazyInitializer?displayProperty=nameWithType>|<span data-ttu-id="306a4-153">専用の遅延初期化インスタンスを割り当てる必要のない静的メソッドを提供します。</span><span class="sxs-lookup"><span data-stu-id="306a4-153">Provides static methods that avoid the need to allocate a dedicated, lazy-initialization instance.</span></span> <span data-ttu-id="306a4-154">代わりに、参照を使って、ターゲットがアクセスされたときは初期化されているようにします。</span><span class="sxs-lookup"><span data-stu-id="306a4-154">Instead, they use references to ensure targets have been initialized as they are accessed.</span></span>|  
  
 <span data-ttu-id="306a4-155">詳細については、「[限定的な初期化](../../framework/performance/lazy-initialization.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="306a4-155">For more information, see [Lazy Initialization](../../framework/performance/lazy-initialization.md).</span></span>  
  
## <a name="aggregate-exceptions"></a><span data-ttu-id="306a4-156">例外集約</span><span class="sxs-lookup"><span data-stu-id="306a4-156">Aggregate Exceptions</span></span>  

 <span data-ttu-id="306a4-157"><xref:System.AggregateException?displayProperty=nameWithType> 型を使うと、別のスレッドで同時にスローされた複数の例外をキャプチャし、1 つの例外として結合スレッドに戻すことができます。</span><span class="sxs-lookup"><span data-stu-id="306a4-157">The <xref:System.AggregateException?displayProperty=nameWithType> type can be used to capture multiple exceptions that are thrown concurrently on separate threads, and return them to the joining thread as a single exception.</span></span> <span data-ttu-id="306a4-158"><xref:System.Threading.Tasks.Task?displayProperty=nameWithType> 型、<xref:System.Threading.Tasks.Parallel?displayProperty=nameWithType> 型、PLINQ は、この目的に <xref:System.AggregateException> を広範に使います。</span><span class="sxs-lookup"><span data-stu-id="306a4-158">The <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Parallel?displayProperty=nameWithType> types and PLINQ use <xref:System.AggregateException> extensively for this purpose.</span></span> <span data-ttu-id="306a4-159">詳細については、「[例外処理](exception-handling-task-parallel-library.md)」および「[方法: PLINQ クエリの例外を処理する](how-to-handle-exceptions-in-a-plinq-query.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="306a4-159">For more information, see [Exception Handling](exception-handling-task-parallel-library.md) and [How to: Handle Exceptions in a PLINQ Query](how-to-handle-exceptions-in-a-plinq-query.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="306a4-160">関連項目</span><span class="sxs-lookup"><span data-stu-id="306a4-160">See also</span></span>

- <xref:System.Collections.Concurrent?displayProperty=nameWithType>
- <xref:System.Threading?displayProperty=nameWithType>
- [<span data-ttu-id="306a4-161">並列プログラミング</span><span class="sxs-lookup"><span data-stu-id="306a4-161">Parallel Programming</span></span>](index.md)
