---
description: '詳細情報: コレクションに関するガイドライン'
title: コレクションに関するガイドライン
ms.date: 10/22/2008
ms.assetid: 297b8f1d-b11f-4dc6-960a-8e990817304e
ms.openlocfilehash: fa189068e9f3e06b3e88999bd4b0ea0998cd16e3
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/06/2021
ms.locfileid: "99642033"
---
# <a name="guidelines-for-collections"></a><span data-ttu-id="cc749-103">コレクションに関するガイドライン</span><span class="sxs-lookup"><span data-stu-id="cc749-103">Guidelines for Collections</span></span>

<span data-ttu-id="cc749-104">共通の特性をいくつか持つオブジェクトのグループを操作するために特に設計された型はすべて、コレクションと見なすことができます。</span><span class="sxs-lookup"><span data-stu-id="cc749-104">Any type designed specifically to manipulate a group of objects having some common characteristic can be considered a collection.</span></span> <span data-ttu-id="cc749-105">ほとんどの場合、そのような型には <xref:System.Collections.IEnumerable> または <xref:System.Collections.Generic.IEnumerable%601> を実装するのが適しているので、このセクションでは、それらのインターフェイスのいずれかまたは両方を実装している型のみを、コレクションとして考えます。</span><span class="sxs-lookup"><span data-stu-id="cc749-105">It is almost always appropriate for such types to implement <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601>, so in this section we only consider types implementing one or both of those interfaces to be collections.</span></span>

 <span data-ttu-id="cc749-106">❌ パブリック API では、弱く型指定されたコレクションを使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="cc749-106">❌ DO NOT use weakly typed collections in public APIs.</span></span>

 <span data-ttu-id="cc749-107">コレクション項目を表すすべての戻り値とパラメーターの型は、その基本データ型のいずれか (これは、コレクションのパブリック メンバーにのみ適用されます) ではなく、項目の完全な型にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="cc749-107">The type of all return values and parameters representing collection items should be the exact item type, not any of its base types (this applies only to public members of the collection).</span></span>

 <span data-ttu-id="cc749-108">❌ パブリック API では、<xref:System.Collections.ArrayList> または <xref:System.Collections.Generic.List%601> を使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="cc749-108">❌ DO NOT use <xref:System.Collections.ArrayList> or <xref:System.Collections.Generic.List%601> in public APIs.</span></span>

 <span data-ttu-id="cc749-109">これらの型は、パブリック API ではなく、内部実装で使用するように設計されたデータ構造です。</span><span class="sxs-lookup"><span data-stu-id="cc749-109">These types are data structures designed to be used in internal implementation, not in public APIs.</span></span> <span data-ttu-id="cc749-110">`List<T>` は、API のクリーンさと柔軟性を犠牲にする代わりに、パフォーマンスとパワーに最適化されています。</span><span class="sxs-lookup"><span data-stu-id="cc749-110">`List<T>` is optimized for performance and power at the cost of cleanness of the APIs and flexibility.</span></span> <span data-ttu-id="cc749-111">たとえば、`List<T>` を返した場合、クライアント コードによってコレクションが変更されても通知を受け取ることはできません。</span><span class="sxs-lookup"><span data-stu-id="cc749-111">For example, if you return `List<T>`, you will not ever be able to receive notifications when client code modifies the collection.</span></span> <span data-ttu-id="cc749-112">また、`List<T>` によって <xref:System.Collections.Generic.List%601.BinarySearch%2A> などの多くのメンバーが公開されていますが、それらは多くのシナリオでは役に立たないか、適用できません。</span><span class="sxs-lookup"><span data-stu-id="cc749-112">Also, `List<T>` exposes many members, such as <xref:System.Collections.Generic.List%601.BinarySearch%2A>, that are not useful or applicable in many scenarios.</span></span> <span data-ttu-id="cc749-113">次の 2 つのセクションでは、パブリック API 専用に設計されている型 (抽象化) について説明します。</span><span class="sxs-lookup"><span data-stu-id="cc749-113">The following two sections describe types (abstractions) designed specifically for use in public APIs.</span></span>

 <span data-ttu-id="cc749-114">❌ パブリック API では、`Hashtable` または `Dictionary<TKey,TValue>` を使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="cc749-114">❌ DO NOT use `Hashtable` or `Dictionary<TKey,TValue>` in public APIs.</span></span>

 <span data-ttu-id="cc749-115">これらの型は、内部実装で使用するように設計されたデータ構造です。</span><span class="sxs-lookup"><span data-stu-id="cc749-115">These types are data structures designed to be used in internal implementation.</span></span> <span data-ttu-id="cc749-116">パブリック API では、<xref:System.Collections.IDictionary>、`IDictionary <TKey, TValue>`、またはこれらのインターフェイスの一方か両方が実装されているカスタム型を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="cc749-116">Public APIs should use <xref:System.Collections.IDictionary>, `IDictionary <TKey, TValue>`, or a custom type implementing one or both of the interfaces.</span></span>

 <span data-ttu-id="cc749-117">❌ `GetEnumerator` メソッドの戻り値の型として使用する場合を除き、<xref:System.Collections.Generic.IEnumerator%601>、<xref:System.Collections.IEnumerator>、またはこれらのインターフェイスのいずれかが実装されている他の型を使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="cc749-117">❌ DO NOT use <xref:System.Collections.Generic.IEnumerator%601>, <xref:System.Collections.IEnumerator>, or any other type that implements either of these interfaces, except as the return type of a `GetEnumerator` method.</span></span>

 <span data-ttu-id="cc749-118">`GetEnumerator` 以外のメソッドから列挙子を返す型を、`foreach` ステートメントと共に使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="cc749-118">Types returning enumerators from methods other than `GetEnumerator` cannot be used with the `foreach` statement.</span></span>

 <span data-ttu-id="cc749-119">❌ `IEnumerator<T>` と `IEnumerable<T>` の両方を同じ型で実装しないでください。</span><span class="sxs-lookup"><span data-stu-id="cc749-119">❌ DO NOT implement both `IEnumerator<T>` and `IEnumerable<T>` on the same type.</span></span> <span data-ttu-id="cc749-120">同じことが、非ジェネリック インターフェイスの `IEnumerator` と `IEnumerable` にも当てはまります。</span><span class="sxs-lookup"><span data-stu-id="cc749-120">The same applies to the nongeneric interfaces `IEnumerator` and `IEnumerable`.</span></span>

## <a name="collection-parameters"></a><span data-ttu-id="cc749-121">コレクションのパラメーター</span><span class="sxs-lookup"><span data-stu-id="cc749-121">Collection Parameters</span></span>

 <span data-ttu-id="cc749-122">✔️ パラメーターの型としては、可能な限り最も特殊化されていない型を使用してください。</span><span class="sxs-lookup"><span data-stu-id="cc749-122">✔️ DO use the least-specialized type possible as a parameter type.</span></span> <span data-ttu-id="cc749-123">パラメーターとしてコレクションを受け取るほとんどのメンバーは、`IEnumerable<T>` インターフェイスを使用します。</span><span class="sxs-lookup"><span data-stu-id="cc749-123">Most members taking collections as parameters use the `IEnumerable<T>` interface.</span></span>

 <span data-ttu-id="cc749-124">❌ `Count` プロパティにアクセスするためだけに、パラメーターとして <xref:System.Collections.Generic.ICollection%601> または <xref:System.Collections.ICollection> を使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="cc749-124">❌ AVOID using <xref:System.Collections.Generic.ICollection%601> or <xref:System.Collections.ICollection> as a parameter just to access the `Count` property.</span></span>

 <span data-ttu-id="cc749-125">代わりに、`IEnumerable<T>` または `IEnumerable` を使用し、オブジェクトで `ICollection<T>` または `ICollection` が実装されているかどうかを動的にチェックすることを検討します。</span><span class="sxs-lookup"><span data-stu-id="cc749-125">Instead, consider using `IEnumerable<T>` or `IEnumerable` and dynamically checking whether the object implements `ICollection<T>` or `ICollection`.</span></span>

## <a name="collection-properties-and-return-values"></a><span data-ttu-id="cc749-126">コレクションのプロパティと戻り値</span><span class="sxs-lookup"><span data-stu-id="cc749-126">Collection Properties and Return Values</span></span>

 <span data-ttu-id="cc749-127">❌ 設定可能なコレクション プロパティを提供しないでください。</span><span class="sxs-lookup"><span data-stu-id="cc749-127">❌ DO NOT provide settable collection properties.</span></span>

 <span data-ttu-id="cc749-128">ユーザーは、最初にコレクションをクリアしてから、新しい内容を追加することで、コレクションの内容を置き換えることができます。</span><span class="sxs-lookup"><span data-stu-id="cc749-128">Users can replace the contents of the collection by clearing the collection first and then adding the new contents.</span></span> <span data-ttu-id="cc749-129">コレクション全体を置き換えるのが一般的なシナリオである場合は、コレクションで `AddRange` メソッドを提供することを検討します。</span><span class="sxs-lookup"><span data-stu-id="cc749-129">If replacing the whole collection is a common scenario, consider providing the `AddRange` method on the collection.</span></span>

 <span data-ttu-id="cc749-130">✔️ 読み取り/書き込みコレクションを表すプロパティまたは戻り値の場合は、`Collection<T>` または `Collection<T>` のサブクラスを使用します。</span><span class="sxs-lookup"><span data-stu-id="cc749-130">✔️ DO use `Collection<T>` or a subclass of `Collection<T>` for properties or return values representing read/write collections.</span></span>

 <span data-ttu-id="cc749-131">`Collection<T>` によって満たされない要件がある場合は (たとえば、コレクションで <xref:System.Collections.IList> が実装されていてはならない)、`IEnumerable<T>`、`ICollection<T>`、または <xref:System.Collections.Generic.IList%601> を実装してカスタム コレクションを使用します。</span><span class="sxs-lookup"><span data-stu-id="cc749-131">If `Collection<T>` does not meet some requirement (e.g., the collection must not implement <xref:System.Collections.IList>), use a custom collection by implementing `IEnumerable<T>`, `ICollection<T>`, or <xref:System.Collections.Generic.IList%601>.</span></span>

 <span data-ttu-id="cc749-132">✔️ 読み取り専用コレクションを表すプロパティまたは戻り値の場合は、<xref:System.Collections.ObjectModel.ReadOnlyCollection%601>、`ReadOnlyCollection<T>` のサブクラス、またはまれに `IEnumerable<T>` を使用します。</span><span class="sxs-lookup"><span data-stu-id="cc749-132">✔️ DO use <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>, a subclass of `ReadOnlyCollection<T>`, or in rare cases `IEnumerable<T>` for properties or return values representing read-only collections.</span></span>

 <span data-ttu-id="cc749-133">一般には、`ReadOnlyCollection<T>` が推奨されます。</span><span class="sxs-lookup"><span data-stu-id="cc749-133">In general, prefer `ReadOnlyCollection<T>`.</span></span> <span data-ttu-id="cc749-134">満たされない要件がある場合は (たとえば、コレクションで `IList` が実装されていてはならない)、`IEnumerable<T>`、`ICollection<T>`、または `IList<T>` を実装してカスタム コレクションを使用します。</span><span class="sxs-lookup"><span data-stu-id="cc749-134">If it does not meet some requirement (e.g., the collection must not implement `IList`), use a custom collection by implementing `IEnumerable<T>`, `ICollection<T>`, or `IList<T>`.</span></span> <span data-ttu-id="cc749-135">読み取り専用のカスタム コレクションを実装する場合は、`ICollection<T>.IsReadOnly` を実装して `true` を返します。</span><span class="sxs-lookup"><span data-stu-id="cc749-135">If you do implement a custom read-only collection, implement `ICollection<T>.IsReadOnly` to return `true`.</span></span>

 <span data-ttu-id="cc749-136">サポートする必要があるシナリオが、順方向のみの反復だけであることが確実な場合は、単に `IEnumerable<T>` を使用できます。</span><span class="sxs-lookup"><span data-stu-id="cc749-136">In cases where you are sure that the only scenario you will ever want to support is forward-only iteration, you can simply use `IEnumerable<T>`.</span></span>

 <span data-ttu-id="cc749-137">✔️ コレクションを直接使用するのではなく、ジェネリック基本コレクションのサブクラスの使用を検討します。</span><span class="sxs-lookup"><span data-stu-id="cc749-137">✔️ CONSIDER using subclasses of generic base collections instead of using the collections directly.</span></span>

 <span data-ttu-id="cc749-138">このようにすると、より適切な名前を使用したり、基本コレクション型に存在しないヘルパー メンバーを追加したりすることができます。</span><span class="sxs-lookup"><span data-stu-id="cc749-138">This allows for a better name and for adding helper members that are not present on the base collection types.</span></span> <span data-ttu-id="cc749-139">これは、高レベルの API に特に当てはまります。</span><span class="sxs-lookup"><span data-stu-id="cc749-139">This is especially applicable to high-level APIs.</span></span>

 <span data-ttu-id="cc749-140">✔️ 非常によく使用されるメソッドとプロパティからは、`Collection<T>` または `ReadOnlyCollection<T>` のサブクラスを返すことを検討します。</span><span class="sxs-lookup"><span data-stu-id="cc749-140">✔️ CONSIDER returning a subclass of `Collection<T>` or `ReadOnlyCollection<T>` from very commonly used methods and properties.</span></span>

 <span data-ttu-id="cc749-141">これにより、後でヘルパー メソッドを追加したり、コレクションの実装を変更したりできるようになります。</span><span class="sxs-lookup"><span data-stu-id="cc749-141">This will make it possible for you to add helper methods or change the collection implementation in the future.</span></span>

 <span data-ttu-id="cc749-142">✔️ コレクションに格納される項目に一意のキー (名前、ID など) がある場合は、キー付きコレクションを使用することを検討します。</span><span class="sxs-lookup"><span data-stu-id="cc749-142">✔️ CONSIDER using a keyed collection if the items stored in the collection have unique keys (names, IDs, etc.).</span></span> <span data-ttu-id="cc749-143">キー付きコレクションは、整数とキーの両方でインデックスを作成できるコレクションであり、通常は `KeyedCollection<TKey,TItem>` を継承することによって実装されます。</span><span class="sxs-lookup"><span data-stu-id="cc749-143">Keyed collections are collections that can be indexed by both an integer and a key and are usually implemented by inheriting from `KeyedCollection<TKey,TItem>`.</span></span>

 <span data-ttu-id="cc749-144">通常、キー付きコレクションはメモリ占有領域が大きいため、メモリのオーバーヘッドがキーを使用する利点を上回る場合は使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="cc749-144">Keyed collections usually have larger memory footprints and should not be used if the memory overhead outweighs the benefits of having the keys.</span></span>

 <span data-ttu-id="cc749-145">❌ コレクションのプロパティから、またはコレクションを返すメソッドからは、null 値を返さないでください。</span><span class="sxs-lookup"><span data-stu-id="cc749-145">❌ DO NOT return null values from collection properties or from methods returning collections.</span></span> <span data-ttu-id="cc749-146">代わりに空のコレクションまたは空の配列を返します。</span><span class="sxs-lookup"><span data-stu-id="cc749-146">Return an empty collection or an empty array instead.</span></span>

 <span data-ttu-id="cc749-147">一般的なルールとして、null と空の (0 項目) のコレクションまたは配列は、同じように扱う必要があります。</span><span class="sxs-lookup"><span data-stu-id="cc749-147">The general rule is that null and empty (0 item) collections or arrays should be treated the same.</span></span>

### <a name="snapshots-versus-live-collections"></a><span data-ttu-id="cc749-148">スナップショットとライブ コレクション</span><span class="sxs-lookup"><span data-stu-id="cc749-148">Snapshots Versus Live Collections</span></span>

 <span data-ttu-id="cc749-149">ある時点での状態を表すコレクションは、スナップショット コレクションと呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="cc749-149">Collections representing a state at some point in time are called snapshot collections.</span></span> <span data-ttu-id="cc749-150">たとえば、データベース クエリから返された行が格納されるコレクションはスナップショットです。</span><span class="sxs-lookup"><span data-stu-id="cc749-150">For example, a collection containing rows returned from a database query would be a snapshot.</span></span> <span data-ttu-id="cc749-151">常に現在の状態を表すコレクションは、ライブ コレクションと呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="cc749-151">Collections that always represent the current state are called live collections.</span></span> <span data-ttu-id="cc749-152">たとえば、`ComboBox` 項目のコレクションはライブ コレクションです。</span><span class="sxs-lookup"><span data-stu-id="cc749-152">For example, a collection of `ComboBox` items is a live collection.</span></span>

 <span data-ttu-id="cc749-153">❌ プロパティからスナップショット コレクションを返さないでください。</span><span class="sxs-lookup"><span data-stu-id="cc749-153">❌ DO NOT return snapshot collections from properties.</span></span> <span data-ttu-id="cc749-154">プロパティからはライブ コレクションを返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="cc749-154">Properties should return live collections.</span></span>

 <span data-ttu-id="cc749-155">プロパティのゲッターは、非常に軽量な操作にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="cc749-155">Property getters should be very lightweight operations.</span></span> <span data-ttu-id="cc749-156">スナップショットを返すには、O(n) 操作で内部コレクションのコピーを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="cc749-156">Returning a snapshot requires creating a copy of an internal collection in an O(n) operation.</span></span>

 <span data-ttu-id="cc749-157">✔️ 揮発性である (つまり、コレクションを明示的に変更しなくても、変化する可能性がある) コレクションを表すには、スナップショット コレクションまたはライブ `IEnumerable<T>` (またはそのサブタイプ) のいずれかを使用します。</span><span class="sxs-lookup"><span data-stu-id="cc749-157">✔️ DO use either a snapshot collection or a live `IEnumerable<T>` (or its subtype) to represent collections that are volatile (i.e., that can change without explicitly modifying the collection).</span></span>

 <span data-ttu-id="cc749-158">一般に、共有リソース (ディレクトリ内のファイルなど) を表すコレクションはすべて揮発性です。</span><span class="sxs-lookup"><span data-stu-id="cc749-158">In general, all collections representing a shared resource (e.g., files in a directory) are volatile.</span></span> <span data-ttu-id="cc749-159">そのようなコレクションは、実装が単に順方向のみの列挙子である場合を除き、ライブ コレクションとして実装するのは非常に困難または不可能です。</span><span class="sxs-lookup"><span data-stu-id="cc749-159">Such collections are very difficult or impossible to implement as live collections unless the implementation is simply a forward-only enumerator.</span></span>

## <a name="choosing-between-arrays-and-collections"></a><span data-ttu-id="cc749-160">配列とコレクションの選択</span><span class="sxs-lookup"><span data-stu-id="cc749-160">Choosing Between Arrays and Collections</span></span>

 <span data-ttu-id="cc749-161">✔️ 配列よりコレクションを優先します。</span><span class="sxs-lookup"><span data-stu-id="cc749-161">✔️ DO prefer collections over arrays.</span></span>

 <span data-ttu-id="cc749-162">コレクションの方が、内容をきめ細かく制御でき、時間と共に発展でき、いっそう便利です。</span><span class="sxs-lookup"><span data-stu-id="cc749-162">Collections provide more control over contents, can evolve over time, and are more usable.</span></span> <span data-ttu-id="cc749-163">さらに、配列の複製にかかるコストは膨大であるため、読み取り専用のシナリオに配列を使用することはお勧めしません。</span><span class="sxs-lookup"><span data-stu-id="cc749-163">In addition, using arrays for read-only scenarios is discouraged because the cost of cloning the array is prohibitive.</span></span> <span data-ttu-id="cc749-164">使いやすさの研究では、一部の開発者はコレクション ベースの API を使用する方が快適であることが示されています。</span><span class="sxs-lookup"><span data-stu-id="cc749-164">Usability studies have shown that some developers feel more comfortable using collection-based APIs.</span></span>

 <span data-ttu-id="cc749-165">ただし、低レベルの API を開発している場合は、読み取り/書き込みのシナリオには配列を使用する方が適切な場合があります。</span><span class="sxs-lookup"><span data-stu-id="cc749-165">However, if you are developing low-level APIs, it might be better to use arrays for read-write scenarios.</span></span> <span data-ttu-id="cc749-166">配列の方がメモリ占有領域が小さいため、作業セットを減らすことができます。また、配列内の要素へのアクセスは、ランタイムによって最適化されるため、より高速になります。</span><span class="sxs-lookup"><span data-stu-id="cc749-166">Arrays have a smaller memory footprint, which helps reduce the working set, and access to elements in an array is faster because it is optimized by the runtime.</span></span>

 <span data-ttu-id="cc749-167">✔️ メモリ消費を最小限に抑え、パフォーマンスを最大にするため、低レベルの API では配列を使用することを検討します。</span><span class="sxs-lookup"><span data-stu-id="cc749-167">✔️ CONSIDER using arrays in low-level APIs to minimize memory consumption and maximize performance.</span></span>

 <span data-ttu-id="cc749-168">✔️ バイトのコレクションではなく、バイト配列を使用します。</span><span class="sxs-lookup"><span data-stu-id="cc749-168">✔️ DO use byte arrays instead of collections of bytes.</span></span>

 <span data-ttu-id="cc749-169">❌ プロパティ ゲッターが呼び出されるたびに、プロパティから新しい配列 (内部配列のコピーなど) を返す必要がある場合は、プロパティに配列を使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="cc749-169">❌ DO NOT use arrays for properties if the property would have to return a new array (e.g., a copy of an internal array) every time the property getter is called.</span></span>

## <a name="implementing-custom-collections"></a><span data-ttu-id="cc749-170">カスタム コレクションの実装</span><span class="sxs-lookup"><span data-stu-id="cc749-170">Implementing Custom Collections</span></span>

 <span data-ttu-id="cc749-171">✔️ 新しいコレクションを設計するときは、`Collection<T>`、`ReadOnlyCollection<T>`、または `KeyedCollection<TKey,TItem>` から継承することを検討します。</span><span class="sxs-lookup"><span data-stu-id="cc749-171">✔️ CONSIDER inheriting from `Collection<T>`, `ReadOnlyCollection<T>`, or `KeyedCollection<TKey,TItem>` when designing new collections.</span></span>

 <span data-ttu-id="cc749-172">✔️ 新しいコレクションを設計するときは、`IEnumerable<T>` を実装します。</span><span class="sxs-lookup"><span data-stu-id="cc749-172">✔️ DO implement `IEnumerable<T>` when designing new collections.</span></span> <span data-ttu-id="cc749-173">合理的である場合は、`ICollection<T>` または `IList<T>` を実装することを検討します。</span><span class="sxs-lookup"><span data-stu-id="cc749-173">Consider implementing `ICollection<T>` or even `IList<T>` where it makes sense.</span></span>

 <span data-ttu-id="cc749-174">そのようなカスタム コレクションを実装するときは、`Collection<T>` および `ReadOnlyCollection<T>` によって確立されている API パターンに、可能な限り忠実に従います。</span><span class="sxs-lookup"><span data-stu-id="cc749-174">When implementing such custom collection, follow the API pattern established by `Collection<T>` and `ReadOnlyCollection<T>` as closely as possible.</span></span> <span data-ttu-id="cc749-175">つまり、同じメンバーを明示的に実装する、これら 2 つのコレクションと同じようにパラメーターに名前を付ける、といったことです。</span><span class="sxs-lookup"><span data-stu-id="cc749-175">That is, implement the same members explicitly, name the parameters like these two collections name them, and so on.</span></span>

 <span data-ttu-id="cc749-176">✔️ これらのインターフェイスを入力として受け取る API にコレクションを頻繁に渡す場合は、非ジェネリック コレクション インターフェイス (`IList` と `ICollection`) を実装することを検討します。</span><span class="sxs-lookup"><span data-stu-id="cc749-176">✔️ CONSIDER implementing nongeneric collection interfaces (`IList` and `ICollection`) if the collection will often be passed to APIs taking these interfaces as input.</span></span>

 <span data-ttu-id="cc749-177">❌ コレクションの概念と関係のない複雑な API のある型に、コレクション インターフェイスを実装しないでください。</span><span class="sxs-lookup"><span data-stu-id="cc749-177">❌ AVOID implementing collection interfaces on types with complex APIs unrelated to the concept of a collection.</span></span>

 <span data-ttu-id="cc749-178">❌ `CollectionBase` などの非ジェネリック基本コレクションから継承しないでください。</span><span class="sxs-lookup"><span data-stu-id="cc749-178">❌ DO NOT inherit from nongeneric base collections such as `CollectionBase`.</span></span> <span data-ttu-id="cc749-179">代わりに `Collection<T>`、`ReadOnlyCollection<T>`、および `KeyedCollection<TKey,TItem>` 型を使用してください。</span><span class="sxs-lookup"><span data-stu-id="cc749-179">Use `Collection<T>`, `ReadOnlyCollection<T>`, and `KeyedCollection<TKey,TItem>` instead.</span></span>

### <a name="naming-custom-collections"></a><span data-ttu-id="cc749-180">カスタム コレクションの名前付け</span><span class="sxs-lookup"><span data-stu-id="cc749-180">Naming Custom Collections</span></span>

 <span data-ttu-id="cc749-181">コレクション (`IEnumerable` を実装する型) は、主に次の 2 つの理由で作成されます。(1) 構造固有の操作があり、多くの場合は既存のデータ構造 (<xref:System.Collections.Generic.List%601>、<xref:System.Collections.Generic.LinkedList%601>、<xref:System.Collections.Generic.Stack%601> など) と異なるパフォーマンス特性を持つ、新しいデータ構造を作成する、(2) 特定の項目のセットを保持するための特殊なコレクションを作成する (例: <xref:System.Collections.Specialized.StringCollection>)。</span><span class="sxs-lookup"><span data-stu-id="cc749-181">Collections (types that implement `IEnumerable`) are created mainly for two reasons: (1) to create a new data structure with structure-specific operations and often different performance characteristics than existing data structures (e.g.,  <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.LinkedList%601>, <xref:System.Collections.Generic.Stack%601>), and (2) to create a specialized collection for holding a specific set of items (e.g.,  <xref:System.Collections.Specialized.StringCollection>).</span></span> <span data-ttu-id="cc749-182">データ構造は、アプリケーションやライブラリの内部実装で最もよく使用されます。</span><span class="sxs-lookup"><span data-stu-id="cc749-182">Data structures are most often used in the internal implementation of applications and libraries.</span></span> <span data-ttu-id="cc749-183">特殊なコレクションは、主に API で公開されます (プロパティとパラメーターの型として)。</span><span class="sxs-lookup"><span data-stu-id="cc749-183">Specialized collections are mainly to be exposed in APIs (as property and parameter types).</span></span>

 <span data-ttu-id="cc749-184">✔️ `IDictionary` または `IDictionary<TKey,TValue>` を実装する抽象化の名前では、"Dictionary" サフィックスを使用します。</span><span class="sxs-lookup"><span data-stu-id="cc749-184">✔️ DO use the "Dictionary" suffix in names of abstractions implementing `IDictionary` or `IDictionary<TKey,TValue>`.</span></span>

 <span data-ttu-id="cc749-185">✔️ `IEnumerable` (またはその子孫) を実装し、項目のリストを表す型の名前では、"Collection" サフィックスを使用します。</span><span class="sxs-lookup"><span data-stu-id="cc749-185">✔️ DO use the "Collection" suffix in names of types implementing `IEnumerable` (or any of its descendants) and representing a list of items.</span></span>

 <span data-ttu-id="cc749-186">✔️ カスタム データ構造には、適切なデータ構造名を使用します。</span><span class="sxs-lookup"><span data-stu-id="cc749-186">✔️ DO use the appropriate data structure name for custom data structures.</span></span>

 <span data-ttu-id="cc749-187">❌ コレクションの抽象化の名前では、"LinkedList" や "Hashtable" など、特定の実装を意味するサフィックスを使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="cc749-187">❌ AVOID using any suffixes implying particular implementation, such as "LinkedList" or "Hashtable," in names of collection abstractions.</span></span>

 <span data-ttu-id="cc749-188">✔️ コレクションの名前には、項目の型の名前をプレフィックスとして付けることを検討します。</span><span class="sxs-lookup"><span data-stu-id="cc749-188">✔️ CONSIDER prefixing collection names with the name of the item type.</span></span> <span data-ttu-id="cc749-189">たとえば、(`IEnumerable<Address>` を実装する) `Address` 型の項目を格納するコレクションの名前は、`AddressCollection` にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="cc749-189">For example, a collection storing items of type `Address` (implementing `IEnumerable<Address>`) should be named `AddressCollection`.</span></span> <span data-ttu-id="cc749-190">項目の型がインターフェイスの場合は、項目の型の "I" プレフィックスを省略できます。</span><span class="sxs-lookup"><span data-stu-id="cc749-190">If the item type is an interface, the "I" prefix of the item type can be omitted.</span></span> <span data-ttu-id="cc749-191">したがって、<xref:System.IDisposable> 項目のコレクションは、`DisposableCollection` という名前にできます。</span><span class="sxs-lookup"><span data-stu-id="cc749-191">Thus, a collection of <xref:System.IDisposable> items can be called `DisposableCollection`.</span></span>

 <span data-ttu-id="cc749-192">✔️ フレームワークに対応する書き込み可能なコレクションが追加される可能性がある場合、または既に存在する場合は、読み取り専用コレクションの名前に "ReadOnly" プレフィックスを使用することを検討します。</span><span class="sxs-lookup"><span data-stu-id="cc749-192">✔️ CONSIDER using the "ReadOnly" prefix in names of read-only collections if a corresponding writeable collection might be added or already exists in the framework.</span></span>

 <span data-ttu-id="cc749-193">たとえば、文字列の読み取り専用コレクションの名前は、`ReadOnlyStringCollection` にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="cc749-193">For example, a read-only collection of strings should be called `ReadOnlyStringCollection`.</span></span>

 <span data-ttu-id="cc749-194">*Portions © 2005, 2009 Microsoft Corporation.All rights reserved.*</span><span class="sxs-lookup"><span data-stu-id="cc749-194">*Portions © 2005, 2009 Microsoft Corporation. All rights reserved.*</span></span>

 <span data-ttu-id="cc749-195">*2008 年 10 月 22 日に Microsoft Windows Development シリーズの一部として、Addison-Wesley Professional によって発行された、Krzysztof Cwalina および Brad Abrams による「[Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619)」 (フレームワーク デザイン ガイドライン: 再利用可能な .NET ライブラリの規則、用法、パターン、第 2 版) から Pearson Education, Inc. の許可を得て再印刷されています。*</span><span class="sxs-lookup"><span data-stu-id="cc749-195">*Reprinted by permission of Pearson Education, Inc. from [Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.*</span></span>

## <a name="see-also"></a><span data-ttu-id="cc749-196">関連項目</span><span class="sxs-lookup"><span data-stu-id="cc749-196">See also</span></span>

- [<span data-ttu-id="cc749-197">フレームワーク デザインのガイドライン</span><span class="sxs-lookup"><span data-stu-id="cc749-197">Framework Design Guidelines</span></span>](index.md)
- [<span data-ttu-id="cc749-198">使用方法のガイドライン</span><span class="sxs-lookup"><span data-stu-id="cc749-198">Usage Guidelines</span></span>](usage-guidelines.md)
