---
description: '詳細情報: イベントベースの非同期パターンを実装するための推奨される手順'
title: イベントベースの非同期パターンを実装するための推奨される手順
ms.date: 03/30/2017
helpviewer_keywords:
- Event-based Asynchronous Pattern
- ProgressChangedEventArgs class
- BackgroundWorker component
- events [.NET], asynchronous
- AsyncOperationManager class
- threading [.NET], asynchronous features
- AsyncOperation class
- AsyncCompletedEventArgs class
ms.assetid: 4acd2094-4f46-4eff-9190-92d0d9ff47db
ms.openlocfilehash: 8c34133664b9fae25ca2d9ef5e906a75c4603d58
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/06/2021
ms.locfileid: "99751938"
---
# <a name="best-practices-for-implementing-the-event-based-asynchronous-pattern"></a><span data-ttu-id="ba2a5-103">イベントベースの非同期パターンを実装するための推奨される手順</span><span class="sxs-lookup"><span data-stu-id="ba2a5-103">Best Practices for Implementing the Event-based Asynchronous Pattern</span></span>

<span data-ttu-id="ba2a5-104">イベントベースの非同期パターンは、使い慣れたイベントおよびデリゲートのセマンティクスと共に、クラス内の非同期動作を公開する効果的な方法を提供します。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-104">The Event-based Asynchronous Pattern provides you with an effective way to expose asynchronous behavior in classes, with familiar event and delegate semantics.</span></span> <span data-ttu-id="ba2a5-105">イベント ベースの非同期パターンを実装するには、いくつかの固有の動作要件に従う必要があります。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-105">To implement Event-based Asynchronous Pattern, you need to follow some specific behavioral requirements.</span></span> <span data-ttu-id="ba2a5-106">以降のセクションでは、イベントベースの非同期パターンに従うクラスを実装する際に検討すべき要件とガイドラインについて説明します。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-106">The following sections describe requirements and guidelines you should consider when you implement a class that follows the Event-based Asynchronous Pattern.</span></span>  
  
 <span data-ttu-id="ba2a5-107">概要については、「[イベントベースの非同期パターンの実装](implementing-the-event-based-asynchronous-pattern.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-107">For an overview, see [Implementing the Event-based Asynchronous Pattern](implementing-the-event-based-asynchronous-pattern.md).</span></span>  
  
## <a name="required-behavioral-guarantees"></a><span data-ttu-id="ba2a5-108">必要な動作保証</span><span class="sxs-lookup"><span data-stu-id="ba2a5-108">Required Behavioral Guarantees</span></span>

 <span data-ttu-id="ba2a5-109">イベントベースの非同期パターンを実装する場合は、クラスが適切に動作し、クラスのクライアントがそのような動作に依存できるようにするため、多数の保証を提供する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-109">If you implement the Event-based Asynchronous Pattern, you must provide a number of guarantees to ensure that your class will behave properly and clients of your class can rely on such behavior.</span></span>  
  
### <a name="completion"></a><span data-ttu-id="ba2a5-110">Completion</span><span class="sxs-lookup"><span data-stu-id="ba2a5-110">Completion</span></span>

 <span data-ttu-id="ba2a5-111">正常完了、エラー、またはキャンセルの場合に常に <em>MethodName</em>**Completed** イベント ハンドラーを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-111">Always invoke the <em>MethodName</em>**Completed** event handler when you have successful completion, an error, or a cancellation.</span></span> <span data-ttu-id="ba2a5-112">アプリケーションがアイドルになり完了しない状態が発生してはなりません。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-112">Applications should never encounter a situation where they remain idle and completion never occurs.</span></span> <span data-ttu-id="ba2a5-113">この規則の唯一の例外として、非同期操作自体は完了することがないように設計されている場合があります。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-113">One exception to this rule is if the asynchronous operation itself is designed so that it never completes.</span></span>  
  
### <a name="completed-event-and-eventargs"></a><span data-ttu-id="ba2a5-114">完了イベントおよび EventArg</span><span class="sxs-lookup"><span data-stu-id="ba2a5-114">Completed Event and EventArgs</span></span>

<span data-ttu-id="ba2a5-115">個別の <em>MethodName</em>**Async** メソッドごとに、次の設計要件を適用します。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-115">For each separate <em>MethodName</em>**Async** method, apply the following design requirements:</span></span>  
  
- <span data-ttu-id="ba2a5-116">メソッドと同じクラスで <em>MethodName</em>**Completed** イベントを定義します。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-116">Define a <em>MethodName</em>**Completed** event on the same class as the method.</span></span>  
  
- <span data-ttu-id="ba2a5-117"><xref:System.ComponentModel.AsyncCompletedEventArgs> クラスから派生した <em>MethodName</em>**Completed** イベントの <xref:System.EventArgs> クラスと、これに付随するデリゲートを定義します。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-117">Define an <xref:System.EventArgs> class and accompanying delegate for the <em>MethodName</em>**Completed** event that derives from the <xref:System.ComponentModel.AsyncCompletedEventArgs> class.</span></span> <span data-ttu-id="ba2a5-118">既定のクラス名の形式は、<em>MethodName</em>**CompletedEventArgs** です。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-118">The default class name should be of the form <em>MethodName</em>**CompletedEventArgs**.</span></span>  
  
- <span data-ttu-id="ba2a5-119"><xref:System.EventArgs> クラスは、<em>MethodName</em> メソッドの戻り値に固有のクラスにしてください。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-119">Ensure that the <xref:System.EventArgs> class is specific to the return values of the <em>MethodName</em> method.</span></span> <span data-ttu-id="ba2a5-120"><xref:System.EventArgs> クラスを使用する場合は、開発者に対して結果をキャストすることを義務付けないでください。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-120">When you use the <xref:System.EventArgs> class, you should never require developers to cast the result.</span></span>  
  
     <span data-ttu-id="ba2a5-121">設計要件の適切な実装と不適切な実装を次のコード例に示します。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-121">The following code example shows good and bad implementation of this design requirement respectively.</span></span>  
  
```csharp  
// Good design  
private void Form1_MethodNameCompleted(object sender, xxxCompletedEventArgs e)
{
    DemoType result = e.Result;  
}  
  
// Bad design  
private void Form1_MethodNameCompleted(object sender, MethodNameCompletedEventArgs e)
{
    DemoType result = (DemoType)(e.Result);  
}  
```  
  
- <span data-ttu-id="ba2a5-122"><xref:System.EventArgs> を返すメソッドのために `void` クラスを定義しないでください。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-122">Do not define an <xref:System.EventArgs> class for returning methods that return `void`.</span></span> <span data-ttu-id="ba2a5-123">代わりに <xref:System.ComponentModel.AsyncCompletedEventArgs> クラスのインスタンスを使用してください。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-123">Instead, use an instance of the <xref:System.ComponentModel.AsyncCompletedEventArgs> class.</span></span>  
  
- <span data-ttu-id="ba2a5-124">必ず常に <em>MethodName</em>**Completed** イベントを発生させます。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-124">Ensure that you always raise the <em>MethodName</em>**Completed** event.</span></span> <span data-ttu-id="ba2a5-125">このイベントは、正常完了、エラー、またはキャンセル時に発生する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-125">This event should be raised on successful completion, on an error, or on cancellation.</span></span> <span data-ttu-id="ba2a5-126">アプリケーションがアイドルになり完了しない状態が発生してはなりません。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-126">Applications should never encounter a situation where they remain idle and completion never occurs.</span></span>  
  
- <span data-ttu-id="ba2a5-127">非同期操作で発生した例外をすべてキャッチし、キャッチした例外を <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> プロパティに割り当ててください。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-127">Ensure that you catch any exceptions that occur in the asynchronous operation and assign the caught exception to the <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> property.</span></span>  
  
- <span data-ttu-id="ba2a5-128">タスクの実行中にエラーが発生した場合は、結果にアクセスできないようにしてください。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-128">If there was an error completing the task, the results should not be accessible.</span></span> <span data-ttu-id="ba2a5-129"><xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> プロパティが `null` ではない場合は、<xref:System.EventArgs> 構造体のプロパティにアクセスすると例外が発生するようにしてください。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-129">When the <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> property is not `null`, ensure that accessing any property in the <xref:System.EventArgs> structure raises an exception.</span></span> <span data-ttu-id="ba2a5-130">この検証を行うには、<xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-130">Use the <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A> method to perform this verification.</span></span>  
  
- <span data-ttu-id="ba2a5-131">タイムアウトをエラーとしてモデル化します。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-131">Model a time out as an error.</span></span> <span data-ttu-id="ba2a5-132">タイムアウトが発生したら、<em>MethodName</em>**Completed** イベントを発生させ、<xref:System.TimeoutException> を <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> プロパティに割り当てます。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-132">When a time out occurs, raise the <em>MethodName</em>**Completed** event and assign a <xref:System.TimeoutException> to the <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> property.</span></span>  
  
- <span data-ttu-id="ba2a5-133">クラスで複数の同時呼び出しがサポートされている場合は、必ず <em>MethodName</em>**Completed** イベントに適切な `userSuppliedState` オブジェクトが含まれるようにします。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-133">If your class supports multiple concurrent invocations, ensure that the <em>MethodName</em>**Completed** event contains the appropriate `userSuppliedState` object.</span></span>  
  
- <span data-ttu-id="ba2a5-134"><em>MethodName</em>**Completed** イベントが、適切なスレッドでアプリケーション サイクルの適切な時点で発生するようにしてください。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-134">Ensure that the <em>MethodName</em>**Completed** event is raised on the appropriate thread and at the appropriate time in the application lifecycle.</span></span> <span data-ttu-id="ba2a5-135">詳細については、「スレッド処理およびコンテキスト」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-135">For more information, see the Threading and Contexts section.</span></span>  
  
### <a name="simultaneously-executing-operations"></a><span data-ttu-id="ba2a5-136">操作の同時実行</span><span class="sxs-lookup"><span data-stu-id="ba2a5-136">Simultaneously Executing Operations</span></span>  
  
- <span data-ttu-id="ba2a5-137">クラスで複数の同時呼び出しがサポートされている場合は、開発者が各呼び出しを個別に追跡できるようにするため、`userSuppliedState` というオブジェクト値状態パラメーター、またはタスク ID を受け取る <em>MethodName</em>**Async** オーバーライドを定義します。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-137">If your class supports multiple concurrent invocations, enable the developer to track each invocation separately by defining the <em>MethodName</em>**Async** overload that takes an object-valued state parameter, or task ID, called `userSuppliedState`.</span></span> <span data-ttu-id="ba2a5-138">このパラメーターは、常に <em>MethodName</em>**Async** メソッドのシグネチャの最終パラメーターにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-138">This parameter should always be the last parameter in the <em>MethodName</em>**Async** method's signature.</span></span>  
  
- <span data-ttu-id="ba2a5-139">オブジェクト値状態パラメーターまたはタスク ID を受け取る <em>MethodName</em>**Async** オーバーロードがクラスによって定義される場合は、そのタスク ID の操作の有効期間を追跡し、完了ハンドラーに戻す必要があります。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-139">If your class defines the <em>MethodName</em>**Async** overload that takes an object-valued state parameter, or task ID, be sure to track the lifetime of the operation with that task ID, and be sure to provide it back into the completion handler.</span></span> <span data-ttu-id="ba2a5-140">役に立つヘルパー クラスがあります。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-140">There are helper classes available to assist.</span></span> <span data-ttu-id="ba2a5-141">コンカレンシー管理について詳しくは、「[方法 : イベントベースの非同期パターンをサポートするコンポーネントを実装する](component-that-supports-the-event-based-asynchronous-pattern.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-141">For more information on concurrency management, see [How to: Implement a Component That Supports the Event-based Asynchronous Pattern](component-that-supports-the-event-based-asynchronous-pattern.md).</span></span>  
  
- <span data-ttu-id="ba2a5-142">クラスによって、状態パラメーターなしで <em>MethodName</em>**Async** メソッドが定義され、このクラスで複数の同時呼び出しがサポートされていない場合、直前の <em>MethodName</em>**Async** 呼び出しが完了する前に <em>MethodName</em>**Async** を呼び出そうとすると、<xref:System.InvalidOperationException> が発生するようにします。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-142">If your class defines the <em>MethodName</em>**Async** method without the state parameter, and it does not support multiple concurrent invocations, ensure that any attempt to invoke <em>MethodName</em>**Async** before the prior <em>MethodName</em>**Async** invocation has completed raises an <xref:System.InvalidOperationException>.</span></span>  
  
- <span data-ttu-id="ba2a5-143">一般に、`userSuppliedState` パラメーターのない <em>MethodName</em>**Async** メソッドを複数回呼び出すときには、複数の未完了操作が存在するようにするため、例外を発生させないでください。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-143">In general, do not raise an exception if the <em>MethodName</em>**Async** method without the `userSuppliedState` parameter is invoked multiple times so that there are multiple outstanding operations.</span></span> <span data-ttu-id="ba2a5-144">例外を発生させることができるのは、クラスがその状況に対処できないことが明らかであるものの、開発者がこのような区別できない複数のコールバックを処理できる場合です。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-144">You can raise an exception when your class explicitly cannot handle that situation, but assume that developers can handle these multiple indistinguishable callbacks</span></span>  
  
### <a name="accessing-results"></a><span data-ttu-id="ba2a5-145">結果へのアクセス</span><span class="sxs-lookup"><span data-stu-id="ba2a5-145">Accessing Results</span></span>  
  
- <span data-ttu-id="ba2a5-146">非同期操作の実行中にエラーが発生した場合、その結果にはアクセスできないようにしてください。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-146">If there was an error during execution of the asynchronous operation, the results should not be accessible.</span></span> <span data-ttu-id="ba2a5-147"><xref:System.ComponentModel.AsyncCompletedEventArgs> が <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> ではない場合に `null` のプロパティにアクセスすると、<xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> により参照される例外が発生するようにしてください。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-147">Ensure that accessing any property in the <xref:System.ComponentModel.AsyncCompletedEventArgs> when <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> is not `null` raises the exception referenced by <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A>.</span></span> <span data-ttu-id="ba2a5-148"><xref:System.ComponentModel.AsyncCompletedEventArgs> クラスには、この目的で使用する <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A> メソッドが用意されています。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-148">The <xref:System.ComponentModel.AsyncCompletedEventArgs> class provides the <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A> method for this purpose.</span></span>  
  
- <span data-ttu-id="ba2a5-149">結果にアクセスしようとすると、操作がキャンセルされたことを示す <xref:System.InvalidOperationException> が発生するようにしてください。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-149">Ensure that any attempt to access the result raises an <xref:System.InvalidOperationException> stating that the operation was canceled.</span></span> <span data-ttu-id="ba2a5-150">この検証を行うには、<xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A?displayProperty=nameWithType> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-150">Use the <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A?displayProperty=nameWithType> method to perform this verification.</span></span>  
  
### <a name="progress-reporting"></a><span data-ttu-id="ba2a5-151">進行状況レポート</span><span class="sxs-lookup"><span data-stu-id="ba2a5-151">Progress Reporting</span></span>  
  
- <span data-ttu-id="ba2a5-152">可能であれば、進行状況レポートをサポートします。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-152">Support progress reporting, if possible.</span></span> <span data-ttu-id="ba2a5-153">これにより、開発者はクラスを使用する際に、より優れたアプリケーション ユーザー エクスペリエンスを提供できます。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-153">This enables developers to provide a better application user experience when they use your class.</span></span>  
  
- <span data-ttu-id="ba2a5-154">**ProgressChanged** または <em>MethodName</em>**ProgressChanged** イベントを実装する場合は、操作の <em>MethodName</em>**Completed** イベントが発生した後で、特定の非同期操作についてそのようなイベントが発生していないようにしてください。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-154">If you implement a **ProgressChanged** or <em>MethodName</em>**ProgressChanged** event, ensure that there are no such events raised for a particular asynchronous operation after that operation's <em>MethodName</em>**Completed** event has been raised.</span></span>  
  
- <span data-ttu-id="ba2a5-155">標準 <xref:System.ComponentModel.ProgressChangedEventArgs> の値が設定される場合は、<xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A> が常にパーセンテージとして解釈できるようにしてください。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-155">If the standard <xref:System.ComponentModel.ProgressChangedEventArgs> is being populated, ensure that the <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A> can always be interpreted as a percentage.</span></span> <span data-ttu-id="ba2a5-156">パーセンテージは正確である必要はありませんが、パーセンテージを表している必要があります。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-156">The percentage does not need to be accurate, but it should represent a percentage.</span></span> <span data-ttu-id="ba2a5-157">進行状況レポート メトリックがパーセンテージ以外でなければならない場合は、<xref:System.ComponentModel.ProgressChangedEventArgs> クラスからクラスを派生し、<xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A> は 0 のままにしておきます。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-157">If your progress reporting metric must be something other than a percentage, derive a class from the <xref:System.ComponentModel.ProgressChangedEventArgs> class and leave <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A> at 0.</span></span> <span data-ttu-id="ba2a5-158">パーセンテージ以外のレポート メトリックは使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-158">Avoid using a reporting metric other than a percentage.</span></span>  
  
- <span data-ttu-id="ba2a5-159">`ProgressChanged` イベントが、適切なスレッドでアプリケーション サイクルの適切な時点で発生するようにしてください。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-159">Ensure that the `ProgressChanged` event is raised on the appropriate thread and at the appropriate time in the application lifecycle.</span></span> <span data-ttu-id="ba2a5-160">詳細については、「スレッド処理およびコンテキスト」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-160">For more information, see the Threading and Contexts section.</span></span>  
  
### <a name="isbusy-implementation"></a><span data-ttu-id="ba2a5-161">IsBusy 実装</span><span class="sxs-lookup"><span data-stu-id="ba2a5-161">IsBusy Implementation</span></span>  
  
- <span data-ttu-id="ba2a5-162">クラスが複数の同時呼び出しをサポートしている場合は、`IsBusy` プロパティを公開しないでください。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-162">Do not expose an `IsBusy` property if your class supports multiple concurrent invocations.</span></span> <span data-ttu-id="ba2a5-163">たとえば XML Web サービス プロキシは、非同期メソッドの複数同時呼び出しをサポートしているため、`IsBusy` プロパティを公開しません。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-163">For example, XML Web service proxies do not expose an `IsBusy` property because they support multiple concurrent invocations of asynchronous methods.</span></span>  
  
- <span data-ttu-id="ba2a5-164">`IsBusy` プロパティは、<em>MethodName</em>**Async** メソッドが呼び出されてから、<em>MethodName</em>**Completed** イベントが発生するまでの間は、`true` を返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-164">The `IsBusy` property should return `true` after the <em>MethodName</em>**Async** method has been called and before the <em>MethodName</em>**Completed** event has been raised.</span></span> <span data-ttu-id="ba2a5-165">それ以外の場合は、`false` を返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-165">Otherwise it should return `false`.</span></span> <span data-ttu-id="ba2a5-166"><xref:System.ComponentModel.BackgroundWorker> プロパティを公開するクラスの例として、<xref:System.Net.WebClient> および `IsBusy` コンポーネントがあります。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-166">The <xref:System.ComponentModel.BackgroundWorker> and <xref:System.Net.WebClient> components are examples of classes that expose an `IsBusy` property.</span></span>  
  
### <a name="cancellation"></a><span data-ttu-id="ba2a5-167">キャンセル</span><span class="sxs-lookup"><span data-stu-id="ba2a5-167">Cancellation</span></span>  
  
- <span data-ttu-id="ba2a5-168">可能であれば、キャンセルをサポートしてください。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-168">Support cancellation, if possible.</span></span> <span data-ttu-id="ba2a5-169">これにより、開発者はクラスを使用する際に、より優れたアプリケーション ユーザー エクスペリエンスを提供できます。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-169">This enables developers to provide a better application user experience when they use your class.</span></span>  
  
- <span data-ttu-id="ba2a5-170">キャンセルの場合、<xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> オブジェクトに <xref:System.ComponentModel.AsyncCompletedEventArgs> フラグを設定します。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-170">In the case of cancellation, set the <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> flag in the <xref:System.ComponentModel.AsyncCompletedEventArgs> object.</span></span>  
  
- <span data-ttu-id="ba2a5-171">結果にアクセスしようとすると、操作がキャンセルされたことを示す <xref:System.InvalidOperationException> が発生するようにしてください。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-171">Ensure that any attempt to access the result raises an <xref:System.InvalidOperationException> stating that the operation was canceled.</span></span> <span data-ttu-id="ba2a5-172">この検証を行うには、<xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A?displayProperty=nameWithType> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-172">Use the <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A?displayProperty=nameWithType> method to perform this verification.</span></span>  
  
- <span data-ttu-id="ba2a5-173">キャンセル メソッドの呼び出しは常に正常に戻り、例外を発生させないようにしてください。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-173">Ensure that calls to a cancellation method always return successfully, and never raise an exception.</span></span> <span data-ttu-id="ba2a5-174">一般に、特定の時点で操作が実際にキャンセル可能かどうかと、前に発行したキャンセルが正常に実行されたかどうかはクライアントに通知されません。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-174">In general, a client is not notified as to whether an operation is truly cancelable at any given time, and is not notified as to whether a previously issued cancellation has succeeded.</span></span> <span data-ttu-id="ba2a5-175">ただし、キャンセルが正常に完了すると常にアプリケーションに通知が送られます。これは、アプリケーションが完了ステータスに関与しているためです。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-175">However, the application will always be given notification when a cancellation succeeded, because the application takes part in the completion status.</span></span>  
  
- <span data-ttu-id="ba2a5-176">操作がキャンセルされた場合は、<em>MethodName</em>**Completed** イベントを発生させます。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-176">Raise the <em>MethodName</em>**Completed** event when the operation is canceled.</span></span>  
  
### <a name="errors-and-exceptions"></a><span data-ttu-id="ba2a5-177">エラーと例外</span><span class="sxs-lookup"><span data-stu-id="ba2a5-177">Errors and Exceptions</span></span>  
  
- <span data-ttu-id="ba2a5-178">非同期操作で発生した例外をすべてキャッチし、その例外の <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A?displayProperty=nameWithType> プロパティの値を設定します。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-178">Catch any exceptions that occur in the asynchronous operation and set the value of the <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A?displayProperty=nameWithType> property to that exception.</span></span>  
  
### <a name="threading-and-contexts"></a><span data-ttu-id="ba2a5-179">スレッド処理およびコンテキスト</span><span class="sxs-lookup"><span data-stu-id="ba2a5-179">Threading and Contexts</span></span>

 <span data-ttu-id="ba2a5-180">クラスを正しく操作するには、特定のアプリケーション モデル (ASP.NET および Windows フォーム アプリケーションを含む) の適切なスレッドまたはコンテキストで、クライアントのイベント ハンドラーが呼び出されることが重要です。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-180">For correct operation of your class, it is critical that the client's event handlers are invoked on the proper thread or context for the given application model, including ASP.NET and Windows Forms applications.</span></span> <span data-ttu-id="ba2a5-181">非同期クラスがどのアプリケーション モデルでも正しく動作するように、<xref:System.ComponentModel.AsyncOperation> と <xref:System.ComponentModel.AsyncOperationManager> という 2 つの重要なヘルパー クラスが用意されています。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-181">Two important helper classes are provided to ensure that your asynchronous class behaves correctly under any application model: <xref:System.ComponentModel.AsyncOperation> and <xref:System.ComponentModel.AsyncOperationManager>.</span></span>  
  
 <span data-ttu-id="ba2a5-182"><xref:System.ComponentModel.AsyncOperationManager> にはメソッド <xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A> が含まれています。このメソッドは <xref:System.ComponentModel.AsyncOperation> を返します。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-182"><xref:System.ComponentModel.AsyncOperationManager> provides one method, <xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A>, which returns an <xref:System.ComponentModel.AsyncOperation>.</span></span> <span data-ttu-id="ba2a5-183"><em>MethodName</em>**Async** メソッドは <xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A> を呼び出し、クラスは返される <xref:System.ComponentModel.AsyncOperation> を使用して非同期タスクの有効期間を追跡します。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-183">Your <em>MethodName</em>**Async** method calls <xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A> and your class uses the returned <xref:System.ComponentModel.AsyncOperation> to track the lifetime of the asynchronous task.</span></span>  
  
 <span data-ttu-id="ba2a5-184">進行状況、インクリメンタル結果、および完了をクライアントに報告するため、<xref:System.ComponentModel.AsyncOperation.Post%2A> で <xref:System.ComponentModel.AsyncOperation.OperationCompleted%2A> メソッドと <xref:System.ComponentModel.AsyncOperation> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-184">To report progress, incremental results, and completion to the client, call the <xref:System.ComponentModel.AsyncOperation.Post%2A> and <xref:System.ComponentModel.AsyncOperation.OperationCompleted%2A> methods on the <xref:System.ComponentModel.AsyncOperation>.</span></span> <span data-ttu-id="ba2a5-185"><xref:System.ComponentModel.AsyncOperation> は、クライアントのイベント ハンドラーに対する呼び出しを適切なスレッドまたはコンテキストにマーシャリングします。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-185"><xref:System.ComponentModel.AsyncOperation> is responsible for marshaling calls to the client's event handlers to the proper thread or context.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="ba2a5-186">アプリケーション モデルのポリシーに対し明示的に準拠しないものの、イベント ベースの非同期パターンを使用する他のメリットを利用したい場合は、これらの規則を回避できます。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-186">You can circumvent these rules if you explicitly want to go against the policy of the application model, but still benefit from the other advantages of using the Event-based Asynchronous Pattern.</span></span> <span data-ttu-id="ba2a5-187">たとえば、Windows Forms でのクラス操作をフリー スレッド化するとします。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-187">For example, you may want a class operating in Windows Forms to be free threaded.</span></span> <span data-ttu-id="ba2a5-188">開発者がフリー スレッド化クラスの暗黙的な制限を理解している場合は、フリースレッド化クラスを作成できます。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-188">You can create a free threaded class, as long as developers understand the implied restrictions.</span></span> <span data-ttu-id="ba2a5-189">コンソール アプリケーションは <xref:System.ComponentModel.AsyncOperation.Post%2A> 呼び出しの実行を同期しません。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-189">Console applications do not synchronize the execution of <xref:System.ComponentModel.AsyncOperation.Post%2A> calls.</span></span> <span data-ttu-id="ba2a5-190">これが原因で、`ProgressChanged` イベントが正しくない順序で発生することがあります。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-190">This can cause `ProgressChanged` events to be raised out of order.</span></span> <span data-ttu-id="ba2a5-191"><xref:System.ComponentModel.AsyncOperation.Post%2A> 呼び出しを順次実行するには、<xref:System.Threading.SynchronizationContext?displayProperty=nameWithType> クラスを実装およびインストールします。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-191">If you wish to have serialized execution of <xref:System.ComponentModel.AsyncOperation.Post%2A> calls, implement and install a <xref:System.Threading.SynchronizationContext?displayProperty=nameWithType> class.</span></span>  
  
 <span data-ttu-id="ba2a5-192"><xref:System.ComponentModel.AsyncOperation> と <xref:System.ComponentModel.AsyncOperationManager> を使用した非同期操作について詳しくは、「[方法 : イベントベースの非同期パターンをサポートするコンポーネントを実装する](component-that-supports-the-event-based-asynchronous-pattern.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-192">For more information about using <xref:System.ComponentModel.AsyncOperation> and <xref:System.ComponentModel.AsyncOperationManager> to enable your asynchronous operations, see [How to: Implement a Component That Supports the Event-based Asynchronous Pattern](component-that-supports-the-event-based-asynchronous-pattern.md).</span></span>  
  
## <a name="guidelines"></a><span data-ttu-id="ba2a5-193">ガイドライン</span><span class="sxs-lookup"><span data-stu-id="ba2a5-193">Guidelines</span></span>  
  
- <span data-ttu-id="ba2a5-194">各メソッド呼び出しが相互に独立していることが理想的です。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-194">Ideally, each method invocation should be independent of others.</span></span> <span data-ttu-id="ba2a5-195">呼び出しを共有リソースと組み合わせないでください。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-195">You should avoid coupling invocations with shared resources.</span></span> <span data-ttu-id="ba2a5-196">リソースを複数の呼び出し間で共有する場合は、実装に適切な同期メカニズムを提供する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-196">If resources are to be shared among invocations, you will need to provide a proper synchronization mechanism in your implementation.</span></span>  
  
- <span data-ttu-id="ba2a5-197">クライアントが同期を実装する必要がある設計は推奨されません。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-197">Designs that require the client to implement synchronization are discouraged.</span></span> <span data-ttu-id="ba2a5-198">たとえば、グローバルな静的オブジェクトをパラメータとして受け取る非同期メソッドがあり、この非同期メソッドを同時に複数呼び出すと、データの破損またはデッドロックが発生することがあります。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-198">For example, you could have an asynchronous method that receives a global static object as a parameter; multiple concurrent invocations of such a method could result in data corruption or deadlocks.</span></span>  
  
- <span data-ttu-id="ba2a5-199">複数呼び出しのオーバーロード (シグネチャの `userState`) を使用してメソッドを実装する場合、ユーザー状態、タスク ID、対応する保留操作のコレクションをクラスで管理する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-199">If you implement a method with the multiple-invocation overload (`userState` in the signature), your class will need to manage a collection of user states, or task IDs, and their corresponding pending operations.</span></span> <span data-ttu-id="ba2a5-200">さまざまな呼び出しでこのコレクションの `lock` オブジェクトが追加および削除されるため、このコレクションを `userState` 領域で保護する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-200">This collection should be protected with `lock` regions, because the various invocations add and remove `userState` objects in the collection.</span></span>  
  
- <span data-ttu-id="ba2a5-201">可能かつ適切な場合は、`CompletedEventArgs` クラスの再利用を検討してください。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-201">Consider reusing `CompletedEventArgs` classes where feasible and appropriate.</span></span> <span data-ttu-id="ba2a5-202">この場合、特定のデリゲートと <xref:System.EventArgs> 型が 1 つのメソッドに関連付けられていないため、名前付けにはメソッド名との整合性がありません。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-202">In this case, the naming is not consistent with the method name, because a given delegate and <xref:System.EventArgs> type are not tied to a single method.</span></span> <span data-ttu-id="ba2a5-203">ただし、開発者に対して <xref:System.EventArgs> のプロパティから取得した値をキャストすることを強制することはできません。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-203">However, forcing developers to cast the value retrieved from a property on the <xref:System.EventArgs> is never acceptable.</span></span>  
  
- <span data-ttu-id="ba2a5-204"><xref:System.ComponentModel.Component> から派生したクラスを編集する場合、独自の <xref:System.Threading.SynchronizationContext> クラスを実装およびインストールしないでください。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-204">If you are authoring a class that derives from <xref:System.ComponentModel.Component>, do not implement and install your own <xref:System.Threading.SynchronizationContext> class.</span></span> <span data-ttu-id="ba2a5-205">使用される <xref:System.Threading.SynchronizationContext> を制御するのは、コンポーネントではなくアプリケーション モデルです。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-205">Application models, not components, control the <xref:System.Threading.SynchronizationContext> that is used.</span></span>  
  
- <span data-ttu-id="ba2a5-206">どのようなマルチスレッドを使用する場合でも、深刻かつ複雑なバグが発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-206">When you use multithreading of any sort, you potentially expose yourself to very serious and complex bugs.</span></span> <span data-ttu-id="ba2a5-207">マルチスレッドを使用するソリューションを実装する前に、「[マネージド スレッド処理の実施](../threading/managed-threading-best-practices.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ba2a5-207">Before implementing any solution that uses multithreading, see [Managed Threading Best Practices](../threading/managed-threading-best-practices.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="ba2a5-208">関連項目</span><span class="sxs-lookup"><span data-stu-id="ba2a5-208">See also</span></span>

- <xref:System.ComponentModel.AsyncOperation>
- <xref:System.ComponentModel.AsyncOperationManager>
- <xref:System.ComponentModel.AsyncCompletedEventArgs>
- <xref:System.ComponentModel.ProgressChangedEventArgs>
- <xref:System.ComponentModel.BackgroundWorker>
- [<span data-ttu-id="ba2a5-209">イベントベースの非同期パターンの実装</span><span class="sxs-lookup"><span data-stu-id="ba2a5-209">Implementing the Event-based Asynchronous Pattern</span></span>](implementing-the-event-based-asynchronous-pattern.md)
- [<span data-ttu-id="ba2a5-210">イベント ベースの非同期パターン (EAP)</span><span class="sxs-lookup"><span data-stu-id="ba2a5-210">Event-based Asynchronous Pattern (EAP)</span></span>](event-based-asynchronous-pattern-eap.md)
- [<span data-ttu-id="ba2a5-211">イベントベースの非同期パターンをいつ実装するかの決定</span><span class="sxs-lookup"><span data-stu-id="ba2a5-211">Deciding When to Implement the Event-based Asynchronous Pattern</span></span>](deciding-when-to-implement-the-event-based-asynchronous-pattern.md)
- [<span data-ttu-id="ba2a5-212">イベントベースの非同期パターンを実装するための推奨される手順</span><span class="sxs-lookup"><span data-stu-id="ba2a5-212">Best Practices for Implementing the Event-based Asynchronous Pattern</span></span>](best-practices-for-implementing-the-event-based-asynchronous-pattern.md)
- [<span data-ttu-id="ba2a5-213">方法: イベントベースの非同期パターンをサポートするコンポーネントを使用する</span><span class="sxs-lookup"><span data-stu-id="ba2a5-213">How to: Use Components That Support the Event-based Asynchronous Pattern</span></span>](how-to-use-components-that-support-the-event-based-asynchronous-pattern.md)
- [<span data-ttu-id="ba2a5-214">方法: イベントベースの非同期パターンをサポートするコンポーネントを実装する</span><span class="sxs-lookup"><span data-stu-id="ba2a5-214">How to: Implement a Component That Supports the Event-based Asynchronous Pattern</span></span>](component-that-supports-the-event-based-asynchronous-pattern.md)
