---
description: '詳細情報: 正規表現の動作の詳細'
title: 正規表現の動作
ms.date: 03/30/2017
ms.topic: conceptual
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, behavior
- .NET regular expressions, behavior
ms.assetid: 0ee1a6b8-caac-41d2-917f-d35570021b10
ms.openlocfilehash: a06d66da92ae711abfbcbb477fd08e1da036f439
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/06/2021
ms.locfileid: "99629826"
---
# <a name="details-of-regular-expression-behavior"></a><span data-ttu-id="8396e-103">正規表現の動作の詳細</span><span class="sxs-lookup"><span data-stu-id="8396e-103">Details of regular expression behavior</span></span>

<span data-ttu-id="8396e-104">.NET の正規表現エンジンはバックトラッキング型の正規表現マッチャーであり、Perl、Python、Emacs、および Tcl で使用されているのと同じ従来型の非決定性有限オートマトン (NFA) エンジンを採用しています。</span><span class="sxs-lookup"><span data-stu-id="8396e-104">The .NET regular expression engine is a backtracking regular expression matcher that incorporates a traditional Nondeterministic Finite Automaton (NFA) engine such as that used by Perl, Python, Emacs, and Tcl.</span></span> <span data-ttu-id="8396e-105">このエンジンは、awk、egrep、または lex に見られるような、より高速であるが制限が多い、純粋な正規表現決定性有限オートマトン (DFA) エンジンとは異なります。</span><span class="sxs-lookup"><span data-stu-id="8396e-105">This distinguishes it from faster, but more limited, pure regular expression Deterministic Finite Automaton (DFA) engines such as those found in awk, egrep, or lex.</span></span> <span data-ttu-id="8396e-106">また、標準化されているが低速な POSIX NFA とも異なります。</span><span class="sxs-lookup"><span data-stu-id="8396e-106">This also distinguishes it from standardized, but slower, POSIX NFAs.</span></span> <span data-ttu-id="8396e-107">次のセクションでは、これら 3 種類の正規表現エンジンについて説明し、.NET の正規表現が従来型 NFA エンジンを使用して実装されている理由について説明します。</span><span class="sxs-lookup"><span data-stu-id="8396e-107">The following section describes the three types of regular expression engines, and explains why regular expressions in .NET are implemented by using a traditional NFA engine.</span></span>

## <a name="benefits-of-the-nfa-engine"></a><span data-ttu-id="8396e-108">NFA エンジンの利点</span><span class="sxs-lookup"><span data-stu-id="8396e-108">Benefits of the NFA engine</span></span>

 <span data-ttu-id="8396e-109">DFA エンジンがパターン一致を実行する場合、その処理順序は入力文字列によって決定されます。</span><span class="sxs-lookup"><span data-stu-id="8396e-109">When DFA engines perform pattern matching, their processing order is driven by the input string.</span></span> <span data-ttu-id="8396e-110">このエンジンは入力文字列の先頭で開始し、順番に進んで、次の文字が正規表現パターンと一致するかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="8396e-110">The engine begins at the beginning of the input string and proceeds sequentially to determine whether the next character matches the regular expression pattern.</span></span> <span data-ttu-id="8396e-111">このエンジンでは、想定され得る最長の文字列を確実に検索できます。</span><span class="sxs-lookup"><span data-stu-id="8396e-111">They can guarantee to match the longest string possible.</span></span> <span data-ttu-id="8396e-112">同じ文字が 2 回テストされることはないため、DFA エンジンはバックトラッキングをサポートしません。</span><span class="sxs-lookup"><span data-stu-id="8396e-112">Because they never test the same character twice, DFA engines do not support backtracking.</span></span> <span data-ttu-id="8396e-113">ただし、DFA エンジンには有限状態しか含まれないため、前方参照を使用してパターンを検索することはできません。また、明示的な展開が作成されないため、部分式をキャプチャできません。</span><span class="sxs-lookup"><span data-stu-id="8396e-113">However, because a DFA engine contains only finite state, it cannot match a pattern with backreferences, and because it does not construct an explicit expansion, it cannot capture subexpressions.</span></span>

 <span data-ttu-id="8396e-114">DFA エンジンとは異なり、従来型 NFA エンジンがパターン一致を実行する場合、その処理順序は正規表現パターンによって決定されます。</span><span class="sxs-lookup"><span data-stu-id="8396e-114">Unlike DFA engines, when traditional NFA engines perform pattern matching, their processing order is driven by the regular expression pattern.</span></span> <span data-ttu-id="8396e-115">特定の言語要素を処理するときに、エンジンは最長一致を使用します。つまり、できるだけ多くの入力文字列と一致するようにします。</span><span class="sxs-lookup"><span data-stu-id="8396e-115">As it processes a particular language element, the engine uses greedy matching; that is, it matches as much of the input string as it possibly can.</span></span> <span data-ttu-id="8396e-116">しかし、部分式の一致が見つかった後の状態も保存します。</span><span class="sxs-lookup"><span data-stu-id="8396e-116">But it also saves its state after successfully matching a subexpression.</span></span> <span data-ttu-id="8396e-117">最終的に一致が見つからなかった場合、エンジンは保存した状態に戻ることができるため、さらに照合を試行できます。</span><span class="sxs-lookup"><span data-stu-id="8396e-117">If a match eventually fails, the engine can return to a saved state so it can try additional matches.</span></span> <span data-ttu-id="8396e-118">正規表現の後の言語要素も照合できるようにするために、この見つかった部分式の一致を破棄するプロセスを "*バックトラッキング*" と呼びます。</span><span class="sxs-lookup"><span data-stu-id="8396e-118">This process of abandoning a successful subexpression match so that later language elements in the regular expression can also match is known as *backtracking*.</span></span> <span data-ttu-id="8396e-119">NFA エンジンは、バックトラッキングを使用して、ある正規表現で可能なすべての展開を特定の順序でテストし、最初に一致した文字列を採用します。</span><span class="sxs-lookup"><span data-stu-id="8396e-119">NFA engines use backtracking to test all possible expansions of a regular expression in a specific order and accept the first match.</span></span> <span data-ttu-id="8396e-120">従来型 NFA エンジンでは、見つかった一致文字列の正規表現に固有の展開が作成されるため、部分式に一致する文字列と、一致する前方参照をキャプチャできます。</span><span class="sxs-lookup"><span data-stu-id="8396e-120">Because a traditional NFA engine constructs a specific expansion of the regular expression for a successful match, it can capture subexpression matches and matching backreferences.</span></span> <span data-ttu-id="8396e-121">しかし、従来型 NFA ではバックトラックが行われるため、1 つの状態に到達する経路が複数ある場合には、同じ状態に何度も到達する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8396e-121">However, because a traditional NFA backtracks, it can visit the same state multiple times if it arrives at the state over different paths.</span></span> <span data-ttu-id="8396e-122">その結果、最悪の場合には指数関数的に実行速度が遅くなることがあります。</span><span class="sxs-lookup"><span data-stu-id="8396e-122">As a result, it can run exponentially slowly in the worst case.</span></span> <span data-ttu-id="8396e-123">従来型 NFA エンジンでは、最初に見つかった一致文字列が採用されるため、その他の (おそらく、より長い) 一致文字列が見つからないままになる場合もあります。</span><span class="sxs-lookup"><span data-stu-id="8396e-123">Because a traditional NFA engine accepts the first match it finds, it can also leave other (possibly longer) matches undiscovered.</span></span>

 <span data-ttu-id="8396e-124">POSIX NFA エンジンは従来型 NFA エンジンと似ていますが、一致する最長の文字列が確実に見つかるまでバックトラックが継続される点が異なります。</span><span class="sxs-lookup"><span data-stu-id="8396e-124">POSIX NFA engines are like traditional NFA engines, except that they continue to backtrack until they can guarantee that they have found the longest match possible.</span></span> <span data-ttu-id="8396e-125">その結果、POSIX NFA エンジンは従来型 NFA エンジンよりも実行速度が遅くなります。また、POSIX NFA エンジンを使用する場合は、バックトラッキング検索の順序を変更して、より短い一致文字列を長い一致文字列よりも優先させることはできません。</span><span class="sxs-lookup"><span data-stu-id="8396e-125">As a result, a POSIX NFA engine is slower than a traditional NFA engine, and when you use a POSIX NFA engine, you cannot favor a shorter match over a longer one by changing the order of the backtracking search.</span></span>

 <span data-ttu-id="8396e-126">従来型 NFA エンジンは、DFA エンジンや POSIX NFA エンジンよりも文字列の一致をより厳密に制御するため、プログラマに人気があります。</span><span class="sxs-lookup"><span data-stu-id="8396e-126">Traditional NFA engines are favored by programmers because they offer greater control over string matching than either DFA or POSIX NFA engines.</span></span> <span data-ttu-id="8396e-127">NFA エンジンは、最悪の場合には実行速度が遅くなることもありますが、あいまいさを少なくし、バックトラッキングを制限するパターンを使用すると、一致する文字列を線形時間または多項式時間で見つけるように調整できます。</span><span class="sxs-lookup"><span data-stu-id="8396e-127">Although, in the worst case, they can run slowly, you can steer them to find matches in linear or polynomial time by using patterns that reduce ambiguities and limit backtracking.</span></span> <span data-ttu-id="8396e-128">言い換えると、NFA エンジンはパフォーマンスと引き換えに能力と柔軟性を向上させますが、ほとんどの場合、正規表現が適切に記述されていれば十分に許容できるパフォーマンスを実現でき、バックトラッキングによってパフォーマンスが指数関数的に低下する状況は回避されます。</span><span class="sxs-lookup"><span data-stu-id="8396e-128">In other words, although NFA engines trade performance for power and flexibility, in most cases they offer good to acceptable performance if a regular expression is well written and avoids cases in which backtracking degrades performance exponentially.</span></span>

> [!NOTE]
> <span data-ttu-id="8396e-129">過度なバックトラッキングによって発生するパフォーマンスの低下と、そのような問題を回避する正規表現の作成方法については、「[バックトラッキング](backtracking-in-regular-expressions.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="8396e-129">For information about the performance penalty caused by excessive backtracking and ways to craft a regular expression to work around them, see [Backtracking](backtracking-in-regular-expressions.md).</span></span>

## <a name="net-engine-capabilities"></a><span data-ttu-id="8396e-130">.NET エンジンの機能</span><span class="sxs-lookup"><span data-stu-id="8396e-130">.NET engine capabilities</span></span>

 <span data-ttu-id="8396e-131">従来型の NFA エンジンの長所を利用するために、.NET の正規表現エンジンには、プログラマがバックトラッキング エンジンを調整できるようにするための構成体セットが組み込まれています。</span><span class="sxs-lookup"><span data-stu-id="8396e-131">To take advantage of the benefits of a traditional NFA engine, the .NET regular expression engine includes a complete set of constructs to enable programmers to steer the backtracking engine.</span></span> <span data-ttu-id="8396e-132">それらの構成体を使用すると、高速検索を実行したり、他の展開よりも特定の展開を優先させたりできます。</span><span class="sxs-lookup"><span data-stu-id="8396e-132">These constructs can be used to find matches faster or to favor specific expansions over others.</span></span>

 <span data-ttu-id="8396e-133">.NET の正規表現エンジンのその他の機能は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="8396e-133">Other features of the .NET regular expression engine include the following:</span></span>

- <span data-ttu-id="8396e-134">最短一致の量指定子: `??`、`*?`、`+?`、`{`*n*`,`*m*`}?`。</span><span class="sxs-lookup"><span data-stu-id="8396e-134">Lazy quantifiers: `??`, `*?`, `+?`, `{`*n*`,`*m*`}?`.</span></span> <span data-ttu-id="8396e-135">これらの構成体は、バックトラッキング エンジンに対し、繰り返しの回数が最も少ない文字列を最初に検索するように指示します。</span><span class="sxs-lookup"><span data-stu-id="8396e-135">These constructs tell the backtracking engine to search the minimum number of repetitions first.</span></span> <span data-ttu-id="8396e-136">逆に、通常の最長一致の量指定子は、繰り返しの回数が最も多い文字列を最初に検索しようとします。</span><span class="sxs-lookup"><span data-stu-id="8396e-136">In contrast, ordinary greedy quantifiers try to match the maximum number of repetitions first.</span></span> <span data-ttu-id="8396e-137">2 つの量指定子の動作の違いを次の例に示します。</span><span class="sxs-lookup"><span data-stu-id="8396e-137">The following example illustrates the difference between the two.</span></span> <span data-ttu-id="8396e-138">正規表現は、数字で終わる文を照合し、キャプチャ グループはその数字を抽出します。</span><span class="sxs-lookup"><span data-stu-id="8396e-138">A regular expression matches a sentence that ends in a number, and a capturing group is intended to extract that number.</span></span> <span data-ttu-id="8396e-139">正規表現 `.+(\d+)\.` には最長一致の量指定子 `.+` が含まれます。これにより、正規表現エンジンは数字の最後の桁のみをキャプチャします。</span><span class="sxs-lookup"><span data-stu-id="8396e-139">The regular expression `.+(\d+)\.` includes the greedy quantifier `.+`, which causes the regular expression engine to capture only the last digit of the number.</span></span> <span data-ttu-id="8396e-140">対照的に、正規表現 `.+?(\d+)\.` には最短一致の量指定子 `.+?` が含まれます。これにより、正規表現エンジンは数字全体をキャプチャします。</span><span class="sxs-lookup"><span data-stu-id="8396e-140">In contrast, the regular expression `.+?(\d+)\.` includes the lazy quantifier `.+?`, which causes the regular expression engine to capture the entire number.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lazy1.cs#1)]
     [!code-vb[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lazy1.vb#1)]

     <span data-ttu-id="8396e-141">この正規表現の最長一致バージョンと最短一致バージョンは、次の表に示すように定義されています。</span><span class="sxs-lookup"><span data-stu-id="8396e-141">The greedy and lazy versions of this regular expression are defined as shown in the following table:</span></span>

    |<span data-ttu-id="8396e-142">パターン</span><span class="sxs-lookup"><span data-stu-id="8396e-142">Pattern</span></span>|<span data-ttu-id="8396e-143">説明</span><span class="sxs-lookup"><span data-stu-id="8396e-143">Description</span></span>|
    |-------------|-----------------|
    |<span data-ttu-id="8396e-144">`.+` (最長一致の量指定子)</span><span class="sxs-lookup"><span data-stu-id="8396e-144">`.+` (greedy quantifier)</span></span>|<span data-ttu-id="8396e-145">任意の文字の 1 回以上の出現に一致します。</span><span class="sxs-lookup"><span data-stu-id="8396e-145">Match at least one occurrence of any character.</span></span> <span data-ttu-id="8396e-146">これにより、正規表現エンジンは文字列全体を照合してから、必要に応じてバックトラックし、パターンの残りの部分を照合します。</span><span class="sxs-lookup"><span data-stu-id="8396e-146">This causes the regular expression engine to match the entire string, and then to backtrack as needed to match the remainder of the pattern.</span></span>|
    |<span data-ttu-id="8396e-147">`.+?` (最短一致の量指定子)</span><span class="sxs-lookup"><span data-stu-id="8396e-147">`.+?` (lazy quantifier)</span></span>|<span data-ttu-id="8396e-148">任意の文字の 1 回以上の出現 (ただし、可能な限り少ない回数) に一致します。</span><span class="sxs-lookup"><span data-stu-id="8396e-148">Match at least one occurrence of any character, but match as few as possible.</span></span>|
    |`(\d+)`|<span data-ttu-id="8396e-149">1 文字以上の数字と一致し、その文字を最初のキャプチャ グループに代入します。</span><span class="sxs-lookup"><span data-stu-id="8396e-149">Match at least one numeric character, and assign it to the first capturing group.</span></span>|
    |`\.`|<span data-ttu-id="8396e-150">ピリオドと一致します。</span><span class="sxs-lookup"><span data-stu-id="8396e-150">Match a period.</span></span>|

     <span data-ttu-id="8396e-151">最短一致の量指定子について詳しくは、「[限定子](quantifiers-in-regular-expressions.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="8396e-151">For more information about lazy quantifiers, see [Quantifiers](quantifiers-in-regular-expressions.md).</span></span>

- <span data-ttu-id="8396e-152">肯定先読み: `(?=`*subexpression*`)`。</span><span class="sxs-lookup"><span data-stu-id="8396e-152">Positive lookahead: `(?=`*subexpression*`)`.</span></span> <span data-ttu-id="8396e-153">この機能により、バックトラッキング エンジンは部分式と一致する文字列を見つけた後で、テキスト内の同じ位置に戻ることができます。</span><span class="sxs-lookup"><span data-stu-id="8396e-153">This feature allows the backtracking engine to return to the same spot in the text after matching a subexpression.</span></span> <span data-ttu-id="8396e-154">同じ位置から開始する複数のパターンを確認してテキスト全体を検索する場合に便利です。</span><span class="sxs-lookup"><span data-stu-id="8396e-154">It is useful for searching throughout the text by verifying multiple patterns that start from the same position.</span></span> <span data-ttu-id="8396e-155">また、エンジンは、一致するテキストに部分文字列を含めずに、一致文字列の末尾に部分文字列が存在することを検証できます。</span><span class="sxs-lookup"><span data-stu-id="8396e-155">It also allows the engine to verify that a substring exists at the end of the match without including the substring in the matched text.</span></span> <span data-ttu-id="8396e-156">次の例では、肯定先読みを使用して、後に区切り記号が続かない文中の単語を抽出します。</span><span class="sxs-lookup"><span data-stu-id="8396e-156">The following example uses positive lookahead to extract the words in a sentence that are not followed by punctuation symbols.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead1.cs#2)]
     [!code-vb[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead1.vb#2)]

     <span data-ttu-id="8396e-157">正規表現 `\b[A-Z]+\b(?=\P{P})` は、次の表に示すように定義されています。</span><span class="sxs-lookup"><span data-stu-id="8396e-157">The regular expression `\b[A-Z]+\b(?=\P{P})` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="8396e-158">パターン</span><span class="sxs-lookup"><span data-stu-id="8396e-158">Pattern</span></span>|<span data-ttu-id="8396e-159">説明</span><span class="sxs-lookup"><span data-stu-id="8396e-159">Description</span></span>|
    |-------------|-----------------|
    |`\b`|<span data-ttu-id="8396e-160">ワード境界から照合を開始します。</span><span class="sxs-lookup"><span data-stu-id="8396e-160">Begin the match at a word boundary.</span></span>|
    |`[A-Z]+`|<span data-ttu-id="8396e-161">任意の英字と 1 回以上、一致します。</span><span class="sxs-lookup"><span data-stu-id="8396e-161">Match any alphabetic character one or more times.</span></span> <span data-ttu-id="8396e-162"><xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> メソッドが <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> オプションを使って呼び出されているため、比較では大文字と小文字が区別されません。</span><span class="sxs-lookup"><span data-stu-id="8396e-162">Because the <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option, the comparison is case-insensitive.</span></span>|
    |`\b`|<span data-ttu-id="8396e-163">ワード境界で照合を終了します。</span><span class="sxs-lookup"><span data-stu-id="8396e-163">End the match at a word boundary.</span></span>|
    |`(?=\P{P})`|<span data-ttu-id="8396e-164">先読みして次の文字が区切り記号かどうかを判定します。</span><span class="sxs-lookup"><span data-stu-id="8396e-164">Look ahead to determine whether the next character is a punctuation symbol.</span></span> <span data-ttu-id="8396e-165">区切り記号でない場合は、一致と見なされます。</span><span class="sxs-lookup"><span data-stu-id="8396e-165">If it is not, the match succeeds.</span></span>|

     <span data-ttu-id="8396e-166">肯定先読みアサーションについて詳しくは、「[グループ化構成体](grouping-constructs-in-regular-expressions.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="8396e-166">For more information about positive lookahead assertions, see [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="8396e-167">否定先読み: `(?!`*subexpression*`)`。</span><span class="sxs-lookup"><span data-stu-id="8396e-167">Negative lookahead: `(?!`*subexpression*`)`.</span></span> <span data-ttu-id="8396e-168">この機能により、部分式に一致する文字列が見つからなかった場合にのみ、表現に一致できるようになります。</span><span class="sxs-lookup"><span data-stu-id="8396e-168">This feature adds the ability to match an expression only if a subexpression fails to match.</span></span> <span data-ttu-id="8396e-169">ある文字列を除外する表現の方が、含める表現よりも単純になることが多いため、この機能は検索を簡略化する場合に力を発揮します。</span><span class="sxs-lookup"><span data-stu-id="8396e-169">This is powerful for pruning a search, because it is often simpler to provide an expression for a case that should be eliminated than an expression for cases that must be included.</span></span> <span data-ttu-id="8396e-170">たとえば、"non" で始まらない単語を表す表現を記述するのは簡単ではありません。</span><span class="sxs-lookup"><span data-stu-id="8396e-170">For example, it is difficult to write an expression for words that do not begin with "non".</span></span> <span data-ttu-id="8396e-171">次の例では、否定先読みを使用してこれらを除外します。</span><span class="sxs-lookup"><span data-stu-id="8396e-171">The following example uses negative lookahead to exclude them.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead2.cs#3)]
     [!code-vb[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead2.vb#3)]

     <span data-ttu-id="8396e-172">正規表現パターン `\b(?!non)\w+\b` は、次の表に示すように定義されています。</span><span class="sxs-lookup"><span data-stu-id="8396e-172">The regular expression pattern `\b(?!non)\w+\b` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="8396e-173">パターン</span><span class="sxs-lookup"><span data-stu-id="8396e-173">Pattern</span></span>|<span data-ttu-id="8396e-174">説明</span><span class="sxs-lookup"><span data-stu-id="8396e-174">Description</span></span>|
    |-------------|-----------------|
    |`\b`|<span data-ttu-id="8396e-175">ワード境界から照合を開始します。</span><span class="sxs-lookup"><span data-stu-id="8396e-175">Begin the match at a word boundary.</span></span>|
    |`(?!non)`|<span data-ttu-id="8396e-176">先読みして、現在の文字列が "non" で始まらないことを確認します。</span><span class="sxs-lookup"><span data-stu-id="8396e-176">Look ahead to ensure that the current string does not begin with "non".</span></span> <span data-ttu-id="8396e-177">"non" で始まる場合は、一致と見なされません。</span><span class="sxs-lookup"><span data-stu-id="8396e-177">If it does, the match fails.</span></span>|
    |`(\w+)`|<span data-ttu-id="8396e-178">1 つ以上の単語文字に一致します。</span><span class="sxs-lookup"><span data-stu-id="8396e-178">Match one or more word characters.</span></span>|
    |`\b`|<span data-ttu-id="8396e-179">ワード境界で照合を終了します。</span><span class="sxs-lookup"><span data-stu-id="8396e-179">End the match at a word boundary.</span></span>|

     <span data-ttu-id="8396e-180">否定先読みアサーションについて詳しくは、「[グループ化構成体](grouping-constructs-in-regular-expressions.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="8396e-180">For more information about negative lookahead assertions, see [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="8396e-181">条件付き評価: `(?(`*expression*`)`*yes*`|`*no*`)` および`(?(`*name*`)`*yes*`|`*no*`)`。ここで、*expression* は照合する部分式、*name* はキャプチャ グループの名前、*yes* は、*expression* が一致するか、または *name* が空でない有効なキャプチャ グループである場合に照合する文字列、*no* は、*expression* が一致しないか、または *name* が空でない有効なキャプチャ グループではない場合に照合する部分式です。</span><span class="sxs-lookup"><span data-stu-id="8396e-181">Conditional evaluation: `(?(`*expression*`)`*yes*`|`*no*`)` and `(?(`*name*`)`*yes*`|`*no*`)`, where *expression* is a subexpression to match, *name* is the name of a capturing group, *yes* is the string to match if *expression* is matched or *name* is a valid, non-empty captured group, and *no* is the subexpression to match if *expression* is not matched or *name* is not a valid, non-empty captured group.</span></span> <span data-ttu-id="8396e-182">この機能により、エンジンは直前の部分式の一致結果またはゼロ幅アサーションの結果に従って、複数の代替パターンを使用した検索を実行できます。</span><span class="sxs-lookup"><span data-stu-id="8396e-182">This feature allows the engine to search by using more than one alternate pattern, depending on the result of a previous subexpression match or the result of a zero-width assertion.</span></span> <span data-ttu-id="8396e-183">そのため、より強力な前方参照が可能になります。たとえば、直前の部分式が一致したかどうかに基づいて部分式を照合できます。</span><span class="sxs-lookup"><span data-stu-id="8396e-183">This allows a more powerful form of backreference that permits, for example, matching a subexpression based on whether a previous subexpression was matched.</span></span> <span data-ttu-id="8396e-184">次の例の正規表現は、パブリック使用と内部使用の両方を目的とした段落と一致します。</span><span class="sxs-lookup"><span data-stu-id="8396e-184">The regular expression in the following example matches paragraphs that are intended for both public and internal use.</span></span> <span data-ttu-id="8396e-185">内部使用のみを目的とした段落は `<PRIVATE>` タグで始まります。</span><span class="sxs-lookup"><span data-stu-id="8396e-185">Paragraphs intended only for internal use begin with a `<PRIVATE>` tag.</span></span> <span data-ttu-id="8396e-186">正規表現パターン `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` は、条件付き評価を使用して、パブリック使用と内部使用を目的とした段落の内容を別のキャプチャ グループに代入します。</span><span class="sxs-lookup"><span data-stu-id="8396e-186">The regular expression pattern `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` uses conditional evaluation to assign the contents of paragraphs intended for public and for internal use to separate capturing groups.</span></span> <span data-ttu-id="8396e-187">これらの段落は、異なる方法で処理できます。</span><span class="sxs-lookup"><span data-stu-id="8396e-187">These paragraphs can then be handled differently.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/conditional1.cs#4)]
     [!code-vb[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/conditional1.vb#4)]

     <span data-ttu-id="8396e-188">正規表現パターンは、次の表に示すように定義されています。</span><span class="sxs-lookup"><span data-stu-id="8396e-188">The regular expression pattern is defined as shown in the following table.</span></span>

    |<span data-ttu-id="8396e-189">パターン</span><span class="sxs-lookup"><span data-stu-id="8396e-189">Pattern</span></span>|<span data-ttu-id="8396e-190">説明</span><span class="sxs-lookup"><span data-stu-id="8396e-190">Description</span></span>|
    |-------------|-----------------|
    |`^`|<span data-ttu-id="8396e-191">行の先頭から照合を開始します。</span><span class="sxs-lookup"><span data-stu-id="8396e-191">Begin the match at the beginning of a line.</span></span>|
    |`(?<Pvt>\<PRIVATE\>\s)?`|<span data-ttu-id="8396e-192">文字列 `<PRIVATE>` の後に空白文字が続くパターンの 0 回または 1 回の出現と一致します。</span><span class="sxs-lookup"><span data-stu-id="8396e-192">Match zero or one occurrence of the string `<PRIVATE>` followed by a white-space character.</span></span> <span data-ttu-id="8396e-193">一致文字列を `Pvt` という名前のキャプチャ グループに代入します。</span><span class="sxs-lookup"><span data-stu-id="8396e-193">Assign the match to a capturing group named `Pvt`.</span></span>|
    |`(?(Pvt)((\w+\p{P}?\s)+)`|<span data-ttu-id="8396e-194">`Pvt` キャプチャ グループが存在する場合は、1 個以上の単語文字の後に 0 個または 1 個の区切り記号と 1 つの空白文字が続くパターンの 1 回以上の出現と一致します。</span><span class="sxs-lookup"><span data-stu-id="8396e-194">If the `Pvt` capturing group exists, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="8396e-195">部分文字列を最初のキャプチャ グループに代入します。</span><span class="sxs-lookup"><span data-stu-id="8396e-195">Assign the substring to the first capturing group.</span></span>|
    |<code>&#124;((\w+\p{P}?\s)+))</code>|<span data-ttu-id="8396e-196">`Pvt` キャプチャ グループが存在しない場合は、1 個以上の単語文字の後に 0 個または 1 個の区切り記号と 1 つの空白文字が続くパターンの 1 回以上の出現と一致します。</span><span class="sxs-lookup"><span data-stu-id="8396e-196">If the `Pvt` capturing group does not exist, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="8396e-197">部分文字列を 3 番目のキャプチャ グループに代入します。</span><span class="sxs-lookup"><span data-stu-id="8396e-197">Assign the substring to the third capturing group.</span></span>|
    |`\r?$`|<span data-ttu-id="8396e-198">行末または文字列の末尾と一致します。</span><span class="sxs-lookup"><span data-stu-id="8396e-198">Match the end of a line or the end of the string.</span></span>|

     <span data-ttu-id="8396e-199">条件付き評価について詳しくは、「[代替構成体](alternation-constructs-in-regular-expressions.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="8396e-199">For more information about conditional evaluation, see [Alternation Constructs](alternation-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="8396e-200">グループ定義の均等化: `(?<`*name1*`-`*name2*`>` *subexpression*`)`。</span><span class="sxs-lookup"><span data-stu-id="8396e-200">Balancing group definitions: `(?<`*name1*`-`*name2*`>` *subexpression*`)`.</span></span> <span data-ttu-id="8396e-201">この機能により、正規表現エンジンは、かっこや左右の角かっこなどの入れ子になった構成体を追跡できます。</span><span class="sxs-lookup"><span data-stu-id="8396e-201">This feature allows the regular expression engine to keep track of nested constructs such as parentheses or opening and closing brackets.</span></span> <span data-ttu-id="8396e-202">例については、「[グループ化構成体](grouping-constructs-in-regular-expressions.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="8396e-202">For an example, see [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="8396e-203">アトミック グループ: `(?>`*subexpression*`)`。</span><span class="sxs-lookup"><span data-stu-id="8396e-203">Atomic groups: `(?>`*subexpression*`)`.</span></span> <span data-ttu-id="8396e-204">この機能により、バックトラッキング エンジンは、部分式と最初に一致した文字列だけを確実に検索できるようになります。この場合、表現は、部分式を含む表現とは関係ないように処理されます。</span><span class="sxs-lookup"><span data-stu-id="8396e-204">This feature allows the backtracking engine to guarantee that a subexpression matches only the first match found for that subexpression, as if the expression were running independent of its containing expression.</span></span> <span data-ttu-id="8396e-205">この構成体を使用しない場合は、より大きな表現によるバックトラッキング検索時に、部分式の動作が変化する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8396e-205">If you do not use this construct, backtracking searches from the larger expression can change the behavior of a subexpression.</span></span> <span data-ttu-id="8396e-206">たとえば、正規表現 `(a+)\w` は、1 つ以上の "a" の文字と、"a" の文字のシーケンスに続く単語文字と一致し、最初のキャプチャ グループに "a" の文字のシーケンスを割り当てます。</span><span class="sxs-lookup"><span data-stu-id="8396e-206">For example, the regular expression `(a+)\w` matches one or more "a" characters, along with a word character that follows the sequence of "a" characters, and assigns the sequence of "a" characters to the first capturing group.</span></span> <span data-ttu-id="8396e-207">ただし、入力文字列の最後の文字も "a" である場合は、`\w` 言語要素で照合され、キャプチャされたグループには含まれません。</span><span class="sxs-lookup"><span data-stu-id="8396e-207">However, if the final character of the input string is also an "a", it is matched by the `\w` language element and is not included in the captured group.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking2.cs#7)]
     [!code-vb[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking2.vb#7)]

     <span data-ttu-id="8396e-208">正規表現 `((?>a+))\w` では、この動作は回避されます。</span><span class="sxs-lookup"><span data-stu-id="8396e-208">The regular expression `((?>a+))\w` prevents this behavior.</span></span> <span data-ttu-id="8396e-209">連続するすべての "a" 文字はバックトラッキングなしで照合されるため、最初のキャプチャ グループにはすべての連続する "a" 文字が含まれます。</span><span class="sxs-lookup"><span data-stu-id="8396e-209">Because all consecutive "a" characters are matched without backtracking, the first capturing group includes all consecutive "a" characters.</span></span> <span data-ttu-id="8396e-210">"a" 文字の後に "a" 以外の文字が少なくとも 1 つ続かない場合は、一致と見なされません。</span><span class="sxs-lookup"><span data-stu-id="8396e-210">If the "a" characters are not followed by at least one more character other than "a", the match fails.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking1.cs#8)]
     [!code-vb[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking1.vb#8)]

     <span data-ttu-id="8396e-211">アトミック グループの詳細については、[グループ化構造体](grouping-constructs-in-regular-expressions.md)に関する記事を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8396e-211">For more information about atomic groups, see [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="8396e-212">右から左への一致。<xref:System.Text.RegularExpressions.Regex> クラス コンストラクターまたは静的インスタンス一致メソッドに <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> オプションを設定すると指定されます。</span><span class="sxs-lookup"><span data-stu-id="8396e-212">Right-to-left matching, which is specified by supplying the <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> option to a <xref:System.Text.RegularExpressions.Regex> class constructor or static instance matching method.</span></span> <span data-ttu-id="8396e-213">この機能は、左から右ではなく右から左に向かって検索する場合や、パターンの左側ではなく右側で検索を開始した方が効果的な場合に便利です。</span><span class="sxs-lookup"><span data-stu-id="8396e-213">This feature is useful when searching from right to left instead of from left to right, or in cases where it is more efficient to begin a match at the right part of the pattern instead of the left.</span></span> <span data-ttu-id="8396e-214">次の例に示すように、右から左への一致を使用すると、最長一致の量指定子の動作を変更できます。</span><span class="sxs-lookup"><span data-stu-id="8396e-214">As the following example illustrates, using right-to-left matching can change the behavior of greedy quantifiers.</span></span> <span data-ttu-id="8396e-215">この例では、数字で終わる文に対して 2 つの検索を実行します。</span><span class="sxs-lookup"><span data-stu-id="8396e-215">The example conducts two searches for a sentence that ends in a number.</span></span> <span data-ttu-id="8396e-216">最長一致の量指定子 `+` を使用する左から右への検索では、文中の 6 桁の数字の 1 つと一致しますが、右から左への検索では 6 桁の数字すべてと一致します。</span><span class="sxs-lookup"><span data-stu-id="8396e-216">The left-to-right search that uses the greedy quantifier `+` matches one of the six digits in the sentence, whereas the right-to-left search matches all six digits.</span></span> <span data-ttu-id="8396e-217">正規表現パターンの説明については、このセクションで前に示した最短一致の量指定子の例を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8396e-217">For a description of the regular expression pattern, see the example that illustrates lazy quantifiers earlier in this section.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/rtl1.cs#6)]
     [!code-vb[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/rtl1.vb#6)]

     <span data-ttu-id="8396e-218">右から左への一致の詳細については、「[正規表現のオプション](regular-expression-options.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="8396e-218">For more information about right-to-left matching, see [Regular Expression Options](regular-expression-options.md).</span></span>

- <span data-ttu-id="8396e-219">肯定および否定後読み: 肯定後読みの場合は `(?<=`*subexpression*`)`、否定後読みの場合は `(?<!`*subexpression*`)`。</span><span class="sxs-lookup"><span data-stu-id="8396e-219">Positive and negative lookbehind: `(?<=`*subexpression*`)` for positive lookbehind, and `(?<!`*subexpression*`)` for negative lookbehind.</span></span> <span data-ttu-id="8396e-220">この機能は、このトピックで前に説明した先読みと同様です。</span><span class="sxs-lookup"><span data-stu-id="8396e-220">This feature is similar to lookahead, which is discussed earlier in this topic.</span></span> <span data-ttu-id="8396e-221">正規表現エンジンでは、完全な右から左への一致を実行できるため、正規表現では制限のない後読みが可能です。</span><span class="sxs-lookup"><span data-stu-id="8396e-221">Because the regular expression engine allows complete right-to-left matching, regular expressions allow unrestricted lookbehinds.</span></span> <span data-ttu-id="8396e-222">肯定および否定後読みを使用して、入れ子になった部分式が外側の式のスーパーセットである場合に、入れ子の量指定子を回避することもできます。</span><span class="sxs-lookup"><span data-stu-id="8396e-222">Positive and negative lookbehind can also be used to avoid nesting quantifiers when the nested subexpression is a superset of an outer expression.</span></span> <span data-ttu-id="8396e-223">そのような入れ子の量指定子を使用した正規表現は、多くの場合にパフォーマンスを低下させます。</span><span class="sxs-lookup"><span data-stu-id="8396e-223">Regular expressions with such nested quantifiers often offer poor performance.</span></span> <span data-ttu-id="8396e-224">たとえば、次の例では、文字列が英数字で始まって英数字で終わること、および文字列内の他の文字がより大きなサブセットの 1 つであることを検証します。</span><span class="sxs-lookup"><span data-stu-id="8396e-224">For example, the following example verifies that a string begins and ends with an alphanumeric character, and that any other character in the string is one of a larger subset.</span></span> <span data-ttu-id="8396e-225">電子メール アドレスの検証に使用される正規表現の一部になります。詳しくは、「[方法:文字列が有効な電子メール形式であるかどうかを検証する](how-to-verify-that-strings-are-in-valid-email-format.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="8396e-225">It forms a portion of the regular expression used to validate email addresses; for more information, see [How to: Verify that Strings Are in Valid Email Format](how-to-verify-that-strings-are-in-valid-email-format.md).</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookbehind1.cs#5)]
     [!code-vb[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookbehind1.vb#5)]

     <span data-ttu-id="8396e-226">正規表現 ``^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])*(?<=[A-Z0-9])$`` は、次の表に示すように定義されています。</span><span class="sxs-lookup"><span data-stu-id="8396e-226">The regular expression ``^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])*(?<=[A-Z0-9])$`` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="8396e-227">パターン</span><span class="sxs-lookup"><span data-stu-id="8396e-227">Pattern</span></span>|<span data-ttu-id="8396e-228">説明</span><span class="sxs-lookup"><span data-stu-id="8396e-228">Description</span></span>|
    |-------------|-----------------|
    |`^`|<span data-ttu-id="8396e-229">文字列の先頭から照合を開始します。</span><span class="sxs-lookup"><span data-stu-id="8396e-229">Begin the match at the beginning of the string.</span></span>|
    |`[A-Z0-9]`|<span data-ttu-id="8396e-230">任意の数字または英数字と一致します。</span><span class="sxs-lookup"><span data-stu-id="8396e-230">Match any numeric or alphanumeric character.</span></span> <span data-ttu-id="8396e-231">(比較では、大文字と小文字を区別しません。)</span><span class="sxs-lookup"><span data-stu-id="8396e-231">(The comparison is case-insensitive.)</span></span>|
    |<code>([-!#$%&'.*+/=?^\`{}&#124;~\w])\*</code>|<span data-ttu-id="8396e-232">任意の単語文字の 0 回以上の繰り返し、または次の文字のいずれかと一致します: -、!、#、$、%、&、'、.、\*、+、/、=、?、^、&#96;、{、}、&#124;、~。</span><span class="sxs-lookup"><span data-stu-id="8396e-232">Match zero or more occurrences of any word character, or any of the following characters:  -, !, #, $, %, &, ', ., \*, +, /, =, ?, ^, &#96;, {, }, &#124;, or ~.</span></span>|
    |`(?<=[A-Z0-9])`|<span data-ttu-id="8396e-233">前の文字を後読みします。これは数字または英数字である必要があります。</span><span class="sxs-lookup"><span data-stu-id="8396e-233">Look behind to the previous character, which must be numeric or alphanumeric.</span></span> <span data-ttu-id="8396e-234">(比較では、大文字と小文字を区別しません。)</span><span class="sxs-lookup"><span data-stu-id="8396e-234">(The comparison is case-insensitive.)</span></span>|
    |`$`|<span data-ttu-id="8396e-235">入力文字列の末尾で照合を終了します。</span><span class="sxs-lookup"><span data-stu-id="8396e-235">End the match at the end of the string.</span></span>|

     <span data-ttu-id="8396e-236">肯定および否定後読みについて詳しくは、「[グループ化構成体](grouping-constructs-in-regular-expressions.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="8396e-236">For more information about positive and negative lookbehind, see [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span></span>

## <a name="related-articles"></a><span data-ttu-id="8396e-237">関連記事</span><span class="sxs-lookup"><span data-stu-id="8396e-237">Related articles</span></span>

|<span data-ttu-id="8396e-238">Title</span><span class="sxs-lookup"><span data-stu-id="8396e-238">Title</span></span>|<span data-ttu-id="8396e-239">説明</span><span class="sxs-lookup"><span data-stu-id="8396e-239">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="8396e-240">バックトラッキング</span><span class="sxs-lookup"><span data-stu-id="8396e-240">Backtracking</span></span>](backtracking-in-regular-expressions.md)|<span data-ttu-id="8396e-241">正規表現のバックトラッキングを使用して、分岐処理によって別の一致を検索する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="8396e-241">Provides information about how regular expression backtracking branches to find alternative matches.</span></span>|
|[<span data-ttu-id="8396e-242">コンパイルと再利用</span><span class="sxs-lookup"><span data-stu-id="8396e-242">Compilation and Reuse</span></span>](compilation-and-reuse-in-regular-expressions.md)|<span data-ttu-id="8396e-243">パフォーマンスを向上させるための正規表現のコンパイルと再利用について説明します。</span><span class="sxs-lookup"><span data-stu-id="8396e-243">Provides information about compiling and reusing regular expressions to increase performance.</span></span>|
|[<span data-ttu-id="8396e-244">スレッド セーフ</span><span class="sxs-lookup"><span data-stu-id="8396e-244">Thread Safety</span></span>](thread-safety-in-regular-expressions.md)|<span data-ttu-id="8396e-245">正規表現のスレッド セーフの詳細と、正規表現オブジェクトへのアクセスを同期することが必要なケースについて説明します。</span><span class="sxs-lookup"><span data-stu-id="8396e-245">Provides information about regular expression thread safety and explains when you should synchronize access to regular expression objects.</span></span>|
|[<span data-ttu-id="8396e-246">.NET の正規表現</span><span class="sxs-lookup"><span data-stu-id="8396e-246">.NET Regular Expressions</span></span>](regular-expressions.md)|<span data-ttu-id="8396e-247">正規表現のプログラミング言語的な面の概要について説明します。</span><span class="sxs-lookup"><span data-stu-id="8396e-247">Provides an overview of the programming language aspect of regular expressions.</span></span>|
|[<span data-ttu-id="8396e-248">正規表現のオブジェクト モデル</span><span class="sxs-lookup"><span data-stu-id="8396e-248">The Regular Expression Object Model</span></span>](the-regular-expression-object-model.md)|<span data-ttu-id="8396e-249">正規表現クラスの使用方法について詳しく説明し、コード例を示します。</span><span class="sxs-lookup"><span data-stu-id="8396e-249">Provides information and code examples illustrating how to use the regular expression classes.</span></span>|
|[<span data-ttu-id="8396e-250">正規表現言語 - クイック リファレンス</span><span class="sxs-lookup"><span data-stu-id="8396e-250">Regular Expression Language - Quick Reference</span></span>](regular-expression-language-quick-reference.md)|<span data-ttu-id="8396e-251">正規表現の定義に使用できる一連の文字、演算子、および構成体について説明します。</span><span class="sxs-lookup"><span data-stu-id="8396e-251">Provides information about the set of characters, operators, and constructs that you can use to define regular expressions.</span></span>|

## <a name="reference"></a><span data-ttu-id="8396e-252">関連項目</span><span class="sxs-lookup"><span data-stu-id="8396e-252">Reference</span></span>

- <xref:System.Text.RegularExpressions?displayProperty=nameWithType>
