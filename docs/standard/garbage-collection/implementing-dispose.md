---
title: Dispose メソッドの実装
description: この記事では、.NET のコードで使用されるアンマネージド リソースを解放する Dispose メソッドを実装する方法について説明します。
ms.date: 04/07/2021
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Dispose method
- garbage collection, Dispose method
ms.assetid: eb4e1af0-3b48-4fbc-ad4e-fc2f64138bf9
ms.openlocfilehash: f14c4979024209fb7e5e6364f0627f4e796799c5
ms.sourcegitcommit: e7e0921d0a10f85e9cb12f8b87cc1639a6c8d3fe
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/09/2021
ms.locfileid: "107260528"
---
# <a name="implement-a-dispose-method"></a><span data-ttu-id="a635f-103">Dispose メソッドの実装</span><span class="sxs-lookup"><span data-stu-id="a635f-103">Implement a Dispose method</span></span>

<span data-ttu-id="a635f-104"><xref:System.IDisposable.Dispose%2A> メソッドを実装するのは、主にアンマネージ リソースをリリースするためです。</span><span class="sxs-lookup"><span data-stu-id="a635f-104">Implementing the <xref:System.IDisposable.Dispose%2A> method is primarily for releasing unmanaged resources.</span></span> <span data-ttu-id="a635f-105"><xref:System.IDisposable> の実装であるインスタンス メンバーを使用する場合は、<xref:System.IDisposable.Dispose%2A> 呼び出しをカスケードするのが一般的です。</span><span class="sxs-lookup"><span data-stu-id="a635f-105">When working with instance members that are <xref:System.IDisposable> implementations, it's common to cascade <xref:System.IDisposable.Dispose%2A> calls.</span></span> <span data-ttu-id="a635f-106"><xref:System.IDisposable.Dispose%2A> を実装するのは他にも理由があります。たとえば、割り当てられたメモリを解放したり、コレクションに追加された項目を削除したり、取得されていたロックのリリースを通知したりするためです。</span><span class="sxs-lookup"><span data-stu-id="a635f-106">There are additional reasons for implementing <xref:System.IDisposable.Dispose%2A>, for example, to free memory that was allocated, remove an item that was added to a collection, or signal the release of a lock that was acquired.</span></span>

<span data-ttu-id="a635f-107">[.NET のガベージ コレクター](index.md)は、アンマネージド メモリの割り当てや解放を行いません。</span><span class="sxs-lookup"><span data-stu-id="a635f-107">The [.NET garbage collector](index.md) does not allocate or release unmanaged memory.</span></span> <span data-ttu-id="a635f-108">破棄パターンと呼ばれる、オブジェクトを破棄するパターンによって、オブジェクトの有効期間に順番が付けられます。</span><span class="sxs-lookup"><span data-stu-id="a635f-108">The pattern for disposing an object, referred to as the dispose pattern, imposes order on the lifetime of an object.</span></span> <span data-ttu-id="a635f-109">破棄パターンは、<xref:System.IDisposable> インターフェイスを実装するオブジェクトでのみ使用され、ファイルおよびパイプ ハンドル、レジストリ ハンドル、待機ハンドル、またはアンマネージド メモリ ブロックのポインターを操作する際に一般的です。</span><span class="sxs-lookup"><span data-stu-id="a635f-109">The dispose pattern is used for objects that implement the <xref:System.IDisposable> interface, and is common when interacting with file and pipe handles, registry handles, wait handles, or pointers to blocks of unmanaged memory.</span></span> <span data-ttu-id="a635f-110">これは、ガベージ コレクターは、アンマネージド オブジェクトを再利用できないためです。</span><span class="sxs-lookup"><span data-stu-id="a635f-110">This is because the garbage collector is unable to reclaim unmanaged objects.</span></span>

<span data-ttu-id="a635f-111"><xref:System.IDisposable.Dispose%2A> メソッドをべき等にする (複数回呼び出し可能など) 必要がある場合でも、例外をスローすることなく呼び出されるようにして、リソースが常に適切にクリーンアップされるようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="a635f-111">To help ensure that resources are always cleaned up appropriately, a <xref:System.IDisposable.Dispose%2A> method should be idempotent, such that it is callable multiple times without throwing an exception.</span></span> <span data-ttu-id="a635f-112">さらに、後続の <xref:System.IDisposable.Dispose%2A> の呼び出しでは、何も行ってはなりません。</span><span class="sxs-lookup"><span data-stu-id="a635f-112">Furthermore, subsequent invocations of <xref:System.IDisposable.Dispose%2A> should do nothing.</span></span>

<span data-ttu-id="a635f-113"><xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> メソッドに関して提供されたコード例では、オブジェクトまたはそのメンバーへのアンマネージ参照がまだ使用中であるにも関わらず、ガベージ コレクションによりファイナライザーがどのように実行される可能性があるのかを示しています。</span><span class="sxs-lookup"><span data-stu-id="a635f-113">The code example provided for the <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> method shows how garbage collection can cause a finalizer to run, while an unmanaged reference to the object or its members is still in use.</span></span> <span data-ttu-id="a635f-114">現在のルーチンの開始時点からこのメソッドが呼び出される時点まで、<xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> を利用してそのオブジェクトをガベージ コレクションの対象から外すことは理にかなっていると考えられます。</span><span class="sxs-lookup"><span data-stu-id="a635f-114">It may make sense to utilize <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> to make the object ineligible for garbage collection from the start of the current routine to the point where this method is called.</span></span>

[!INCLUDE [disposables-and-dependency-injection](includes/disposables-and-dependency-injection.md)]

## <a name="safe-handles"></a><span data-ttu-id="a635f-115">セーフ ハンドル</span><span class="sxs-lookup"><span data-stu-id="a635f-115">Safe handles</span></span>

<span data-ttu-id="a635f-116">オブジェクトのファイナライザーのコードを記述することは、正しく行わないと問題が発生する可能性がある複雑なタスクです。</span><span class="sxs-lookup"><span data-stu-id="a635f-116">Writing code for an object's finalizer is a complex task that can cause problems if not done correctly.</span></span> <span data-ttu-id="a635f-117">そのため、ファイナライザーを実装するのではなく、<xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> オブジェクトを構築することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="a635f-117">Therefore, we recommend that you construct <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> objects instead of implementing a finalizer.</span></span>

<span data-ttu-id="a635f-118"><xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> は、アンマネージ リソースを識別する <xref:System.IntPtr?displayProperty=nameWithType> をラップする抽象マネージド型です。</span><span class="sxs-lookup"><span data-stu-id="a635f-118">A <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> is an abstract managed type that wraps an <xref:System.IntPtr?displayProperty=nameWithType> that identifies an unmanaged resource.</span></span> <span data-ttu-id="a635f-119">Windows ではハンドルを識別しますが、Unix ではファイル記述子を識別します。</span><span class="sxs-lookup"><span data-stu-id="a635f-119">On Windows it might identify a handle while on Unix, a file descriptor.</span></span> <span data-ttu-id="a635f-120">これが、このリソースが 1 回しか解放されないことを保証するために必要なすべてのロジックを提供するのは、`SafeHandle` が破棄されるとき、または `SafeHandle` へのすべての参照が削除され、`SafeHandle` インスタンスが終了するときです。</span><span class="sxs-lookup"><span data-stu-id="a635f-120">It provides all of the logic necessary to ensure that this resource is released once and only once, when the `SafeHandle` is disposed of or when all references to the `SafeHandle` have been dropped and the `SafeHandle` instance is finalized.</span></span>

<span data-ttu-id="a635f-121"><xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> は抽象基底クラスです。</span><span class="sxs-lookup"><span data-stu-id="a635f-121">The <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> is an abstract base class.</span></span> <span data-ttu-id="a635f-122">派生クラスは、さまざまな種類のハンドルのために特定のインスタンスを提供します。</span><span class="sxs-lookup"><span data-stu-id="a635f-122">Derived classes provide specific instances for different kinds of handle.</span></span> <span data-ttu-id="a635f-123">これらの派生クラスは、<xref:System.IntPtr?displayProperty=nameWithType> のどの値が無効と見なされるかを検証し、実際にハンドルを解放する方法を検証します。</span><span class="sxs-lookup"><span data-stu-id="a635f-123">These derived classes validate what values for the <xref:System.IntPtr?displayProperty=nameWithType> are considered invalid and how to actually free the handle.</span></span> <span data-ttu-id="a635f-124">たとえば、<xref:Microsoft.Win32.SafeHandles.SafeFileHandle> は `SafeHandle` から派生し、開いているファイル ハンドル/記述子を識別する `IntPtrs` をラップし、その <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType> メソッドをオーバーライドして閉じます (Unix では `close` 関数または Windows では `CloseHandle` 関数)。</span><span class="sxs-lookup"><span data-stu-id="a635f-124">For example, <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> derives from `SafeHandle` to wrap `IntPtrs` that identify open file handles/descriptors, and overrides its <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType> method to close it (via the `close` function on Unix or `CloseHandle` function on Windows).</span></span> <span data-ttu-id="a635f-125">アンマネージ リソースを作成する .NET ライブラリのほとんどの API は、それを `SafeHandle` でラップし、生ポインターを渡す代わりに、必要に応じて `SafeHandle` をユーザーに返します。</span><span class="sxs-lookup"><span data-stu-id="a635f-125">Most APIs in .NET libraries that create an unmanaged resource will wrap it in a `SafeHandle` and return that `SafeHandle` to you as needed, rather than handing back the raw pointer.</span></span> <span data-ttu-id="a635f-126">アンマネージ コンポーネントと対話し、アンマネージ リソースの `IntPtr` を取得する状況では、独自の `SafeHandle` 型を作成してラップすることができます。</span><span class="sxs-lookup"><span data-stu-id="a635f-126">In situations where you interact with an unmanaged component and get an `IntPtr` for an unmanaged resource, you can create your own `SafeHandle` type to wrap it.</span></span> <span data-ttu-id="a635f-127">その結果、`SafeHandle` 以外の型でファイナライザーを実装する必要があるのはごく少数になります。ほとんどの破棄可能パターンの実装では、`SafeHandle` を含む他の管理対象リソースをラップするだけで終了します。</span><span class="sxs-lookup"><span data-stu-id="a635f-127">As a result, few non-`SafeHandle` types need to implement finalizers; most disposable pattern implementations only end up wrapping other managed resources, some of which may be `SafeHandle`s.</span></span>

<span data-ttu-id="a635f-128"><xref:Microsoft.Win32.SafeHandles> 名前空間の次の派生クラスは、セーフ ハンドルを提供します。</span><span class="sxs-lookup"><span data-stu-id="a635f-128">The following derived classes in the <xref:Microsoft.Win32.SafeHandles> namespace provide safe handles:</span></span>

- <span data-ttu-id="a635f-129">ファイル、メモリ マップ ファイルおよびパイプのための <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>、<xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle>、<xref:Microsoft.Win32.SafeHandles.SafePipeHandle> クラス。</span><span class="sxs-lookup"><span data-stu-id="a635f-129">The <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle>, and <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> class, for files, memory mapped files, and pipes.</span></span>
- <span data-ttu-id="a635f-130">メモリ ビューのための <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> クラス。</span><span class="sxs-lookup"><span data-stu-id="a635f-130">The <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> class, for memory views.</span></span>
- <span data-ttu-id="a635f-131">暗号の構成要素のための <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>、<xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>、<xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> クラス。</span><span class="sxs-lookup"><span data-stu-id="a635f-131">The <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> classes, for cryptography constructs.</span></span>
- <span data-ttu-id="a635f-132">レジストリ キーのための <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> クラス。</span><span class="sxs-lookup"><span data-stu-id="a635f-132">The <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> class, for registry keys.</span></span>
- <span data-ttu-id="a635f-133">待機ハンドルのための <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> クラス。</span><span class="sxs-lookup"><span data-stu-id="a635f-133">The <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> class, for wait handles.</span></span>

## <a name="dispose-and-disposebool"></a><span data-ttu-id="a635f-134">Dispose() と Dispose(bool)</span><span class="sxs-lookup"><span data-stu-id="a635f-134">Dispose() and Dispose(bool)</span></span>

<span data-ttu-id="a635f-135"><xref:System.IDisposable> インターフェイスでは、パラメーターのない <xref:System.IDisposable.Dispose%2A> メソッドを 1 つ実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="a635f-135">The <xref:System.IDisposable> interface requires the implementation of a single parameterless method, <xref:System.IDisposable.Dispose%2A>.</span></span> <span data-ttu-id="a635f-136">また、すべての非シールド クラスは、追加の `Dispose(bool)` オーバーロード メソッドを実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="a635f-136">Also, any non-sealed class should have an additional `Dispose(bool)` overload method to be implemented:</span></span>

- <span data-ttu-id="a635f-137">`public` で非仮想 (Visual Basic では `NonInheritable`) の <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> の実装。パラメーターはありません。</span><span class="sxs-lookup"><span data-stu-id="a635f-137">A `public` non-virtual (`NonInheritable` in Visual Basic) <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation that has no parameters.</span></span>

- <span data-ttu-id="a635f-138">`protected virtual` (Visual Basic では `Overridable`) の `Dispose` メソッド。シグネチャは次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="a635f-138">A `protected virtual` (`Overridable` in Visual Basic) `Dispose` method whose signature is:</span></span>

  [!code-csharp[Conceptual.Disposable#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#8)]
  [!code-vb[Conceptual.Disposable#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#8)]

  > [!IMPORTANT]
  > <span data-ttu-id="a635f-139">`disposing` パラメーターは、ファイナライザーから呼び出されたときは `false`、<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> メソッドから呼び出されたときは `true` にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="a635f-139">The `disposing` parameter should be `false` when called from a finalizer, and `true` when called from the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="a635f-140">つまり、確定的に呼び出されたときは `true`、非確定的に呼び出されたときは `false` です。</span><span class="sxs-lookup"><span data-stu-id="a635f-140">In other words, it is `true` when deterministically called and `false` when non-deterministically called.</span></span>

### <a name="the-dispose-method"></a><span data-ttu-id="a635f-141">Dispose() メソッド</span><span class="sxs-lookup"><span data-stu-id="a635f-141">The Dispose() method</span></span>

<span data-ttu-id="a635f-142">この `public` で非仮想 (Visual Basic では `NonInheritable`)、パラメーターなしの `Dispose` メソッドは、型のコンシューマーによって呼び出されるため、その目的は、アンマネージ リソースを解放し、通常のクリーンアップを実行し、ファイナライザーが存在する場合、それを実行する必要がないことを示すことです。</span><span class="sxs-lookup"><span data-stu-id="a635f-142">Because the `public`, non-virtual (`NonInheritable` in Visual Basic), parameterless `Dispose` method is called by a consumer of the type, its purpose is to free unmanaged resources, perform general cleanup, and to indicate that the finalizer, if one is present, doesn't have to run.</span></span> <span data-ttu-id="a635f-143">マネージド オブジェクトに関連付けられている実際のメモリを解放するのは、常に[ガベージ コレクター](index.md)のドメインです。</span><span class="sxs-lookup"><span data-stu-id="a635f-143">Freeing the actual memory associated with a managed object is always the domain of the [garbage collector](index.md).</span></span> <span data-ttu-id="a635f-144">このため、次のような標準的な実装があります。</span><span class="sxs-lookup"><span data-stu-id="a635f-144">Because of this, it has a standard implementation:</span></span>

[!code-csharp[Conceptual.Disposable#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#7)]
[!code-vb[Conceptual.Disposable#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#7)]

<span data-ttu-id="a635f-145">`Dispose` メソッドはオブジェクトのクリーンアップをすべて実行するため、ガベージ コレクターはもはやオブジェクトの <xref:System.Object.Finalize%2A?displayProperty=nameWithType> のオーバーライドを呼び出す必要はありません。</span><span class="sxs-lookup"><span data-stu-id="a635f-145">The `Dispose` method performs all object cleanup, so the garbage collector no longer needs to call the objects' <xref:System.Object.Finalize%2A?displayProperty=nameWithType> override.</span></span> <span data-ttu-id="a635f-146">そこで、<xref:System.GC.SuppressFinalize%2A> メソッドを呼び出して、ガベージ コレクターによるファイナライザーの実行を抑制します。</span><span class="sxs-lookup"><span data-stu-id="a635f-146">Therefore, the call to the <xref:System.GC.SuppressFinalize%2A> method prevents the garbage collector from running the finalizer.</span></span> <span data-ttu-id="a635f-147">型にファイナライザーがない場合、<xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> を呼び出しても無効です。</span><span class="sxs-lookup"><span data-stu-id="a635f-147">If the type has no finalizer, the call to <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> has no effect.</span></span> <span data-ttu-id="a635f-148">実際のクリーンアップは、`Dispose(bool)` メソッド オーバーロードによって実行されることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="a635f-148">Note that the actual cleanup is performed by the `Dispose(bool)` method overload.</span></span>

### <a name="the-disposebool-method-overload"></a><span data-ttu-id="a635f-149">Dispose (bool) メソッドオーバーロード</span><span class="sxs-lookup"><span data-stu-id="a635f-149">The Dispose(bool) method overload</span></span>

<span data-ttu-id="a635f-150">オーバーロードでは、`disposing` パラメーターは <xref:System.Boolean> で、メソッドの呼び出し元が <xref:System.IDisposable.Dispose%2A> メソッドか (値は `true`)、それともファイナライザーか (値は `false`) を示します。</span><span class="sxs-lookup"><span data-stu-id="a635f-150">In the overload, the `disposing` parameter is a <xref:System.Boolean> that indicates whether the method call comes from a <xref:System.IDisposable.Dispose%2A> method (its value is `true`) or from a finalizer (its value is `false`).</span></span>

<span data-ttu-id="a635f-151">メソッドの本体は 2 つのコード ブロックで構成されます。</span><span class="sxs-lookup"><span data-stu-id="a635f-151">The body of the method consists of two blocks of code:</span></span>

- <span data-ttu-id="a635f-152">アンマネージ リソースを解放するブロック。</span><span class="sxs-lookup"><span data-stu-id="a635f-152">A block that frees unmanaged resources.</span></span> <span data-ttu-id="a635f-153">このブロックは、`disposing` パラメーターの値に関係なく実行されます。</span><span class="sxs-lookup"><span data-stu-id="a635f-153">This block executes regardless of the value of the `disposing` parameter.</span></span>
- <span data-ttu-id="a635f-154">マネージド リソースを解放する条件付きブロック。</span><span class="sxs-lookup"><span data-stu-id="a635f-154">A conditional block that frees managed resources.</span></span> <span data-ttu-id="a635f-155">このブロックは、`disposing` の値が `true` の場合に実行されます。</span><span class="sxs-lookup"><span data-stu-id="a635f-155">This block executes if the value of `disposing` is `true`.</span></span> <span data-ttu-id="a635f-156">解放するマネージド リソースには、次のオブジェクトを含めることができます。</span><span class="sxs-lookup"><span data-stu-id="a635f-156">The managed resources that it frees can include:</span></span>

  - <span data-ttu-id="a635f-157">**<xref:System.IDisposable> を実装するマネージド オブジェクト。**</span><span class="sxs-lookup"><span data-stu-id="a635f-157">**Managed objects that implement <xref:System.IDisposable>.**</span></span> <span data-ttu-id="a635f-158">条件付きブロックを使用して <xref:System.IDisposable.Dispose%2A> の実装を呼び出すことができます (カスケード破棄)。</span><span class="sxs-lookup"><span data-stu-id="a635f-158">The conditional block can be used to call their <xref:System.IDisposable.Dispose%2A> implementation (cascade dispose).</span></span> <span data-ttu-id="a635f-159"><xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> の派生クラスを使用してアンマネージ リソースをラップしている場合は、ここで <xref:System.Runtime.InteropServices.SafeHandle.Dispose?displayProperty=nameWithType> の実装を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="a635f-159">If you have used a derived class of <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> to wrap your unmanaged resource, you should call the <xref:System.Runtime.InteropServices.SafeHandle.Dispose?displayProperty=nameWithType> implementation here.</span></span>

  - <span data-ttu-id="a635f-160">**大量のメモリを消費するか、不足しているリソースを消費するマネージド オブジェクト。**</span><span class="sxs-lookup"><span data-stu-id="a635f-160">**Managed objects that consume large amounts of memory or consume scarce resources.**</span></span> <span data-ttu-id="a635f-161">`null` に大きなマネージド オブジェクト参照を割り当てて、到達不能の可能性が高くなるようにします。</span><span class="sxs-lookup"><span data-stu-id="a635f-161">Assign large managed object references to `null` to make them more likely to be unreachable.</span></span> <span data-ttu-id="a635f-162">これにより、非決定的に要求された場合よりも早く解放されます。また、これは通常、条件付きブロックの外で行われます。</span><span class="sxs-lookup"><span data-stu-id="a635f-162">This releases them faster than if they were reclaimed non-deterministically, and this is usually done outside of the conditional block.</span></span>

<span data-ttu-id="a635f-163">メソッドの呼び出し元がファイナライザーの場合、アンマネージ リソースを解放するコードだけを実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="a635f-163">If the method call comes from a finalizer, only the code that frees unmanaged resources should execute.</span></span> <span data-ttu-id="a635f-164">実装側は、正しくないパスが再利用された可能性があるマネージド オブジェクトと対話しないことを確保する必要があります。</span><span class="sxs-lookup"><span data-stu-id="a635f-164">The implementer is responsible for ensuring that the false path doesn't interact with managed objects that may have been reclaimed.</span></span> <span data-ttu-id="a635f-165">これが重要なのは、ガベージ コレクターがマネージド オブジェクトを破棄する順序が非確定的であるためです。</span><span class="sxs-lookup"><span data-stu-id="a635f-165">This is important because the order in which the garbage collector destroys managed objects during finalization is non-deterministic.</span></span>

## <a name="cascade-dispose-calls"></a><span data-ttu-id="a635f-166">カスケード破棄呼び出し</span><span class="sxs-lookup"><span data-stu-id="a635f-166">Cascade dispose calls</span></span>

<span data-ttu-id="a635f-167">クラスがフィールドまたはプロパティを所有しており、その型が <xref:System.IDisposable> を実装する場合、それを含むクラスそのものが <xref:System.IDisposable> も実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="a635f-167">If your class owns a field or property, and its type implements <xref:System.IDisposable>, the containing class itself should also implement <xref:System.IDisposable>.</span></span> <span data-ttu-id="a635f-168"><xref:System.IDisposable> の実装をインスタンス化して、それをインスタンス メンバーとして格納するクラスも、そのクリーンアップを担当します。</span><span class="sxs-lookup"><span data-stu-id="a635f-168">A class that instantiates an <xref:System.IDisposable> implementation and storing it as an instance member, is also responsible for its cleanup.</span></span> <span data-ttu-id="a635f-169">これで、参照される破棄可能な型が、<xref:System.IDisposable.Dispose%2A> メソッドを介してクリーンアップを確定的に実行できるようになります。</span><span class="sxs-lookup"><span data-stu-id="a635f-169">This is to help ensure that the referenced disposable types are given the opportunity to deterministically perform clean up through the <xref:System.IDisposable.Dispose%2A> method.</span></span> <span data-ttu-id="a635f-170">この例では、クラスは `sealed` (または Visual Basic では `NotInheritable`) です。</span><span class="sxs-lookup"><span data-stu-id="a635f-170">In this example, the class is `sealed` (or `NotInheritable` in Visual Basic).</span></span>

[!code-csharp[Conceptual.Disposable#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/disposable1.cs#1)]
[!code-vb[Conceptual.Disposable#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/disposable1.vb#1)]

## <a name="implement-the-dispose-pattern"></a><span data-ttu-id="a635f-171">破棄パターンの実装</span><span class="sxs-lookup"><span data-stu-id="a635f-171">Implement the dispose pattern</span></span>

<span data-ttu-id="a635f-172">非シールド クラス (つまり `NotInheritable` として修飾されない Visual Basic クラス) は、継承される可能性があるため、潜在的な基底クラスと見なす必要があります。</span><span class="sxs-lookup"><span data-stu-id="a635f-172">All non-sealed classes or (Visual Basic classes not modified as `NotInheritable`) should be considered a potential base class, because they could be inherited.</span></span> <span data-ttu-id="a635f-173">潜在的な基底クラスの破棄パターンを実装する場合、以下を用意する必要があります。</span><span class="sxs-lookup"><span data-stu-id="a635f-173">If you implement the dispose pattern for any potential base class, you must provide the following:</span></span>

- <span data-ttu-id="a635f-174"><xref:System.IDisposable.Dispose%2A> メソッドを呼び出す `Dispose(bool)` の実装。</span><span class="sxs-lookup"><span data-stu-id="a635f-174">A <xref:System.IDisposable.Dispose%2A> implementation that calls the `Dispose(bool)` method.</span></span>
- <span data-ttu-id="a635f-175">実際のクリーンアップを実行する `Dispose(bool)` メソッド。</span><span class="sxs-lookup"><span data-stu-id="a635f-175">A `Dispose(bool)` method that performs the actual cleanup.</span></span>
- <span data-ttu-id="a635f-176">アンマネージ リソースをラップする <xref:System.Runtime.InteropServices.SafeHandle> から派生したクラス (推奨)、または、<xref:System.Object.Finalize%2A?displayProperty=nameWithType> メソッドのオーバーライド。</span><span class="sxs-lookup"><span data-stu-id="a635f-176">Either a class derived from <xref:System.Runtime.InteropServices.SafeHandle> that wraps your unmanaged resource (recommended), or an override to the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="a635f-177"><xref:System.Runtime.InteropServices.SafeHandle> クラスにはファイナライザーが用意されているので、自分で作成する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="a635f-177">The <xref:System.Runtime.InteropServices.SafeHandle> class provides a finalizer, so you do not have to write one yourself.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="a635f-178">基底クラスはマネージド オブジェクトを参照するだけで、破棄パターンを実装することができます。</span><span class="sxs-lookup"><span data-stu-id="a635f-178">It is possible for a base class to only reference managed objects, and implement the dispose pattern.</span></span> <span data-ttu-id="a635f-179">このような場合、ファイナライザーは不要です。</span><span class="sxs-lookup"><span data-stu-id="a635f-179">In these cases, a finalizer is unnecessary.</span></span> <span data-ttu-id="a635f-180">ファイナライザーは、アンマネージ リソースを直接参照する場合にのみ必要です。</span><span class="sxs-lookup"><span data-stu-id="a635f-180">A finalizer is only required if you directly reference unmanaged resources.</span></span>

<span data-ttu-id="a635f-181">セーフ ハンドルを使用して基底クラスで Dispose パターンを実装する一般的なパターンを次に示します。</span><span class="sxs-lookup"><span data-stu-id="a635f-181">Here's the general pattern for implementing the dispose pattern for a base class that uses a safe handle.</span></span>

[!code-csharp[System.IDisposable#3](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base1.cs#3)]
[!code-vb[System.IDisposable#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base1.vb#3)]

> [!NOTE]
> <span data-ttu-id="a635f-182">前の例では、<xref:Microsoft.Win32.SafeHandles.SafeFileHandle> オブジェクトを使用してパターンを示しています。代わりに、<xref:System.Runtime.InteropServices.SafeHandle> から派生した任意のオブジェクトを使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="a635f-182">The previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead.</span></span> <span data-ttu-id="a635f-183">例では、<xref:Microsoft.Win32.SafeHandles.SafeFileHandle> オブジェクトを正しくインスタンス化していないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="a635f-183">Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object.</span></span>

<span data-ttu-id="a635f-184"><xref:System.Object.Finalize%2A?displayProperty=nameWithType> をオーバーライドして基底クラスで Dispose パターンを実装する一般的なパターンを次に示します。</span><span class="sxs-lookup"><span data-stu-id="a635f-184">Here's the general pattern for implementing the dispose pattern for a base class that overrides <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span>

[!code-csharp[System.IDisposable#5](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base2.cs#5)]
[!code-vb[System.IDisposable#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base2.vb#5)]

> [!TIP]
> <span data-ttu-id="a635f-185">C# では、<xref:System.Object.Finalize%2A?displayProperty=nameWithType> をオーバーライドして[ファイナライザー](../../csharp/programming-guide/classes-and-structs/destructors.md)を作成します。</span><span class="sxs-lookup"><span data-stu-id="a635f-185">In C#, you create a [finalizer](../../csharp/programming-guide/classes-and-structs/destructors.md) by overriding <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="a635f-186">Visual Basic では、これは `Protected Overrides Sub Finalize()` を使用して行われます。</span><span class="sxs-lookup"><span data-stu-id="a635f-186">In Visual Basic, this is done with `Protected Overrides Sub Finalize()`.</span></span>

## <a name="implement-the-dispose-pattern-for-a-derived-class"></a><span data-ttu-id="a635f-187">派生クラスの破棄パターンの実装</span><span class="sxs-lookup"><span data-stu-id="a635f-187">Implement the dispose pattern for a derived class</span></span>

<span data-ttu-id="a635f-188"><xref:System.IDisposable> インターフェイスを実装するクラスから派生したクラスは、<xref:System.IDisposable> の基底クラスでの実装が派生クラスに継承されるため、<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> を実装しないでください。</span><span class="sxs-lookup"><span data-stu-id="a635f-188">A class derived from a class that implements the <xref:System.IDisposable> interface shouldn't implement <xref:System.IDisposable>, because the base class implementation of <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> is inherited by its derived classes.</span></span> <span data-ttu-id="a635f-189">代わりに、派生クラスをクリーンアップするには、以下を用意します。</span><span class="sxs-lookup"><span data-stu-id="a635f-189">Instead, to cleanup a derived class, you provide the following:</span></span>

- <span data-ttu-id="a635f-190">基底クラスのメソッドをオーバーライドして、派生クラスの実際のクリーンアップを実行する `protected override void Dispose(bool)` メソッド。</span><span class="sxs-lookup"><span data-stu-id="a635f-190">A `protected override void Dispose(bool)` method that overrides the base class method and performs the actual cleanup of the derived class.</span></span> <span data-ttu-id="a635f-191">このメソッドは、基底クラスの `base.Dispose(bool)` (Visual Basic では `MyBase.Dispose(bool)`) メソッドも呼び出して、引数の破棄状態を渡す必要があります。</span><span class="sxs-lookup"><span data-stu-id="a635f-191">This method must also call the `base.Dispose(bool)` (`MyBase.Dispose(bool)` in Visual Basic) method of the base class and pass its disposing status for the argument.</span></span>
- <span data-ttu-id="a635f-192">アンマネージ リソースをラップする <xref:System.Runtime.InteropServices.SafeHandle> から派生したクラス (推奨)、または、<xref:System.Object.Finalize%2A?displayProperty=nameWithType> メソッドのオーバーライド。</span><span class="sxs-lookup"><span data-stu-id="a635f-192">Either a class derived from <xref:System.Runtime.InteropServices.SafeHandle> that wraps your unmanaged resource (recommended), or an override to the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="a635f-193"><xref:System.Runtime.InteropServices.SafeHandle> クラスには、コーディングが不要なファイナライザーが用意されています。</span><span class="sxs-lookup"><span data-stu-id="a635f-193">The <xref:System.Runtime.InteropServices.SafeHandle> class provides a finalizer that frees you from having to code one.</span></span> <span data-ttu-id="a635f-194">ファイナライザーを用意する場合は、`disposing` 引数を `false` として `Dispose(bool)` オーバーロードを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="a635f-194">If you do provide a finalizer, it must call the `Dispose(bool)` overload with a `disposing` argument of `false`.</span></span>

<span data-ttu-id="a635f-195">セーフ ハンドルを使用して派生クラスで Dispose パターンを実装する一般的なパターンを次に示します。</span><span class="sxs-lookup"><span data-stu-id="a635f-195">Here's the general pattern for implementing the dispose pattern for a derived class that uses a safe handle:</span></span>

[!code-csharp[System.IDisposable#4](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived1.cs#4)]
[!code-vb[System.IDisposable#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived1.vb#4)]

> [!NOTE]
> <span data-ttu-id="a635f-196">前の例では、<xref:Microsoft.Win32.SafeHandles.SafeFileHandle> オブジェクトを使用してパターンを示しています。代わりに、<xref:System.Runtime.InteropServices.SafeHandle> から派生した任意のオブジェクトを使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="a635f-196">The previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead.</span></span> <span data-ttu-id="a635f-197">例では、<xref:Microsoft.Win32.SafeHandles.SafeFileHandle> オブジェクトを正しくインスタンス化していないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="a635f-197">Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object.</span></span>

<span data-ttu-id="a635f-198"><xref:System.Object.Finalize%2A?displayProperty=nameWithType> をオーバーライドして派生クラスで Dispose パターンを実装する一般的なパターンを次に示します。</span><span class="sxs-lookup"><span data-stu-id="a635f-198">Here's the general pattern for implementing the dispose pattern for a derived class that overrides <xref:System.Object.Finalize%2A?displayProperty=nameWithType>:</span></span>

[!code-csharp[System.IDisposable#6](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived2.cs#6)]
[!code-vb[System.IDisposable#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived2.vb#6)]

## <a name="implement-the-dispose-pattern-with-safe-handles"></a><span data-ttu-id="a635f-199">セーフ ハンドルを使用した破棄パターンの実装</span><span class="sxs-lookup"><span data-stu-id="a635f-199">Implement the dispose pattern with safe handles</span></span>

<span data-ttu-id="a635f-200">次の例は、セーフ ハンドルを使用してアンマネージ リソースをカプセル化する、基底クラス `DisposableStreamResource` での Dispose パターンを示します。</span><span class="sxs-lookup"><span data-stu-id="a635f-200">The following example illustrates the dispose pattern for a base class, `DisposableStreamResource`, that uses a safe handle to encapsulate unmanaged resources.</span></span> <span data-ttu-id="a635f-201">例では、`DisposableStreamResource` を使用して、開いているファイルを表す <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> オブジェクトをラップする <xref:System.IO.Stream> クラスを定義しています。</span><span class="sxs-lookup"><span data-stu-id="a635f-201">It defines a `DisposableStreamResource` class that uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> to wrap a <xref:System.IO.Stream> object that represents an open file.</span></span> <span data-ttu-id="a635f-202">このクラスには、ファイル ストリームの合計バイト数を返す `Size` プロパティも含まれています。</span><span class="sxs-lookup"><span data-stu-id="a635f-202">The class also includes a single property, `Size`, that returns the total number of bytes in the file stream.</span></span>

[!code-csharp[Conceptual.Disposable#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/base1.cs#9)]
[!code-vb[Conceptual.Disposable#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/base1.vb#9)]

## <a name="implement-the-dispose-pattern-for-a-derived-class-with-safe-handles"></a><span data-ttu-id="a635f-203">セーフ ハンドルを使用した派生クラスの破棄パターンの実装</span><span class="sxs-lookup"><span data-stu-id="a635f-203">Implement the dispose pattern for a derived class with safe handles</span></span>

<span data-ttu-id="a635f-204">次の例は、前の例で挙げた `DisposableStreamResource2` クラスを継承した派生クラス `DisposableStreamResource` での Dispose パターンを示します。</span><span class="sxs-lookup"><span data-stu-id="a635f-204">The following example illustrates the dispose pattern for a derived class, `DisposableStreamResource2`, that inherits from the `DisposableStreamResource` class presented in the previous example.</span></span> <span data-ttu-id="a635f-205">このクラスは `WriteFileInfo` メソッドを追加し、<xref:Microsoft.Win32.SafeHandles.SafeFileHandle> オブジェクトを使用して書き込み可能ファイル ハンドルをラップしています。</span><span class="sxs-lookup"><span data-stu-id="a635f-205">The class adds an additional method, `WriteFileInfo`, and uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to wrap the handle of the writable file.</span></span>

[!code-csharp[Conceptual.Disposable#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/derived1.cs#10)]
[!code-vb[Conceptual.Disposable#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/derived1.vb#10)]

## <a name="see-also"></a><span data-ttu-id="a635f-206">関連項目</span><span class="sxs-lookup"><span data-stu-id="a635f-206">See also</span></span>

- [<span data-ttu-id="a635f-207">サービスの破棄</span><span class="sxs-lookup"><span data-stu-id="a635f-207">Disposal of services</span></span>](../../core/extensions/dependency-injection-guidelines.md#disposal-of-services)
- <xref:System.GC.SuppressFinalize%2A>
- <xref:System.IDisposable>
- <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>
- <xref:Microsoft.Win32.SafeHandles>
- <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>
- <xref:System.Object.Finalize%2A?displayProperty=nameWithType>
- [<span data-ttu-id="a635f-208">クラスと構造体を定義および使用する (C++/CLI)</span><span class="sxs-lookup"><span data-stu-id="a635f-208">Define and consume classes and structs (C++/CLI)</span></span>](/cpp/dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli)
