---
title: 概念と用語 (関数型変換) - LINQ to XML
description: 純粋関数型変換の概念と用語について説明します。
ms.date: 07/20/2015
ms.assetid: 03defb3a-7e17-4ab1-8efa-4dd66621e860
ms.openlocfilehash: 0ecdbdf88ee9f868143f466222fa06f0ccf641d8
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/15/2020
ms.locfileid: "103412202"
---
# <a name="concepts-and-terminology-functional-transformation-linq-to-xml"></a><span data-ttu-id="6fce9-103">概念と用語 (関数型変換) (LINQ to XML)</span><span class="sxs-lookup"><span data-stu-id="6fce9-103">Concepts and terminology (functional transformation) (LINQ to XML)</span></span>

<span data-ttu-id="6fce9-104">この記事では、純粋関数型変換の概念と用語について説明します。</span><span class="sxs-lookup"><span data-stu-id="6fce9-104">This article introduces the concepts and terminology of pure functional transformations.</span></span> <span data-ttu-id="6fce9-105">データを変換する場合に関数型変換の方法を使用すると、多くの場合、従来の命令型のプログラミングよりも迅速にプログラミングでき、さまざまな表現を使用できる、デバッグや保守の容易なコードを生成できます。</span><span class="sxs-lookup"><span data-stu-id="6fce9-105">The functional transformation approach to transforming data yields code that's often quicker to program, more expressive, and easier to debug and maintain than more traditional, imperative programming.</span></span>

<span data-ttu-id="6fce9-106">このセクションの記事は、関数型プログラミングのすべてを説明するのではなく、</span><span class="sxs-lookup"><span data-stu-id="6fce9-106">Note that the articles in this section aren't intended to fully explain functional programming.</span></span> <span data-ttu-id="6fce9-107">簡単に XML を別の形に変換するいくつかの関数型プログラミングの機能を紹介することを目的としています。</span><span class="sxs-lookup"><span data-stu-id="6fce9-107">Instead, these articles identify some of the functional programming capabilities that make it easier to transform XML from one shape to another.</span></span>

## <a name="what-is-pure-functional-transformation"></a><span data-ttu-id="6fce9-108">純粋関数型変換とは</span><span class="sxs-lookup"><span data-stu-id="6fce9-108">What is pure functional transformation</span></span>

<span data-ttu-id="6fce9-109">"*純粋関数型変換*" では、"*純粋関数*" と呼ばれる一連の関数により、一連の構造化データを元の形式から別の形式に変換する方法が定義されます。</span><span class="sxs-lookup"><span data-stu-id="6fce9-109">In *pure functional transformation*, a set of functions, called *pure functions*, define how to transform a set of structured data from its original form into another form.</span></span> <span data-ttu-id="6fce9-110">"純粋" という語は、それらの関数が "*構成可能*" であることを示します。そのためには、次が必要です。</span><span class="sxs-lookup"><span data-stu-id="6fce9-110">The word "pure" indicates that the functions are *composable*, which requires that they're:</span></span>

- <span data-ttu-id="6fce9-111">"*自己完結している*"。このため、プログラムの他の部分との結び付きや相互依存を気にせずに、関数を自由に並べ替えることができます。</span><span class="sxs-lookup"><span data-stu-id="6fce9-111">*Self-contained*, so that they can be freely ordered and rearranged without entanglement or interdependencies with the rest of the program.</span></span> <span data-ttu-id="6fce9-112">純粋変換では、その環境を考慮する必要はなく、また環境に対して影響を与えることもありません。</span><span class="sxs-lookup"><span data-stu-id="6fce9-112">Pure transformations have no knowledge of or effect upon their environment.</span></span> <span data-ttu-id="6fce9-113">つまり、変換で使用される関数には "*副作用*" がありません。</span><span class="sxs-lookup"><span data-stu-id="6fce9-113">That is, the functions used in the transformation have no *side effects*.</span></span>
- <span data-ttu-id="6fce9-114">"*ステートレス*"。このため、同じ関数または関数のセットを同じ入力に対して実行すると、常に同じ出力が得られます。</span><span class="sxs-lookup"><span data-stu-id="6fce9-114">*Stateless*, so that executing the same function or specific set of functions on the same input will always result in the same output.</span></span> <span data-ttu-id="6fce9-115">純粋変換には、以前に使用されたときの情報は保持されません。</span><span class="sxs-lookup"><span data-stu-id="6fce9-115">Pure transformations have no memory of their prior use.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="6fce9-116">このチュートリアルの以降では、"純粋関数" という用語を、特定の言語機能ではなくプログラミング方法を指す広い意味で使用します。</span><span class="sxs-lookup"><span data-stu-id="6fce9-116">In the rest of this tutorial, the term "pure function" is used in a general sense to indicate a programming approach, and not a specific language feature.</span></span>
>
> <span data-ttu-id="6fce9-117">純粋関数は、C# ではメソッドとして、Visual Basic では関数として実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="6fce9-117">Note that pure functions must be implemented as methods in C#, and as functions in Visual Basic.</span></span>
>
> <span data-ttu-id="6fce9-118">純粋関数を C++ の純粋仮想メソッドとは混同しないでください。</span><span class="sxs-lookup"><span data-stu-id="6fce9-118">You shouldn't confuse pure functions with pure virtual methods in C++.</span></span> <span data-ttu-id="6fce9-119">純粋仮想メソッドとは、そのメソッドを含むクラスが抽象クラスであり、メソッドの本体が提供されないことを指します。</span><span class="sxs-lookup"><span data-stu-id="6fce9-119">The latter indicates that the containing class is abstract and that no method body is supplied.</span></span>

### <a name="functional-programming"></a><span data-ttu-id="6fce9-120">関数型プログラミング</span><span class="sxs-lookup"><span data-stu-id="6fce9-120">Functional programming</span></span>

<span data-ttu-id="6fce9-121">"*関数型プログラミング*" とは、純粋関数型変換を直接サポートするプログラミング方法です。</span><span class="sxs-lookup"><span data-stu-id="6fce9-121">*Functional programming* is a programming approach that directly supports pure functional transformation.</span></span>

<span data-ttu-id="6fce9-122">これまで、ML、Scheme、Haskell、F# などの汎用関数型プログラミング言語に対する関心は、主に学術的な分野に限られていました。</span><span class="sxs-lookup"><span data-stu-id="6fce9-122">Historically, general-purpose functional programming languages, such as ML, Scheme, Haskell, and F#, have been primarily of interest to the academic community.</span></span> <span data-ttu-id="6fce9-123">C# や Visual Basic では常に純粋関数型変換を記述することが可能でしたが、その難しさから、ほとんどのプログラマにとっては魅力的な選択肢になりませんでした。</span><span class="sxs-lookup"><span data-stu-id="6fce9-123">Although it has always been possible to write pure functional transformations in C# and Visual Basic, the difficulty of doing so has not made it an attractive option to most programmers.</span></span> <span data-ttu-id="6fce9-124">しかし、これらの言語の最近のバージョンでは、ラムダ式や型の推定などの新しい言語構成要素により、関数型プログラミングがより簡単で生産性の高いものとなっています。</span><span class="sxs-lookup"><span data-stu-id="6fce9-124">In recent versions of these languages, however, new language constructs such as lambda expressions and type inference make functional programming much easier and more productive.</span></span>

<span data-ttu-id="6fce9-125">関数型プログラミングの詳細については、「[関数型プログラミングと命令型プログラミング](functional-vs-imperative-programming.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="6fce9-125">For more information about functional programming, see [Functional programming vs. imperative programming](functional-vs-imperative-programming.md).</span></span>

#### <a name="domain-specific-functional-programming-languages"></a><span data-ttu-id="6fce9-126">ドメイン固有の関数型プログラミング言語</span><span class="sxs-lookup"><span data-stu-id="6fce9-126">Domain-specific functional programming languages</span></span>

<span data-ttu-id="6fce9-127">一般的な関数型プログラミング言語が広く採用されていないのに対し、一部のドメイン固有の関数型プログラミング言語はそれよりも成功しています。</span><span class="sxs-lookup"><span data-stu-id="6fce9-127">Although general functional programming languages haven't been widely adopted, some domain-specific functional programming languages have had better success.</span></span> <span data-ttu-id="6fce9-128">たとえば、多くの Web ページの外観の決定に利用されているカスケード スタイル シート (CSS) や、XML データ操作に広く利用されている XSLT(Extensible Stylesheet Language Transformations) スタイル シートです。</span><span class="sxs-lookup"><span data-stu-id="6fce9-128">For example, Cascading Style Sheets (CSS) are used to determine the look and feel of many web pages, and Extensible Stylesheet Language Transformations (XSLT) style sheets are used extensively in XML data manipulation.</span></span> <span data-ttu-id="6fce9-129">XSLT について詳しくは、「[XSLT 変換](../data/xml/xslt-transformations.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="6fce9-129">For more information about XSLT, see [XSLT Transformations](../data/xml/xslt-transformations.md).</span></span>

## <a name="terminology"></a><span data-ttu-id="6fce9-130">用語</span><span class="sxs-lookup"><span data-stu-id="6fce9-130">Terminology</span></span>

<span data-ttu-id="6fce9-131">次に、関数型変換に関連するいくつかの用語を定義します。</span><span class="sxs-lookup"><span data-stu-id="6fce9-131">The following list defines some terms related to functional transformations.</span></span>

<span data-ttu-id="6fce9-132">高階 (ファーストクラス) 関数 </span><span class="sxs-lookup"><span data-stu-id="6fce9-132">higher-order (first-class) function </span></span>\
<span data-ttu-id="6fce9-133">プログラム オブジェクトとして扱うことのできる関数です。</span><span class="sxs-lookup"><span data-stu-id="6fce9-133">A function that can be treated as a programmatic object.</span></span> <span data-ttu-id="6fce9-134">たとえば、他の関数に渡したり、他の関数から返したりすることができます。</span><span class="sxs-lookup"><span data-stu-id="6fce9-134">For example, a higher-order function can be passed to or returned from other functions.</span></span> <span data-ttu-id="6fce9-135">C# や Visual Basic では、高階関数をサポートする言語機能として、デリゲートやラムダ式があります。</span><span class="sxs-lookup"><span data-stu-id="6fce9-135">In C# and Visual Basic, delegates and lambda expressions are language features that support higher-order functions.</span></span> <span data-ttu-id="6fce9-136">高階関数を記述するには、デリゲートを受け取る引数を 1 つ以上宣言し、通常はラムダ式を使用して呼び出します。</span><span class="sxs-lookup"><span data-stu-id="6fce9-136">To write a higher-order function, you declare one or more arguments to take delegates, and you often use lambda expressions when calling it.</span></span> <span data-ttu-id="6fce9-137">標準クエリ演算子の多くは高階関数です。</span><span class="sxs-lookup"><span data-stu-id="6fce9-137">Many of the standard query operators are higher-order functions.</span></span>

<span data-ttu-id="6fce9-138">詳細については、「[標準クエリ演算子の概要 (C#)](../../csharp/programming-guide/concepts/linq/standard-query-operators-overview.md)」および「[標準クエリ演算子の概要 (Visual Basic)](../../visual-basic/programming-guide/concepts/linq/standard-query-operators-overview.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="6fce9-138">For more information, see [Standard Query Operators Overview (C#)](../../csharp/programming-guide/concepts/linq/standard-query-operators-overview.md) and [Standard Query Operators Overview (Visual Basic)](../../visual-basic/programming-guide/concepts/linq/standard-query-operators-overview.md).</span></span>

<span data-ttu-id="6fce9-139">ラムダ式 </span><span class="sxs-lookup"><span data-stu-id="6fce9-139">lambda expression </span></span>\
<span data-ttu-id="6fce9-140">基本的には、デリゲート型が必要とされる場所で使用できるインラインの匿名関数です。</span><span class="sxs-lookup"><span data-stu-id="6fce9-140">Essentially, an inline anonymous function that can be used wherever a delegate type is expected.</span></span> <span data-ttu-id="6fce9-141">これはラムダ式の簡単な定義ですが、このチュートリアルの目的には十分です。</span><span class="sxs-lookup"><span data-stu-id="6fce9-141">This is a simplified definition of lambda expressions, but it's adequate for the purposes of this tutorial.</span></span>

<span data-ttu-id="6fce9-142">詳細については、[ラムダ式 (C# プログラミング ガイド)](../../csharp/language-reference/operators/lambda-expressions.md) に関するページおよび「[ラムダ式 (Visual Basic)](../../visual-basic/programming-guide/language-features/procedures/lambda-expressions.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="6fce9-142">For more information, see [Lambda expressions (C# Programming Guide)](../../csharp/language-reference/operators/lambda-expressions.md) and [Lambda Expressions (Visual Basic))](../../visual-basic/programming-guide/language-features/procedures/lambda-expressions.md).</span></span>

<span data-ttu-id="6fce9-143">コレクション </span><span class="sxs-lookup"><span data-stu-id="6fce9-143">collection </span></span>\
<span data-ttu-id="6fce9-144">データの構造化されたセットです。コレクション内のデータは同じ型であるのが一般的です。</span><span class="sxs-lookup"><span data-stu-id="6fce9-144">A structured set of data, usually of a uniform type.</span></span> <span data-ttu-id="6fce9-145">コレクションで LINQ との互換性を確保するには、<xref:System.Collections.IEnumerable> インターフェイスか <xref:System.Linq.IQueryable> インターフェイス (または対応するジェネリック インターフェイスである <xref:System.Collections.Generic.IEnumerator%601> か <xref:System.Linq.IQueryable%601>) を実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="6fce9-145">To be compatible with LINQ, a collection must implement the <xref:System.Collections.IEnumerable> interface or the <xref:System.Linq.IQueryable> interface (or one of their generic counterparts, <xref:System.Collections.Generic.IEnumerator%601> or <xref:System.Linq.IQueryable%601>).</span></span>

<span data-ttu-id="6fce9-146">タプル (匿名型) </span><span class="sxs-lookup"><span data-stu-id="6fce9-146">tuple (anonymous types) </span></span>\
<span data-ttu-id="6fce9-147">タプルは数学的概念で、それぞれが特定の型を持つオブジェクトの有限のシーケンスを意味します。</span><span class="sxs-lookup"><span data-stu-id="6fce9-147">A mathematical concept, a tuple is a finite sequence of objects, each of a specific type.</span></span> <span data-ttu-id="6fce9-148">順序付きリストとも呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="6fce9-148">A tuple is also known as an ordered list.</span></span> <span data-ttu-id="6fce9-149">匿名型は、この概念の言語実装です。匿名型を使用すると、名前のないクラス型を宣言し、同時にその型のオブジェクトをインスタンス化することができます。</span><span class="sxs-lookup"><span data-stu-id="6fce9-149">Anonymous types are a language implementation of this concept, which enable an unnamed class type to be declared and an object of that type to be instantiated at the same time.</span></span>

<span data-ttu-id="6fce9-150">詳細については、「[匿名型 (C# プログラミング ガイド)](../../csharp/programming-guide/classes-and-structs/anonymous-types.md)」および「[匿名型 (Visual Basic)](../../visual-basic/programming-guide/language-features/objects-and-classes/anonymous-types.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="6fce9-150">For more information, see [Anonymous Types (C# Programming Guide)](../../csharp/programming-guide/classes-and-structs/anonymous-types.md) and [Anonymous Types (Visual Basic)](../../visual-basic/programming-guide/language-features/objects-and-classes/anonymous-types.md).</span></span>

<span data-ttu-id="6fce9-151">型推論 (暗黙の型指定) </span><span class="sxs-lookup"><span data-stu-id="6fce9-151">type inference (implicit typing) </span></span>\
<span data-ttu-id="6fce9-152">明示的な型宣言がない場合に変数の型を特定するコンパイラの機能です。</span><span class="sxs-lookup"><span data-stu-id="6fce9-152">The ability of a compiler to determine the type of a variable in the absence of an explicit type declaration.</span></span>

<span data-ttu-id="6fce9-153">詳細については、「[暗黙的に型指定されるローカル変数 (C# プログラミング ガイド)](../../csharp/programming-guide/classes-and-structs/implicitly-typed-local-variables.md)」および「[ローカル型の推論 (Visual Basic)](../../visual-basic/programming-guide/language-features/variables/local-type-inference.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="6fce9-153">For more information, see [Implicitly typed local variables (C# Programming Guide)](../../csharp/programming-guide/classes-and-structs/implicitly-typed-local-variables.md) and [Local Type Inference (Visual Basic)](../../visual-basic/programming-guide/language-features/variables/local-type-inference.md).</span></span>

<span data-ttu-id="6fce9-154">遅延実行とレイジー評価 </span><span class="sxs-lookup"><span data-stu-id="6fce9-154">deferred execution and lazy evaluation </span></span>\
<span data-ttu-id="6fce9-155">解決された値が実際に必要となるまで式の評価を遅らせることを意味します。</span><span class="sxs-lookup"><span data-stu-id="6fce9-155">The delaying of evaluation of an expression until its resolved value is actually required.</span></span> <span data-ttu-id="6fce9-156">遅延実行はコレクションでサポートされています。</span><span class="sxs-lookup"><span data-stu-id="6fce9-156">Deferred execution is supported in collections.</span></span>

<span data-ttu-id="6fce9-157">C# の詳細については、「[LINQ クエリの概要 (C#)](../../csharp/programming-guide/concepts/linq/introduction-to-linq-queries.md)」および [LINQ to XML における遅延実行とレイジー評価 (C#)](./deferred-execution-lazy-evaluation.md) に関するページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="6fce9-157">For more C# information, see [Introduction to LINQ Queries (C#)](../../csharp/programming-guide/concepts/linq/introduction-to-linq-queries.md) and [Deferred Execution and Lazy Evaluation in LINQ to XML (C#)](./deferred-execution-lazy-evaluation.md).</span></span>

<span data-ttu-id="6fce9-158">Visual Basic の詳細については、「[基本的なクエリ操作 (Visual Basic)](../../visual-basic/programming-guide/concepts/linq/basic-query-operations.md)」および [LINQ to XML における遅延実行とレイジー評価 (Visual Basic)](./deferred-execution-lazy-evaluation.md) に関するページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="6fce9-158">For more Visual Basic information, see [Basic Query Operations (Visual Basic)](../../visual-basic/programming-guide/concepts/linq/basic-query-operations.md) and [Deferred Execution and Lazy Evaluation in LINQ to XML (Visual Basic)](./deferred-execution-lazy-evaluation.md).</span></span>

<span data-ttu-id="6fce9-159">これらの言語機能は、このセクション全体にわたってサンプル コードで使用されています。</span><span class="sxs-lookup"><span data-stu-id="6fce9-159">These language features will be used in code samples throughout this section.</span></span>

## <a name="see-also"></a><span data-ttu-id="6fce9-160">関連項目</span><span class="sxs-lookup"><span data-stu-id="6fce9-160">See also</span></span>

- [<span data-ttu-id="6fce9-161">純粋関数型変換の概要</span><span class="sxs-lookup"><span data-stu-id="6fce9-161">Introduction to pure functional transformations</span></span>](introduction-pure-functional-transformations.md)
- [<span data-ttu-id="6fce9-162">関数型プログラミングと命令型プログラミング</span><span class="sxs-lookup"><span data-stu-id="6fce9-162">Functional programming vs. imperative programming</span></span>](functional-vs-imperative-programming.md)
