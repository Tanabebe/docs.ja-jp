---
title: コード品質ルールの概要
description: コード分析に使用できるすべてのコード品質規則について説明します。
ms.date: 09/01/2020
ms.topic: reference
author: mikadumont
ms.author: midumont
ms.openlocfilehash: f62d6a0e44e29375987e7c62b1868808f4bb0cc3
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/06/2021
ms.locfileid: "103235223"
---
# <a name="code-quality-rules"></a><span data-ttu-id="dbe94-103">コード品質規則</span><span class="sxs-lookup"><span data-stu-id="dbe94-103">Code quality rules</span></span>

<span data-ttu-id="dbe94-104">.NET コード分析には、コードの品質向上を目的とした規則が用意されています。</span><span class="sxs-lookup"><span data-stu-id="dbe94-104">.NET code analysis provides rules that aim to improve code quality.</span></span> <span data-ttu-id="dbe94-105">規則は、デザイン、グローバリゼーション、パフォーマンス、セキュリティなどの区分に分類されています。</span><span class="sxs-lookup"><span data-stu-id="dbe94-105">The rules are organized into areas such as design, globalization, performance, and security.</span></span> <span data-ttu-id="dbe94-106">特定の規則は .NET API の使用に固有であり、他の規則は一般的なコードの品質に関するものです。</span><span class="sxs-lookup"><span data-stu-id="dbe94-106">Certain rules are specific to .NET API usage, while others are about generic code quality.</span></span>

## <a name="index-of-rules"></a><span data-ttu-id="dbe94-107">規則のインデックス</span><span class="sxs-lookup"><span data-stu-id="dbe94-107">Index of rules</span></span>

<span data-ttu-id="dbe94-108">次の表に、コード品質分析規則の一覧を示します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-108">The following table lists code quality analysis rules.</span></span>

> [!div class="mx-tdCol2BreakAll"]
> | <span data-ttu-id="dbe94-109">規則 ID と警告</span><span class="sxs-lookup"><span data-stu-id="dbe94-109">Rule ID and warning</span></span> | <span data-ttu-id="dbe94-110">説明</span><span class="sxs-lookup"><span data-stu-id="dbe94-110">Description</span></span> |
> | - | - |
> | [<span data-ttu-id="dbe94-111">CA1000:ジェネリック型の静的メンバーを宣言しません</span><span class="sxs-lookup"><span data-stu-id="dbe94-111">CA1000: Do not declare static members on generic types</span></span>](ca1000.md) | <span data-ttu-id="dbe94-112">ジェネリック型の静的メンバーを呼び出すときには、その型の型引数も指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-112">When a static member of a generic type is called, the type argument must be specified for the type.</span></span> <span data-ttu-id="dbe94-113">推論をサポートしないジェネリック インスタンス メンバーを呼び出すときには、そのメンバーに型引数を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-113">When a generic instance member that does not support inference is called, the type argument must be specified for the member.</span></span> <span data-ttu-id="dbe94-114">この 2 つの場合、型引数を指定するときに使用される構文は異なりますが、混同される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-114">In these two cases, the syntax for specifying the type argument is different and easily confused.</span></span> |
> | [<span data-ttu-id="dbe94-115">CA1001:破棄可能なフィールドを所有する型は、破棄可能でなければなりません</span><span class="sxs-lookup"><span data-stu-id="dbe94-115">CA1001: Types that own disposable fields should be disposable</span></span>](ca1001.md) | <span data-ttu-id="dbe94-116">クラスが System.IDisposable 型であるインスタンス フィールドを宣言および実装していますが、IDisposable を実装していません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-116">A class declares and implements an instance field that is a System.IDisposable type, and the class does not implement IDisposable.</span></span> <span data-ttu-id="dbe94-117">IDisposable フィールドを宣言するクラスは間接的にアンマネージ リソースを所有しているため、IDisposable インターフェイスを実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-117">A class that declares an IDisposable field indirectly owns an unmanaged resource and should implement the IDisposable interface.</span></span> |
> | [<span data-ttu-id="dbe94-118">CA1002:ジェネリック リストを公開しません</span><span class="sxs-lookup"><span data-stu-id="dbe94-118">CA1002: Do not expose generic lists</span></span>](ca1002.md) | <span data-ttu-id="dbe94-119">System.Collections.Generic.List<(Of \<(T>)>) は継承ではなくパフォーマンスを目的としたジェネリック コレクションです。</span><span class="sxs-lookup"><span data-stu-id="dbe94-119">System.Collections.Generic.List<(Of \<(T>)>) is a generic collection that is designed for performance, not inheritance.</span></span> <span data-ttu-id="dbe94-120">このため、List には仮想メンバーは含まれません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-120">Therefore, List does not contain any virtual members.</span></span> <span data-ttu-id="dbe94-121">代わりに、継承を目的としたジェネリック コレクションを公開する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-121">The generic collections that are designed for inheritance should be exposed instead.</span></span> |
> | [<span data-ttu-id="dbe94-122">CA1003:汎用イベント ハンドラーのインスタンスを使用します</span><span class="sxs-lookup"><span data-stu-id="dbe94-122">CA1003: Use generic event handler instances</span></span>](ca1003.md) |<span data-ttu-id="dbe94-123">型に void を返すデリゲートが含まれており、デリゲートのシグネチャに 2 つのパラメーター (1 つはオブジェクト、もう 1 つは EventArgs に割り当て可能な型) が含まれ、包含アセンブリの対象が Microsoft .NET Framework 2.0. です。</span><span class="sxs-lookup"><span data-stu-id="dbe94-123">A type contains a delegate that returns void, whose signature contains two parameters (the first an object and the second a type that is assignable to EventArgs), and the containing assembly targets Microsoft .NET Framework 2.0.</span></span> |
> | [<span data-ttu-id="dbe94-124">CA1005:ジェネリック型でパラメーターを使用しすぎないでください</span><span class="sxs-lookup"><span data-stu-id="dbe94-124">CA1005: Avoid excessive parameters on generic types</span></span>](ca1005.md) | <span data-ttu-id="dbe94-125">ジェネリック型に含まれる型パラメーターが増えれば増えるほど、それぞれの型パラメーターが表す意味を調べることや覚えることが難しくなります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-125">The more type parameters a generic type contains, the more difficult it is to know and remember what each type parameter represents.</span></span> <span data-ttu-id="dbe94-126">通常、List\<T> のように型パラメーターが 1 つの場合や、Dictionary\<TKey, TValue> のように型パラメーターが 2 つの場合、意味は明確です。</span><span class="sxs-lookup"><span data-stu-id="dbe94-126">It is usually obvious with one type parameter, as in List\<T>, and in certain cases that have two type parameters, as in Dictionary\<TKey, TValue>.</span></span> <span data-ttu-id="dbe94-127">しかし、型パラメーターが 3 つ以上になると、ほとんどのユーザーには意味を把握することが困難になります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-127">However, if more than two type parameters exist, the difficulty becomes too great for most users.</span></span> |
> | [<span data-ttu-id="dbe94-128">CA1008:Enums は 0 値を含んでいなければなりません</span><span class="sxs-lookup"><span data-stu-id="dbe94-128">CA1008: Enums should have zero value</span></span>](ca1008.md) | <span data-ttu-id="dbe94-129">初期化されていない列挙型の既定値は、他の値型と同様に、ゼロです。</span><span class="sxs-lookup"><span data-stu-id="dbe94-129">The default value of an uninitialized enumeration, just as other value types, is zero.</span></span> <span data-ttu-id="dbe94-130">フラグではない属性が付いた列挙型では、ゼロの値を使用してメンバーを定義する必要があります。これは、既定値を有効な列挙値にするためです。</span><span class="sxs-lookup"><span data-stu-id="dbe94-130">A nonflags-attributed enumeration should define a member by using the value of zero so that the default value is a valid value of the enumeration.</span></span> <span data-ttu-id="dbe94-131">FlagsAttribute 属性を適用した列挙型でゼロ値のメンバーを定義する場合、名前を "None" にして、列挙型に設定済みの値がないことを示します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-131">If an enumeration that has the FlagsAttribute attribute applied defines a zero-valued member, its name should be "None" to indicate that no values have been set in the enumeration.</span></span> |
> | [<span data-ttu-id="dbe94-132">CA1010:コレクションは、ジェネリック インターフェイスを実装しなければなりません</span><span class="sxs-lookup"><span data-stu-id="dbe94-132">CA1010: Collections should implement generic interface</span></span>](ca1010.md) | <span data-ttu-id="dbe94-133">コレクションの操作性を拡充するために、ジェネリック コレクション インターフェイスの 1 つを実装します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-133">To broaden the usability of a collection, implement one of the generic collection interfaces.</span></span> <span data-ttu-id="dbe94-134">これにより、コレクションを使用してジェネリック コレクション型を設定できます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-134">Then the collection can be used to populate generic collection types.</span></span> |
> | [<span data-ttu-id="dbe94-135">CA1012:抽象型にはコンストラクターを含めません</span><span class="sxs-lookup"><span data-stu-id="dbe94-135">CA1012: Abstract types should not have constructors</span></span>](ca1012.md) | <span data-ttu-id="dbe94-136">抽象型上のコンストラクターは、派生型からのみ呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-136">Constructors on abstract types can be called only by derived types.</span></span> <span data-ttu-id="dbe94-137">パブリック コンストラクターで型のインスタンスが作成され、抽象型のインスタンスは自分で作成できないため、パブリック コンストラクターが含まれる抽象型のデザインは不適切になります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-137">Because public constructors create instances of a type, and you cannot create instances of an abstract type, an abstract type that has a public constructor is incorrectly designed.</span></span> |
> | [<span data-ttu-id="dbe94-138">CA1014:アセンブリに CLSCompliantAttribute を設定します</span><span class="sxs-lookup"><span data-stu-id="dbe94-138">CA1014: Mark assemblies with CLSCompliantAttribute</span></span>](ca1014.md) | <span data-ttu-id="dbe94-139">共通言語仕様 (CLS) には、名前付けの制約、データ型、および規則が定義されています。アセンブリを複数のプログラミング言語で使用する場合、この仕様に準拠する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-139">The Common Language Specification (CLS) defines naming restrictions, data types, and rules to which assemblies must conform if they will be used across programming languages.</span></span> <span data-ttu-id="dbe94-140">すべてのアセンブリに <xref:System.CLSCompliantAttribute> を使用して、CLS への準拠を明示することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="dbe94-140">Good design dictates that all assemblies explicitly indicate CLS compliance by using <xref:System.CLSCompliantAttribute> .</span></span> <span data-ttu-id="dbe94-141">この属性が使用されていないアセンブリは、CLS に準拠しません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-141">If this attribute is not present on an assembly, the assembly is not compliant.</span></span> |
> | [<span data-ttu-id="dbe94-142">CA1016:アセンブリに AssemblyVersionAttribute を設定します</span><span class="sxs-lookup"><span data-stu-id="dbe94-142">CA1016: Mark assemblies with AssemblyVersionAttribute</span></span>](ca1016.md) | <span data-ttu-id="dbe94-143">.NET では、バージョン番号を使用してアセンブリを一意に識別し、厳密な名前を持つアセンブリの型にバインドします。</span><span class="sxs-lookup"><span data-stu-id="dbe94-143">.NET uses the version number to uniquely identify an assembly and to bind to types in strongly named assemblies.</span></span> <span data-ttu-id="dbe94-144">バージョン番号は、バージョンと発行者のポリシーと共に使用されます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-144">The version number is used together with version and publisher policy.</span></span> <span data-ttu-id="dbe94-145">既定で、アプリケーションは、ビルドされたアセンブリのバージョンでのみ実行されます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-145">By default, applications run only with the assembly version with which they were built.</span></span> |
> | [<span data-ttu-id="dbe94-146">CA1017:アセンブリに ComVisibleAttribute を設定します</span><span class="sxs-lookup"><span data-stu-id="dbe94-146">CA1017: Mark assemblies with ComVisibleAttribute</span></span>](ca1017.md) |<span data-ttu-id="dbe94-147">ComVisibleAttribute 属性によって、COM クライアントからマネージド コードにアクセスする方法が決まります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-147">ComVisibleAttribute determines how COM clients access managed code.</span></span> <span data-ttu-id="dbe94-148">アセンブリで COM の参照範囲を明示することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="dbe94-148">Good design dictates that assemblies explicitly indicate COM visibility.</span></span> <span data-ttu-id="dbe94-149">COM の参照範囲は、アセンブリ全体に設定し、個々の型と型のメンバー用にオーバーライドできます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-149">COM visibility can be set for the whole assembly and then overridden for individual types and type members.</span></span> <span data-ttu-id="dbe94-150">この属性がない場合、アセンブリのコンテンツは COM クライアントから参照できます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-150">If this attribute is not present, the contents of the assembly are visible to COM clients.</span></span> |
> | [<span data-ttu-id="dbe94-151">CA1018:属性を AttributeUsageAttribute に設定します</span><span class="sxs-lookup"><span data-stu-id="dbe94-151">CA1018: Mark attributes with AttributeUsageAttribute</span></span>](ca1018.md) | <span data-ttu-id="dbe94-152">カスタム属性を定義する場合、AttributeUsageAttribute を使用してマークし、カスタム属性を適用できるソース コードの位置を示します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-152">When you define a custom attribute, mark it by using AttributeUsageAttribute to indicate where in the source code the custom attribute can be applied.</span></span> <span data-ttu-id="dbe94-153">属性の意味と用途によって、コード内の有効な位置が決まります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-153">The meaning and intended usage of an attribute will determine its valid locations in code.</span></span> |
> | [<span data-ttu-id="dbe94-154">CA1019:属性引数にアクセサーを定義します</span><span class="sxs-lookup"><span data-stu-id="dbe94-154">CA1019: Define accessors for attribute arguments</span></span>](ca1019.md) | <span data-ttu-id="dbe94-155">属性では、対象に適用するときに必ず指定する必須の引数を定義できます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-155">Attributes can define mandatory arguments that must be specified when you apply the attribute to a target.</span></span> <span data-ttu-id="dbe94-156">この引数は、コンストラクターに位置指定パラメーターで属性を指定できるようになるため、位置指定引数とも呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-156">These are also known as positional arguments because they are supplied to attribute constructors as positional parameters.</span></span> <span data-ttu-id="dbe94-157">必須のすべての引数について、対応する読み取り専用のプロパティも属性で規定する必要があります。これは、引数値を実行時に取得できるようにするためです。</span><span class="sxs-lookup"><span data-stu-id="dbe94-157">For every mandatory argument, the attribute should also provide a corresponding read-only property so that the value of the argument can be retrieved at execution time.</span></span> <span data-ttu-id="dbe94-158">また、属性ではオプションの引数も定義できます。これは名前付き引数とも呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-158">Attributes can also define optional arguments, which are also known as named arguments.</span></span> <span data-ttu-id="dbe94-159">この引数は、名前でコンストラクターに属性を指定するときに使用されます。また、対応する読み取り/書き込みプロパティが必要です。</span><span class="sxs-lookup"><span data-stu-id="dbe94-159">These arguments are supplied to attribute constructors by name and should have a corresponding read/write property.</span></span> |
> | [<span data-ttu-id="dbe94-160">CA1021:out パラメーターを使用しません</span><span class="sxs-lookup"><span data-stu-id="dbe94-160">CA1021: Avoid out parameters</span></span>](ca1021.md) | <span data-ttu-id="dbe94-161">(out または ref を使用した) 型の参照渡しには、ポインターの使用経験、値型と参照型の違いの理解、および複数の戻り値を持つメソッドの処理が必要です。</span><span class="sxs-lookup"><span data-stu-id="dbe94-161">Passing types by reference (using out or ref) requires experience with pointers, understanding how value types and reference types differ, and handling methods with multiple return values.</span></span> <span data-ttu-id="dbe94-162">また、out パラメーターと ref パラメーターの違いはあまり理解されていません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-162">Also, the difference between out and ref parameters is not widely understood.</span></span> |
> | [<span data-ttu-id="dbe94-163">CA1024:適切な場所にプロパティを使用します</span><span class="sxs-lookup"><span data-stu-id="dbe94-163">CA1024: Use properties where appropriate</span></span>](ca1024.md) | <span data-ttu-id="dbe94-164">パブリック メソッドまたはプロテクト メソッドに、"Get" で始まる名前が付けられ、パラメーターは使用されていません。また、配列ではない値を返します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-164">A public or protected method has a name that starts with "Get", takes no parameters, and returns a value that is not an array.</span></span> <span data-ttu-id="dbe94-165">このメソッドは、プロパティに変更できる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-165">The method might be a good candidate to become a property.</span></span> |
> |[<span data-ttu-id="dbe94-166">CA1027:列挙型を FlagsAttribute に設定します</span><span class="sxs-lookup"><span data-stu-id="dbe94-166">CA1027: Mark enums with FlagsAttribute</span></span>](ca1027.md) | <span data-ttu-id="dbe94-167">列挙型は、関連する名前付き定数が複数定義された値型です。</span><span class="sxs-lookup"><span data-stu-id="dbe94-167">An enumeration is a value type that defines a set of related named constants.</span></span> <span data-ttu-id="dbe94-168">名前付き定数を有意に結合できる場合、列挙型に FlagsAttribute を適用します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-168">Apply FlagsAttribute to an enumeration when its named constants can be meaningfully combined.</span></span> |
> | [<span data-ttu-id="dbe94-169">CA1028:列挙ストレージは Int32 でなければなりません</span><span class="sxs-lookup"><span data-stu-id="dbe94-169">CA1028: Enum storage should be Int32</span></span>](ca1028.md) | <span data-ttu-id="dbe94-170">列挙型は、関連する名前付き定数が複数定義された値型です。</span><span class="sxs-lookup"><span data-stu-id="dbe94-170">An enumeration is a value type that defines a set of related named constants.</span></span> <span data-ttu-id="dbe94-171">既定で、System.Int32 データ型は、定数値を格納するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-171">By default, the System.Int32 data type is used to store the constant value.</span></span> <span data-ttu-id="dbe94-172">この基になる型を変更できる場合でも、ほとんどの場合、変更する必要はなく、推奨もされません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-172">Although you can change this underlying type, it is not required or recommended for most scenarios.</span></span> |
> | [<span data-ttu-id="dbe94-173">CA1030:適切な場所にイベントを使用します</span><span class="sxs-lookup"><span data-stu-id="dbe94-173">CA1030: Use events where appropriate</span></span>](ca1030.md) |<span data-ttu-id="dbe94-174">この規則では、通常はイベントに使用される名前を持つメソッドを検出します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-174">This rule detects methods that have names that ordinarily would be used for events.</span></span> <span data-ttu-id="dbe94-175">明示的に定義された状態変化に応答してメソッドが呼び出される場合、メソッドはイベント ハンドラーから呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-175">If a method is called in response to a clearly defined state change, the method should be invoked by an event handler.</span></span> <span data-ttu-id="dbe94-176">メソッドを呼び出すオブジェクトは、メソッドを直接呼び出すのではなく、イベントを発生させる必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-176">Objects that call the method should raise events instead of calling the method directly.</span></span> |
> | [<span data-ttu-id="dbe94-177">CA1031:一般的な例外の種類はキャッチしません</span><span class="sxs-lookup"><span data-stu-id="dbe94-177">CA1031: Do not catch general exception types</span></span>](ca1031.md) | <span data-ttu-id="dbe94-178">汎用的な例外はキャッチしないでください。</span><span class="sxs-lookup"><span data-stu-id="dbe94-178">General exceptions should not be caught.</span></span> <span data-ttu-id="dbe94-179">より具体的な例外をキャッチするか、汎用的な例外を catch ブロックの最後のステートメントでスローし直します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-179">Catch a more specific exception, or rethrow the general exception as the last statement in the catch block.</span></span> |
> |[<span data-ttu-id="dbe94-180">CA1032:標準例外コンストラクターを実装します</span><span class="sxs-lookup"><span data-stu-id="dbe94-180">CA1032: Implement standard exception constructors</span></span>](ca1032.md) | <span data-ttu-id="dbe94-181">コンストラクターを完全に宣言していないと、例外を正しく処理するのが困難になります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-181">Failure to provide the full set of constructors can make it difficult to correctly handle exceptions.</span></span> |
> | [<span data-ttu-id="dbe94-182">CA1033:インターフェイス メソッドは、子型によって呼び出し可能でなければなりません</span><span class="sxs-lookup"><span data-stu-id="dbe94-182">CA1033: Interface methods should be callable by child types</span></span>](ca1033.md) | <span data-ttu-id="dbe94-183">シールされていない外部から参照できる型によって、パブリック インターフェイスを持つメソッドを明示的に実装しています。また、同じ名前を持つ外部から参照できる代替のメソッドがありません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-183">An unsealed externally visible type provides an explicit method implementation of a public interface and does not provide an alternative externally visible method that has the same name.</span></span> |
> | [<span data-ttu-id="dbe94-184">CA1034:入れ子にされた型を参照可能にすることはできません</span><span class="sxs-lookup"><span data-stu-id="dbe94-184">CA1034: Nested types should not be visible</span></span>](ca1034.md) | <span data-ttu-id="dbe94-185">入れ子にされた型とは、別の型のスコープ内で宣言された型のことです。</span><span class="sxs-lookup"><span data-stu-id="dbe94-185">A nested type is a type that is declared in the scope of another type.</span></span> <span data-ttu-id="dbe94-186">入れ子にされた型は、包含型のプライベート実装の詳細をカプセル化するときに便利です。</span><span class="sxs-lookup"><span data-stu-id="dbe94-186">Nested types are useful to encapsulate private implementation details of the containing type.</span></span> <span data-ttu-id="dbe94-187">このような用途なので、入れ子にされた型は外部から参照できないようにします。</span><span class="sxs-lookup"><span data-stu-id="dbe94-187">Used for this purpose, nested types should not be externally visible.</span></span> |
> | [<span data-ttu-id="dbe94-188">CA1036:比較可能な型でメソッドをオーバーライドします</span><span class="sxs-lookup"><span data-stu-id="dbe94-188">CA1036: Override methods on comparable types</span></span>](ca1036.md) |<span data-ttu-id="dbe94-189">パブリック型またはプロテクト型で System.IComparable インターフェイスを実装しています。</span><span class="sxs-lookup"><span data-stu-id="dbe94-189">A public or protected type implements the System.IComparable interface.</span></span> <span data-ttu-id="dbe94-190">これによって、Object.Equals はオーバーライドされません。また、"等しい"、"等しくない"、"未満"、"より大きい" を示す言語固有の演算子はオーバーロードされません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-190">It does not override Object.Equals nor does it overload the language-specific operator for equality, inequality, less than, or greater than.</span></span> |
> |[<span data-ttu-id="dbe94-191">CA1040:空のインターフェイスは使用しません</span><span class="sxs-lookup"><span data-stu-id="dbe94-191">CA1040: Avoid empty interfaces</span></span>](ca1040.md) | <span data-ttu-id="dbe94-192">インターフェイスには、動作や使用のコントラクトを実現するメンバーが定義されます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-192">Interfaces define members that provide a behavior or usage contract.</span></span> <span data-ttu-id="dbe94-193">インターフェイスで示される機能は、継承の階層構造内に型が存在するかどうかにかかわらず、どの型からも適用できます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-193">The functionality that is described by the interface can be adopted by any type, regardless of where the type appears in the inheritance hierarchy.</span></span> <span data-ttu-id="dbe94-194">型ではインターフェイスのメンバーに実装することで、インターフェイスが実装されます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-194">A type implements an interface by providing implementations for the members of the interface.</span></span> <span data-ttu-id="dbe94-195">空のインターフェイスではメンバーが定義されません。そのため、実装できるコントラクトも定義されません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-195">An empty interface does not define any members; therefore, it does not define a contract that can be implemented.</span></span> |
> | [<span data-ttu-id="dbe94-196">CA1041:ObsoleteAttribute メッセージを指定します</span><span class="sxs-lookup"><span data-stu-id="dbe94-196">CA1041: Provide ObsoleteAttribute message</span></span>](ca1041.md) | <span data-ttu-id="dbe94-197">型またはメンバーが System.ObsoleteAttribute 属性を使用してマークされていますが、この属性で ObsoleteAttribute.Message プロパティが指定されていません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-197">A type or member is marked by using a System.ObsoleteAttribute attribute that does not have its ObsoleteAttribute.Message property specified.</span></span> <span data-ttu-id="dbe94-198">ObsoleteAttribute でマークされている型またはメンバーをコンパイルすると、属性の Message プロパティが表示されます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-198">When a type or member that is marked by using ObsoleteAttribute is compiled, the Message property of the attribute is displayed.</span></span> <span data-ttu-id="dbe94-199">これによって、ユーザーは旧式の型またはメンバーに関する情報を知ることができます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-199">This gives the user information about the obsolete type or member.</span></span> |
> | [<span data-ttu-id="dbe94-200">CA1043:インデクサーには整数または文字列引数を使用します</span><span class="sxs-lookup"><span data-stu-id="dbe94-200">CA1043: Use integral or string argument for indexers</span></span>](ca1043.md) | <span data-ttu-id="dbe94-201">インデクサー (つまり、インデックスされたプロパティ) では、インデックスに整数型または文字列型を使用します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-201">Indexers (that is, indexed properties) should use integral or string types for the index.</span></span> <span data-ttu-id="dbe94-202">一般に、このような型はデータ構造のインデックス作成に使用され、ライブラリの操作性も改善されます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-202">These types are typically used for indexing data structures and they increase the usability of the library.</span></span> <span data-ttu-id="dbe94-203">Object 型の使用は、デザイン時に特定の整数型または文字列型を指定できない場合に限定してください。</span><span class="sxs-lookup"><span data-stu-id="dbe94-203">Use of the Object type should be restricted to those cases where the specific integral or string type cannot be specified at design time.</span></span> |
> | [<span data-ttu-id="dbe94-204">CA1044:プロパティを書き込み専用にすることはできません</span><span class="sxs-lookup"><span data-stu-id="dbe94-204">CA1044: Properties should not be write only</span></span>](ca1044.md) | <span data-ttu-id="dbe94-205">読み取り専用のプロパティは許容され、必要な場合もよくありますが、書き込み専用のプロパティを使用することはデザインのガイドラインで禁止されています。</span><span class="sxs-lookup"><span data-stu-id="dbe94-205">Although it is acceptable and often necessary to have a read-only property, the design guidelines prohibit the use of write-only properties.</span></span> <span data-ttu-id="dbe94-206">これは、値を設定できてもその値を参照できず、セキュリティが確保されないためです。</span><span class="sxs-lookup"><span data-stu-id="dbe94-206">This is because letting a user set a value, and then preventing the user from viewing that value, does not provide any security.</span></span> <span data-ttu-id="dbe94-207">また、読み取りアクセスがないと、共有オブジェクトのステータスを参照できないため、実用性が制限されます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-207">Also, without read access, the state of shared objects cannot be viewed, which limits their usefulness.</span></span> |
> |[<span data-ttu-id="dbe94-208">CA1045:型を参照によって渡しません</span><span class="sxs-lookup"><span data-stu-id="dbe94-208">CA1045: Do not pass types by reference</span></span>](ca1045.md) | <span data-ttu-id="dbe94-209">(out または ref を使用した) 型の参照渡しには、ポインターの使用経験、値の型と参照型の違いの理解、および複数の戻り値を持つメソッドの処理が必要です。</span><span class="sxs-lookup"><span data-stu-id="dbe94-209">Passing types by reference (using out or ref) requires experience with pointers, understanding how value types and reference types differ, and handling methods that have multiple return values.</span></span> <span data-ttu-id="dbe94-210">開発者全般に向けてライブラリをデザインする場合、ユーザーが `out` パラメーターまたは `ref` パラメーターの扱い方を習得することは期待しないでください。</span><span class="sxs-lookup"><span data-stu-id="dbe94-210">Library architects who design for a general audience should not expect users to master working with `out` or `ref` parameters.</span></span> |
> | [<span data-ttu-id="dbe94-211">CA1046:参照型で、演算子 equals をオーバーロードしないでください</span><span class="sxs-lookup"><span data-stu-id="dbe94-211">CA1046: Do not overload operator equals on reference types</span></span>](ca1046.md) | <span data-ttu-id="dbe94-212">参照型の場合、等値演算子は既定の実装でほぼ問題がありません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-212">For reference types, the default implementation of the equality operator is almost always correct.</span></span> <span data-ttu-id="dbe94-213">既定で、2 つの参照が等値と見なされるのは、同じオブジェクトを参照する場合のみです。</span><span class="sxs-lookup"><span data-stu-id="dbe94-213">By default, two references are equal only if they point to the same object.</span></span> |
> |[<span data-ttu-id="dbe94-214">CA1047:シールド型の保護されたメンバーを宣言しません</span><span class="sxs-lookup"><span data-stu-id="dbe94-214">CA1047: Do not declare protected members in sealed types</span></span>](ca1047.md) | <span data-ttu-id="dbe94-215">型でプロテクト メンバーを宣言するのは、継承する型からメンバーにアクセスまたはオーバーライドできるようにするためです。</span><span class="sxs-lookup"><span data-stu-id="dbe94-215">Types declare protected members so that inheriting types can access or override the member.</span></span> <span data-ttu-id="dbe94-216">定義により、シールされた型から継承することはできません。これは、シールされた型のプロテクト メソッドを呼び出すことができないということを意味します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-216">By definition, sealed types cannot be inherited, which means that protected methods on sealed types cannot be called.</span></span> |
> | [<span data-ttu-id="dbe94-217">CA1050:名前空間で型を宣言します</span><span class="sxs-lookup"><span data-stu-id="dbe94-217">CA1050: Declare types in namespaces</span></span>](ca1050.md) | <span data-ttu-id="dbe94-218">型を名前空間内で宣言するのは、名前が衝突しないようにするためと、関連する型をオブジェクト階層形式で編成するためです。</span><span class="sxs-lookup"><span data-stu-id="dbe94-218">Types are declared in namespaces to prevent name collisions and as a way to organize related types in an object hierarchy.</span></span> |
> | [<span data-ttu-id="dbe94-219">CA1051:参照可能なインスタンス フィールドを宣言しません</span><span class="sxs-lookup"><span data-stu-id="dbe94-219">CA1051: Do not declare visible instance fields</span></span>](ca1051.md) | <span data-ttu-id="dbe94-220">フィールドの主な用途は、実装の詳細にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-220">The primary use of a field should be as an implementation detail.</span></span> <span data-ttu-id="dbe94-221">フィールドは private または internal にし、プロパティによって公開するようにします。</span><span class="sxs-lookup"><span data-stu-id="dbe94-221">Fields should be private or internal and should be exposed by using properties.</span></span> |
> | [<span data-ttu-id="dbe94-222">CA1052:スタティック ホルダー型はシールドされていなければなりません</span><span class="sxs-lookup"><span data-stu-id="dbe94-222">CA1052: Static holder types should be sealed</span></span>](ca1052.md) | <span data-ttu-id="dbe94-223">パブリック型またはプロテクト型に静的メンバーしかなく、sealed (C# リファレンス) (NotInheritable) 修飾子を使用して宣言されていません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-223">A public or protected type contains only static members and is not declared by using the sealed (C# Reference) (NotInheritable) modifier.</span></span> <span data-ttu-id="dbe94-224">継承を意図していない型は、sealed 修飾子を使用してマークし、基本型として使用できないようにします。</span><span class="sxs-lookup"><span data-stu-id="dbe94-224">A type that is not meant to be inherited should be marked by using the sealed modifier to prevent its use as a base type.</span></span> |
> |[<span data-ttu-id="dbe94-225">CA1053:スタティック ホルダー型はコンストラクターを含むことはできません</span><span class="sxs-lookup"><span data-stu-id="dbe94-225">CA1053: Static holder types should not have constructors</span></span>](ca1053.md) | <span data-ttu-id="dbe94-226">パブリック型または入れ子になったパブリック型で、静的なメンバーのみが宣言されています。また、パブリックまたはプロテクトの既定のコンストラクターが含まれます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-226">A public or nested public type declares only static members and has a public or protected default constructor.</span></span> <span data-ttu-id="dbe94-227">静的メンバーの呼び出しに型のインスタンスは必要ないため、コンストラクターは不要です。</span><span class="sxs-lookup"><span data-stu-id="dbe94-227">The constructor is unnecessary because calling static members does not require an instance of the type.</span></span> <span data-ttu-id="dbe94-228">安全性とセキュリティを確保するために、文字列引数を使用して文字列オーバーロードで URI (Uniform Resource Identifier) オーバーロードを呼び出してください。</span><span class="sxs-lookup"><span data-stu-id="dbe94-228">The string overload should call the uniform resource identifier (URI) overload by using the string argument for safety and security.</span></span> |
> | [<span data-ttu-id="dbe94-229">CA1054:URI パラメーターを文字列にすることはできません</span><span class="sxs-lookup"><span data-stu-id="dbe94-229">CA1054: URI parameters should not be strings</span></span>](ca1054.md) | <span data-ttu-id="dbe94-230">メソッドで URI の文字列形式を使用する場合、対応するオーバーロードを宣言し、URI クラスのインスタンスを使用します。こうすることで、安全な方法でこのサービスを実現できます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-230">If a method takes a string representation of a URI, a corresponding overload should be provided that takes an instance of the URI class, which provides these services in a safe and secure manner.</span></span> |
> | [<span data-ttu-id="dbe94-231">CA1055:URI 戻り値を文字列にすることはできません</span><span class="sxs-lookup"><span data-stu-id="dbe94-231">CA1055: URI return values should not be strings</span></span>](ca1055.md) | <span data-ttu-id="dbe94-232">この規則では、メソッドは URI を返すと想定されます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-232">This rule assumes that the method returns a URI.</span></span> <span data-ttu-id="dbe94-233">URI の文字列表現は解析エラーやエンコーディング エラーが発生しやすく、セキュリティ上の脆弱性の原因となる場合があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-233">A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities.</span></span> <span data-ttu-id="dbe94-234">System.Uri クラスを使用すると、安全な方法でこのサービスを実現できます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-234">The System.Uri class provides these services in a safe and secure manner.</span></span> |
> | [<span data-ttu-id="dbe94-235">CA1056:URI プロパティを文字列にすることはできません</span><span class="sxs-lookup"><span data-stu-id="dbe94-235">CA1056: URI properties should not be strings</span></span>](ca1056.md) | <span data-ttu-id="dbe94-236">この規則では、プロパティは URI (Uniform Resource Identifier) を表すと想定されます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-236">This rule assumes that the property represents a Uniform Resource Identifier (URI).</span></span> <span data-ttu-id="dbe94-237">URI の文字列表現は解析エラーやエンコーディング エラーが発生しやすく、セキュリティ上の脆弱性の原因となる場合があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-237">A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities.</span></span> <span data-ttu-id="dbe94-238">System.Uri クラスを使用すると、安全な方法でこのサービスを実現できます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-238">The System.Uri class provides these services in a safe and secure manner.</span></span> |
> | [<span data-ttu-id="dbe94-239">CA1058:型は、一定の基本型を拡張することはできません</span><span class="sxs-lookup"><span data-stu-id="dbe94-239">CA1058: Types should not extend certain base types</span></span>](ca1058.md) | <span data-ttu-id="dbe94-240">外部から参照可能な型では、特定の基本型が拡張されます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-240">An externally visible type extends certain base types.</span></span> <span data-ttu-id="dbe94-241">別の型を使用してください。</span><span class="sxs-lookup"><span data-stu-id="dbe94-241">Use one of the alternatives.</span></span> |
> | [<span data-ttu-id="dbe94-242">CA1060: P/Invoke を NativeMethods クラスに移動します</span><span class="sxs-lookup"><span data-stu-id="dbe94-242">CA1060: Move P/Invokes to NativeMethods class</span></span>](ca1060.md) | <span data-ttu-id="dbe94-243">System.Runtime.InteropServices.DllImportAttribute 属性でマークされているメソッドなどのプラットフォーム呼び出しメソッド、または Visual Basic で `Declare` キーワードを使用して定義されたメソッドから、アンマネージド コードにアクセスしています。</span><span class="sxs-lookup"><span data-stu-id="dbe94-243">Platform Invocation methods, such as those that are marked by using the System.Runtime.InteropServices.DllImportAttribute attribute, or methods that are defined by using the `Declare` keyword in Visual Basic, access unmanaged code.</span></span> <span data-ttu-id="dbe94-244">これらのメソッドは、NativeMethods、SafeNativeMethods、UnsafeNativeMethods の各クラスのいずれかに含まれる必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-244">These methods should be of the NativeMethods, SafeNativeMethods, or UnsafeNativeMethods class.</span></span> |
> |[<span data-ttu-id="dbe94-245">CA1061:基底クラス メソッドを非表示にしません</span><span class="sxs-lookup"><span data-stu-id="dbe94-245">CA1061: Do not hide base class methods</span></span>](ca1061.md) | <span data-ttu-id="dbe94-246">派生メソッドのパラメーター シグネチャ内のある型が、基本メソッドのパラメーター シグネチャ内のそれに対応する型より弱く型指定されていることが、両者の唯一の相違点である場合、基本型内のメソッドが派生型内の同じ名前のメソッドによって隠ぺいされます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-246">A method in a base type is hidden by an identically named method in a derived type, when the parameter signature of the derived method differs only by types that are more weakly derived than the corresponding types in the parameter signature of the base method.</span></span> |
> | [<span data-ttu-id="dbe94-247">CA1062:パブリック メソッドの引数の検証</span><span class="sxs-lookup"><span data-stu-id="dbe94-247">CA1062: Validate arguments of public methods</span></span>](ca1062.md) | <span data-ttu-id="dbe94-248">外部から参照可能なメソッドに渡されるすべての参照引数について、null かどうかをチェックする必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-248">All reference arguments that are passed to externally visible methods should be checked against null.</span></span> |
> | [<span data-ttu-id="dbe94-249">CA1063:IDisposable を正しく実装します</span><span class="sxs-lookup"><span data-stu-id="dbe94-249">CA1063: Implement IDisposable correctly</span></span>](ca1063.md) | <span data-ttu-id="dbe94-250">すべての IDisposable 型は、Dispose パターンを適切に実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-250">All IDisposable types should implement the Dispose pattern correctly.</span></span> |
> | [<span data-ttu-id="dbe94-251">CA1064:例外は public として設定する必要があります</span><span class="sxs-lookup"><span data-stu-id="dbe94-251">CA1064: Exceptions should be public</span></span>](ca1064.md) | <span data-ttu-id="dbe94-252">内部例外は、その内部スコープ内でのみ認識されます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-252">An internal exception is visible only inside its own internal scope.</span></span> <span data-ttu-id="dbe94-253">内部スコープの外側にある例外は、基本例外を使用しなければキャッチできません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-253">After the exception falls outside the internal scope, only the base exception can be used to catch the exception.</span></span> <span data-ttu-id="dbe94-254">内部例外が <xref:System.Exception>、<xref:System.SystemException>、または <xref:System.ApplicationException> を継承している場合、外部コードはその例外の処理に関する十分な情報を取得できません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-254">If the internal exception is inherited from <xref:System.Exception>, <xref:System.SystemException>, or <xref:System.ApplicationException>, the external code will not have sufficient information to know what to do with the exception.</span></span> |
> | [<span data-ttu-id="dbe94-255">CA1065:予期しない場所に例外を発生させません</span><span class="sxs-lookup"><span data-stu-id="dbe94-255">CA1065: Do not raise exceptions in unexpected locations</span></span>](ca1065.md) | <span data-ttu-id="dbe94-256">例外をスローしないはずのメソッドが例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="dbe94-256">A method that is not expected to throw exceptions throws an exception.</span></span> |
> | [<span data-ttu-id="dbe94-257">CA1066: Equals をオーバーライドする際に IEquatable を実装します</span><span class="sxs-lookup"><span data-stu-id="dbe94-257">CA1066: Implement IEquatable when overriding Equals</span></span>](ca1066.md) | <span data-ttu-id="dbe94-258">値の型では、<xref:System.Object.Equals%2A> をオーバーライドしていますが、<xref:System.IEquatable%601>を実装していません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-258">A value type overrides <xref:System.Object.Equals%2A> method, but does not implement <xref:System.IEquatable%601>.</span></span> |
> | [<span data-ttu-id="dbe94-259">CA1067: IEquatable を実装するときに Equals をオーバーライドします</span><span class="sxs-lookup"><span data-stu-id="dbe94-259">CA1067: Override Equals when implementing IEquatable</span></span>](ca1067.md) | <span data-ttu-id="dbe94-260">型では <xref:System.IEquatable%601> を実装していますが、<xref:System.Object.Equals%2A> メソッドをオーバーライドしていません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-260">A type implements <xref:System.IEquatable%601>, but does not override <xref:System.Object.Equals%2A> method.</span></span> |
> | [<span data-ttu-id="dbe94-261">CA1068:CancellationToken パラメーターは最後に指定する必要があります</span><span class="sxs-lookup"><span data-stu-id="dbe94-261">CA1068: CancellationToken parameters must come last</span></span>](ca1068.md) | <span data-ttu-id="dbe94-262">メソッドに、最後のパラメーターではない CancellationToken パラメーターが指定されています。</span><span class="sxs-lookup"><span data-stu-id="dbe94-262">A method has a CancellationToken parameter that is not the last parameter.</span></span> |
> | [<span data-ttu-id="dbe94-263">CA1069: 列挙型には重複する値を指定できません</span><span class="sxs-lookup"><span data-stu-id="dbe94-263">CA1069: Enums should not have duplicate values</span></span>](ca1069.md) | <span data-ttu-id="dbe94-264">列挙型に、同じ定数値が明示的に割り当てられている複数のメンバーがあります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-264">An enumeration has multiple members which are explicitly assigned the same constant value.</span></span> |
> | [<span data-ttu-id="dbe94-265">CA1070: イベント フィールドを virtual として宣言しません</span><span class="sxs-lookup"><span data-stu-id="dbe94-265">CA1070: Do not declare event fields as virtual</span></span>](ca1070.md) | <span data-ttu-id="dbe94-266">[フィールドのように使用するイベント](../../../csharp/event-pattern.md#defining-and-raising-field-like-events)が virtual として宣言されました。</span><span class="sxs-lookup"><span data-stu-id="dbe94-266">A [field-like event](../../../csharp/event-pattern.md#defining-and-raising-field-like-events) was declared as virtual.</span></span> |
> | [<span data-ttu-id="dbe94-267">CA1200:プレフィックスで cref タグを使用しません</span><span class="sxs-lookup"><span data-stu-id="dbe94-267">CA1200: Avoid using cref tags with a prefix</span></span>](ca1200.md) | <span data-ttu-id="dbe94-268">XML ドキュメント タグの [cref](../../../csharp/programming-guide/xmldoc/cref-attribute.md) 属性は "コード参照" を意味します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-268">The [cref](../../../csharp/programming-guide/xmldoc/cref-attribute.md) attribute in an XML documentation tag means "code reference".</span></span> <span data-ttu-id="dbe94-269">タグの内部テキストが、型、メソッド、プロパティなど、コード要素であることを指定します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-269">It specifies that the inner text of the tag is a code element, such as a type, method, or property.</span></span> <span data-ttu-id="dbe94-270">`cref` タグとプレフィックスを一緒に使用すると、コンパイラで参照を検証できなくなるため、一緒に使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="dbe94-270">Avoid using `cref` tags with prefixes, because it prevents the compiler from verifying references.</span></span> <span data-ttu-id="dbe94-271">また、Visual Studio 統合開発環境 (IDE) でリファクタリング中にこれらのシンボル参照を見つけたり、更新したりすることもできなくなります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-271">It also prevents the Visual Studio integrated development environment (IDE) from finding and updating these symbol references during refactorings.</span></span> |
> | [<span data-ttu-id="dbe94-272">CA1303:ローカライズされるパラメーターとしてリテラルを渡さない</span><span class="sxs-lookup"><span data-stu-id="dbe94-272">CA1303: Do not pass literals as localized parameters</span></span>](ca1303.md) | <span data-ttu-id="dbe94-273">外部から参照できるメソッドで、.NET コンストラクターまたはメソッドへのパラメーターとして、リテラル文字列を渡しています。その文字列はローカライズ可能です。</span><span class="sxs-lookup"><span data-stu-id="dbe94-273">An externally visible method passes a string literal as a parameter to a .NET constructor or method, and that string should be localizable.</span></span> |
> | [<span data-ttu-id="dbe94-274">CA1304:CultureInfo を指定します</span><span class="sxs-lookup"><span data-stu-id="dbe94-274">CA1304: Specify CultureInfo</span></span>](ca1304.md) | <span data-ttu-id="dbe94-275">System.Globalization.CultureInfo パラメーターを受け入れるオーバーロードを持つメンバーを呼び出しているメソッドまたはコンストラクターが、CultureInfo パラメーターを使用するオーバーロードを呼び出していません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-275">A method or constructor calls a member that has an overload that accepts a System.Globalization.CultureInfo parameter, and the method or constructor does not call the overload that takes the CultureInfo parameter.</span></span> <span data-ttu-id="dbe94-276">CultureInfo オブジェクトまたは System.IFormatProvider オブジェクトが指定されない場合、オーバーロードされたメンバーから提示された既定値は、すべてのロケールに効果が及ばない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-276">When a CultureInfo or System.IFormatProvider object is not supplied, the default value that is supplied by the overloaded member might not have the effect that you want in all locales.</span></span> |
> | [<span data-ttu-id="dbe94-277">CA1305:IFormatProvider を指定します</span><span class="sxs-lookup"><span data-stu-id="dbe94-277">CA1305: Specify IFormatProvider</span></span>](ca1305.md) | <span data-ttu-id="dbe94-278">System.IFormatProvider パラメーターを受け入れるオーバーロードを持つメンバーを 1 つ以上呼び出しているメソッドまたはコンストラクターが、IFormatProvider パラメーターを使用するオーバーロードを呼び出していません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-278">A method or constructor calls one or more members that have overloads that accept a System.IFormatProvider parameter, and the method or constructor does not call the overload that takes the IFormatProvider parameter.</span></span> <span data-ttu-id="dbe94-279">System.Globalization.CultureInfo オブジェクトまたは IFormatProvider オブジェクトが指定されない場合、オーバーロードされたメンバーから提示された既定値は、すべてのロケールに効果が及ばない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-279">When a System.Globalization.CultureInfo or IFormatProvider object is not supplied, the default value that is supplied by the overloaded member might not have the effect that you want in all locales.</span></span> |
> | [<span data-ttu-id="dbe94-280">CA1307:意味を明確にするための StringComparison の指定</span><span class="sxs-lookup"><span data-stu-id="dbe94-280">CA1307: Specify StringComparison for clarity</span></span>](ca1307.md) | <span data-ttu-id="dbe94-281">文字列比較演算で、StringComparison パラメーターを設定しないメソッド オーバーロードが使用されています。</span><span class="sxs-lookup"><span data-stu-id="dbe94-281">A string comparison operation uses a method overload that does not set a StringComparison parameter.</span></span> |
> |[<span data-ttu-id="dbe94-282">CA1308:文字列を大文字に標準化します</span><span class="sxs-lookup"><span data-stu-id="dbe94-282">CA1308: Normalize strings to uppercase</span></span>](ca1308.md) | <span data-ttu-id="dbe94-283">文字列は大文字に正規化する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-283">Strings should be normalized to uppercase.</span></span> <span data-ttu-id="dbe94-284">小文字への変換時に 1 つの小さい文字グループをラウンド トリップさせることができません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-284">A small group of characters cannot make a round trip when they are converted to lowercase.</span></span> |
> | [<span data-ttu-id="dbe94-285">CA1309:順序を示す StringComparison を使用します</span><span class="sxs-lookup"><span data-stu-id="dbe94-285">CA1309: Use ordinal StringComparison</span></span>](ca1309.md) | <span data-ttu-id="dbe94-286">非言語的な文字列比較演算で、StringComparison パラメーターが Ordinal または OrdinalIgnoreCase に設定されていません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-286">A string comparison operation that is nonlinguistic does not set the StringComparison parameter to either Ordinal or OrdinalIgnoreCase.</span></span> <span data-ttu-id="dbe94-287">パラメーターを StringComparison.Ordinal または StringComparison.OrdinalIgnoreCase に明示的に設定することによって、多くの場合、コードの速度、正確さ、および信頼性が向上します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-287">By explicitly setting the parameter to either StringComparison.Ordinal or StringComparison.OrdinalIgnoreCase, your code often gains speed, becomes more correct, and becomes more reliable.</span></span> |
> | [<span data-ttu-id="dbe94-288">CA1310:正確な StringComparison の指定</span><span class="sxs-lookup"><span data-stu-id="dbe94-288">CA1310: Specify StringComparison for correctness</span></span>](ca1310.md) | <span data-ttu-id="dbe94-289">文字列比較演算で、StringComparison パラメーターが設定されておらず、カルチャ固有の文字列比較が既定で使用されるメソッド オーバーロードを使用しています。</span><span class="sxs-lookup"><span data-stu-id="dbe94-289">A string comparison operation uses a method overload that does not set a StringComparison parameter and uses culture-specific string comparison by default.</span></span> |
> | [<span data-ttu-id="dbe94-290">CA1401: P/Invoke は参照可能になりません</span><span class="sxs-lookup"><span data-stu-id="dbe94-290">CA1401: P/Invokes should not be visible</span></span>](ca1401.md) | <span data-ttu-id="dbe94-291">パブリック型のパブリック メソッドまたはプロテクト メソッドに、System.Runtime.InteropServices.DllImportAttribute 属性があります (Visual Basic では Declare キーワードでも実装されます)。</span><span class="sxs-lookup"><span data-stu-id="dbe94-291">A public or protected method in a public type has the System.Runtime.InteropServices.DllImportAttribute attribute (also implemented by the Declare keyword in Visual Basic).</span></span> <span data-ttu-id="dbe94-292">このようなメソッドは公開しないでください。</span><span class="sxs-lookup"><span data-stu-id="dbe94-292">Such methods should not be exposed.</span></span> |
> | [<span data-ttu-id="dbe94-293">CA1416:プラットフォームの互換性を検証する</span><span class="sxs-lookup"><span data-stu-id="dbe94-293">CA1416: Validate platform compatibility</span></span>](ca1416.md) | <span data-ttu-id="dbe94-294">プラットフォーム依存 API をコンポーネント上で使用すると、一部のプラットフォームでコードが動作しなくなります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-294">Using platform-dependent APIs on a component makes the code no longer work across all platforms.</span></span> |
> | [<span data-ttu-id="dbe94-295">CA1417: P/Invokes の文字列パラメーターに `OutAttribute` を使用しません</span><span class="sxs-lookup"><span data-stu-id="dbe94-295">CA1417: Do not use `OutAttribute` on string parameters for P/Invokes</span></span>](ca1417.md) | <span data-ttu-id="dbe94-296">文字列がインターン処理された文字列で、文字列パラメーターが `OutAttribute` の値で渡された場合、ランタイムが不安定になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-296">String parameters passed by value with the `OutAttribute` can destabilize the runtime if the string is an interned string.</span></span> |
> | [<span data-ttu-id="dbe94-297">CA1501:継承を使用しすぎないでください</span><span class="sxs-lookup"><span data-stu-id="dbe94-297">CA1501: Avoid excessive inheritance</span></span>](ca1501.md) | <span data-ttu-id="dbe94-298">型が、その継承階層内の 5 つ以上深いレベルにあります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-298">A type is more than four levels deep in its inheritance hierarchy.</span></span> <span data-ttu-id="dbe94-299">深いレベルで入れ子にされた型の確認、理解、および保守は困難です。</span><span class="sxs-lookup"><span data-stu-id="dbe94-299">Deeply nested type hierarchies can be difficult to follow, understand, and maintain.</span></span> |
> | [<span data-ttu-id="dbe94-300">CA1502:メソッドの実装を複雑にしすぎないでください</span><span class="sxs-lookup"><span data-stu-id="dbe94-300">CA1502: Avoid excessive complexity</span></span>](ca1502.md) | <span data-ttu-id="dbe94-301">この規則は、線形独立のメソッド経路数を示す尺度で、条件分岐の数と複雑さによって決まります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-301">This rule measures the number of linearly independent paths through the method, which is determined by the number and complexity of conditional branches.</span></span> |
> | [<span data-ttu-id="dbe94-302">CA1505:メンテナンスできないコードを使用しないでください</span><span class="sxs-lookup"><span data-stu-id="dbe94-302">CA1505: Avoid unmaintainable code</span></span>](ca1505.md) | <span data-ttu-id="dbe94-303">型またはメソッドの保守容易性指数が低い値です。</span><span class="sxs-lookup"><span data-stu-id="dbe94-303">A type or method has a low maintainability index value.</span></span> <span data-ttu-id="dbe94-304">保守容易性指数の低い型またはメソッドは、保守が困難な可能性があるため、デザインの変更を検討することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="dbe94-304">A low maintainability index indicates that a type or method is probably difficult to maintain and would be a good candidate for redesign.</span></span> |
> | [<span data-ttu-id="dbe94-305">CA1506:クラス結合度を大きくしすぎないでください</span><span class="sxs-lookup"><span data-stu-id="dbe94-305">CA1506: Avoid excessive class coupling</span></span>](ca1506.md) | <span data-ttu-id="dbe94-306">この規則は、型またはメソッドに含まれる一意の型参照の数をカウントすることによって、クラス結合度を計測します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-306">This rule measures class coupling by counting the number of unique type references that a type or method contains.</span></span> |
> | [<span data-ttu-id="dbe94-307">CA1507:文字列の代わりに nameof を使用します</span><span class="sxs-lookup"><span data-stu-id="dbe94-307">CA1507: Use nameof in place of string</span></span>](ca1507.md) | <span data-ttu-id="dbe94-308">`nameof` 式を使用できる場合に、文字列リテラルが引数として使用されています。</span><span class="sxs-lookup"><span data-stu-id="dbe94-308">A string literal is used as an argument where a `nameof` expression could be used.</span></span> |
> | [<span data-ttu-id="dbe94-309">CA1508:使用されない条件付きコードを回避する</span><span class="sxs-lookup"><span data-stu-id="dbe94-309">CA1508: Avoid dead conditional code</span></span>](ca1508.md) | <span data-ttu-id="dbe94-310">実行時に常に `true` または `false` と評価される条件付きコードがメソッドにあります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-310">A method has conditional code that always evaluates to `true` or `false` at runtime.</span></span> <span data-ttu-id="dbe94-311">このため、条件の `false` 分岐で実行されないコードになります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-311">This leads to dead code in the `false` branch of the condition.</span></span> |
> | [<span data-ttu-id="dbe94-312">CA1509: コード メトリック構成ファイルのエントリが無効です</span><span class="sxs-lookup"><span data-stu-id="dbe94-312">CA1509: Invalid entry in code metrics configuration file</span></span>](ca1509.md) | <span data-ttu-id="dbe94-313">[CA1501](ca1501.md)、[CA1502](ca1502.md)、[CA1505](ca1505.md)、[CA1506](ca1506.md) などのコード メトリック規則で、無効なエントリを含んだ `CodeMetricsConfig.txt` という名前の構成ファイルが指定されました。</span><span class="sxs-lookup"><span data-stu-id="dbe94-313">Code metrics rules, such as [CA1501](ca1501.md), [CA1502](ca1502.md), [CA1505](ca1505.md) and [CA1506](ca1506.md), supplied a configuration file named `CodeMetricsConfig.txt` that has an invalid entry.</span></span> |
> | [<span data-ttu-id="dbe94-314">CA1700:列挙型値に 'Reserved' という名前を指定しません</span><span class="sxs-lookup"><span data-stu-id="dbe94-314">CA1700: Do not name enum values 'Reserved'</span></span>](ca1700.md) | <span data-ttu-id="dbe94-315">この規則では、"reserved" を含む名前の列挙体のメンバーは、現在使用されていなくても、将来的なバージョンでは名前を変更するか削除されるプレースホルダーと想定しています。</span><span class="sxs-lookup"><span data-stu-id="dbe94-315">This rule assumes that an enumeration member that has a name that contains "reserved" is not currently used but is a placeholder to be renamed or removed in a future version.</span></span> <span data-ttu-id="dbe94-316">メンバーの名前変更や削除は、互換性に影響する変更点です。</span><span class="sxs-lookup"><span data-stu-id="dbe94-316">Renaming or removing a member is a breaking change.</span></span> |
> | [<span data-ttu-id="dbe94-317">CA1707:識別子はアンダースコアを含むことはできません</span><span class="sxs-lookup"><span data-stu-id="dbe94-317">CA1707: Identifiers should not contain underscores</span></span>](ca1707.md) | <span data-ttu-id="dbe94-318">名前付け規則では、識別子名にアンダースコア (_) 文字を含めることができません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-318">By convention, identifier names do not contain the underscore (_) character.</span></span> <span data-ttu-id="dbe94-319">この規則により、名前空間、型、メンバー、およびパラメーターがチェックされます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-319">This rule checks namespaces, types, members, and parameters.</span></span> |
> | [<span data-ttu-id="dbe94-320">CA1708:識別子は、大文字と小文字の区別以外にも相違していなければなりません</span><span class="sxs-lookup"><span data-stu-id="dbe94-320">CA1708: Identifiers should differ by more than case</span></span>](ca1708.md) | <span data-ttu-id="dbe94-321">名前空間、型、メンバー、およびパラメーターの各識別子は、大文字/小文字以外のみでは区別できません。共通言語ランタイムを対象とする言語は、大文字と小文字を区別する必要はないためです。</span><span class="sxs-lookup"><span data-stu-id="dbe94-321">Identifiers for namespaces, types, members, and parameters cannot differ only by case because languages that target the common language runtime are not required to be case-sensitive.</span></span> |
> | [<span data-ttu-id="dbe94-322">CA1710:識別子は、正しいサフィックスを含んでいなければなりません</span><span class="sxs-lookup"><span data-stu-id="dbe94-322">CA1710: Identifiers should have correct suffix</span></span>](ca1710.md) |<span data-ttu-id="dbe94-323">名前付け規則によると、特定の基本型を拡張した型、特定のインターフェイスを実装する型、またはそのような型の派生型は、基本型やインターフェイスに関連するサフィックスを名前に付けます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-323">By convention, the names of types that extend certain base types or that implement certain interfaces, or types that are derived from these types, have a suffix that is associated with the base type or interface.</span></span> |
> | [<span data-ttu-id="dbe94-324">CA1711:識別子は、不適切なサフィックスを含むことはできません</span><span class="sxs-lookup"><span data-stu-id="dbe94-324">CA1711: Identifiers should not have incorrect suffix</span></span>](ca1711.md) | <span data-ttu-id="dbe94-325">規則では、特定の基本型を拡張する型、特定のインターフェイスを実装する型、またはそのような型から派生した型の名前にのみ、固有の予約済みサフィックスを末尾に付けます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-325">By convention, only the names of types that extend certain base types or that implement certain interfaces, or types that are derived from these types, should end with specific reserved suffixes.</span></span> <span data-ttu-id="dbe94-326">その他の型名では、予約済みのサフィックスを使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="dbe94-326">Other type names should not use these reserved suffixes.</span></span> |
> | [<span data-ttu-id="dbe94-327">CA1712:列挙型値を型名のプレフィックスにしません</span><span class="sxs-lookup"><span data-stu-id="dbe94-327">CA1712: Do not prefix enum values with type name</span></span>](ca1712.md) | <span data-ttu-id="dbe94-328">型情報は開発ツールで表示されるため、列挙型のメンバー名には、型名のプレフィックスを付けません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-328">Names of enumeration members are not prefixed by using the type name because development tools are expected to provide type information.</span></span> |
> | [<span data-ttu-id="dbe94-329">CA1713:イベントは、before または after プレフィックスを含むことはできません</span><span class="sxs-lookup"><span data-stu-id="dbe94-329">CA1713: Events should not have before or after prefix</span></span>](ca1713.md) | <span data-ttu-id="dbe94-330">イベント名が "Before" または "After" で始まっています。</span><span class="sxs-lookup"><span data-stu-id="dbe94-330">The name of an event starts with "Before" or "After".</span></span> <span data-ttu-id="dbe94-331">特定のシーケンスで発生する関連イベントに名前を付ける場合、現在時制または過去時制を使用して、アクション シーケンスの相対的な位置を示します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-331">To name related events that are raised in a specific sequence, use the present or past tense to indicate the relative position in the sequence of actions.</span></span> |
> | [<span data-ttu-id="dbe94-332">CA1714:フラグ列挙型は、複数形の名前を含んでいなければなりません</span><span class="sxs-lookup"><span data-stu-id="dbe94-332">CA1714: Flags enums should have plural names</span></span>](ca1714.md) | <span data-ttu-id="dbe94-333">パブリック列挙体に System.FlagsAttribute 属性があり、その名前の末尾に "s" がありません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-333">A public enumeration has the System.FlagsAttribute attribute, and its name does not end in "s".</span></span> <span data-ttu-id="dbe94-334">FlagsAttribute でマークされた型は複数形の名前を持ちます。これは、この属性が複数の値を指定できることを示すからです。</span><span class="sxs-lookup"><span data-stu-id="dbe94-334">Types that are marked by using FlagsAttribute have names that are plural because the attribute indicates that more than one value can be specified.</span></span> |
> | [<span data-ttu-id="dbe94-335">CA1715:識別子は正しいプレフィックスを含んでいなければなりません</span><span class="sxs-lookup"><span data-stu-id="dbe94-335">CA1715: Identifiers should have correct prefix</span></span>](ca1715.md) | <span data-ttu-id="dbe94-336">外部から参照できるインターフェイスの名前が大文字の "I" から始まっていません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-336">The name of an externally visible interface does not start with an uppercase "I".</span></span> <span data-ttu-id="dbe94-337">外部から参照できる型またはメソッドのジェネリック型パラメーターの名前が、大文字の "T" から始まっていません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-337">The name of a generic type parameter on an externally visible type or method does not start with an uppercase "T".</span></span> |
> | [<span data-ttu-id="dbe94-338">CA1716:識別子はキーワードと同一にすることはできません</span><span class="sxs-lookup"><span data-stu-id="dbe94-338">CA1716: Identifiers should not match keywords</span></span>](ca1716.md) | <span data-ttu-id="dbe94-339">名前空間の名前または型の名前が、プログラミング言語で、予約済みのキーワードと一致します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-339">A namespace name or a type name matches a reserved keyword in a programming language.</span></span> <span data-ttu-id="dbe94-340">名前空間と型の識別子は、共通言語ランタイムを対象にする言語で定義されているキーワードと一致しないようにします。</span><span class="sxs-lookup"><span data-stu-id="dbe94-340">Identifiers for namespaces and types should not match keywords that are defined by languages that target the common language runtime.</span></span> |
> | [<span data-ttu-id="dbe94-341">CA1717:FlagsAttribute 列挙型のみが複数形の名前を含んでいなければなりません</span><span class="sxs-lookup"><span data-stu-id="dbe94-341">CA1717: Only FlagsAttribute enums should have plural names</span></span>](ca1717.md) | <span data-ttu-id="dbe94-342">名前付け規則では、列挙体の複数形の名前は同時に複数の列挙値を指定できることを意味します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-342">Naming conventions dictate that a plural name for an enumeration indicates that more than one value of the enumeration can be specified at the same time.</span></span> |
> |[<span data-ttu-id="dbe94-343">CA1720:識別子には型名を含めないでください</span><span class="sxs-lookup"><span data-stu-id="dbe94-343">CA1720: Identifiers should not contain type names</span></span>](ca1720.md) | <span data-ttu-id="dbe94-344">外部から参照できるメンバーのパラメーター名にデータ型の名前が含まれているか、外部から参照できるメンバーの名前に言語固有のデータ型の名前が含まれています。</span><span class="sxs-lookup"><span data-stu-id="dbe94-344">The name of a parameter in an externally visible member contains a data type name, or the name of an externally visible member contains a language-specific data type name.</span></span> |
> | [<span data-ttu-id="dbe94-345">CA1721:プロパティ名は get メソッドと同一にすることはできません</span><span class="sxs-lookup"><span data-stu-id="dbe94-345">CA1721: Property names should not match get methods</span></span>](ca1721.md) |<span data-ttu-id="dbe94-346">パブリック メンバーまたはプロテクト メンバーの名前が、"Get" から始まっているか、パブリック プロパティまたはプロテクト プロパティの名前と一致します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-346">The name of a public or protected member starts with "Get" and otherwise matches the name of a public or protected property.</span></span> <span data-ttu-id="dbe94-347">"Get" メソッドとプロパティには、それぞれの機能を明確に区別する名前を指定しなければなりません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-347">"Get" methods and properties should have names that clearly distinguish their function.</span></span> |
> | [<span data-ttu-id="dbe94-348">CA1724:型名は名前空間と同一にすることはできません</span><span class="sxs-lookup"><span data-stu-id="dbe94-348">CA1724: Type Names Should Not Match Namespaces</span></span>](ca1724.md) | <span data-ttu-id="dbe94-349">型名は .NET 名前空間と同一にすることはできません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-349">Type names should not match the names of .NET namespaces.</span></span> <span data-ttu-id="dbe94-350">この規則に違反すると、ライブラリが使いづらくなります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-350">Violating this rule can reduce the usability of the library.</span></span> |
> | [<span data-ttu-id="dbe94-351">CA1725:パラメーター名は基本宣言と同一でなければなりません</span><span class="sxs-lookup"><span data-stu-id="dbe94-351">CA1725: Parameter names should match base declaration</span></span>](ca1725.md) | <span data-ttu-id="dbe94-352">オーバーライド階層のパラメーターに対する一貫性のある名前付けによって、メソッド オーバーライドの有用性が高まります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-352">Consistent naming of parameters in an override hierarchy increases the usability of the method overrides.</span></span> <span data-ttu-id="dbe94-353">派生メソッドのパラメーター名が基本宣言のパラメーター名と異なる場合、メソッドが基本メソッドのオーバーライドであるか、またはメソッドの新しいオーバーライドであるかについて混乱が生じる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-353">A parameter name in a derived method that differs from the name in the base declaration can cause confusion about whether the method is an override of the base method or a new overload of the method.</span></span> |
> | [<span data-ttu-id="dbe94-354">CA1801:使用されていないパラメーターの確認</span><span class="sxs-lookup"><span data-stu-id="dbe94-354">CA1801: Review unused parameters</span></span>](ca1801.md) | <span data-ttu-id="dbe94-355">メソッドのシグネチャに、メソッドの本体で使用されていないパラメーターがあります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-355">A method signature includes a parameter that is not used in the method body.</span></span> |
> |[<span data-ttu-id="dbe94-356">CA1802:適切な場所にリテラルを使用します</span><span class="sxs-lookup"><span data-stu-id="dbe94-356">CA1802: Use Literals Where Appropriate</span></span>](ca1802.md) |<span data-ttu-id="dbe94-357">フィールドが static および read-only (Visual Basic では Shared および ReadOnly) として宣言され、コンパイル時に計算できる値によって初期化されています。</span><span class="sxs-lookup"><span data-stu-id="dbe94-357">A field is declared static and read-only (Shared and ReadOnly in Visual Basic), and is initialized by using a value that is computable at compile time.</span></span> <span data-ttu-id="dbe94-358">対象フィールドに代入された値はコンパイル時に計算できるので、宣言を const (Visual Basic では Const) フィールドに変更して、値が実行時ではなくコンパイル時に計算されるようにします。</span><span class="sxs-lookup"><span data-stu-id="dbe94-358">Because the value that is assigned to the targeted field is computable at compile time, change the declaration to a const (Const in Visual Basic) field so that the value is computed at compile time instead of at run time.</span></span> |
> | [<span data-ttu-id="dbe94-359">CA1805: 不必要に初期化しない</span><span class="sxs-lookup"><span data-stu-id="dbe94-359">CA1805: Do not initialize unnecessarily</span></span>](ca1805.md) | <span data-ttu-id="dbe94-360">.NET ランタイムでは、コンストラクターを実行する前に参照型のすべてのフィールドを既定値に初期化します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-360">The .NET runtime initializes all fields of reference types to their default values before running the constructor.</span></span> <span data-ttu-id="dbe94-361">ほとんどの場合、フィールドを明示的に既定値に初期化することは冗長であり、メンテナンス コストが増加し、パフォーマンスが低下 (アセンブリのサイズの増加など) する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-361">In most cases, explicitly initializing a field to its default value is redundant, which adds to maintenance costs and may degrade performance (such as with increased assembly size).</span></span> |
> | [<span data-ttu-id="dbe94-362">CA1806:メソッドの結果を無視しない</span><span class="sxs-lookup"><span data-stu-id="dbe94-362">CA1806: Do not ignore method results</span></span>](ca1806.md) | <span data-ttu-id="dbe94-363">新しく作成されたオブジェクトが現在まで使用されていないか、新しい文字列を作成して返すメソッドが呼び出されて作成された新しい文字列が現在まで使用されていません。あるいは、COM または P/Invoke メソッドから返された HRESULT またはエラー コードが現在まで使用されていません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-363">A new object is created but never used; or a method that creates and returns a new string is called and the new string is never used; or a COM or P/Invoke method returns an HRESULT or error code that is never used.</span></span> |
> | [<span data-ttu-id="dbe94-364">CA1810:参照型の静的フィールドをインラインで初期化します</span><span class="sxs-lookup"><span data-stu-id="dbe94-364">CA1810: Initialize reference type static fields inline</span></span>](ca1810.md) | <span data-ttu-id="dbe94-365">型で明示的な静的コンストラクターを宣言すると、Just-In-Time (JIT) コンパイラが、静的コンストラクターが呼び出されたことを確認するために、型の静的メソッドと静的インスタンス コンストラクターに個別にチェックを追加します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-365">When a type declares an explicit static constructor, the just-in-time (JIT) compiler adds a check to each static method and instance constructor of the type to make sure that the static constructor was previously called.</span></span> <span data-ttu-id="dbe94-366">静的コンストラクターのチェックによってパフォーマンスが低下することがあります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-366">Static constructor checks can decrease performance.</span></span> |
> | [<span data-ttu-id="dbe94-367">CA1812:インスタンス化されていない内部クラスを使用しません</span><span class="sxs-lookup"><span data-stu-id="dbe94-367">CA1812: Avoid uninstantiated internal classes</span></span>](ca1812.md) | <span data-ttu-id="dbe94-368">アセンブリ レベルの型のインスタンスが、アセンブリ内のコードから作成されません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-368">An instance of an assembly-level type is not created by code in the assembly.</span></span> |
> | [<span data-ttu-id="dbe94-369">CA1813:アンシールド属性を使用しません</span><span class="sxs-lookup"><span data-stu-id="dbe94-369">CA1813: Avoid unsealed attributes</span></span>](ca1813.md) | <span data-ttu-id="dbe94-370">.NET には、カスタム属性を取得するメソッドが用意されています。</span><span class="sxs-lookup"><span data-stu-id="dbe94-370">.NET provides methods for retrieving custom attributes.</span></span> <span data-ttu-id="dbe94-371">既定では、これらのメソッドで属性の継承階層が検索されます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-371">By default, these methods search the attribute inheritance hierarchy.</span></span> <span data-ttu-id="dbe94-372">属性をシールすると、継承階層の全体が検索されなくなるため、パフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-372">Sealing the attribute eliminates the search through the inheritance hierarchy and can improve performance.</span></span> |
> | [<span data-ttu-id="dbe94-373">CA1814:複数次元の配列ではなくジャグ配列を使用します</span><span class="sxs-lookup"><span data-stu-id="dbe94-373">CA1814: Prefer jagged arrays over multidimensional</span></span>](ca1814.md) | <span data-ttu-id="dbe94-374">ジャグ配列とは、その要素も配列である配列です。</span><span class="sxs-lookup"><span data-stu-id="dbe94-374">A jagged array is an array whose elements are arrays.</span></span> <span data-ttu-id="dbe94-375">要素を構成する配列のサイズは異なってもよいため、データ セットによっては無駄な空間が少なくなります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-375">The arrays that make up the elements can be of different sizes, leading to less wasted space for some sets of data.</span></span> |
> | [<span data-ttu-id="dbe94-376">CA1815:equals および operator equals を値型でオーバーライドします</span><span class="sxs-lookup"><span data-stu-id="dbe94-376">CA1815: Override equals and operator equals on value types</span></span>](ca1815.md) | <span data-ttu-id="dbe94-377">値型の場合、Equals を継承した実装が Reflection ライブラリを使用して、すべてのフィールドの内容を比較します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-377">For value types, the inherited implementation of Equals uses the Reflection library and compares the contents of all fields.</span></span> <span data-ttu-id="dbe94-378">Reflection は計算コストが高いため、場合によってはすべてのフィールドで等値性を比較する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-378">Reflection is computationally expensive, and comparing every field for equality might be unnecessary.</span></span> <span data-ttu-id="dbe94-379">ユーザーがインスタンスの比較または並べ替えを行うことや、ハッシュ テーブル キーとしてインスタンスを使用することが予想される場合には、値型に Equals を実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-379">If you expect users to compare or sort instances, or to use instances as hash table keys, your value type should implement Equals.</span></span> |
> | [<span data-ttu-id="dbe94-380">CA1816:GC.SuppressFinalize を正しく呼び出します</span><span class="sxs-lookup"><span data-stu-id="dbe94-380">CA1816: Call GC.SuppressFinalize correctly</span></span>](ca1816.md) | <span data-ttu-id="dbe94-381">Dispose を実装するメソッドが GC.SuppressFinalize を呼び出していないか、Dispose を実装しないメソッドが GC.SuppressFinalize を呼び出しています。または、あるメソッドが GC.SuppressFinalize を呼び出し、this (Visual Basic では Me) 以外のオブジェクトを渡しています。</span><span class="sxs-lookup"><span data-stu-id="dbe94-381">A method that is an implementation of Dispose does not call GC.SuppressFinalize; or a method that is not an implementation of Dispose calls GC.SuppressFinalize; or a method calls GC.SuppressFinalize and passes something other than this (Me in Visual Basic).</span></span> |
> | [<span data-ttu-id="dbe94-382">CA1819:プロパティは、配列を返すことはできません</span><span class="sxs-lookup"><span data-stu-id="dbe94-382">CA1819: Properties should not return arrays</span></span>](ca1819.md) | <span data-ttu-id="dbe94-383">プロパティが読み取り専用であっても、プロパティで返される配列は書き込みから保護されません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-383">Arrays that are returned by properties are not write-protected, even when the property is read-only.</span></span> <span data-ttu-id="dbe94-384">配列の改ざんを防ぐには、プロパティで配列のコピーを返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-384">To keep the array tamper-proof, the property must return a copy of the array.</span></span> <span data-ttu-id="dbe94-385">一般に、このようなプロパティを呼び出すときのパフォーマンス低下は理解されません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-385">Typically, users will not understand the adverse performance implications of calling such a property.</span></span> |
> | [<span data-ttu-id="dbe94-386">CA1820:文字列の長さを使用して空の文字列をテストします</span><span class="sxs-lookup"><span data-stu-id="dbe94-386">CA1820: Test for empty strings using string length</span></span>](ca1820.md) | <span data-ttu-id="dbe94-387">String.Length プロパティまたは String.IsNullOrEmpty メソッドを使用して文字列を比較する方法は、Equals を使用する場合よりもはるかに高速です。</span><span class="sxs-lookup"><span data-stu-id="dbe94-387">Comparing strings by using the String.Length property or the String.IsNullOrEmpty method is significantly faster than using Equals.</span></span> |
> | [<span data-ttu-id="dbe94-388">CA1821:空のファイナライザーを削除します</span><span class="sxs-lookup"><span data-stu-id="dbe94-388">CA1821: Remove empty finalizers</span></span>](ca1821.md) | <span data-ttu-id="dbe94-389">オブジェクトの有効期間の追跡に関連するパフォーマンス オーバーヘッドが増大するため、ファイナライザーは可能な限り使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="dbe94-389">Whenever you can, avoid finalizers because of the additional performance overhead that is involved in tracking object lifetime.</span></span> <span data-ttu-id="dbe94-390">空のファイナライザーを使用すると、オーバーヘッドが増大するだけで何の利点もありません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-390">An empty finalizer incurs added overhead and delivers no benefit.</span></span> |
> |[<span data-ttu-id="dbe94-391">CA1822:メンバーを static に設定します</span><span class="sxs-lookup"><span data-stu-id="dbe94-391">CA1822: Mark members as static</span></span>](ca1822.md) | <span data-ttu-id="dbe94-392">インスタンス データにアクセスしない、またはインスタンス メソッドを呼び出さないメンバーは、静的 (Visual Basic では Shared) としてマークできます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-392">Members that do not access instance data or call instance methods can be marked as static (Shared in Visual Basic).</span></span> <span data-ttu-id="dbe94-393">メソッドを静的としてマークすると、コンパイラはこれらのメンバーに対する非仮想呼び出しサイトを出力します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-393">After you mark the methods as static, the compiler will emit nonvirtual call sites to these members.</span></span> <span data-ttu-id="dbe94-394">パフォーマンス重視のコードでは、これにより大きくパフォーマンスを向上できます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-394">This can give you a measurable performance gain for performance-sensitive code.</span></span> |
> | [<span data-ttu-id="dbe94-395">CA1823:使用されていないプライベート フィールドを使用しません</span><span class="sxs-lookup"><span data-stu-id="dbe94-395">CA1823: Avoid unused private fields</span></span>](ca1823.md) | <span data-ttu-id="dbe94-396">アセンブリ内でアクセスされていないと思われるプライベート フィールドが検出されました。</span><span class="sxs-lookup"><span data-stu-id="dbe94-396">Private fields were detected that do not appear to be accessed in the assembly.</span></span> |
> |[<span data-ttu-id="dbe94-397">CA1824:アセンブリを NeutralResourcesLanguageAttribute に設定します</span><span class="sxs-lookup"><span data-stu-id="dbe94-397">CA1824: Mark assemblies with NeutralResourcesLanguageAttribute</span></span>](ca1824.md) | <span data-ttu-id="dbe94-398">NeutralResourcesLanguage 属性は、リソース マネージャーに対し、アセンブリのニュートラル カルチャのリソースを表示するために使用した言語を通知します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-398">The NeutralResourcesLanguage attribute informs the resource manager of the language that was used to display the resources of a neutral culture for an assembly.</span></span> <span data-ttu-id="dbe94-399">これにより、読み込んだ最初のリソースに対する検索のパフォーマンスが向上し、ワーキング セットを縮小できます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-399">This improves lookup performance for the first resource that you load and can reduce your working set.</span></span> |
> |[<span data-ttu-id="dbe94-400">CA1825:長さ 0 の配列割り当てを回避します</span><span class="sxs-lookup"><span data-stu-id="dbe94-400">CA1825: Avoid zero-length array allocations</span></span>](ca1825.md) | <span data-ttu-id="dbe94-401">長さ 0 の配列を初期化すると、不要なメモリ割り当てが発生します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-401">Initializing a zero-length array leads to unnecessary memory allocation.</span></span> <span data-ttu-id="dbe94-402">代わりに、<xref:System.Array.Empty%2A?displayProperty=nameWithType> を呼び出して、静的に割り当てられた空の配列インスタンスを使用してください。</span><span class="sxs-lookup"><span data-stu-id="dbe94-402">Instead, use the statically allocated empty array instance by calling <xref:System.Array.Empty%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="dbe94-403">メモリ割り当ては、このメソッドのすべての呼び出しで共有されます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-403">The memory allocation is shared across all invocations of this method.</span></span> |
> |[<span data-ttu-id="dbe94-404">CA1826:Linq の列挙可能なメソッドの代わりにプロパティを使用します</span><span class="sxs-lookup"><span data-stu-id="dbe94-404">CA1826: Use property instead of Linq Enumerable method</span></span>](ca1826.md) | <span data-ttu-id="dbe94-405"><xref:System.Linq.Enumerable> LINQ メソッドが同等のより効率的なプロパティをサポートする型で使用されました。</span><span class="sxs-lookup"><span data-stu-id="dbe94-405"><xref:System.Linq.Enumerable> LINQ method was used on a type that supports an equivalent, more efficient property.</span></span> |
> |[<span data-ttu-id="dbe94-406">CA1827:Any が使用できる場合は Count/LongCount を使用しません</span><span class="sxs-lookup"><span data-stu-id="dbe94-406">CA1827: Do not use Count/LongCount when Any can be used</span></span>](ca1827.md) | <span data-ttu-id="dbe94-407"><xref:System.Linq.Enumerable.Any%2A> メソッドの方が効率的な状況で、<xref:System.Linq.Enumerable.Count%2A> または <xref:System.Linq.Enumerable.LongCount%2A> メソッドが使用されました。</span><span class="sxs-lookup"><span data-stu-id="dbe94-407"><xref:System.Linq.Enumerable.Count%2A> or <xref:System.Linq.Enumerable.LongCount%2A> method was used where <xref:System.Linq.Enumerable.Any%2A> method would be more efficient.</span></span> |
> |[<span data-ttu-id="dbe94-408">CA1828:AnyAsync が使用できる場合は CountAsync/LongCountAsync を使用しません</span><span class="sxs-lookup"><span data-stu-id="dbe94-408">CA1828: Do not use CountAsync/LongCountAsync when AnyAsync can be used</span></span>](ca1828.md) | <span data-ttu-id="dbe94-409"><xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.AnyAsync%2A> メソッドの方が効率的な状況で、<xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.CountAsync%2A> または <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.LongCountAsync%2A> メソッドが使用されました。</span><span class="sxs-lookup"><span data-stu-id="dbe94-409"><xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.CountAsync%2A> or <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.LongCountAsync%2A> method was used where <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.AnyAsync%2A> method would be more efficient.</span></span> |
> |[<span data-ttu-id="dbe94-410">CA1829:Enumerable. Count メソッドではなく Length/Count プロパティを使用します</span><span class="sxs-lookup"><span data-stu-id="dbe94-410">CA1829: Use Length/Count property instead of Enumerable.Count method</span></span>](ca1829.md) | <span data-ttu-id="dbe94-411"><xref:System.Linq.Enumerable.Count%2A> LINQ メソッドが同等のより効率的な `Length` または `Count` プロパティをサポートする型で使用されました。</span><span class="sxs-lookup"><span data-stu-id="dbe94-411"><xref:System.Linq.Enumerable.Count%2A> LINQ method was used on a type that supports an equivalent, more efficient `Length` or `Count` property.</span></span> |
> |[<span data-ttu-id="dbe94-412">CA1830:StringBuilder の厳密に型指定された Append および Insert メソッドのオーバーロードをお勧めします</span><span class="sxs-lookup"><span data-stu-id="dbe94-412">CA1830: Prefer strongly-typed Append and Insert method overloads on StringBuilder</span></span>](ca1830.md) | <span data-ttu-id="dbe94-413"><xref:System.Text.StringBuilder.Append%2A> と <xref:System.Text.StringBuilder.Insert%2A> では、<xref:System.String> 以外の複数の型に対してオーバーロードを提供します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-413"><xref:System.Text.StringBuilder.Append%2A> and <xref:System.Text.StringBuilder.Insert%2A> provide overloads for multiple types beyond <xref:System.String>.</span></span>  <span data-ttu-id="dbe94-414">可能であれば、ToString() と文字列ベースのオーバーロードを使用するよりも、厳密に型指定されたオーバーロードを優先して使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="dbe94-414">When possible, prefer the strongly-typed overloads over using ToString() and the string-based overload.</span></span> |
> |[<span data-ttu-id="dbe94-415">CA1831: 該当する場合、文字列に範囲ベースのインデクサーの代わりに AsSpan を使用します</span><span class="sxs-lookup"><span data-stu-id="dbe94-415">CA1831: Use AsSpan instead of Range-based indexers for string when appropriate</span></span>](ca1831.md) | <span data-ttu-id="dbe94-416">文字列に対して範囲インデクサーを使用し、その値を ReadOnlySpan&lt;char&gt; 型に暗黙的に割り当てると、<xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> の代わりにメソッド <xref:System.String.Substring%2A?#System_String_Substring_System_Int32_System_Int32_> が使用されます。これにより、文字列の要求された部分のコピーが生成されます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-416">When using a range-indexer on a string and implicitly assigning the value to  ReadOnlySpan&lt;char&gt; type, the method <xref:System.String.Substring%2A?#System_String_Substring_System_Int32_System_Int32_> will be used instead of <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_>, which produces a copy of requested portion of the string.</span></span> |
> |[<span data-ttu-id="dbe94-417">CA1832: 配列の ReadOnlySpan または ReadOnlyMemory 部分を取得するために、範囲ベースのインデクサーの代わりに AsSpan または AsMemory を使用します</span><span class="sxs-lookup"><span data-stu-id="dbe94-417">CA1832: Use AsSpan or AsMemory instead of Range-based indexers for getting ReadOnlySpan or ReadOnlyMemory portion of an array</span></span>](ca1832.md) | <span data-ttu-id="dbe94-418">配列に対して範囲インデクサーを使用し、その値を <xref:System.ReadOnlySpan%601> または <xref:System.ReadOnlyMemory%601> 型に暗黙的に割り当てると、<xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> の代わりにメソッド <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> が使用されます。これにより、配列の要求された部分のコピーが生成されます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-418">When using a range-indexer on an array and implicitly assigning the value to a <xref:System.ReadOnlySpan%601> or <xref:System.ReadOnlyMemory%601> type, the method <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> will be used instead of <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_>, which produces a copy of requested portion of the array.</span></span> |
> |[<span data-ttu-id="dbe94-419">CA1833: 配列の Span または Memory 部分を取得するために、範囲ベースのインデクサーの代わりに AsSpan または AsMemory を使用します</span><span class="sxs-lookup"><span data-stu-id="dbe94-419">CA1833: Use AsSpan or AsMemory instead of Range-based indexers for getting Span or Memory portion of an array</span></span>](ca1833.md) | <span data-ttu-id="dbe94-420">配列に対して範囲インデクサーを使用し、その値を <xref:System.Span%601> または <xref:System.Memory%601> 型に暗黙的に割り当てると、<xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> の代わりにメソッド <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> が使用されます。これにより、配列の要求された部分のコピーが生成されます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-420">When using a range-indexer on an array and implicitly assigning the value to a <xref:System.Span%601> or <xref:System.Memory%601> type, the method <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> will be used instead of <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_>, which produces a copy of requested portion of the array.</span></span> |
> |[<span data-ttu-id="dbe94-421">CA1834:1 文字の文字列に対して StringBuilder.Append(char) を使用する</span><span class="sxs-lookup"><span data-stu-id="dbe94-421">CA1834: Use StringBuilder.Append(char) for single character strings</span></span>](ca1834.md) | <span data-ttu-id="dbe94-422"><xref:System.Text.StringBuilder> には、引数として `char` を取る `Append` オーバーロードがあります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-422"><xref:System.Text.StringBuilder> has an `Append` overload that takes a `char` as its argument.</span></span> <span data-ttu-id="dbe94-423">パフォーマンス上の理由から、`char` オーバーロードを呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="dbe94-423">Prefer calling the `char` overload for performance reasons.</span></span> |
> |[<span data-ttu-id="dbe94-424">CA1835: 'ReadAsync' および 'WriteAsync' で 'Memory' ベースのオーバーロードを優先的に使用します</span><span class="sxs-lookup"><span data-stu-id="dbe94-424">CA1835: Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'</span></span>](ca1835.md) | <span data-ttu-id="dbe94-425">'Stream' には、最初の引数として 'Memory&lt;Byte&gt;' を取る 'ReadAsync' オーバーロードと、最初の引数として 'ReadOnlyMemory&lt;Byte&gt;' を取る 'WriteAsync' オーバーロードがあります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-425">'Stream' has a 'ReadAsync' overload that takes a 'Memory&lt;Byte&gt;' as the first argument, and a 'WriteAsync' overload that takes a 'ReadOnlyMemory&lt;Byte&gt;' as the first argument.</span></span> <span data-ttu-id="dbe94-426">より効率的なメモリ ベースのオーバーロードを呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="dbe94-426">Prefer calling the memory based overloads, which are more efficient.</span></span> |
> |[<span data-ttu-id="dbe94-427">CA1836: 使用可能な場合は、`Count` よりも `IsEmpty` を優先します</span><span class="sxs-lookup"><span data-stu-id="dbe94-427">CA1836: Prefer `IsEmpty` over `Count` when available</span></span>](ca1836.md) | <span data-ttu-id="dbe94-428">オブジェクトに項目が含まれているかどうかを確認するときは、`Count`、`Length`、<xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>、<xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> よりも効率的な `IsEmpty` プロパティを使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="dbe94-428">Prefer `IsEmpty` property that is more efficient than `Count`, `Length`, <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> or <xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> to determine whether the object contains or not any items.</span></span> |
> | [<span data-ttu-id="dbe94-429">CA1837: `Process.GetCurrentProcess().Id` ではなく `Environment.ProcessId` を使用します</span><span class="sxs-lookup"><span data-stu-id="dbe94-429">CA1837: Use `Environment.ProcessId` instead of `Process.GetCurrentProcess().Id`</span></span>](ca1837.md) | <span data-ttu-id="dbe94-430">`Environment.ProcessId` は `Process.GetCurrentProcess().Id` よりも簡単かつ高速です。</span><span class="sxs-lookup"><span data-stu-id="dbe94-430">`Environment.ProcessId` is simpler and faster than `Process.GetCurrentProcess().Id`.</span></span> |
> | [<span data-ttu-id="dbe94-431">CA1838: P/Invokes に `StringBuilder` パラメーターを使用しません</span><span class="sxs-lookup"><span data-stu-id="dbe94-431">CA1838: Avoid `StringBuilder` parameters for P/Invokes</span></span>](ca1838.md) | <span data-ttu-id="dbe94-432">'StringBuilder' をマーシャリングすると、ネイティブ バッファーのコピーが常に作成され、1 回のマーシャリング操作に対して複数の割り当てが発生します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-432">Marshaling of 'StringBuilder' always creates a native buffer copy, resulting in multiple allocations for one marshaling operation.</span></span> |
> | [<span data-ttu-id="dbe94-433">CA2000:スコープを失う前にオブジェクトを破棄</span><span class="sxs-lookup"><span data-stu-id="dbe94-433">CA2000: Dispose objects before losing scope</span></span>](ca2000.md) | <span data-ttu-id="dbe94-434">例外的なイベントが発生するとオブジェクトのファイナライザーを実行できないため、オブジェクトに対するすべての参照がスコープ外になる前に、オブジェクトを明示的に破棄する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-434">Because an exceptional event might occur that will prevent the finalizer of an object from running, the object should be explicitly disposed before all references to it are out of scope.</span></span> |
> |[<span data-ttu-id="dbe94-435">CA2002:弱い ID を伴うオブジェクト上でロックしません</span><span class="sxs-lookup"><span data-stu-id="dbe94-435">CA2002: Do not lock on objects with weak identity</span></span>](ca2002.md) |<span data-ttu-id="dbe94-436">アプリケーション ドメインの境界を越えてオブジェクトに直接アクセスできる場合、そのオブジェクトの ID は不十分と表現されます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-436">An object is said to have a weak identity when it can be directly accessed across application domain boundaries.</span></span> <span data-ttu-id="dbe94-437">スレッドで ID が不十分なオブジェクトをロックしようとすると、ブロックされることがあります。たとえば、異なるアプリケーション ドメインの別スレッドで、既に同じオブジェクトがロックされている場合です。</span><span class="sxs-lookup"><span data-stu-id="dbe94-437">A thread that tries to acquire a lock on an object that has a weak identity can be blocked by a second thread in a different application domain that has a lock on the same object.</span></span> |
> | [<span data-ttu-id="dbe94-438">CA2007:タスクを直接待機しないでください</span><span class="sxs-lookup"><span data-stu-id="dbe94-438">CA2007: Do not directly await a Task</span></span>](ca2007.md) | <span data-ttu-id="dbe94-439">非同期メソッドでは <xref:System.Threading.Tasks.Task> を直接[待機](../../../csharp/language-reference/operators/await.md)します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-439">An asynchronous method [awaits](../../../csharp/language-reference/operators/await.md) a <xref:System.Threading.Tasks.Task> directly.</span></span> <span data-ttu-id="dbe94-440">非同期メソッドで <xref:System.Threading.Tasks.Task> を直接待機すると、タスクを作成したのと同じスレッドで継続が発生します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-440">When an asynchronous method awaits a <xref:System.Threading.Tasks.Task> directly, continuation occurs in the same thread that created the task.</span></span> <span data-ttu-id="dbe94-441">この動作はパフォーマンスの面で大きな負担が生じ、その結果 UI スレッドでデッドロックが発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-441">This behavior can be costly in terms of performance and can result in a deadlock on the UI thread.</span></span> <span data-ttu-id="dbe94-442"><xref:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)?displayProperty=nameWithType> を呼び出して継続の意図を示すことを検討してください。</span><span class="sxs-lookup"><span data-stu-id="dbe94-442">Consider calling <xref:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)?displayProperty=nameWithType> to signal your intention for continuation.</span></span> |
> | [<span data-ttu-id="dbe94-443">CA2008:TaskScheduler を渡さずにタスクを作成しない</span><span class="sxs-lookup"><span data-stu-id="dbe94-443">CA2008: Do not create tasks without passing a TaskScheduler</span></span>](ca2008.md) | <span data-ttu-id="dbe94-444">タスクの作成または継続の操作で、<xref:System.Threading.Tasks.TaskScheduler> パラメーターを指定しないメソッド オーバーロードを使用しています。</span><span class="sxs-lookup"><span data-stu-id="dbe94-444">A task creation or continuation operation uses a method overload that does not specify a <xref:System.Threading.Tasks.TaskScheduler> parameter.</span></span> |
> | [<span data-ttu-id="dbe94-445">CA2009: ImmutableCollection 値で ToImmutableCollection を呼び出さないでください</span><span class="sxs-lookup"><span data-stu-id="dbe94-445">CA2009: Do not call ToImmutableCollection on an ImmutableCollection value</span></span>](ca2009.md) | <span data-ttu-id="dbe94-446">`ToImmutable` メソッドが <xref:System.Collections.Immutable> 名前空間から変更できないコレクションで不必要に呼び出されました。</span><span class="sxs-lookup"><span data-stu-id="dbe94-446">`ToImmutable` method was unnecessarily called on an immutable collection from <xref:System.Collections.Immutable> namespace.</span></span> |
> | [<span data-ttu-id="dbe94-447">CA2011: セッター内でプロパティを割り当てません</span><span class="sxs-lookup"><span data-stu-id="dbe94-447">CA2011: Do not assign property within its setter</span></span>](ca2011.md) | <span data-ttu-id="dbe94-448">プロパティの [set アクセサー](../../../csharp/programming-guide/classes-and-structs/using-properties.md#the-set-accessor)内でプロパティに値が誤って割り当てられました。</span><span class="sxs-lookup"><span data-stu-id="dbe94-448">A property was accidentally assigned a value within its own [set accessor](../../../csharp/programming-guide/classes-and-structs/using-properties.md#the-set-accessor).</span></span> |
> | [<span data-ttu-id="dbe94-449">CA2012: ValueTask を正しく使用する必要があります</span><span class="sxs-lookup"><span data-stu-id="dbe94-449">CA2012: Use ValueTasks correctly</span></span>](ca2012.md) | <span data-ttu-id="dbe94-450">メンバーの呼び出しから返される ValueTask は、直接待機される必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-450">ValueTasks returned from member invocations are intended to be directly awaited.</span></span>  <span data-ttu-id="dbe94-451">ValueTask を複数回使用しようとするか、完了が判明する前に結果に直接アクセスしようとすると、例外または破損が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-451">Attempts to consume a ValueTask multiple times or to directly access one's result before it's known to be completed may result in an exception or corruption.</span></span>  <span data-ttu-id="dbe94-452">このような ValueTask を無視することは、機能的なバグを示していることが多く、パフォーマンスを低下させる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-452">Ignoring such a ValueTask is likely an indication of a functional bug and may degrade performance.</span></span> |
> | [<span data-ttu-id="dbe94-453">CA2013: 値の型と共に ReferenceEquals を使用しないでください</span><span class="sxs-lookup"><span data-stu-id="dbe94-453">CA2013: Do not use ReferenceEquals with value types</span></span>](ca2013.md) | <span data-ttu-id="dbe94-454"><xref:System.Object.ReferenceEquals%2A?displayProperty=fullName> を使用して値を比較するときに、objA と objB が値の型である場合、この 2 つは <xref:System.Object.ReferenceEquals%2A> メソッドに渡される前にボックス化されます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-454">When comparing values using <xref:System.Object.ReferenceEquals%2A?displayProperty=fullName>, if objA and objB are value types, they are boxed before they are passed to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="dbe94-455">つまり、objA と objB が同じ値の型のインスタンスを表している場合でも、<xref:System.Object.ReferenceEquals%2A> メソッドからは false が返されます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-455">This means that even if both objA and objB represent the same instance of a value type, the <xref:System.Object.ReferenceEquals%2A> method nevertheless returns false.</span></span> |
> | [<span data-ttu-id="dbe94-456">CA2014: ループ内で stackalloc を使用しません</span><span class="sxs-lookup"><span data-stu-id="dbe94-456">CA2014: Do not use stackalloc in loops.</span></span>](ca2014.md) | <span data-ttu-id="dbe94-457">stackalloc によって割り当てられたスタック領域は、現在のメソッド呼び出しの終了時にのみ解放されます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-457">Stack space allocated by a stackalloc is only released at the end of the current method's invocation.</span></span>  <span data-ttu-id="dbe94-458">これをループ内で使用すると、スタックが無限に増加し、最終的にスタック オーバーフロー状態が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-458">Using it in a loop can result in unbounded stack growth and eventual stack overflow conditions.</span></span> |
> | [<span data-ttu-id="dbe94-459">CA2015: MemoryManager から派生した型にはファイナライザーを定義しません&lt;T&gt;</span><span class="sxs-lookup"><span data-stu-id="dbe94-459">CA2015: Do not define finalizers for types derived from MemoryManager&lt;T&gt;</span></span>](ca2015.md) | <span data-ttu-id="dbe94-460"><xref:System.Buffers.MemoryManager%601> から派生した型にファイナライザーを追加すると、<xref:System.Span%601> によってまだ使用中のメモリが解放される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-460">Adding a finalizer to a type derived from <xref:System.Buffers.MemoryManager%601> may permit memory to be freed while it is still in use by a <xref:System.Span%601>.</span></span> |
> | [<span data-ttu-id="dbe94-461">CA2016:CancellationToken パラメーターを 1 つのメソッドに転送する</span><span class="sxs-lookup"><span data-stu-id="dbe94-461">CA2016: Forward the CancellationToken parameter to methods that take one</span></span>](ca2016.md) | <span data-ttu-id="dbe94-462">`CancellationToken` パラメーターを 1 つを取るメソッドに転送して操作のキャンセル通知が適切に伝達されるようにするか、または `CancellationToken.None` を明示的に渡して意図的にトークンを伝達しないことを指定します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-462">Forward the `CancellationToken` parameter to methods that take one to ensure the operation cancellation notifications gets properly propagated, or pass in `CancellationToken.None` explicitly to indicate intentionally not propagating the token.</span></span> |
> | [<span data-ttu-id="dbe94-463">CA2100:SQL クエリのセキュリティ脆弱性を確認</span><span class="sxs-lookup"><span data-stu-id="dbe94-463">CA2100: Review SQL queries for security vulnerabilities</span></span>](ca2100.md) | <span data-ttu-id="dbe94-464">メソッドに渡された文字列引数から構築された文字列を使用して System.Data.IDbCommand.CommandText プロパティが設定されています。</span><span class="sxs-lookup"><span data-stu-id="dbe94-464">A method sets the System.Data.IDbCommand.CommandText property by using a string that is built from a string argument to the method.</span></span> <span data-ttu-id="dbe94-465">この規則では、文字列引数にユーザー入力が含まれていることが想定されています。</span><span class="sxs-lookup"><span data-stu-id="dbe94-465">This rule assumes that the string argument contains user input.</span></span> <span data-ttu-id="dbe94-466">ユーザー入力から構築された SQL コマンド文字列には、SQL 注入攻撃に対する脆弱性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-466">A SQL command string that is built from user input is vulnerable to SQL injection attacks.</span></span> |
> |[<span data-ttu-id="dbe94-467">CA2101: P/Invoke 文字列引数に対してマーシャリングを指定します</span><span class="sxs-lookup"><span data-stu-id="dbe94-467">CA2101: Specify marshaling for P/Invoke string arguments</span></span>](ca2101.md) | <span data-ttu-id="dbe94-468">プラットフォーム呼び出しメンバーが、部分信頼の呼び出し元を許可し、文字列パラメーターを持ち、さらにその文字列を明示的にマーシャリングしていません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-468">A platform invoke member allows partially trusted callers, has a string parameter, and does not explicitly marshal the string.</span></span> <span data-ttu-id="dbe94-469">これはセキュリティ上の脆弱性となる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-469">This can cause a potential security vulnerability.</span></span> |
> | [<span data-ttu-id="dbe94-470">CA2109:表示するイベント ハンドラーを確認します</span><span class="sxs-lookup"><span data-stu-id="dbe94-470">CA2109: Review visible event handlers</span></span>](ca2109.md) | <span data-ttu-id="dbe94-471">パブリックまたはプロテクトのイベント ハンドラー メソッドが検出されました。</span><span class="sxs-lookup"><span data-stu-id="dbe94-471">A public or protected event-handling method was detected.</span></span> <span data-ttu-id="dbe94-472">イベント ハンドラー メソッドは、絶対に必要な場合を除き公開しないでください。</span><span class="sxs-lookup"><span data-stu-id="dbe94-472">Event-handling methods should not be exposed unless absolutely necessary.</span></span> |
> | [<span data-ttu-id="dbe94-473">CA2119:プライベート インターフェイスを満たすメソッドをシールします</span><span class="sxs-lookup"><span data-stu-id="dbe94-473">CA2119: Seal methods that satisfy private interfaces</span></span>](ca2119.md) | <span data-ttu-id="dbe94-474">継承可能なパブリック型により、internal (Visual Basic では Friend) インターフェイスのオーバーライド可能なメソッド実装が提供されます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-474">An inheritable public type provides an overridable method implementation of an internal (Friend in Visual Basic) interface.</span></span> <span data-ttu-id="dbe94-475">この規則違反を修正するには、アセンブリの外側でメソッドがオーバーライドされないようにします。</span><span class="sxs-lookup"><span data-stu-id="dbe94-475">To fix a violation of this rule, prevent the method from being overridden outside the assembly.</span></span> |
> |[<span data-ttu-id="dbe94-476">CA2153: 破損状態例外の処理を回避します</span><span class="sxs-lookup"><span data-stu-id="dbe94-476">CA2153: Avoid handling Corrupted State Exceptions</span></span>](ca2153.md) | <span data-ttu-id="dbe94-477">破損状態例外 (CSE) は、メモリの破損がプロセス内に存在していることを示します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-477">Corrupted State Exceptions (CSEs) indicate that memory corruption exists in your process.</span></span> <span data-ttu-id="dbe94-478">プロセスをクラッシュさせるのではなくこれらの例外をキャッチすることは、攻撃者が破損したメモリ領域にセキュリティ上の弱点を見出すことができた場合に、セキュリティ上の脆弱性となる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-478">Catching these rather than allowing the process to crash can lead to security vulnerabilities if an attacker can place an exploit into the corrupted memory region.</span></span> |
> | [<span data-ttu-id="dbe94-479">CA2200:スタック詳細を保持するために再度スローします</span><span class="sxs-lookup"><span data-stu-id="dbe94-479">CA2200: Rethrow to preserve stack details</span></span>](ca2200.md) | <span data-ttu-id="dbe94-480">例外が再スローされ、その例外が throw ステートメントで明示的に指定されています。</span><span class="sxs-lookup"><span data-stu-id="dbe94-480">An exception is rethrown and the exception is explicitly specified in the throw statement.</span></span> <span data-ttu-id="dbe94-481">throw ステートメントで例外を指定して例外が再スローされると、例外をスローした元のメソッドと現在のメソッドの間で呼び出されたメソッドの一覧は失われます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-481">If an exception is rethrown by specifying the exception in the throw statement, the list of method calls between the original method that threw the exception and the current method is lost.</span></span> |
> | [<span data-ttu-id="dbe94-482">CA2201:予約された例外の種類を発生させません</span><span class="sxs-lookup"><span data-stu-id="dbe94-482">CA2201: Do not raise reserved exception types</span></span>](ca2201.md) | <span data-ttu-id="dbe94-483">これにより、元のエラーの検出およびデバッグが困難になります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-483">This makes the original error difficult to detect and debug.</span></span> |
> | [<span data-ttu-id="dbe94-484">CA2207:値型のスタティック フィールドのインラインを初期化します</span><span class="sxs-lookup"><span data-stu-id="dbe94-484">CA2207: Initialize value type static fields inline</span></span>](ca2207.md) | <span data-ttu-id="dbe94-485">値型で明示的な静的コンストラクターを宣言しています。</span><span class="sxs-lookup"><span data-stu-id="dbe94-485">A value type declares an explicit static constructor.</span></span> <span data-ttu-id="dbe94-486">この規則違反を修正するには、静的データが宣言されたとき、および静的コンストラクターを削除するときに、静的データをすべて初期化します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-486">To fix a violation of this rule, initialize all static data when it is declared and remove the static constructor.</span></span> |
> |[<span data-ttu-id="dbe94-487">CA2208:引数の例外を正しくインスタンス化します</span><span class="sxs-lookup"><span data-stu-id="dbe94-487">CA2208: Instantiate argument exceptions correctly</span></span>](ca2208.md) | <span data-ttu-id="dbe94-488">ArgumentException またはそのクラスから派生した例外の種類の既定 (パラメーターなし) のコンストラクターに対して呼び出しが行われたか、ArgumentException またはそのクラスから派生した例外の種類のパラメーター付きのコンストラクターに不適切な文字列型の引数が渡されました。</span><span class="sxs-lookup"><span data-stu-id="dbe94-488">A call is made to the default (parameterless) constructor of an exception type that is or derives from ArgumentException, or an incorrect string argument is passed to a parameterized constructor of an exception type that is or derives from ArgumentException.</span></span> |
> |[<span data-ttu-id="dbe94-489">CA2211:非定数フィールドは表示されません</span><span class="sxs-lookup"><span data-stu-id="dbe94-489">CA2211: Non-constant fields should not be visible</span></span>](ca2211.md) | <span data-ttu-id="dbe94-490">定数でも読み取り専用でもない静的フィールドは、スレッド セーフではありません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-490">Static fields that are neither constants nor read-only are not thread-safe.</span></span> <span data-ttu-id="dbe94-491">このようなフィールドへのアクセスは、慎重に制御してください。また、クラス オブジェクトへのアクセスを同期するには、高度なプログラミング技術が必要です。</span><span class="sxs-lookup"><span data-stu-id="dbe94-491">Access to such a field must be carefully controlled and requires advanced programming techniques to synchronize access to the class object.</span></span> |
> | [<span data-ttu-id="dbe94-492">CA2213:破棄可能なフィールドは破棄されなければなりません</span><span class="sxs-lookup"><span data-stu-id="dbe94-492">CA2213: Disposable fields should be disposed</span></span>](ca2213.md) | <span data-ttu-id="dbe94-493">System.IDisposable を実装する型が、IDisposable も実装する型を持つフィールドを宣言しています。</span><span class="sxs-lookup"><span data-stu-id="dbe94-493">A type that implements System.IDisposable declares fields that are of types that also implement IDisposable.</span></span> <span data-ttu-id="dbe94-494">このフィールドの Dispose メソッドは、宣言している型の Dispose メソッドから呼び出されていません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-494">The Dispose method of the field is not called by the Dispose method of the declaring type.</span></span> |
> | [<span data-ttu-id="dbe94-495">CA2214:コンストラクターのオーバーライド可能なメソッドを呼び出しません</span><span class="sxs-lookup"><span data-stu-id="dbe94-495">CA2214: Do not call overridable methods in constructors</span></span>](ca2214.md) | <span data-ttu-id="dbe94-496">コンストラクターから仮想メソッドを呼び出すと、メソッドを呼び出すインスタンスのコンストラクターが実行されないことがあります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-496">When a constructor calls a virtual method, the constructor for the instance that invokes the method may not have executed.</span></span> |
> | [<span data-ttu-id="dbe94-497">CA2215:Dispose メソッドが基底クラスの Dispose を呼び出す必要があります</span><span class="sxs-lookup"><span data-stu-id="dbe94-497">CA2215: Dispose methods should call base class dispose</span></span>](ca2215.md) | <span data-ttu-id="dbe94-498">型が、破棄できる型から継承している場合、使用している Dispose メソッド内から基本型の Dispose メソッドを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-498">If a type inherits from a disposable type, it must call the Dispose method of the base type from its own Dispose method.</span></span> |
> |[<span data-ttu-id="dbe94-499">CA2216:破棄可能な型はファイナライザーを宣言しなければなりません</span><span class="sxs-lookup"><span data-stu-id="dbe94-499">CA2216: Disposable types should declare finalizer</span></span>](ca2216.md) | <span data-ttu-id="dbe94-500">System.IDisposable を実装し、アンマネージ リソースの使用を提案するフィールドが含まれる型が、Object.Finalize で記述されているようにファイナライザーを実装していません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-500">A type that implements System.IDisposable and has fields that suggest the use of unmanaged resources does not implement a finalizer, as described by Object.Finalize.</span></span> |
> | [<span data-ttu-id="dbe94-501">CA2218:オーバーライドする Equals で GetHashCode をオーバーライドします</span><span class="sxs-lookup"><span data-stu-id="dbe94-501">CA2218: Override GetHashCode on overriding Equals</span></span>](ca2218.md) | <span data-ttu-id="dbe94-502">パブリック型で <xref:System.Object.Equals%2A?displayProperty=fullName> をオーバーライドしていますが、<xref:System.Object.GetHashCode%2A?displayProperty=fullName> をオーバーライドしていません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-502">A public type overrides <xref:System.Object.Equals%2A?displayProperty=fullName> but does not override <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</span></span> |
> | [<span data-ttu-id="dbe94-503">CA2217:列挙型を FlagsAttribute に設定しません</span><span class="sxs-lookup"><span data-stu-id="dbe94-503">CA2217: Do not mark enums with FlagsAttribute</span></span>](ca2217.md) | <span data-ttu-id="dbe94-504">外部から参照できる列挙型が FlagsAttribute でマークされ、その列挙型に、2 の累乗でもなく、その列挙型で定義されている他の値の組み合わせでもない値が 1 つ以上含まれています。</span><span class="sxs-lookup"><span data-stu-id="dbe94-504">An externally visible enumeration is marked by using FlagsAttribute, and it has one or more values that are not powers of two or a combination of the other defined values on the enumeration.</span></span> |
> | [<span data-ttu-id="dbe94-505">CA2219:exception 句に例外を発生させないでください</span><span class="sxs-lookup"><span data-stu-id="dbe94-505">CA2219: Do not raise exceptions in exception clauses</span></span>](ca2219.md) | <span data-ttu-id="dbe94-506">finally 句または fault 句で例外が発生すると、アクティブな例外が新しい例外によって隠されます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-506">When an exception is raised in a finally or fault clause, the new exception hides the active exception.</span></span> <span data-ttu-id="dbe94-507">filter 句で例外が発生すると、ランタイムがその例外を暗黙的にキャッチします。</span><span class="sxs-lookup"><span data-stu-id="dbe94-507">When an exception is raised in a filter clause, the run time silently catches the exception.</span></span> <span data-ttu-id="dbe94-508">これにより、元のエラーの検出およびデバッグが困難になります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-508">This makes the original error difficult to detect and debug.</span></span> |
> | [<span data-ttu-id="dbe94-509">CA2224:オーバーロードする演算子 equals で Equals をオーバーライドします</span><span class="sxs-lookup"><span data-stu-id="dbe94-509">CA2224: Override equals on overloading operator equals</span></span>](ca2224.md) | <span data-ttu-id="dbe94-510">パブリック型で等値演算子が実装されていますが、<xref:System.Object.Equals%2A?displayProperty=fullName> がオーバーライドされていません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-510">A public type implements the equality operator but doesn't override <xref:System.Object.Equals%2A?displayProperty=fullName>.</span></span> |
> | [<span data-ttu-id="dbe94-511">CA2225:演算子オーバーロードには名前付けされた代替が存在します</span><span class="sxs-lookup"><span data-stu-id="dbe94-511">CA2225: Operator overloads have named alternates</span></span>](ca2225.md) |<span data-ttu-id="dbe94-512">演算子のオーバーロードが検出され、予想される名前の代替メソッドが検出されませんでした。</span><span class="sxs-lookup"><span data-stu-id="dbe94-512">An operator overload was detected, and the expected named alternative method was not found.</span></span> <span data-ttu-id="dbe94-513">名前付きの代替メンバーによって、演算子と同じ機能へアクセスできるようになります。また、演算子のオーバーロードをサポートしていない言語でプログラミングする場合でも、その代替メンバーを使用できます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-513">The named alternative member provides access to the same functionality as the operator and is provided for developers who program in languages that do not support overloaded operators.</span></span> |
> | [<span data-ttu-id="dbe94-514">CA2226:演算子は対称型オーバーロードを含まなければなりません</span><span class="sxs-lookup"><span data-stu-id="dbe94-514">CA2226: Operators should have symmetrical overloads</span></span>](ca2226.md) | <span data-ttu-id="dbe94-515">型で等値演算子または非等値演算子を実装し、逆の働きをする演算子を実装していません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-515">A type implements the equality or inequality operator and does not implement the opposite operator.</span></span> |
> |[<span data-ttu-id="dbe94-516">CA2227:Collection プロパティは読み取り専用でなければなりません</span><span class="sxs-lookup"><span data-stu-id="dbe94-516">CA2227: Collection properties should be read only</span></span>](ca2227.md) | <span data-ttu-id="dbe94-517">書き込み可能なコレクション プロパティにより、ユーザーはコレクションを異なるコレクションで置換できます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-517">A writable collection property allows a user to replace the collection with a different collection.</span></span> <span data-ttu-id="dbe94-518">読み取り専用プロパティは、コレクションを置換できないようにしますが、個別のメンバーが設定されることは回避できません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-518">A read-only property stops the collection from being replaced but still allows the individual members to be set.</span></span> |
> | [<span data-ttu-id="dbe94-519">CA2229:シリアル化コンストラクターを実装します</span><span class="sxs-lookup"><span data-stu-id="dbe94-519">CA2229: Implement serialization constructors</span></span>](ca2229.md) | <span data-ttu-id="dbe94-520">この規則違反を修正するには、シリアル化コンストラクターを実装します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-520">To fix a violation of this rule, implement the serialization constructor.</span></span> <span data-ttu-id="dbe94-521">シールされたクラスの場合、コンストラクターをプライベートにするか、プロテクトにします。</span><span class="sxs-lookup"><span data-stu-id="dbe94-521">For a sealed class, make the constructor private; otherwise, make it protected.</span></span> |
> | [<span data-ttu-id="dbe94-522">CA2231:ValueType.Equals のオーバーライドで、演算子 equals をオーバーロードします</span><span class="sxs-lookup"><span data-stu-id="dbe94-522">CA2231: Overload operator equals on overriding ValueType.Equals</span></span>](ca2231.md) | <span data-ttu-id="dbe94-523">値型は、Object.Equals をオーバーライドしていますが、等値演算子を実装していません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-523">A value type overrides Object.Equals but does not implement the equality operator.</span></span> |
> | [<span data-ttu-id="dbe94-524">CA2234:文字列の代わりに System.Uri オブジェクトを渡します</span><span class="sxs-lookup"><span data-stu-id="dbe94-524">CA2234: Pass System.Uri objects instead of strings</span></span>](ca2234.md) | <span data-ttu-id="dbe94-525">"uri"、"URI"、"urn"、"URN"、"url"、または "URL" という名前を持つ文字列パラメーターが指定されているメソッドに対して、呼び出しが行われました。</span><span class="sxs-lookup"><span data-stu-id="dbe94-525">A call is made to a method that has a string parameter whose name contains "uri", "URI", "urn", "URN", "url", or "URL".</span></span> <span data-ttu-id="dbe94-526">そのメソッドの型宣言に対応するメソッドのオーバーロードが存在し、それに対して System.Uri パラメーターが指定されています。</span><span class="sxs-lookup"><span data-stu-id="dbe94-526">The declaring type of the method contains a corresponding method overload that has a System.Uri parameter.</span></span> |
> | [<span data-ttu-id="dbe94-527">CA2235:すべてのシリアル化不可能なフィールドを設定します</span><span class="sxs-lookup"><span data-stu-id="dbe94-527">CA2235: Mark all non-serializable fields</span></span>](ca2235.md) | <span data-ttu-id="dbe94-528">シリアル化できない型のインスタンス フィールドが、シリアル化できる型で宣言されています。</span><span class="sxs-lookup"><span data-stu-id="dbe94-528">An instance field of a type that is not serializable is declared in a type that is serializable.</span></span> |
> | [<span data-ttu-id="dbe94-529">CA2237:ISerializable 型を SerializableAttribute に設定します</span><span class="sxs-lookup"><span data-stu-id="dbe94-529">CA2237: Mark ISerializable types with SerializableAttribute</span></span>](ca2237.md) | <span data-ttu-id="dbe94-530">型が共通言語ランタイムでシリアル化できると認識されるようにするには、型を SerializableAttribute 属性でマークする必要があります。型が ISerializable インターフェイスの実装を通じてカスタムのシリアル化ルーチンを使用している場合でも、マークする必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-530">To be recognized by the common language runtime as serializable, types must be marked by using the SerializableAttribute attribute even when the type uses a custom serialization routine through implementation of the ISerializable interface.</span></span> |
> | [<span data-ttu-id="dbe94-531">CA2241:書式設定メソッドに正しい引数を提供</span><span class="sxs-lookup"><span data-stu-id="dbe94-531">CA2241: Provide correct arguments to formatting methods</span></span>](ca2241.md) | <span data-ttu-id="dbe94-532">System.String.Format に渡される引数 format に、各オブジェクトの引数に対応する書式指定項目が含まれていません (その逆も考えられます)。</span><span class="sxs-lookup"><span data-stu-id="dbe94-532">The format argument that is passed to System.String.Format does not contain a format item that corresponds to each object argument, or vice versa.</span></span> |
> |[<span data-ttu-id="dbe94-533">CA2242:NaN に対して正しくテストします</span><span class="sxs-lookup"><span data-stu-id="dbe94-533">CA2242: Test for NaN correctly</span></span>](ca2242.md) | <span data-ttu-id="dbe94-534">この式が Single.Nan または Double.Nan に対して値をテストしています。</span><span class="sxs-lookup"><span data-stu-id="dbe94-534">This expression tests a value against Single.Nan or Double.Nan.</span></span> <span data-ttu-id="dbe94-535">値をテストするには、Single.IsNan(Single) または Double.IsNan(Double) を使用します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-535">Use Single.IsNan(Single) or Double.IsNan(Double) to test the value.</span></span> |
> |[<span data-ttu-id="dbe94-536">CA2243:属性文字列リテラルは、正しく解析する必要があります</span><span class="sxs-lookup"><span data-stu-id="dbe94-536">CA2243: Attribute string literals should parse correctly</span></span>](ca2243.md) | <span data-ttu-id="dbe94-537">属性のリテラル文字列パラメーターが URL、GUID、またはバージョンとして正しく解析されません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-537">The string literal parameter of an attribute does not parse correctly for a URL, a GUID, or a version.</span></span> |
> | [<span data-ttu-id="dbe94-538">CA2244: インデックス付き要素の初期化を重複させません</span><span class="sxs-lookup"><span data-stu-id="dbe94-538">CA2244: Do not duplicate indexed element initializations</span></span>](ca2244.md) | <span data-ttu-id="dbe94-539">オブジェクト初期化子に、定数インデックスが同じインデックス付き要素の初期化子が複数あります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-539">An object initializer has more than one indexed element initializer with the same constant index.</span></span> <span data-ttu-id="dbe94-540">最後の初期化子を除くすべての初期化子は冗長です。</span><span class="sxs-lookup"><span data-stu-id="dbe94-540">All but the last initializer are redundant.</span></span> |
> | [<span data-ttu-id="dbe94-541">CA2245: プロパティをそれ自体に割り当てません</span><span class="sxs-lookup"><span data-stu-id="dbe94-541">CA2245: Do not assign a property to itself</span></span>](ca2245.md) | <span data-ttu-id="dbe94-542">プロパティが誤ってそれ自体に割り当てられました。</span><span class="sxs-lookup"><span data-stu-id="dbe94-542">A property was accidentally assigned to itself.</span></span> |
> | [<span data-ttu-id="dbe94-543">CA2246: 同じステートメントにシンボルとそのメンバーを割り当てません</span><span class="sxs-lookup"><span data-stu-id="dbe94-543">CA2246: Do not assign a symbol and its member in the same statement</span></span>](ca2246.md) | <span data-ttu-id="dbe94-544">同じステートメントでシンボルとそのメンバー、つまりフィールドまたはプロパティを代入することは推奨されていません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-544">Assigning a symbol and its member, that is, a field or a property, in the same statement is not recommended.</span></span> <span data-ttu-id="dbe94-545">メンバー アクセスが代入前のシンボルの古い値を使用するのか、このステートメントの代入からの新しい値を使用するのかが明確ではありません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-545">It is not clear if the member access was intended to use the symbol's old value prior to the assignment or the new value from the assignment in this statement.</span></span> |
> | [<span data-ttu-id="dbe94-546">CA2247: TaskCompletionSource コンストラクターに渡された引数は、TaskContinuationOptions 列挙型ではなく、TaskCreationOptions 列挙型にする必要があります</span><span class="sxs-lookup"><span data-stu-id="dbe94-546">CA2247: Argument passed to TaskCompletionSource constructor should be TaskCreationOptions enum instead of TaskContinuationOptions enum.</span></span>](ca2247.md) | <span data-ttu-id="dbe94-547">TaskCompletionSource には、基になるタスクを制御する TaskCreationOptions を使用するコンストラクターと、そのタスクに格納されているオブジェクトの状態を使用するコンストラクターがあります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-547">TaskCompletionSource has constructors that take TaskCreationOptions that control the underlying Task, and constructors that take object state that's stored in the task.</span></span>  <span data-ttu-id="dbe94-548">TaskCreationOptions の代わりに TaskContinuationOptions を誤って渡すと、呼び出しでオプションが状態として処理されます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-548">Accidentally passing a TaskContinuationOptions instead of a TaskCreationOptions will result in the call treating the options as state.</span></span> |
> | [<span data-ttu-id="dbe94-549">CA2248: 正しい enum 引数を Enum.HasFlag に指定します</span><span class="sxs-lookup"><span data-stu-id="dbe94-549">CA2248: Provide correct enum argument to Enum.HasFlag</span></span>](ca2248.md) | <span data-ttu-id="dbe94-550">`HasFlag` メソッドに引数として渡された列挙型が呼び出し元の列挙型と異なります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-550">The enum type passed as an argument to the `HasFlag` method call is different from the calling enum type.</span></span> |
> | [<span data-ttu-id="dbe94-551">CA2249:String.IndexOf の代わりに String.Contains を使用することを検討します</span><span class="sxs-lookup"><span data-stu-id="dbe94-551">CA2249: Consider using String.Contains instead of String.IndexOf</span></span>](ca2249.md) | <span data-ttu-id="dbe94-552">部分文字列が存在するかどうかを確認するために結果を使用する `string.IndexOf` の呼び出しは、`string.Contains` で置き換えることができます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-552">Calls to `string.IndexOf` where the result is used to check for the presence/absence of a substring can be replaced by `string.Contains`.</span></span> |
> | [<span data-ttu-id="dbe94-553">CA2300:安全ではないデシリアライザー BinaryFormatter を使用しないでください</span><span class="sxs-lookup"><span data-stu-id="dbe94-553">CA2300: Do not use insecure deserializer BinaryFormatter</span></span>](ca2300.md) | <span data-ttu-id="dbe94-554">安全でない逆シリアライザーは、信頼されていないデータを逆シリアル化するときに脆弱です。</span><span class="sxs-lookup"><span data-stu-id="dbe94-554">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="dbe94-555">攻撃者がシリアル化されたデータを変更して予期されない型を追加し、悪意のある副作用を持つオブジェクトを挿入する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-555">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span> |
> | [<span data-ttu-id="dbe94-556">CA2301:最初に BinaryFormatter.Binder を設定しないで BinaryFormatter.Deserialize を呼び出さないでください</span><span class="sxs-lookup"><span data-stu-id="dbe94-556">CA2301: Do not call BinaryFormatter.Deserialize without first setting BinaryFormatter.Binder</span></span>](ca2301.md) | <span data-ttu-id="dbe94-557">安全でない逆シリアライザーは、信頼されていないデータを逆シリアル化するときに脆弱です。</span><span class="sxs-lookup"><span data-stu-id="dbe94-557">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="dbe94-558">攻撃者がシリアル化されたデータを変更して予期されない型を追加し、悪意のある副作用を持つオブジェクトを挿入する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-558">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span> |
> | [<span data-ttu-id="dbe94-559">CA2302:BinaryFormatter.Deserialize を呼び出す前に BinaryFormatter.Binder が設定されていることを確認します</span><span class="sxs-lookup"><span data-stu-id="dbe94-559">CA2302: Ensure BinaryFormatter.Binder is set before calling BinaryFormatter.Deserialize</span></span>](ca2302.md) | <span data-ttu-id="dbe94-560">安全でない逆シリアライザーは、信頼されていないデータを逆シリアル化するときに脆弱です。</span><span class="sxs-lookup"><span data-stu-id="dbe94-560">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="dbe94-561">攻撃者がシリアル化されたデータを変更して予期されない型を追加し、悪意のある副作用を持つオブジェクトを挿入する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-561">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span> |
> | [<span data-ttu-id="dbe94-562">CA2305:安全ではないデシリアライザー LosFormatter を使用しないでください</span><span class="sxs-lookup"><span data-stu-id="dbe94-562">CA2305: Do not use insecure deserializer LosFormatter</span></span>](ca2305.md) | <span data-ttu-id="dbe94-563">安全でない逆シリアライザーは、信頼されていないデータを逆シリアル化するときに脆弱です。</span><span class="sxs-lookup"><span data-stu-id="dbe94-563">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="dbe94-564">攻撃者がシリアル化されたデータを変更して予期されない型を追加し、悪意のある副作用を持つオブジェクトを挿入する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-564">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span> |
> | [<span data-ttu-id="dbe94-565">CA2310:安全ではないデシリアライザー NetDataContractSerializer を使用しないでください</span><span class="sxs-lookup"><span data-stu-id="dbe94-565">CA2310: Do not use insecure deserializer NetDataContractSerializer</span></span>](ca2310.md) | <span data-ttu-id="dbe94-566">安全でない逆シリアライザーは、信頼されていないデータを逆シリアル化するときに脆弱です。</span><span class="sxs-lookup"><span data-stu-id="dbe94-566">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="dbe94-567">攻撃者がシリアル化されたデータを変更して予期されない型を追加し、悪意のある副作用を持つオブジェクトを挿入する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-567">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span> |
> | [<span data-ttu-id="dbe94-568">CA2311:最初に NetDataContractSerializer.Binder を設定しないで逆シリアル化しないでください</span><span class="sxs-lookup"><span data-stu-id="dbe94-568">CA2311: Do not deserialize without first setting NetDataContractSerializer.Binder</span></span>](ca2311.md) | <span data-ttu-id="dbe94-569">安全でない逆シリアライザーは、信頼されていないデータを逆シリアル化するときに脆弱です。</span><span class="sxs-lookup"><span data-stu-id="dbe94-569">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="dbe94-570">攻撃者がシリアル化されたデータを変更して予期されない型を追加し、悪意のある副作用を持つオブジェクトを挿入する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-570">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span> |
> | [<span data-ttu-id="dbe94-571">CA2312:NetDataContractSerializer.Binder を設定してから逆シリアル化してください</span><span class="sxs-lookup"><span data-stu-id="dbe94-571">CA2312: Ensure NetDataContractSerializer.Binder is set before deserializing</span></span>](ca2312.md) | <span data-ttu-id="dbe94-572">安全でない逆シリアライザーは、信頼されていないデータを逆シリアル化するときに脆弱です。</span><span class="sxs-lookup"><span data-stu-id="dbe94-572">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="dbe94-573">攻撃者がシリアル化されたデータを変更して予期されない型を追加し、悪意のある副作用を持つオブジェクトを挿入する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-573">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span> |
> | [<span data-ttu-id="dbe94-574">CA2315:安全ではないデシリアライザー ObjectStateFormatter を使用しないでください</span><span class="sxs-lookup"><span data-stu-id="dbe94-574">CA2315: Do not use insecure deserializer ObjectStateFormatter</span></span>](ca2315.md) | <span data-ttu-id="dbe94-575">安全でない逆シリアライザーは、信頼されていないデータを逆シリアル化するときに脆弱です。</span><span class="sxs-lookup"><span data-stu-id="dbe94-575">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="dbe94-576">攻撃者がシリアル化されたデータを変更して予期されない型を追加し、悪意のある副作用を持つオブジェクトを挿入する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-576">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span> |
> | [<span data-ttu-id="dbe94-577">CA2321:SimpleTypeResolver を使って JavaScriptSerializer で逆シリアル化しないでください</span><span class="sxs-lookup"><span data-stu-id="dbe94-577">CA2321: Do not deserialize with JavaScriptSerializer using a SimpleTypeResolver</span></span>](ca2321.md) | <span data-ttu-id="dbe94-578">安全でない逆シリアライザーは、信頼されていないデータを逆シリアル化するときに脆弱です。</span><span class="sxs-lookup"><span data-stu-id="dbe94-578">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="dbe94-579">攻撃者がシリアル化されたデータを変更して予期されない型を追加し、悪意のある副作用を持つオブジェクトを挿入する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-579">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span> |
> | [<span data-ttu-id="dbe94-580">CA2322:逆シリアル化する前に JavaScriptSerializer が SimpleTypeResolver によって初期化されていないことを確認してください</span><span class="sxs-lookup"><span data-stu-id="dbe94-580">CA2322: Ensure JavaScriptSerializer is not initialized with SimpleTypeResolver before deserializing</span></span>](ca2322.md) | <span data-ttu-id="dbe94-581">安全でない逆シリアライザーは、信頼されていないデータを逆シリアル化するときに脆弱です。</span><span class="sxs-lookup"><span data-stu-id="dbe94-581">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="dbe94-582">攻撃者がシリアル化されたデータを変更して予期されない型を追加し、悪意のある副作用を持つオブジェクトを挿入する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-582">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span> |
> | [<span data-ttu-id="dbe94-583">CA2326: None 以外の TypeNameHandling 値は使用しないでください</span><span class="sxs-lookup"><span data-stu-id="dbe94-583">CA2326: Do not use TypeNameHandling values other than None</span></span>](ca2326.md) | <span data-ttu-id="dbe94-584">安全でない逆シリアライザーは、信頼されていないデータを逆シリアル化するときに脆弱です。</span><span class="sxs-lookup"><span data-stu-id="dbe94-584">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="dbe94-585">攻撃者がシリアル化されたデータを変更して予期されない型を追加し、悪意のある副作用を持つオブジェクトを挿入する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-585">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span> |
> | [<span data-ttu-id="dbe94-586">CA2327: 安全でない JsonSerializerSettings を使用しないでください</span><span class="sxs-lookup"><span data-stu-id="dbe94-586">CA2327: Do not use insecure JsonSerializerSettings</span></span>](ca2327.md) | <span data-ttu-id="dbe94-587">安全でない逆シリアライザーは、信頼されていないデータを逆シリアル化するときに脆弱です。</span><span class="sxs-lookup"><span data-stu-id="dbe94-587">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="dbe94-588">攻撃者がシリアル化されたデータを変更して予期されない型を追加し、悪意のある副作用を持つオブジェクトを挿入する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-588">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span> |
> | [<span data-ttu-id="dbe94-589">CA2328: JsonSerializerSettings が安全であることを確認してください</span><span class="sxs-lookup"><span data-stu-id="dbe94-589">CA2328: Ensure that JsonSerializerSettings are secure</span></span>](ca2328.md) | <span data-ttu-id="dbe94-590">安全でない逆シリアライザーは、信頼されていないデータを逆シリアル化するときに脆弱です。</span><span class="sxs-lookup"><span data-stu-id="dbe94-590">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="dbe94-591">攻撃者がシリアル化されたデータを変更して予期されない型を追加し、悪意のある副作用を持つオブジェクトを挿入する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-591">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span> |
> | [<span data-ttu-id="dbe94-592">CA2329: セキュリティで保護されていない構成が JsonSerializer で使用されている場合は、逆シリアル化を行わないでください</span><span class="sxs-lookup"><span data-stu-id="dbe94-592">CA2329: Do not deserialize with JsonSerializer using an insecure configuration</span></span>](ca2329.md) | <span data-ttu-id="dbe94-593">安全でない逆シリアライザーは、信頼されていないデータを逆シリアル化するときに脆弱です。</span><span class="sxs-lookup"><span data-stu-id="dbe94-593">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="dbe94-594">攻撃者がシリアル化されたデータを変更して予期されない型を追加し、悪意のある副作用を持つオブジェクトを挿入する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-594">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span> |
> | [<span data-ttu-id="dbe94-595">CA2330: 逆シリアル化の際に、JsonSerializer の構成は確実にセキュリティで保護してください</span><span class="sxs-lookup"><span data-stu-id="dbe94-595">CA2330: Ensure that JsonSerializer has a secure configuration when deserializing</span></span>](ca2330.md) | <span data-ttu-id="dbe94-596">安全でない逆シリアライザーは、信頼されていないデータを逆シリアル化するときに脆弱です。</span><span class="sxs-lookup"><span data-stu-id="dbe94-596">Insecure deserializers are vulnerable when deserializing untrusted data.</span></span> <span data-ttu-id="dbe94-597">攻撃者がシリアル化されたデータを変更して予期されない型を追加し、悪意のある副作用を持つオブジェクトを挿入する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-597">An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.</span></span> |
> | [<span data-ttu-id="dbe94-598">CA2350:DataTable.ReadXml() の入力が信頼されていることを確認してください</span><span class="sxs-lookup"><span data-stu-id="dbe94-598">CA2350: Ensure DataTable.ReadXml()'s input is trusted</span></span>](ca2350.md) | <span data-ttu-id="dbe94-599">信頼されていない入力を使用して <xref:System.Data.DataTable> を逆シリアル化すると、攻撃者が悪意のある入力を作成してサービス拒否攻撃を仕掛ける可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-599">When deserializing a <xref:System.Data.DataTable> with untrusted input, an attacker can craft malicious input to perform a denial of service attack.</span></span> <span data-ttu-id="dbe94-600">リモート コード実行の不明な脆弱性が存在する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-600">There may be unknown remote code execution vulnerabilities.</span></span> |
> | [<span data-ttu-id="dbe94-601">CA2351:DataSet.ReadXml() の入力が信頼されていることを確認してください</span><span class="sxs-lookup"><span data-stu-id="dbe94-601">CA2351: Ensure DataSet.ReadXml()'s input is trusted</span></span>](ca2351.md) | <span data-ttu-id="dbe94-602">信頼されていない入力を使用して <xref:System.Data.DataSet> を逆シリアル化すると、攻撃者が悪意のある入力を作成してサービス拒否攻撃を仕掛ける可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-602">When deserializing a <xref:System.Data.DataSet> with untrusted input, an attacker can craft malicious input to perform a denial of service attack.</span></span> <span data-ttu-id="dbe94-603">リモート コード実行の不明な脆弱性が存在する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-603">There may be unknown remote code execution vulnerabilities.</span></span> |
> | [<span data-ttu-id="dbe94-604">CA2352: シリアル化可能な型の安全でない DataSet または DataTable は、リモート コード実行攻撃に対して脆弱になる可能性があります</span><span class="sxs-lookup"><span data-stu-id="dbe94-604">CA2352: Unsafe DataSet or DataTable in serializable type can be vulnerable to remote code execution attacks</span></span>](ca2352.md) | <span data-ttu-id="dbe94-605"><xref:System.SerializableAttribute> でマークされたクラスまたは構造体に <xref:System.Data.DataSet> または <xref:System.Data.DataTable> フィールドまたはプロパティは含まれていますが、<xref:System.CodeDom.Compiler.GeneratedCodeAttribute> はありません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-605">A class or struct marked with <xref:System.SerializableAttribute> contains a <xref:System.Data.DataSet> or <xref:System.Data.DataTable> field or property, and doesn't have a <xref:System.CodeDom.Compiler.GeneratedCodeAttribute>.</span></span> |
> | [<span data-ttu-id="dbe94-606">CA2353: シリアル化可能な型の安全でない DataSet または DataTable</span><span class="sxs-lookup"><span data-stu-id="dbe94-606">CA2353: Unsafe DataSet or DataTable in serializable type</span></span>](ca2353.md) | <span data-ttu-id="dbe94-607">XML シリアル化属性またはデータ コントラクト属性でマークされたクラスまたは構造体に、<xref:System.Data.DataSet> または <xref:System.Data.DataTable> フィールドまたはプロパティが含まれています。</span><span class="sxs-lookup"><span data-stu-id="dbe94-607">A class or struct marked with an XML serialization attribute or a data contract attribute contains a <xref:System.Data.DataSet> or <xref:System.Data.DataTable> field or property.</span></span> |
> | [<span data-ttu-id="dbe94-608">CA2354:逆シリアル化されたオブジェクト グラフの安全でない DataSet または DataTable は、リモート コード実行攻撃に対して脆弱になる可能性があります</span><span class="sxs-lookup"><span data-stu-id="dbe94-608">CA2354: Unsafe DataSet or DataTable in deserialized object graph can be vulnerable to remote code execution attack</span></span>](ca2354.md) | <span data-ttu-id="dbe94-609"><xref:System.Runtime.Serialization.IFormatter?displayProperty=nameWithType> シリアル化で逆シリアル化し、キャストされた型のオブジェクト グラフに <xref:System.Data.DataSet> または <xref:System.Data.DataTable> を含んでいる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-609">Deserializing with an <xref:System.Runtime.Serialization.IFormatter?displayProperty=nameWithType> serialized, and the casted type's object graph can include a <xref:System.Data.DataSet> or <xref:System.Data.DataTable>.</span></span> |
> | [<span data-ttu-id="dbe94-610">CA2355:逆シリアル化されたオブジェクト グラフの安全でない DataSet または DataTable</span><span class="sxs-lookup"><span data-stu-id="dbe94-610">CA2355: Unsafe DataSet or DataTable in deserialized object graph</span></span>](ca2355.md) | <span data-ttu-id="dbe94-611">キャストされたまたは指定された型のオブジェクト グラフに <xref:System.Data.DataSet> または <xref:System.Data.DataTable> を含んでいる可能性があるときに逆シリアル化しています。</span><span class="sxs-lookup"><span data-stu-id="dbe94-611">Deserializing when the casted or specified type's object graph can include a <xref:System.Data.DataSet> or <xref:System.Data.DataTable>.</span></span> |
> | [<span data-ttu-id="dbe94-612">CA2356: Web の逆シリアル化されたオブジェクト グラフの安全でない DataSet または DataTable</span><span class="sxs-lookup"><span data-stu-id="dbe94-612">CA2356: Unsafe DataSet or DataTable in web deserialized object graph</span></span>](ca2356.md) | <span data-ttu-id="dbe94-613"><xref:System.Web.Services.WebMethodAttribute?displayProperty=nameWithType> または <xref:System.ServiceModel.OperationContractAttribute?displayProperty=nameWithType> を持つメソッドに、<xref:System.Data.DataSet> または <xref:System.Data.DataTable> を参照する可能性があるパラメーターがあります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-613">A method with a <xref:System.Web.Services.WebMethodAttribute?displayProperty=nameWithType> or <xref:System.ServiceModel.OperationContractAttribute?displayProperty=nameWithType> has a parameter that may reference a <xref:System.Data.DataSet> or <xref:System.Data.DataTable>.</span></span> |
> | [<span data-ttu-id="dbe94-614">CA2361: DataSet.ReadXml() を含む自動生成クラスが信頼されていないデータで使用されていないことを確認してください</span><span class="sxs-lookup"><span data-stu-id="dbe94-614">CA2361: Ensure autogenerated class containing DataSet.ReadXml() is not used with untrusted data</span></span>](ca2361.md) | <span data-ttu-id="dbe94-615">信頼されていない入力を使用して <xref:System.Data.DataSet> を逆シリアル化すると、攻撃者が悪意のある入力を作成してサービス拒否攻撃を仕掛ける可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-615">When deserializing a <xref:System.Data.DataSet> with untrusted input, an attacker can craft malicious input to perform a denial of service attack.</span></span> <span data-ttu-id="dbe94-616">リモート コード実行の不明な脆弱性が存在する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-616">There may be unknown remote code execution vulnerabilities.</span></span> |
> | [<span data-ttu-id="dbe94-617">CA2362: シリアル化可能な自動生成型の安全でない DataSet または DataTable は、リモート コード実行攻撃に対して脆弱になる可能性があります</span><span class="sxs-lookup"><span data-stu-id="dbe94-617">CA2362: Unsafe DataSet or DataTable in autogenerated serializable type can be vulnerable to remote code execution attacks</span></span>](ca2362.md) | <span data-ttu-id="dbe94-618"><xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> で信頼されていない入力を逆シリアル化し、逆シリアル化されたオブジェクト グラフに <xref:System.Data.DataSet> または <xref:System.Data.DataTable> が含まれている場合、攻撃者が悪意のあるペイロードを作成して、リモート コード実行攻撃を仕掛ける可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-618">When deserializing untrusted input with <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> and the deserialized object graph contains a <xref:System.Data.DataSet> or <xref:System.Data.DataTable>, an attacker can craft a malicious payload to perform a remote code execution attack.</span></span> |
> | [<span data-ttu-id="dbe94-619">CA3001:SQL インジェクションの脆弱性のコード レビュー</span><span class="sxs-lookup"><span data-stu-id="dbe94-619">CA3001: Review code for SQL injection vulnerabilities</span></span>](ca3001.md) | <span data-ttu-id="dbe94-620">信頼されていない入力と SQL コマンドを処理するときには、SQL インジェクション攻撃に注意してください。</span><span class="sxs-lookup"><span data-stu-id="dbe94-620">When working with untrusted input and SQL commands, be mindful of SQL injection attacks.</span></span> <span data-ttu-id="dbe94-621">SQL インジェクション攻撃では、悪意のある SQL コマンドが実行され、アプリケーションのセキュリティと整合性が損なわれる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-621">An SQL injection attack can execute malicious SQL commands, compromising the security and integrity of your application.</span></span> |
> | [<span data-ttu-id="dbe94-622">CA3002:XSS の脆弱性のコード レビュー</span><span class="sxs-lookup"><span data-stu-id="dbe94-622">CA3002: Review code for XSS vulnerabilities</span></span>](ca3002.md) | <span data-ttu-id="dbe94-623">Web 要求からの信頼されていない入力を処理するときには、クロスサイト スクリプティング (XSS) 攻撃に注意してください。</span><span class="sxs-lookup"><span data-stu-id="dbe94-623">When working with untrusted input from web requests, be mindful of cross-site scripting (XSS) attacks.</span></span> <span data-ttu-id="dbe94-624">XSS 攻撃によって信頼されていない入力が未加工の HTML 出力に挿入され、攻撃者が悪意のあるスクリプトを実行するか、Web ページのコンテンツを故意に変更できるようになります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-624">An XSS attack injects untrusted input into raw HTML output, allowing the attacker to execute malicious scripts or maliciously modify content in your web page.</span></span> |
> | [<span data-ttu-id="dbe94-625">CA3003:ファイル パス インジェクションの脆弱性のコード レビュー</span><span class="sxs-lookup"><span data-stu-id="dbe94-625">CA3003: Review code for file path injection vulnerabilities</span></span>](ca3003.md) | <span data-ttu-id="dbe94-626">Web 要求からの信頼されていない入力を処理するときには、ユーザー制御の入力の使用に注意してください。</span><span class="sxs-lookup"><span data-stu-id="dbe94-626">When working with untrusted input from web requests, be mindful of using user-controlled input when specifying paths to files.</span></span> |
> | [<span data-ttu-id="dbe94-627">CA3004:情報漏えいの脆弱性のコード レビュー</span><span class="sxs-lookup"><span data-stu-id="dbe94-627">CA3004: Review code for information disclosure vulnerabilities</span></span>](ca3004.md) | <span data-ttu-id="dbe94-628">例外情報を公開すると、攻撃者はアプリケーションの内部に関する分析情報を入手して、悪用できる他の脆弱性を見つけることができます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-628">Disclosing exception information gives attackers insight into the internals of your application, which can help attackers find other vulnerabilities to exploit.</span></span> |
> | [<span data-ttu-id="dbe94-629">CA3006:プロセス コマンド インジェクションの脆弱性のコード レビュー</span><span class="sxs-lookup"><span data-stu-id="dbe94-629">CA3006: Review code for process command injection vulnerabilities</span></span>](ca3006.md) | <span data-ttu-id="dbe94-630">信頼されていない入力を処理するときには、コマンド インジェクション攻撃に注意してください。</span><span class="sxs-lookup"><span data-stu-id="dbe94-630">When working with untrusted input, be mindful of command injection attacks.</span></span> <span data-ttu-id="dbe94-631">コマンド インジェクション攻撃では、基になるオペレーティング システムに対して悪意のあるコマンドが実行され、サーバーのセキュリティと整合性が損なわれる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-631">A command injection attack can execute malicious commands on the underlying operating system, compromising the security and integrity of your server.</span></span> |
> | [<span data-ttu-id="dbe94-632">CA3007:オープン リダイレクトの脆弱性のコード レビュー</span><span class="sxs-lookup"><span data-stu-id="dbe94-632">CA3007: Review code for open redirect vulnerabilities</span></span>](ca3007.md) | <span data-ttu-id="dbe94-633">信頼されていない入力を処理するときには、オープン リダイレクトの脆弱性に注意してください。</span><span class="sxs-lookup"><span data-stu-id="dbe94-633">When working with untrusted input, be mindful of open redirect vulnerabilities.</span></span> <span data-ttu-id="dbe94-634">攻撃者はオープン リダイレクトの脆弱性を悪用し、Web サイトを利用して正規の URL を表し、疑っていない訪問者をフィッシングなどの悪意のある Web ページにリダイレクトできます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-634">An attacker can exploit an open redirect vulnerability to use your website to give the appearance of a legitimate URL, but redirect an unsuspecting visitor to a phishing or other malicious webpage.</span></span> |
> | [<span data-ttu-id="dbe94-635">CA3008:XPath インジェクションの脆弱性のコード レビュー</span><span class="sxs-lookup"><span data-stu-id="dbe94-635">CA3008: Review code for XPath injection vulnerabilities</span></span>](ca3008.md) | <span data-ttu-id="dbe94-636">信頼されていない入力を処理するときには、XPath インジェクション攻撃に注意してください。</span><span class="sxs-lookup"><span data-stu-id="dbe94-636">When working with untrusted input, be mindful of XPath injection attacks.</span></span> <span data-ttu-id="dbe94-637">信頼されていない入力を使用して XPath クエリを作成すると、攻撃者がクエリを操作して意図しない結果を返したり、クエリ対象の XML のコンテンツを開示したりする可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-637">Constructing XPath queries using untrusted input may allow an attacker to maliciously manipulate the query to return an unintended result, and possibly disclose the contents of the queried XML.</span></span> |
> | [<span data-ttu-id="dbe94-638">CA3009:XML インジェクションの脆弱性のコード レビュー</span><span class="sxs-lookup"><span data-stu-id="dbe94-638">CA3009: Review code for XML injection vulnerabilities</span></span>](ca3009.md) | <span data-ttu-id="dbe94-639">信頼されていない入力を処理するときには、XML インジェクション攻撃に注意してください。</span><span class="sxs-lookup"><span data-stu-id="dbe94-639">When working with untrusted input, be mindful of XML injection attacks.</span></span> |
> | [<span data-ttu-id="dbe94-640">CA3010:XAML インジェクションの脆弱性のコード レビュー</span><span class="sxs-lookup"><span data-stu-id="dbe94-640">CA3010: Review code for XAML injection vulnerabilities</span></span>](ca3010.md) | <span data-ttu-id="dbe94-641">信頼されていない入力を処理するときには、XAML インジェクション攻撃に注意してください。</span><span class="sxs-lookup"><span data-stu-id="dbe94-641">When working with untrusted input, be mindful of XAML injection attacks.</span></span> <span data-ttu-id="dbe94-642">XAML は、オブジェクトのインスタンス化と実行を直接表すマークアップ言語です。</span><span class="sxs-lookup"><span data-stu-id="dbe94-642">XAML is a markup language that directly represents object instantiation and execution.</span></span> <span data-ttu-id="dbe94-643">つまり、XAML に作成された要素とシステム リソース (ネットワーク アクセス、ファイル システム IO など) の間でやり取りできます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-643">That means elements created in XAML can interact with system resources (for example, network access and file system IO).</span></span> |
> | [<span data-ttu-id="dbe94-644">CA3011:DLL インジェクションの脆弱性のコード レビュー</span><span class="sxs-lookup"><span data-stu-id="dbe94-644">CA3011: Review code for DLL injection vulnerabilities</span></span>](ca3011.md) | <span data-ttu-id="dbe94-645">信頼できない入力を処理するときには、信頼されていないコードの読み込みに注意してください。</span><span class="sxs-lookup"><span data-stu-id="dbe94-645">When working with untrusted input, be mindful of loading untrusted code.</span></span> <span data-ttu-id="dbe94-646">Web アプリケーションで信頼されていないコードを読み込むと、攻撃者が悪意のある DLL をプロセスに挿入し、悪意のあるコードを実行できる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-646">If your web application loads untrusted code, an attacker may be able to inject malicious DLLs into your process and execute malicious code.</span></span> |
> | [<span data-ttu-id="dbe94-647">CA3012:RegEx インジェクションの脆弱性のコード レビュー</span><span class="sxs-lookup"><span data-stu-id="dbe94-647">CA3012: Review code for regex injection vulnerabilities</span></span>](ca3012.md) | <span data-ttu-id="dbe94-648">信頼されていない入力を処理するときには、正規表現インジェクション攻撃に注意してください。</span><span class="sxs-lookup"><span data-stu-id="dbe94-648">When working with untrusted input, be mindful of regex injection attacks.</span></span> <span data-ttu-id="dbe94-649">攻撃者は、正規表現インジェクションを使用して正規表現を故意に変更したり、正規表現を意図しない結果と一致させたりする可能性があります。また、正規表現によって CPU を過度に消費し、サービス拒否攻撃を行う可能性もあります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-649">An attacker can use regex injection to maliciously modify a regular expression, to make the regex match unintended results, or to make the regex consume excessive CPU resulting in a Denial of Service attack.</span></span> |
> | [<span data-ttu-id="dbe94-650">CA3061:URL でスキーマを追加しません</span><span class="sxs-lookup"><span data-stu-id="dbe94-650">CA3061: Do not add schema by URL</span></span>](ca3061.md) | <span data-ttu-id="dbe94-651">危険な外部参照を引き起こす可能性があるため、Add メソッドの安全でないオーバーロードは使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="dbe94-651">Do not use the unsafe overload of the Add method because it may cause dangerous external references.</span></span> |
> | [<span data-ttu-id="dbe94-652">CA3075:安全ではない DTD の処理</span><span class="sxs-lookup"><span data-stu-id="dbe94-652">CA3075: Insecure DTD Processing</span></span>](ca3075.md) | <span data-ttu-id="dbe94-653">安全ではない DTDProcessing インスタンスを使用する場合、または外部エンティティ ソースを参照する場合、パーサーは信頼されていない入力を受け入れ、攻撃者に機密情報を漏えいしてしまう可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-653">If you use insecure DTDProcessing instances or reference external entity sources, the parser may accept untrusted input and disclose sensitive information to attackers.</span></span> |
> | [<span data-ttu-id="dbe94-654">CA3076:安全ではない XSLT スクリプトの実行</span><span class="sxs-lookup"><span data-stu-id="dbe94-654">CA3076: Insecure XSLT Script Execution</span></span>](ca3076.md) | <span data-ttu-id="dbe94-655">.NET アプリケーションで XSLT (Extensible Stylesheet Language Transformation) を安全ではない方法で実行すると、攻撃者に機密情報を漏えいする可能性のある、信頼されていない URI 参照がプロセッサにより解決されるおそれがあります。そのことは、サービス拒否攻撃やクロスサイト攻撃につながります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-655">If you execute Extensible Stylesheet Language Transformations (XSLT) in .NET applications insecurely, the processor may resolve untrusted URI references that could disclose sensitive information to attackers, leading to Denial of Service and Cross-Site attacks.</span></span> |
> | [<span data-ttu-id="dbe94-656">CA3077:API のデザイン、XML ドキュメント、および XML テキスト リーダーでの安全ではない処理</span><span class="sxs-lookup"><span data-stu-id="dbe94-656">CA3077: Insecure Processing in API Design, XML Document and XML Text Reader</span></span>](ca3077.md) | <span data-ttu-id="dbe94-657">XMLDocument と XMLTextReader から派生する API をデザインする場合、DtdProcessing にご注意ください。</span><span class="sxs-lookup"><span data-stu-id="dbe94-657">When designing an API derived from XMLDocument and XMLTextReader, be mindful of DtdProcessing.</span></span> <span data-ttu-id="dbe94-658">外部エンティティ ソースを参照または解決したり、XML に安全ではない値を設定したりする場合に、安全ではない DTDProcessing インスタンスを使用すると、情報漏えいにつながる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-658">Using insecure DTDProcessing instances when referencing or resolving external entity sources or setting insecure values in the XML may lead to information disclosure.</span></span> |
> | [<span data-ttu-id="dbe94-659">CA3147:ValidateAntiForgeryToken で動詞ハンドラーをマークします</span><span class="sxs-lookup"><span data-stu-id="dbe94-659">CA3147: Mark verb handlers with ValidateAntiForgeryToken</span></span>](ca3147.md) | <span data-ttu-id="dbe94-660">ASP.NET MVC コントローラーを設計するときには、クロスサイト リクエスト フォージェリ攻撃に注意してください。</span><span class="sxs-lookup"><span data-stu-id="dbe94-660">When designing an ASP.NET MVC controller, be mindful of cross-site request forgery attacks.</span></span> <span data-ttu-id="dbe94-661">クロスサイト リクエスト フォージェリ攻撃では、認証されたユーザーから ASP.NET MVC コントローラーに悪意のある要求が送信される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-661">A cross-site request forgery attack can send malicious requests from an authenticated user to your ASP.NET MVC controller.</span></span> |
> | [<span data-ttu-id="dbe94-662">CA5350:脆弱な暗号アルゴリズムを使用しないでください</span><span class="sxs-lookup"><span data-stu-id="dbe94-662">CA5350: Do Not Use Weak Cryptographic Algorithms</span></span>](ca5350.md) | <span data-ttu-id="dbe94-663">現在、さまざまな理由で弱い暗号化アルゴリズムとハッシュ関数が使用されていますが、保護対象のデータの機密性や整合性を保証するためにこれらを使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="dbe94-663">Weak encryption algorithms and hashing functions are used today for a number of reasons, but they should not be used to guarantee the confidentiality or integrity of the data they protect.</span></span> <span data-ttu-id="dbe94-664">このルールは、コードで TripleDES、SHA1、または RIPEMD160 アルゴリズムが検出されるとトリガーされます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-664">This rule triggers when it finds TripleDES, SHA1, or RIPEMD160 algorithms in the code.</span></span>|
> | [<span data-ttu-id="dbe94-665">CA5351 破られた暗号アルゴリズムを使用しないでください</span><span class="sxs-lookup"><span data-stu-id="dbe94-665">CA5351 Do Not Use Broken Cryptographic Algorithms</span></span>](ca5351.md) | <span data-ttu-id="dbe94-666">破られた暗号アルゴリズムはセキュアであるとは見なされず、それらを使用しないことを強くお勧めします。</span><span class="sxs-lookup"><span data-stu-id="dbe94-666">Broken cryptographic algorithms are not considered secure and their use should be strongly discouraged.</span></span> <span data-ttu-id="dbe94-667">このルールは、コードに MD5 ハッシュ アルゴリズムや、DES か RC2 のいずれかの暗号化アルゴリズムが検出されるとトリガーされます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-667">This rule triggers when it finds the MD5 hash algorithm or either the DES or RC2 encryption algorithms in code.</span></span> |
> | [<span data-ttu-id="dbe94-668">CA5358:安全ではない暗号モードを使用しないでください</span><span class="sxs-lookup"><span data-stu-id="dbe94-668">CA5358: Do Not Use Unsafe Cipher Modes</span></span>](ca5358.md) | <span data-ttu-id="dbe94-669">安全ではない暗号モードを使用しないでください</span><span class="sxs-lookup"><span data-stu-id="dbe94-669">Do Not Use Unsafe Cipher Modes</span></span> |
> | [<span data-ttu-id="dbe94-670">CA5359 証明書の検証を無効にしません</span><span class="sxs-lookup"><span data-stu-id="dbe94-670">CA5359 Do not disable certificate validation</span></span>](ca5359.md) | <span data-ttu-id="dbe94-671">証明書を使用すると、サーバーの ID を認証できます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-671">A certificate can help authenticate the identity of the server.</span></span> <span data-ttu-id="dbe94-672">クライアントでは、サーバー証明書を検証し、要求が意図したとおりのサーバーに送信されるようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-672">Clients should validate the server certificate to ensure requests are sent to the intended server.</span></span> <span data-ttu-id="dbe94-673">ServerCertificateValidationCallback によって常に `true` が返されると、すべての証明書が検証に成功します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-673">If the ServerCertificateValidationCallback always returns `true`, any certificate will pass validation.</span></span> |
> | [<span data-ttu-id="dbe94-674">CA5360 逆シリアル化で危険なメソッドを呼び出しません</span><span class="sxs-lookup"><span data-stu-id="dbe94-674">CA5360 Do not call dangerous methods in deserialization</span></span>](ca5360.md) | <span data-ttu-id="dbe94-675">安全でない逆シリアル化は、信頼されていないデータを使用してアプリケーションのロジックが悪用されたり、サービス拒否 (DoS) 攻撃が仕掛けられたり、逆シリアル化されたときに任意のコードが実行されたりするときに発生する脆弱性です。</span><span class="sxs-lookup"><span data-stu-id="dbe94-675">Insecure deserialization is a vulnerability which occurs when untrusted data is used to abuse the logic of an application, inflict a Denial-of-Service (DoS) attack, or even execute arbitrary code upon it being deserialized.</span></span> <span data-ttu-id="dbe94-676">悪意のあるユーザーが自分の管理下にある信頼されていないデータをアプリケーションで逆シリアル化しているときに、これらの逆シリアル化機能を悪用することがよくあります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-676">It's frequently possible for malicious users to abuse these deserialization features when the application is deserializing untrusted data which is under their control.</span></span> <span data-ttu-id="dbe94-677">具体的には、逆シリアル化の過程で危険なメソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-677">Specifically, invoke dangerous methods in the process of deserialization.</span></span> <span data-ttu-id="dbe94-678">安全でない逆シリアル化攻撃が成功すると、攻撃者は DoS 攻撃、認証回避、リモートでのコード実行などの攻撃を仕掛ける可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-678">Successful insecure deserialization attacks could allow an attacker to carry out attacks such as DoS attacks, authentication bypasses, and remote code execution.</span></span> |
> | [<span data-ttu-id="dbe94-679">CA5361: 強力な暗号の Schannel の使用を無効にしません</span><span class="sxs-lookup"><span data-stu-id="dbe94-679">CA5361: Do not disable Schannel use of strong crypto</span></span>](ca5361.md) | <span data-ttu-id="dbe94-680">`Switch.System.Net.DontEnableSchUseStrongCrypto` を `true` に設定すると、送信トランスポート層セキュリティ (TLS) 接続で使用される暗号が弱くなります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-680">Setting `Switch.System.Net.DontEnableSchUseStrongCrypto` to `true` weakens the cryptography used in outgoing Transport Layer Security (TLS) connections.</span></span> <span data-ttu-id="dbe94-681">暗号が弱くなると、アプリケーションとサーバー間の通信の機密性が損なわれ、攻撃者が機密データを簡単に傍受できるようになります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-681">Weaker cryptography can compromise the confidentiality of communication between your application and the server, making it easier for attackers to eavesdrop sensitive data.</span></span> |
> | [<span data-ttu-id="dbe94-682">CA5362: 逆シリアル化されたオブジェクト グラフで可能性のある参照サイクル</span><span class="sxs-lookup"><span data-stu-id="dbe94-682">CA5362 Potential reference cycle in deserialized object graph</span></span>](ca5362.md) | <span data-ttu-id="dbe94-683">信頼されていないデータを逆シリアル化すると、逆シリアル化されたオブジェクト グラフを処理するすべてのコードで、無限ループに入ることなく参照サイクルを処理する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-683">If deserializing untrusted data, then any code processing the deserialized object graph needs to handle reference cycles without going into infinite loops.</span></span> <span data-ttu-id="dbe94-684">これには、逆シリアル化コールバックの一部であるコードと、逆シリアル化が完了した後にオブジェクト グラフを処理するコードの両方が含まれます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-684">This includes both code that's part of a deserialization callback and code that processes the object graph after deserialization completed.</span></span> <span data-ttu-id="dbe94-685">そうしないと、攻撃者が参照サイクルを含む悪意のあるデータを使用してサービス拒否攻撃を仕掛ける可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-685">Otherwise, an attacker could perform a Denial-of-Service attack with malicious data containing a reference cycle.</span></span> |
> | [<span data-ttu-id="dbe94-686">CA5363:要求の検証を無効にしません</span><span class="sxs-lookup"><span data-stu-id="dbe94-686">CA5363: Do not disable request validation</span></span>](ca5363.md) | <span data-ttu-id="dbe94-687">要求の検証は、ASP.NET の機能の 1 つで、HTTP 要求を調べ、その要求にクロスサイトスクリプティングを含むインジェクション攻撃につながる可能性のある危険なコンテンツが含まれていないかどうかを確認します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-687">Request validation is a feature in ASP.NET that examines HTTP requests and determines whether they contain potentially dangerous content that can lead to injection attacks, including cross-site-scripting.</span></span> |
> | [<span data-ttu-id="dbe94-688">CA5364: 非推奨のセキュリティ プロトコルを使用しないでください</span><span class="sxs-lookup"><span data-stu-id="dbe94-688">CA5364: Do not use deprecated security protocols</span></span>](ca5364.md) | <span data-ttu-id="dbe94-689">トランスポート層セキュリティ (TLS) では、コンピューター間の通信を保護し、ハイパーテキスト転送プロトコル セキュア (HTTPS) とよく併用されます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-689">Transport Layer Security (TLS) secures communication between computers, most commonly with Hypertext Transfer Protocol Secure (HTTPS).</span></span> <span data-ttu-id="dbe94-690">TLS の古いプロトコル バージョンは TLS 1.2 や TLS 1.3 よりも安全性が低く、新しい脆弱性が見つかる可能性が高くなります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-690">Older protocol versions of TLS are less secure than TLS 1.2 and TLS 1.3 and are more likely to have new vulnerabilities.</span></span> <span data-ttu-id="dbe94-691">リスクを最小限に抑えるために、古いプロトコル バージョンを使用しないようにしてください。</span><span class="sxs-lookup"><span data-stu-id="dbe94-691">Avoid older protocol versions to minimize risk.</span></span> |
> | [<span data-ttu-id="dbe94-692">CA5365: HTTP ヘッダーのチェックを無効にしません</span><span class="sxs-lookup"><span data-stu-id="dbe94-692">CA5365 Do Not Disable HTTP Header Checking</span></span>](ca5365.md) | <span data-ttu-id="dbe94-693">HTTP ヘッダーのチェックでは、応答ヘッダーに含まれる復帰 \r や改行文字 \n のエンコードを有効にします。</span><span class="sxs-lookup"><span data-stu-id="dbe94-693">HTTP header checking enables encoding of the carriage return and newline characters, \r and \n, that are found in response headers.</span></span> <span data-ttu-id="dbe94-694">このエンコードは、ヘッダーに含まれる信頼されていないデータをエコーするアプリケーションを悪用するインジェクション攻撃を回避するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-694">This encoding can help to avoid injection attacks that exploit an application that echoes untrusted data contained by the header.</span></span> |
> | [<span data-ttu-id="dbe94-695">CA5366: DataSet Read XML に XmlReader を使用します</span><span class="sxs-lookup"><span data-stu-id="dbe94-695">CA5366 Use XmlReader For DataSet Read XML</span></span>](ca5366.md) | <span data-ttu-id="dbe94-696"><xref:System.Data.DataSet> を使用して信頼されていないデータを含んだ XML を読み取ると、危険な外部参照が読み込まれる可能性があります。<xref:System.Xml.XmlReader> を安全なリゾルバーと共に使用するか、DTD 処理を無効にして使用することにより、この処理を制限する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-696">Using a <xref:System.Data.DataSet> to read XML with untrusted data may load dangerous external references, which should be restricted by using an <xref:System.Xml.XmlReader> with a secure resolver or with DTD processing disabled.</span></span> |
> | [<span data-ttu-id="dbe94-697">CA5367: ポインター フィールドを持つ型をシリアル化しません</span><span class="sxs-lookup"><span data-stu-id="dbe94-697">CA5367 Do Not Serialize Types With Pointer Fields</span></span>](ca5367.md) | <span data-ttu-id="dbe94-698">この規則では、ポインター フィールドまたはプロパティを持つシリアル化可能なクラスがあるかどうかをチェックします。</span><span class="sxs-lookup"><span data-stu-id="dbe94-698">This rule checks whether there's a serializable class with a pointer field or property.</span></span> <span data-ttu-id="dbe94-699">静的メンバー、<xref:System.NonSerializedAttribute> でマークされたフィールドなど、シリアル化できないメンバーがポインターになる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-699">Members that can't be serialized can be a pointer, such as static members or fields marked with <xref:System.NonSerializedAttribute>.</span></span> |
> | [<span data-ttu-id="dbe94-700">CA5368: ページから派生したクラスに ViewStateUserKey を設定します</span><span class="sxs-lookup"><span data-stu-id="dbe94-700">CA5368 Set ViewStateUserKey For Classes Derived From Page</span></span>](ca5368.md) | <span data-ttu-id="dbe94-701"><xref:System.Web.UI.Page.ViewStateUserKey> プロパティを設定すると、識別子を個別のユーザーの view-state 変数に割り当てて、攻撃者が変数を使用した攻撃を実行できないようにすることで、アプリケーションに対する攻撃を防ぐことができます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-701">Setting the <xref:System.Web.UI.Page.ViewStateUserKey> property can help you prevent attacks on your application by allowing you to assign an identifier to the view-state variable for individual users so that attackers cannot use the variable to generate an attack.</span></span> <span data-ttu-id="dbe94-702">そうしない場合、クロスサイト リクエスト フォージェリに対する脆弱性が生じます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-702">Otherwise, there will be vulnerabilities to cross-site request forgery.</span></span> |
> | [<span data-ttu-id="dbe94-703">CA5369:逆シリアル化に XmlReader を使用します</span><span class="sxs-lookup"><span data-stu-id="dbe94-703">CA5369: Use XmlReader for Deserialize</span></span>](ca5369.md) | <span data-ttu-id="dbe94-704">信頼されていない DTD と XML スキーマを処理すると、危険な外部参照を読み込むことができる可能性があります。XmlReader を安全なリゾルバーと共に使用するか、DTD と XML インライン スキーマ処理を無効にして使用することにより、この処理を制限する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-704">Processing untrusted DTD and XML schemas may enable loading dangerous external references, which should be restricted by using an XmlReader with a secure resolver or with DTD and XML inline schema processing disabled.</span></span> |
> | [<span data-ttu-id="dbe94-705">CA5370:読み取りの検証に XmlReader を使用します</span><span class="sxs-lookup"><span data-stu-id="dbe94-705">CA5370: Use XmlReader for validating reader</span></span>](ca5370.md) | <span data-ttu-id="dbe94-706">信頼されていない DTD と XML スキーマを処理すると、危険な外部参照を読み込むことができる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-706">Processing untrusted DTD and XML schemas may enable loading dangerous external references.</span></span> <span data-ttu-id="dbe94-707">この危険な読み込みは、XmlReader を安全なリゾルバーと共に使用するか、DTD と XML インライン スキーマ処理を無効にして使用することにより制限する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-707">This dangerous loading can be restricted by using an XmlReader with a secure resolver or with DTD and XML inline schema processing disabled.</span></span> |
> | [<span data-ttu-id="dbe94-708">CA5371:スキーマの読み取りに XmlReader を使用します</span><span class="sxs-lookup"><span data-stu-id="dbe94-708">CA5371: Use XmlReader for schema read</span></span>](ca5371.md) | <span data-ttu-id="dbe94-709">信頼されていない DTD と XML スキーマを処理すると、危険な外部参照を読み込むことができる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-709">Processing untrusted DTD and XML schemas may enable loading dangerous external references.</span></span> <span data-ttu-id="dbe94-710">XmlReader を安全なリゾルバーと共に使用するか、DTD と XML インライン スキーマ処理を無効にして使用することにより、この処理を制限します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-710">Using an XmlReader with a secure resolver or with DTD and XML inline schema processing disabled restricts this.</span></span> |
> | [<span data-ttu-id="dbe94-711">CA5372:XPathDocument に XmlReader を使用します</span><span class="sxs-lookup"><span data-stu-id="dbe94-711">CA5372: Use XmlReader for XPathDocument</span></span>](ca5372.md) | <span data-ttu-id="dbe94-712">信頼されていないデータから XML を処理すると、危険な外部参照を読み込む可能性があります。XmlReader を安全なリゾルバーと共に使用するか、DTD 処理を無効にして使用することにより、この処理を制限できます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-712">Processing XML from untrusted data may load dangerous external references, which can be restricted by using an XmlReader with a secure resolver or with DTD processing disabled.</span></span> |
> | [<span data-ttu-id="dbe94-713">CA5373:廃止されたキー派生関数を使用しません</span><span class="sxs-lookup"><span data-stu-id="dbe94-713">CA5373: Do not use obsolete key derivation function</span></span>](ca5373.md) | <span data-ttu-id="dbe94-714">この規則では、弱いキー派生メソッド <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> と `Rfc2898DeriveBytes.CryptDeriveKey` の呼び出しを検出します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-714">This rule detects the invocation of weak key derivation methods <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> and `Rfc2898DeriveBytes.CryptDeriveKey`.</span></span> <span data-ttu-id="dbe94-715"><xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> で弱いアルゴリズム PBKDF1 が使用されました。</span><span class="sxs-lookup"><span data-stu-id="dbe94-715"><xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> used a weak algorithm PBKDF1.</span></span> |
> | [<span data-ttu-id="dbe94-716">CA5374: XslTransform を使用しません</span><span class="sxs-lookup"><span data-stu-id="dbe94-716">CA5374 Do Not Use XslTransform</span></span>](ca5374.md) | <span data-ttu-id="dbe94-717">この規則では、<xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> がコードでインスタンス化されるかどうかをチェックします。</span><span class="sxs-lookup"><span data-stu-id="dbe94-717">This rule checks if <xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> is instantiated in the code.</span></span> <span data-ttu-id="dbe94-718"><xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> は古いため、使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="dbe94-718"><xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> is now obsolete and shouldn't be used.</span></span> |
> | [<span data-ttu-id="dbe94-719">CA5375: アカウントの Shared Access Signature を使用しません</span><span class="sxs-lookup"><span data-stu-id="dbe94-719">CA5375 Do not use account shared access signature</span></span>](ca5375.md) | <span data-ttu-id="dbe94-720">アカウントの SAS では、サービス SAS で許可されていない BLOB コンテナー、テーブル、キューおよびファイル共有の読み取り、書き込みおよび削除操作へのアクセスを委任できます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-720">An account SAS can delegate access to read, write, and delete operations on blob containers, tables, queues, and file shares that are not permitted with a service SAS.</span></span> <span data-ttu-id="dbe94-721">ただし、コンテナーレベルのポリシーをサポートしておらず、付与されるアクセス許可に対する柔軟性と制御力は高くありません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-721">However, it doesn't support container-level policies and has less flexibility and control over the permissions that are granted.</span></span> <span data-ttu-id="dbe94-722">悪意のあるユーザーがアカウントの SAS を入手すると、ストレージ アカウントは簡単に侵害されます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-722">Once malicious users get it, your storage account will be compromised easily.</span></span> |
> | [<span data-ttu-id="dbe94-723">CA5376: SharedAccessProtocol HttpsOnly を使用します</span><span class="sxs-lookup"><span data-stu-id="dbe94-723">CA5376 Use SharedAccessProtocol HttpsOnly</span></span>](ca5376.md) | <span data-ttu-id="dbe94-724">SAS は HTTP を介してプレーン テキストで転送できない機密データです。</span><span class="sxs-lookup"><span data-stu-id="dbe94-724">SAS is sensitive data that can't be transported in plain text on HTTP.</span></span> |
> | [<span data-ttu-id="dbe94-725">CA5377: コンテナー レベルのアクセス ポリシーを使用します</span><span class="sxs-lookup"><span data-stu-id="dbe94-725">CA5377 Use container level access policy</span></span>](ca5377.md) | <span data-ttu-id="dbe94-726">コンテナーレベルのアクセス ポリシーは、いつでも変更または取り消すことができます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-726">A container-level access policy can be modified or revoked at any time.</span></span> <span data-ttu-id="dbe94-727">このため、付与されるアクセス許可をより柔軟に制御できます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-727">It provides greater flexibility and control over the permissions that are granted.</span></span> |
> | [<span data-ttu-id="dbe94-728">CA5378: ServicePointManagerSecurityProtocols を無効にしません</span><span class="sxs-lookup"><span data-stu-id="dbe94-728">CA5378: Do not disable ServicePointManagerSecurityProtocols</span></span>](ca5378.md) | <span data-ttu-id="dbe94-729">`Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols` を `true` に設定すると、Windows Communication Framework (WCF) のトランスポート層セキュリティ (TLS) 接続が TLS 1.0 に制限されます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-729">Setting `Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols` to `true` limits Windows Communication Framework's (WCF) Transport Layer Security (TLS) connections to using TLS 1.0.</span></span> <span data-ttu-id="dbe94-730">このバージョンの TLS は非推奨になる予定です。</span><span class="sxs-lookup"><span data-stu-id="dbe94-730">That version of TLS will be deprecated.</span></span> |
> | [<span data-ttu-id="dbe94-731">CA5379: 弱いキー派生関数アルゴリズムを使用しません</span><span class="sxs-lookup"><span data-stu-id="dbe94-731">CA5379 Do not use weak key derivation function algorithm</span></span>](ca5379.md) | <span data-ttu-id="dbe94-732"><xref:System.Security.Cryptography.Rfc2898DeriveBytes> クラスでは、既定で <xref:System.Security.Cryptography.HashAlgorithmName.SHA1> アルゴリズムを使用します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-732">The <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class defaults to using the <xref:System.Security.Cryptography.HashAlgorithmName.SHA1> algorithm.</span></span> <span data-ttu-id="dbe94-733"><xref:System.Security.Cryptography.HashAlgorithmName.SHA256> またはそれ以上を使用して、コンストラクターの一部のオーバーロードで使用するハッシュ アルゴリズムを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-733">You should specify the hash algorithm to use in some overloads of the constructor with <xref:System.Security.Cryptography.HashAlgorithmName.SHA256> or higher.</span></span> <span data-ttu-id="dbe94-734">ただし、<xref:System.Security.Cryptography.Rfc2898DeriveBytes.HashAlgorithm> プロパティには `get` アクセサーしかなく、`overriden` 修飾子はありません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-734">Note, <xref:System.Security.Cryptography.Rfc2898DeriveBytes.HashAlgorithm> property only has a `get` accessor and doesn't have a `overriden` modifier.</span></span> |
> | [<span data-ttu-id="dbe94-735">CA5380:ルート ストアに証明書を追加しません</span><span class="sxs-lookup"><span data-stu-id="dbe94-735">CA5380: Do not add certificates to root store</span></span>](ca5380.md) | <span data-ttu-id="dbe94-736">この規則では、証明書を信頼されたルート証明機関の証明書ストアに追加するコードを検出します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-736">This rule detects code that adds a certificate into the Trusted Root Certification Authorities certificate store.</span></span> <span data-ttu-id="dbe94-737">既定では、信頼されたルート証明機関の証明書ストアは、Microsoft ルート証明書プログラムの要件を満たした一連の公的 CA で構成されています。</span><span class="sxs-lookup"><span data-stu-id="dbe94-737">By default, the Trusted Root Certification Authorities certificate store is configured with a set of public CAs that has met the requirements of the Microsoft Root Certificate Program.</span></span> |
> | [<span data-ttu-id="dbe94-738">CA5381:証明書がルート ストアに追加されていないことを確認します</span><span class="sxs-lookup"><span data-stu-id="dbe94-738">CA5381: Ensure certificates are not added to root store</span></span>](ca5381.md) | <span data-ttu-id="dbe94-739">この規則では、証明書を信頼されたルート証明機関の証明書ストアに追加する可能性があるコードを検出します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-739">This rule detects code that potentially adds a certificate into the Trusted Root Certification Authorities certificate store.</span></span> <span data-ttu-id="dbe94-740">既定では、信頼されたルート証明機関の証明書ストアは、Microsoft ルート証明書プログラムの要件を満たした一連の公的証明機関 (CA) で構成されています。</span><span class="sxs-lookup"><span data-stu-id="dbe94-740">By default, the Trusted Root Certification Authorities certificate store is configured with a set of public certification authorities (CAs) that has met the requirements of the Microsoft Root Certificate Program.</span></span> |
> | [<span data-ttu-id="dbe94-741">CA5382: ASP.NET Core で安全な Cookie を使用します</span><span class="sxs-lookup"><span data-stu-id="dbe94-741">CA5382 Use secure cookies in ASP.NET Core</span></span>](ca5382.md) | <span data-ttu-id="dbe94-742">HTTPS 経由で使用できるアプリケーションでは、セキュリティで保護された Cookie を使用する必要があります。つまり、Cookie は Secure Sockets Layer (SSL) のみを使用して転送する必要があることをブラウザーに示す必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-742">Applications available over HTTPS must use secure cookies, which indicate to the browser that the cookie should only be transmitted using Secure Sockets Layer (SSL).</span></span> |
> | [<span data-ttu-id="dbe94-743">CA5383: ASP.NET Core で安全な Cookie を使用することを確認します</span><span class="sxs-lookup"><span data-stu-id="dbe94-743">CA5383 Ensure use secure cookies in ASP.NET Core</span></span>](ca5383.md) | <span data-ttu-id="dbe94-744">HTTPS 経由で使用できるアプリケーションでは、セキュリティで保護された Cookie を使用する必要があります。つまり、Cookie は Secure Sockets Layer (SSL) のみを使用して転送する必要があることをブラウザーに示す必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-744">Applications available over HTTPS must use secure cookies, which indicate to the browser that the cookie should only be transmitted using Secure Sockets Layer (SSL).</span></span> |
> | [<span data-ttu-id="dbe94-745">CA5384: デジタル署名アルゴリズム (DSA) を使用しません</span><span class="sxs-lookup"><span data-stu-id="dbe94-745">CA5384 Do not use digital signature algorithm (DSA)</span></span>](ca5384.md) | <span data-ttu-id="dbe94-746">DSA は、弱い非対称暗号化アルゴリズムです。</span><span class="sxs-lookup"><span data-stu-id="dbe94-746">DSA is a weak asymmetric encryption algorithm.</span></span> |
> | [<span data-ttu-id="dbe94-747">CA5385: 十分なキー サイズの Rivest–Shamir–Adleman (RSA) アルゴリズムを使用します</span><span class="sxs-lookup"><span data-stu-id="dbe94-747">CA5385 Use Rivest–Shamir–Adleman (RSA) algorithm with sufficient key size</span></span>](ca5385.md) | <span data-ttu-id="dbe94-748">2048 ビットよりも小さい RSA キーは、ブルート フォース攻撃に対する脆弱性が高くなります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-748">An RSA key smaller than 2048 bits is more vulnerable to brute force attacks.</span></span> |
> | [<span data-ttu-id="dbe94-749">CA5386: SecurityProtocolType 値のハードコードを避けます</span><span class="sxs-lookup"><span data-stu-id="dbe94-749">CA5386: Avoid hardcoding SecurityProtocolType value</span></span>](ca5386.md) | <span data-ttu-id="dbe94-750">トランスポート層セキュリティ (TLS) では、コンピューター間の通信を保護し、ハイパーテキスト転送プロトコル セキュア (HTTPS) とよく併用されます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-750">Transport Layer Security (TLS) secures communication between computers, most commonly with Hypertext Transfer Protocol Secure (HTTPS).</span></span> <span data-ttu-id="dbe94-751">プロトコル バージョン TLS 1.0 と TLS 1.1 は非推奨で、TLS 1.2 と TLS 1.3 が現行のバージョンです。</span><span class="sxs-lookup"><span data-stu-id="dbe94-751">Protocol versions TLS 1.0 and TLS 1.1 are deprecated, while TLS 1.2 and TLS 1.3 are current.</span></span> <span data-ttu-id="dbe94-752">今後、TLS 1.2 と TLS 1.3 も非推奨になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-752">In the future, TLS 1.2 and TLS 1.3 may be deprecated.</span></span> <span data-ttu-id="dbe94-753">アプリケーションをセキュリティで保護し続けるために、プロトコル バージョンをハードコーティングしないようにし、少なくとも .NET Framework v4.7.1 を対象にしてください。</span><span class="sxs-lookup"><span data-stu-id="dbe94-753">To ensure that your application remains secure, avoid hardcoding a protocol version and target at least .NET Framework v4.7.1.</span></span> |
> | [<span data-ttu-id="dbe94-754">CA5387: 反復回数が十分でない弱いキー派生関数は使用しません</span><span class="sxs-lookup"><span data-stu-id="dbe94-754">CA5387 Do not use weak key derivation function with insufficient iteration count</span></span>](ca5387.md) | <span data-ttu-id="dbe94-755">この規則では、反復回数が 100,000 回未満の <xref:System.Security.Cryptography.Rfc2898DeriveBytes> によって暗号化キーが生成されたかどうかをチェックします。</span><span class="sxs-lookup"><span data-stu-id="dbe94-755">This rule checks if a cryptographic key was generated by <xref:System.Security.Cryptography.Rfc2898DeriveBytes> with an iteration count of less than 100,000.</span></span> <span data-ttu-id="dbe94-756">反復回数が多いほど、生成された暗号化キーを推測しようとする辞書攻撃を緩和するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-756">A higher iteration count can help mitigate against dictionary attacks that try to guess the generated cryptographic key.</span></span> |
> | [<span data-ttu-id="dbe94-757">CA5388: 弱いキー派生関数を使用する場合は十分な反復回数を確保してください</span><span class="sxs-lookup"><span data-stu-id="dbe94-757">CA5388 Ensure sufficient iteration count when using weak key derivation function</span></span>](ca5388.md) | <span data-ttu-id="dbe94-758">この規則では、反復回数が 100,000 回未満の可能性がある <xref:System.Security.Cryptography.Rfc2898DeriveBytes> によって暗号化キーが生成されたかどうかをチェックします。</span><span class="sxs-lookup"><span data-stu-id="dbe94-758">This rule checks if a cryptographic key was generated by <xref:System.Security.Cryptography.Rfc2898DeriveBytes> with an iteration count that may be less than 100,000.</span></span> <span data-ttu-id="dbe94-759">反復回数が多いほど、生成された暗号化キーを推測しようとする辞書攻撃を緩和するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-759">A higher iteration count can help mitigate against dictionary attacks that try to guess the generated cryptographic key.</span></span> |
> | [<span data-ttu-id="dbe94-760">CA5389:アーカイブ項目のパスをターゲット ファイル システム パスに追加しません</span><span class="sxs-lookup"><span data-stu-id="dbe94-760">CA5389: Do not add archive item's path to the target file system path</span></span>](ca5389.md) | <span data-ttu-id="dbe94-761">ファイル パスは相対パスの場合があり、想定されるファイル システムのターゲット パス以外でファイル システムへのアクセスが可能になる可能性があります。これは、lay-and-wait の技法によって悪意のある構成変更とリモート コードの実行につながります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-761">File path can be relative and can lead to file system access outside of the expected file system target path, leading to malicious config changes and remote code execution via lay-and-wait technique.</span></span> |
> | [<span data-ttu-id="dbe94-762">CA5390: 暗号化キーをハードコーディングしません</span><span class="sxs-lookup"><span data-stu-id="dbe94-762">CA5390 Do not hard-code encryption key</span></span>](ca5390.md) | <span data-ttu-id="dbe94-763">対称アルゴリズムを成功させるには、送信側と受信側だけに秘密キーを伝える必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-763">For a symmetric algorithm to be successful, the secret key must be known only to the sender and the receiver.</span></span> <span data-ttu-id="dbe94-764">キーがハードコーディングされていると、簡単に検出できます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-764">When a key is hard-coded, it is easily discovered.</span></span> <span data-ttu-id="dbe94-765">コンパイルされたバイナリでも、悪意のあるユーザーが簡単に抽出できます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-765">Even with compiled binaries, it is easy for malicious users to extract it.</span></span> <span data-ttu-id="dbe94-766">秘密キーが侵害されると、暗号テキストを直接復号化できるようになるため、保護されていない状態になります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-766">Once the private key is compromised, the cipher text can be decrypted directly and is not protected anymore.</span></span> |
> | [<span data-ttu-id="dbe94-767">CA5391: ASP.NET Core MVC コントローラーで偽造防止トークンを使用します</span><span class="sxs-lookup"><span data-stu-id="dbe94-767">CA5391 Use antiforgery tokens in ASP.NET Core MVC controllers</span></span>](ca5391.md) | <span data-ttu-id="dbe94-768">偽造防止トークンを検証せずに `POST`、`PUT`、`PATCH` または `DELETE` 要求を処理すると、クロスサイト リクエスト フォージェリ攻撃に対して脆弱になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-768">Handling a `POST`, `PUT`, `PATCH`, or `DELETE` request without validating an antiforgery token may be vulnerable to cross-site request forgery attacks.</span></span> <span data-ttu-id="dbe94-769">クロスサイト リクエスト フォージェリ攻撃では、認証されたユーザーから ASP.NET Core MVC コントローラーに悪意のある要求が送信される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-769">A cross-site request forgery attack can send malicious requests from an authenticated user to your ASP.NET Core MVC controller.</span></span> |
> | [<span data-ttu-id="dbe94-770">CA5392: P/Invoke に対して DefaultDllImportSearchPaths 属性を使用します</span><span class="sxs-lookup"><span data-stu-id="dbe94-770">CA5392 Use DefaultDllImportSearchPaths attribute for P/Invokes</span></span>](ca5392.md) | <span data-ttu-id="dbe94-771">既定では、<xref:System.Runtime.InteropServices.DllImportAttribute> を使用している P/Invoke 関数では、ライブラリが読み込むための現在の作業ディレクトリを含むいくつかのディレクトリを精査します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-771">By default, P/Invoke functions using <xref:System.Runtime.InteropServices.DllImportAttribute> probe a number of directories, including the current working directory for the library to load.</span></span> <span data-ttu-id="dbe94-772">これは特定のアプリケーションでセキュリティ上の問題を引き起こし、DLL のハイジャックにつながる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-772">This can be a security issue for certain applications, leading to DLL hijacking.</span></span> |
> | [<span data-ttu-id="dbe94-773">CA5393: 安全でない DllImportSearchPath 値を使用しない</span><span class="sxs-lookup"><span data-stu-id="dbe94-773">CA5393 Do not use unsafe DllImportSearchPath value</span></span>](ca5393.md) | <span data-ttu-id="dbe94-774">既定の DLL 検索ディレクトリとアセンブリ ディレクトリに悪意のある DLL が存在する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-774">There could be a malicious DLL in the default DLL search directories and assembly directories.</span></span> <span data-ttu-id="dbe94-775">または、アプリケーションが実行されている場所に応じて、アプリケーションのディレクトリに悪意のある DLL が存在する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-775">Or, depending on where your application is run from, there could be a malicious DLL in the application's directory.</span></span> |
> | [<span data-ttu-id="dbe94-776">CA5394: 安全でないランダム度を使用しません</span><span class="sxs-lookup"><span data-stu-id="dbe94-776">CA5394 Do not use insecure randomness</span></span>](ca5394.md) | <span data-ttu-id="dbe94-777">暗号強度の低い擬似乱数ジェネレーターを使用すると、セキュリティ上注意が必要などのような値が生成されるかを攻撃者が予測できる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-777">Using a cryptographically weak pseudo-random number generator may allow an attacker to predict what security-sensitive value will be generated.</span></span> |
> | [<span data-ttu-id="dbe94-778">CA5395 アクション メソッドの HttpVerb 属性がありません</span><span class="sxs-lookup"><span data-stu-id="dbe94-778">CA5395 Miss HttpVerb attribute for action methods</span></span>](ca5395.md) | <span data-ttu-id="dbe94-779">データの作成、編集、削除、またはそれ以外の変更を行うすべてのアクション メソッドは、偽造防止属性を使用してクロスサイト リクエスト フォージェリ攻撃から保護する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-779">All the action methods that create, edit, delete, or otherwise modify data needs to be protected with the antiforgery attribute from cross-site request forgery attacks.</span></span> <span data-ttu-id="dbe94-780">GET 操作の実行は、副作用がなく、永続化されたデータを変更しない、安全な操作である必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-780">Performing a GET operation should be a safe operation that has no side effects and doesn't modify your persisted data.</span></span> |
> | [<span data-ttu-id="dbe94-781">CA5396: HttpCookie で HttpOnly を true に設定します</span><span class="sxs-lookup"><span data-stu-id="dbe94-781">CA5396 Set HttpOnly to true for HttpCookie</span></span>](ca5396.md) | <span data-ttu-id="dbe94-782">高度な防御手段として、セキュリティ上注意が必要な HTTP Cookie が、必ず HttpOnly としてマークされるようにしてください。</span><span class="sxs-lookup"><span data-stu-id="dbe94-782">As a defense in depth measure, ensure security sensitive HTTP cookies are marked as HttpOnly.</span></span> <span data-ttu-id="dbe94-783">これは、スクリプトから Cookie へのアクセスを Web ブラウザーで許可してはならないことを示しています。</span><span class="sxs-lookup"><span data-stu-id="dbe94-783">This indicates web browsers should disallow scripts from accessing the cookies.</span></span> <span data-ttu-id="dbe94-784">挿入された悪意のあるスクリプトは、Cookie を盗むための一般的な方法です。</span><span class="sxs-lookup"><span data-stu-id="dbe94-784">Injected malicious scripts are a common way of stealing cookies.</span></span> |
> | [<span data-ttu-id="dbe94-785">CA5397:非推奨の SslProtocols 値を使用しません</span><span class="sxs-lookup"><span data-stu-id="dbe94-785">CA5397: Do not use deprecated SslProtocols values</span></span>](ca5397.md) | <span data-ttu-id="dbe94-786">トランスポート層セキュリティ (TLS) では、コンピューター間の通信を保護し、ハイパーテキスト転送プロトコル セキュア (HTTPS) とよく併用されます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-786">Transport Layer Security (TLS) secures communication between computers, most commonly with Hypertext Transfer Protocol Secure (HTTPS).</span></span> <span data-ttu-id="dbe94-787">TLS の古いプロトコル バージョンは TLS 1.2 や TLS 1.3 よりも安全性が低く、新しい脆弱性が見つかる可能性が高くなります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-787">Older protocol versions of TLS are less secure than TLS 1.2 and TLS 1.3 and are more likely to have new vulnerabilities.</span></span> <span data-ttu-id="dbe94-788">リスクを最小限に抑えるために、古いプロトコル バージョンを使用しないようにしてください。</span><span class="sxs-lookup"><span data-stu-id="dbe94-788">Avoid older protocol versions to minimize risk.</span></span> |
> | [<span data-ttu-id="dbe94-789">CA5398:ハードコーディングされた SslProtocols 値を回避します</span><span class="sxs-lookup"><span data-stu-id="dbe94-789">CA5398: Avoid hardcoded SslProtocols values</span></span>](ca5398.md) | <span data-ttu-id="dbe94-790">トランスポート層セキュリティ (TLS) では、コンピューター間の通信を保護し、ハイパーテキスト転送プロトコル セキュア (HTTPS) とよく併用されます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-790">Transport Layer Security (TLS) secures communication between computers, most commonly with Hypertext Transfer Protocol Secure (HTTPS).</span></span> <span data-ttu-id="dbe94-791">プロトコル バージョン TLS 1.0 と TLS 1.1 は非推奨で、TLS 1.2 と TLS 1.3 が現行のバージョンです。</span><span class="sxs-lookup"><span data-stu-id="dbe94-791">Protocol versions TLS 1.0 and TLS 1.1 are deprecated, while TLS 1.2 and TLS 1.3 are current.</span></span> <span data-ttu-id="dbe94-792">今後、TLS 1.2 と TLS 1.3 も非推奨になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-792">In the future, TLS 1.2 and TLS 1.3 may be deprecated.</span></span> <span data-ttu-id="dbe94-793">アプリケーションをセキュリティで保護し続けるために、プロトコル バージョンをハードコーティングしないようにしてください。</span><span class="sxs-lookup"><span data-stu-id="dbe94-793">To ensure that your application remains secure, avoid hardcoding a protocol version.</span></span> |
> | [<span data-ttu-id="dbe94-794">CA5399: HttpClient 証明書失効リストの確認を確実に無効にします</span><span class="sxs-lookup"><span data-stu-id="dbe94-794">CA5399 Definitely disable HttpClient certificate revocation list check</span></span>](ca5399.md) | <span data-ttu-id="dbe94-795">失効した証明書は信頼されていません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-795">A revoked certificate isn't trusted anymore.</span></span> <span data-ttu-id="dbe94-796">攻撃者が HTTPS 通信で悪意のあるデータを渡すか、機密データを盗むために使用する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-796">It could be used by attackers passing some malicious data or stealing sensitive data in HTTPS communication.</span></span> |
> | [<span data-ttu-id="dbe94-797">CA5400: HttpClient 証明書失効リストの確認が無効になっていないことをご確認ください</span><span class="sxs-lookup"><span data-stu-id="dbe94-797">CA5400 Ensure HttpClient certificate revocation list check is not disabled</span></span>](ca5400.md) | <span data-ttu-id="dbe94-798">失効した証明書は信頼されていません。</span><span class="sxs-lookup"><span data-stu-id="dbe94-798">A revoked certificate isn't trusted anymore.</span></span> <span data-ttu-id="dbe94-799">攻撃者が HTTPS 通信で悪意のあるデータを渡すか、機密データを盗むために使用する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-799">It could be used by attackers passing some malicious data or stealing sensitive data in HTTPS communication.</span></span> |
> | [<span data-ttu-id="dbe94-800">CA5401: 既定以外の IV で CreateEncryptor を使用しません</span><span class="sxs-lookup"><span data-stu-id="dbe94-800">CA5401 Do not use CreateEncryptor with non-default IV</span></span>](ca5401.md) | <span data-ttu-id="dbe94-801">対称暗号化では、辞書攻撃を防ぐために、反復不能な初期化ベクトルを常に使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-801">Symmetric encryption should always use a non-repeatable initialization vector to prevent dictionary attacks.</span></span> |
> | [<span data-ttu-id="dbe94-802">CA5402: 既定の IV で CreateEncryptor を使用します</span><span class="sxs-lookup"><span data-stu-id="dbe94-802">CA5402 Use CreateEncryptor with the default IV</span></span>](ca5402.md) | <span data-ttu-id="dbe94-803">対称暗号化では、辞書攻撃を防ぐために、反復不能な初期化ベクトルを常に使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbe94-803">Symmetric encryption should always use a non-repeatable initialization vector to prevent dictionary attacks.</span></span> |
> | [<span data-ttu-id="dbe94-804">CA5403:証明書をハードコーディングしない</span><span class="sxs-lookup"><span data-stu-id="dbe94-804">CA5403: Do not hard-code certificate</span></span>](ca5403.md) | <span data-ttu-id="dbe94-805"><xref:System.Security.Cryptography.X509Certificates.X509Certificate> または <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> コンストラクターの `data` または `rawData` パラメーターがハードコーディングされています。</span><span class="sxs-lookup"><span data-stu-id="dbe94-805">The `data` or `rawData` parameter of a <xref:System.Security.Cryptography.X509Certificates.X509Certificate> or <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> constructor is hard-coded.</span></span> |
> | [<span data-ttu-id="dbe94-806">IL3000: 単一ファイルとして発行するときにアセンブリ ファイル パスにアクセスしません</span><span class="sxs-lookup"><span data-stu-id="dbe94-806">IL3000 Avoid accessing Assembly file path when publishing as a single file</span></span>](il3000.md) | <span data-ttu-id="dbe94-807">単一ファイルとして発行するときにアセンブリ ファイル パスにアクセスしないでください。</span><span class="sxs-lookup"><span data-stu-id="dbe94-807">Avoid accessing Assembly file path when publishing as a single file.</span></span> |
> | [<span data-ttu-id="dbe94-808">IL3001: 単一ファイルとして発行するときにアセンブリ ファイル パスにアクセスしません</span><span class="sxs-lookup"><span data-stu-id="dbe94-808">IL3001 Avoid accessing Assembly file path when publishing as a single-file</span></span>](il3001.md) | <span data-ttu-id="dbe94-809">単一ファイルとして発行するときにアセンブリ ファイル パスにアクセスしないでください。</span><span class="sxs-lookup"><span data-stu-id="dbe94-809">Avoid accessing Assembly file path when publishing as a single file.</span></span> |

## <a name="legend"></a><span data-ttu-id="dbe94-810">凡例</span><span class="sxs-lookup"><span data-stu-id="dbe94-810">Legend</span></span>

<span data-ttu-id="dbe94-811">次の表は、参照ドキュメントの各ルールについて提供されている情報の種類を示しています。</span><span class="sxs-lookup"><span data-stu-id="dbe94-811">The following table shows the type of information that is provided for each rule in the reference documentation.</span></span>

|<span data-ttu-id="dbe94-812">項目</span><span class="sxs-lookup"><span data-stu-id="dbe94-812">Item</span></span>|<span data-ttu-id="dbe94-813">説明</span><span class="sxs-lookup"><span data-stu-id="dbe94-813">Description</span></span>|
|----------|-----------------|
|<span data-ttu-id="dbe94-814">種類</span><span class="sxs-lookup"><span data-stu-id="dbe94-814">Type</span></span>|<span data-ttu-id="dbe94-815">規則の TypeName。</span><span class="sxs-lookup"><span data-stu-id="dbe94-815">The TypeName for the rule.</span></span>|
| <span data-ttu-id="dbe94-816">**ルール ID**</span><span class="sxs-lookup"><span data-stu-id="dbe94-816">**Rule ID**</span></span> |<span data-ttu-id="dbe94-817">規則の一意の識別子。</span><span class="sxs-lookup"><span data-stu-id="dbe94-817">The unique identifier for the rule.</span></span> <span data-ttu-id="dbe94-818">規則 ID とカテゴリは、ソース内で警告の省略表記として使用されます。</span><span class="sxs-lookup"><span data-stu-id="dbe94-818">RuleId and Category are used for in-source suppression of a warning.</span></span>|
| <span data-ttu-id="dbe94-819">**カテゴリ**</span><span class="sxs-lookup"><span data-stu-id="dbe94-819">**Category**</span></span> |<span data-ttu-id="dbe94-820">規則のカテゴリ (たとえば、セキュリティ)。</span><span class="sxs-lookup"><span data-stu-id="dbe94-820">The category of the rule, for example, security.</span></span>|
| <span data-ttu-id="dbe94-821">**修正が中断ありか中断なしか**</span><span class="sxs-lookup"><span data-stu-id="dbe94-821">**Fix is breaking or non-breaking**</span></span> |<span data-ttu-id="dbe94-822">規則違反を修正することが、互換性に影響する変更点かどうかを示します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-822">Whether the fix for a violation of the rule is a breaking change.</span></span> <span data-ttu-id="dbe94-823">互換性に影響する変更点とは、違反の原因となった対象に対して依存関係を持つアセンブリが、新たに修正したバージョンで再コンパイルされないこと、または変更によって実行時にエラーになる可能性があることを示します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-823">Breaking change means that an assembly that has a dependency on the target that caused the violation will not recompile with the new fixed version or might fail at run time because of the change.</span></span> <span data-ttu-id="dbe94-824">複数の修正を適用でき、互換性に影響する変更点があるものとないものがある場合、"あり" と "なし" を併記しています。</span><span class="sxs-lookup"><span data-stu-id="dbe94-824">When multiple fixes are available and at least one fix is a breaking change and one fix is not, both 'Breaking' and 'Non-breaking' are specified.</span></span>|
|<span data-ttu-id="dbe94-825">原因</span><span class="sxs-lookup"><span data-stu-id="dbe94-825">Cause</span></span>|<span data-ttu-id="dbe94-826">規則に従って警告が生成される原因になった特定のマネージド コード。</span><span class="sxs-lookup"><span data-stu-id="dbe94-826">The specific managed code that causes the rule to generate a warning.</span></span>|
|<span data-ttu-id="dbe94-827">説明</span><span class="sxs-lookup"><span data-stu-id="dbe94-827">Description</span></span>|<span data-ttu-id="dbe94-828">警告の背景にある問題について説明します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-828">Discusses the issues that are behind the warning.</span></span>|
|<span data-ttu-id="dbe94-829">違反の修正方法</span><span class="sxs-lookup"><span data-stu-id="dbe94-829">How to fix violations</span></span>|<span data-ttu-id="dbe94-830">規則に適合し、警告が生成されないようにソース コードを変更する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-830">Explains how to change the source code to satisfy the rule and prevent it from generating a warning.</span></span>|
|<span data-ttu-id="dbe94-831">どのようなときに警告を抑制するか</span><span class="sxs-lookup"><span data-stu-id="dbe94-831">When to suppress warnings</span></span>|<span data-ttu-id="dbe94-832">規則による警告を抑制しても安全な場合について説明します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-832">Describes when it is safe to suppress a warning from the rule.</span></span>|
|<span data-ttu-id="dbe94-833">コード例</span><span class="sxs-lookup"><span data-stu-id="dbe94-833">Example code</span></span>|<span data-ttu-id="dbe94-834">規則に違反する例と、規則に適合する修正した例を示します。</span><span class="sxs-lookup"><span data-stu-id="dbe94-834">Examples that violate the rule and corrected examples that satisfy the rule.</span></span>|
|<span data-ttu-id="dbe94-835">関連規則</span><span class="sxs-lookup"><span data-stu-id="dbe94-835">Related rules</span></span>|<span data-ttu-id="dbe94-836">関連する規則。</span><span class="sxs-lookup"><span data-stu-id="dbe94-836">Related rules.</span></span>|
