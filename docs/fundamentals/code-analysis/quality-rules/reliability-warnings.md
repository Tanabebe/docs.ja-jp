---
title: 信頼性の規則 (コード分析)
description: コード分析の信頼性の規則について説明します。
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.reliabilityrules
helpviewer_keywords:
- rules, reliability
- reliability rules
- managed code analysis rules, reliability rules
author: gewarren
ms.author: gewarren
ms.openlocfilehash: a747dd4dcda351a1ddb0f3d069bb7bac895c32f8
ms.sourcegitcommit: 05d0087dfca85aac9ca2960f86c5efd218bf833f
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/30/2021
ms.locfileid: "96591772"
---
# <a name="reliability-rules"></a><span data-ttu-id="a8f46-103">信頼性の規則</span><span class="sxs-lookup"><span data-stu-id="a8f46-103">Reliability rules</span></span>

<span data-ttu-id="a8f46-104">信頼性の規則は、メモリやスレッドの適切な使用など、ライブラリとアプリケーションの信頼性をサポートします。</span><span class="sxs-lookup"><span data-stu-id="a8f46-104">Reliability rules support library and application reliability, such as correct memory and thread usage.</span></span> <span data-ttu-id="a8f46-105">次のような信頼性の規則があります。</span><span class="sxs-lookup"><span data-stu-id="a8f46-105">The reliability rules include:</span></span>

|<span data-ttu-id="a8f46-106">ルール</span><span class="sxs-lookup"><span data-stu-id="a8f46-106">Rule</span></span>|<span data-ttu-id="a8f46-107">説明</span><span class="sxs-lookup"><span data-stu-id="a8f46-107">Description</span></span>|
|----------|-----------------|
|[<span data-ttu-id="a8f46-108">CA2000:スコープを失う前にオブジェクトを破棄</span><span class="sxs-lookup"><span data-stu-id="a8f46-108">CA2000: Dispose objects before losing scope</span></span>](ca2000.md)|<span data-ttu-id="a8f46-109">例外的なイベントが発生するとオブジェクトのファイナライザーを実行できないため、オブジェクトに対するすべての参照がスコープ外になる前に、オブジェクトを明示的に破棄する必要があります。</span><span class="sxs-lookup"><span data-stu-id="a8f46-109">Because an exceptional event might occur that will prevent the finalizer of an object from running, the object should be explicitly disposed before all references to it are out of scope.</span></span>|
|[<span data-ttu-id="a8f46-110">CA2002:弱い ID を伴うオブジェクト上でロックしません</span><span class="sxs-lookup"><span data-stu-id="a8f46-110">CA2002: Do not lock on objects with weak identity</span></span>](ca2002.md)|<span data-ttu-id="a8f46-111">アプリケーション ドメインの境界を越えてオブジェクトに直接アクセスできる場合、そのオブジェクトの ID は不十分と表現されます。</span><span class="sxs-lookup"><span data-stu-id="a8f46-111">An object is said to have a weak identity when it can be directly accessed across application domain boundaries.</span></span> <span data-ttu-id="a8f46-112">スレッドで ID が不十分なオブジェクトをロックしようとすると、ブロックされることがあります。たとえば、異なるアプリケーション ドメインの別スレッドで、既に同じオブジェクトがロックされている場合です。</span><span class="sxs-lookup"><span data-stu-id="a8f46-112">A thread that tries to acquire a lock on an object that has a weak identity can be blocked by a second thread in a different application domain that has a lock on the same object.</span></span>|
|[<span data-ttu-id="a8f46-113">CA2007:タスクを直接待機しないでください</span><span class="sxs-lookup"><span data-stu-id="a8f46-113">CA2007: Do not directly await a Task</span></span>](ca2007.md)|<span data-ttu-id="a8f46-114">非同期メソッドでは <xref:System.Threading.Tasks.Task> を直接[待機](../../../csharp/language-reference/operators/await.md)します。</span><span class="sxs-lookup"><span data-stu-id="a8f46-114">An asynchronous method [awaits](../../../csharp/language-reference/operators/await.md) a <xref:System.Threading.Tasks.Task> directly.</span></span>|
|[<span data-ttu-id="a8f46-115">CA2008:TaskScheduler を渡さずにタスクを作成しない</span><span class="sxs-lookup"><span data-stu-id="a8f46-115">CA2008: Do not create tasks without passing a TaskScheduler</span></span>](ca2008.md)|<span data-ttu-id="a8f46-116">タスクの作成または継続の操作で、<xref:System.Threading.Tasks.TaskScheduler> パラメーターを指定しないメソッド オーバーロードを使用しています。</span><span class="sxs-lookup"><span data-stu-id="a8f46-116">A task creation or continuation operation uses a method overload that does not specify a <xref:System.Threading.Tasks.TaskScheduler> parameter.</span></span>|
|[<span data-ttu-id="a8f46-117">CA2009: ImmutableCollection 値で ToImmutableCollection を呼び出さないでください</span><span class="sxs-lookup"><span data-stu-id="a8f46-117">CA2009: Do not call ToImmutableCollection on an ImmutableCollection value</span></span>](ca2009.md)|<span data-ttu-id="a8f46-118">`ToImmutable` メソッドが <xref:System.Collections.Immutable> 名前空間から変更できないコレクションで不必要に呼び出されました。</span><span class="sxs-lookup"><span data-stu-id="a8f46-118">`ToImmutable` method was unnecessarily called on an immutable collection from <xref:System.Collections.Immutable> namespace.</span></span>|
|[<span data-ttu-id="a8f46-119">CA2011: セッター内でプロパティを割り当てません</span><span class="sxs-lookup"><span data-stu-id="a8f46-119">CA2011: Do not assign property within its setter</span></span>](ca2011.md) | <span data-ttu-id="a8f46-120">プロパティの [set アクセサー](../../../csharp/programming-guide/classes-and-structs/using-properties.md#the-set-accessor)内でプロパティに値が誤って割り当てられました。</span><span class="sxs-lookup"><span data-stu-id="a8f46-120">A property was accidentally assigned a value within its own [set accessor](../../../csharp/programming-guide/classes-and-structs/using-properties.md#the-set-accessor).</span></span> |
|[<span data-ttu-id="a8f46-121">CA2012: ValueTask を正しく使用する必要があります</span><span class="sxs-lookup"><span data-stu-id="a8f46-121">CA2012: Use ValueTasks correctly</span></span>](ca2012.md) | <span data-ttu-id="a8f46-122">メンバーの呼び出しから返される ValueTask は、直接待機される必要があります。</span><span class="sxs-lookup"><span data-stu-id="a8f46-122">ValueTasks returned from member invocations are intended to be directly awaited.</span></span>  <span data-ttu-id="a8f46-123">ValueTask を複数回使用しようとするか、完了が判明する前に結果に直接アクセスしようとすると、例外または破損が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="a8f46-123">Attempts to consume a ValueTask multiple times or to directly access one's result before it's known to be completed may result in an exception or corruption.</span></span>  <span data-ttu-id="a8f46-124">このような ValueTask を無視することは、機能的なバグを示していることが多く、パフォーマンスを低下させる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="a8f46-124">Ignoring such a ValueTask is likely an indication of a functional bug and may degrade performance.</span></span> |
|[<span data-ttu-id="a8f46-125">CA2013: 値の型と共に ReferenceEquals を使用しないでください</span><span class="sxs-lookup"><span data-stu-id="a8f46-125">CA2013: Do not use ReferenceEquals with value types</span></span>](ca2013.md) | <span data-ttu-id="a8f46-126"><xref:System.Object.ReferenceEquals%2A?displayProperty=fullName> を使用して値を比較するときに、objA と objB が値の型である場合、この 2 つは <xref:System.Object.ReferenceEquals%2A> メソッドに渡される前にボックス化されます。</span><span class="sxs-lookup"><span data-stu-id="a8f46-126">When comparing values using <xref:System.Object.ReferenceEquals%2A?displayProperty=fullName>, if objA and objB are value types, they are boxed before they are passed to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="a8f46-127">つまり、objA と objB が同じ値の型のインスタンスを表している場合でも、<xref:System.Object.ReferenceEquals%2A> メソッドからは false が返されます。</span><span class="sxs-lookup"><span data-stu-id="a8f46-127">This means that even if both objA and objB represent the same instance of a value type, the <xref:System.Object.ReferenceEquals%2A> method nevertheless returns false.</span></span> |
|[<span data-ttu-id="a8f46-128">CA2014: ループ内で stackalloc を使用しません</span><span class="sxs-lookup"><span data-stu-id="a8f46-128">CA2014: Do not use stackalloc in loops.</span></span>](ca2014.md) | <span data-ttu-id="a8f46-129">stackalloc によって割り当てられたスタック領域は、現在のメソッド呼び出しの終了時にのみ解放されます。</span><span class="sxs-lookup"><span data-stu-id="a8f46-129">Stack space allocated by a stackalloc is only released at the end of the current method's invocation.</span></span>  <span data-ttu-id="a8f46-130">これをループ内で使用すると、スタックが無限に増加し、最終的にスタック オーバーフロー状態が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="a8f46-130">Using it in a loop can result in unbounded stack growth and eventual stack overflow conditions.</span></span> |
|[<span data-ttu-id="a8f46-131">CA2015: MemoryManager から派生した型にはファイナライザーを定義しません&lt;T&gt;</span><span class="sxs-lookup"><span data-stu-id="a8f46-131">CA2015: Do not define finalizers for types derived from MemoryManager&lt;T&gt;</span></span>](ca2015.md) | <span data-ttu-id="a8f46-132"><xref:System.Buffers.MemoryManager%601> から派生した型にファイナライザーを追加すると、<xref:System.Span%601> によってまだ使用中のメモリが解放される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="a8f46-132">Adding a finalizer to a type derived from <xref:System.Buffers.MemoryManager%601> may permit memory to be freed while it is still in use by a <xref:System.Span%601>.</span></span> |
|[<span data-ttu-id="a8f46-133">CA2016:CancellationToken パラメーターを 1 つのメソッドに転送する</span><span class="sxs-lookup"><span data-stu-id="a8f46-133">CA2016: Forward the CancellationToken parameter to methods that take one</span></span>](ca2016.md) | <span data-ttu-id="a8f46-134">`CancellationToken` パラメーターを 1 つを取るメソッドに転送して操作のキャンセル通知が適切に伝達されるようにするか、または `CancellationToken.None` を明示的に渡して意図的にトークンを伝達しないことを指定します。</span><span class="sxs-lookup"><span data-stu-id="a8f46-134">Forward the `CancellationToken` parameter to methods that take one to ensure the operation cancellation notifications gets properly propagated, or pass in `CancellationToken.None` explicitly to indicate intentionally not propagating the token.</span></span> |
