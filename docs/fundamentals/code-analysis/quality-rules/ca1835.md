---
title: 'CA1835: ストリームベースのクラスで ReadAsync/WriteAsync メソッドのメモリベースのオーバーロードを優先する (コード分析)'
description: 'コード分析規則 CA1835: ストリームベースのクラスで ReadAsync/WriteAsync メソッドのメモリベースのオーバーロードを優先するについて説明します'
ms.date: 05/11/2020
ms.topic: reference
f1_keywords:
- PreferStreamAsyncMemoryOverloads
- CA1835
helpviewer_keywords:
- PreferStreamAsyncMemoryOverloads
- CA1835
author: carlossanlop
ms.author: calope
dev_langs:
- CSharp
- VB
ms.openlocfilehash: 5febce07d38bd3781601d6d70a663c779eaa6d66
ms.sourcegitcommit: 05d0087dfca85aac9ca2960f86c5efd218bf833f
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/27/2021
ms.locfileid: "105637274"
---
# <a name="ca1835-prefer-the-memory-based-overloads-of-readasyncwriteasync-methods-in-stream-based-classes"></a><span data-ttu-id="0d031-103">CA1835: ストリームベースのクラスで ReadAsync/WriteAsync メソッドのメモリベースのオーバーロードを優先する</span><span class="sxs-lookup"><span data-stu-id="0d031-103">CA1835: Prefer the memory-based overloads of ReadAsync/WriteAsync methods in stream-based classes</span></span>

| | <span data-ttu-id="0d031-104">値</span><span class="sxs-lookup"><span data-stu-id="0d031-104">Value</span></span> |
|-|-|
| <span data-ttu-id="0d031-105">**型名**</span><span class="sxs-lookup"><span data-stu-id="0d031-105">**Type name**</span></span> |<span data-ttu-id="0d031-106">PreferStreamAsyncMemoryOverloads</span><span class="sxs-lookup"><span data-stu-id="0d031-106">PreferStreamAsyncMemoryOverloads</span></span>|
| <span data-ttu-id="0d031-107">**ルール ID**</span><span class="sxs-lookup"><span data-stu-id="0d031-107">**Rule ID**</span></span> |<span data-ttu-id="0d031-108">CA1835</span><span class="sxs-lookup"><span data-stu-id="0d031-108">CA1835</span></span>|
| <span data-ttu-id="0d031-109">**カテゴリ**</span><span class="sxs-lookup"><span data-stu-id="0d031-109">**Category**</span></span> |[<span data-ttu-id="0d031-110">パフォーマンス</span><span class="sxs-lookup"><span data-stu-id="0d031-110">Performance</span></span>](performance-warnings.md)|
| <span data-ttu-id="0d031-111">**修正が中断ありか中断なしか**</span><span class="sxs-lookup"><span data-stu-id="0d031-111">**Fix is breaking or non-breaking**</span></span> |<span data-ttu-id="0d031-112">なし</span><span class="sxs-lookup"><span data-stu-id="0d031-112">Non-breaking</span></span>|

## <a name="cause"></a><span data-ttu-id="0d031-113">原因</span><span class="sxs-lookup"><span data-stu-id="0d031-113">Cause</span></span>

<span data-ttu-id="0d031-114">この規則は、`ReadAsync` および `WriteAsync` のバイト配列ベースのメソッドのオーバーロードの待機中の呼び出しを特定し、より効率的であるという理由から、代わりにメモリベースのメソッドのオーバーロードを使用することを提案します。</span><span class="sxs-lookup"><span data-stu-id="0d031-114">This rule locates awaited invocations of the byte-array-based method overloads for `ReadAsync` and `WriteAsync`, and suggests using the memory-based method overloads instead, because they are more efficient.</span></span>

## <a name="rule-description"></a><span data-ttu-id="0d031-115">規則の説明</span><span class="sxs-lookup"><span data-stu-id="0d031-115">Rule description</span></span>

<span data-ttu-id="0d031-116">メモリベースのメソッドのオーバーロードは、バイト配列ベースのものよりもメモリ使用の効率性に優れています。</span><span class="sxs-lookup"><span data-stu-id="0d031-116">The memory-based method overloads have a more efficient memory usage than the byte array-based ones.</span></span>

<span data-ttu-id="0d031-117">この規則は、<xref:System.IO.Stream> から継承するすべてのクラスの `ReadAsync` および `WriteAsync` 呼び出しで機能します。</span><span class="sxs-lookup"><span data-stu-id="0d031-117">The rule works on `ReadAsync` and `WriteAsync` invocations of any class that inherits from <xref:System.IO.Stream>.</span></span>

<span data-ttu-id="0d031-118">この規則は、メソッドの前に `await` キーワードが付いている場合にのみ機能します。</span><span class="sxs-lookup"><span data-stu-id="0d031-118">The rule only works when the method is preceded by the `await` keyword.</span></span>

|<span data-ttu-id="0d031-119">検出されたメソッド</span><span class="sxs-lookup"><span data-stu-id="0d031-119">Detected method</span></span>|<span data-ttu-id="0d031-120">提案されたメソッド</span><span class="sxs-lookup"><span data-stu-id="0d031-120">Suggested method</span></span>|
|-|-|
|<xref:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)>|<xref:System.IO.Stream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)>|
|<xref:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)>|<span data-ttu-id="0d031-121"><xref:System.IO.Stream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)>。`CancellationToken` は、C# では `default` に、Visual Basic では `Nothing` に設定します。</span><span class="sxs-lookup"><span data-stu-id="0d031-121"><xref:System.IO.Stream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)> with `CancellationToken` set to `default` in C#, or `Nothing` in Visual Basic.</span></span>|
|<xref:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)>|<xref:System.IO.Stream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)>|
|<xref:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)>|<span data-ttu-id="0d031-122"><xref:System.IO.Stream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)>。`CancellationToken` は、C# では `default` に、Visual Basic では `Nothing` に設定します。</span><span class="sxs-lookup"><span data-stu-id="0d031-122"><xref:System.IO.Stream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)> with `CancellationToken` set to `default` in C#, or `Nothing` in Visual Basic.</span></span>|

> [!IMPORTANT]
> <span data-ttu-id="0d031-123">`offset` および `count` の整数の引数を、作成された `Memory` または `ReadOnlyMemory` のインスタンスに渡すようにしてください。</span><span class="sxs-lookup"><span data-stu-id="0d031-123">Make sure to pass the `offset` and `count` integer arguments to the created `Memory` or `ReadOnlyMemory` instances.</span></span>

> [!NOTE]
> <span data-ttu-id="0d031-124">規則 CA1835 は、メモリベースのオーバーロードが使用可能なすべての .NET バージョンで使用できます。</span><span class="sxs-lookup"><span data-stu-id="0d031-124">Rule CA1835 is available in all .NET versions where the memory-based overloads are available:</span></span>
>
> - <span data-ttu-id="0d031-125">.NET Standard 2.1 以降。</span><span class="sxs-lookup"><span data-stu-id="0d031-125">.NET Standard 2.1 and above.</span></span>
> - <span data-ttu-id="0d031-126">.NET Core 2.1 以降。</span><span class="sxs-lookup"><span data-stu-id="0d031-126">.NET Core 2.1 and above.</span></span>

## <a name="how-to-fix-violations"></a><span data-ttu-id="0d031-127">違反の修正方法</span><span class="sxs-lookup"><span data-stu-id="0d031-127">How to fix violations</span></span>

<span data-ttu-id="0d031-128">これらは手動で修正することも、メソッドの呼び出しの横に表示される電球にマウス カーソルを置いて、提案された変更を選択することによって、Visual Studio に実行を任せることを選ぶこともできます。</span><span class="sxs-lookup"><span data-stu-id="0d031-128">You can either fix them manually, or you can opt to let Visual Studio do it for you, by hovering over the light bulb that shows up next to the method invocation, and selecting the suggested change.</span></span> <span data-ttu-id="0d031-129">例:</span><span class="sxs-lookup"><span data-stu-id="0d031-129">Example:</span></span>

![CA1835 - ストリームベースのクラスで ReadAsync/WriteAsync メソッドのメモリベースのオーバーロードを優先するのコード修正](media/ca1835-codefix.png)

<span data-ttu-id="0d031-131">この規則によって、`ReadAsync` と `WriteAsync` メソッドのさまざまな違反を検出できます。</span><span class="sxs-lookup"><span data-stu-id="0d031-131">The rule can detect a variety of violations for the `ReadAsync` and `WriteAsync` methods.</span></span> <span data-ttu-id="0d031-132">規則が検出できるケースの例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="0d031-132">Here are examples of the cases that the rule can detect:</span></span>

### <a name="example-1"></a><span data-ttu-id="0d031-133">例 1</span><span class="sxs-lookup"><span data-stu-id="0d031-133">Example 1</span></span>

<span data-ttu-id="0d031-134">`CancellationToken` 引数を指定しないときと指定したときの `ReadAsync` の呼び出し:</span><span class="sxs-lookup"><span data-stu-id="0d031-134">Invocations of `ReadAsync`, without and with a `CancellationToken` argument:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod(CancellationToken ct)
    {
        using (FileStream s = new FileStream("path.txt", FileMode.Create))
        {
            byte[] buffer = new byte[s.Length];
            await s.ReadAsync(buffer, 0, buffer.Length);
            await s.ReadAsync(buffer, 0, buffer.Length, ct);
        }
    }
}
```

<span data-ttu-id="0d031-135">解決策:</span><span class="sxs-lookup"><span data-stu-id="0d031-135">Fix:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod(CancellationToken ct)
    {
        using (FileStream s = new FileStream("path.txt", FileMode.Create))
        {
            byte[] buffer = new byte[s.Length];
            await s.ReadAsync(buffer.AsMemory(0, buffer.Length));
            await s.ReadAsync(buffer.AsMemory(0, buffer.Length), ct);
        }
    }
}
```

### <a name="example-2"></a><span data-ttu-id="0d031-136">例 2</span><span class="sxs-lookup"><span data-stu-id="0d031-136">Example 2</span></span>

<span data-ttu-id="0d031-137">`CancellationToken` 引数を指定しないときと指定したときの `WriteAsync` の呼び出し:</span><span class="sxs-lookup"><span data-stu-id="0d031-137">Invocations of `WriteAsync`, without and with a `CancellationToken` argument:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod(CancellationToken ct)
    {
        using (FileStream s = File.Open("path.txt", FileMode.Open))
        {
            byte[] buffer = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
            await s.WriteAsync(buffer, 0, buffer.Length);
            await s.WriteAsync(buffer, 0, buffer.Length, ct);
        }
    }
}
```

<span data-ttu-id="0d031-138">解決策:</span><span class="sxs-lookup"><span data-stu-id="0d031-138">Fix:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod()
    {
        using (FileStream s = File.Open("path.txt", FileMode.Open))
        {
            byte[] buffer = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
            await s.WriteAsync(buffer.AsMemory(0, buffer.Length));
            await s.WriteAsync(buffer.AsMemory(0, buffer.Length), ct);
        }
    }
}
```

### <a name="example-3"></a><span data-ttu-id="0d031-139">例 3</span><span class="sxs-lookup"><span data-stu-id="0d031-139">Example 3</span></span>

<span data-ttu-id="0d031-140">`ConfigureAwait` を使用した呼び出し:</span><span class="sxs-lookup"><span data-stu-id="0d031-140">Invocations with `ConfigureAwait`:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod()
    {
        using (FileStream s = File.Open("path.txt", FileMode.Open))
        {
            byte[] buffer1 = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
            await s.WriteAsync(buffer1, 0, buffer1.Length).ConfigureAwait(false);

            byte[] buffer2 = new byte[s.Length];
            await s.ReadAsync(buffer2, 0, buffer2.Length).ConfigureAwait(true);
        }
    }
}
```

<span data-ttu-id="0d031-141">解決策:</span><span class="sxs-lookup"><span data-stu-id="0d031-141">Fix:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod()
    {
        using (FileStream s = File.Open("path.txt", FileMode.Open))
        {
            byte[] buffer1 = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
            await s.WriteAsync(buffer1.AsMemory(0, buffer1.Length)).ConfigureAwait(false);

            byte[] buffer2 = new byte[s.Length];
            await s.ReadAsync(buffer2.AsMemory(0, buffer.Length)).ConfigureAwait(true);
        }
    }
}
```

## <a name="non-violations"></a><span data-ttu-id="0d031-142">非違反</span><span class="sxs-lookup"><span data-stu-id="0d031-142">Non-violations</span></span>

<span data-ttu-id="0d031-143">次に、規則が実行され **ない** 呼び出しの例をいくつか示します。</span><span class="sxs-lookup"><span data-stu-id="0d031-143">Following are some examples of invocations where the rule will **not** be fired.</span></span>

<span data-ttu-id="0d031-144">戻り値は、待機するのではなく、`Task` 変数に保存されます。</span><span class="sxs-lookup"><span data-stu-id="0d031-144">The return value is saved in a `Task` variable instead of being awaited:</span></span>

```cs
using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

class MyClass
{
    public void MyMethod()
    {
        byte[] buffer = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
        using (FileStream s = new FileStream("path.txt", FileMode.Create))
        {
            Task t = s.WriteAsync(buffer, 0, buffer.Length);
        }
    }
}
```

<span data-ttu-id="0d031-145">戻り値は、待機するのではなく、折り返しメソッドによって返されます。</span><span class="sxs-lookup"><span data-stu-id="0d031-145">The return value is returned by the wrapping method instead of being awaited:</span></span>

```cs
using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

class MyClass
{
    public Task MyMethod(FileStream s, byte[] buffer)
    {
        return s.WriteAsync(buffer, 0, buffer.Length);
    }
}
```

<span data-ttu-id="0d031-146">戻り値は、待機中のメソッド `ContinueWith` を呼び出すために使用されます。</span><span class="sxs-lookup"><span data-stu-id="0d031-146">The return value is used to call `ContinueWith`, which is the method being awaited:</span></span>

```cs
using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

class MyClass
{
    public void MyMethod()
    {
        byte[] buffer = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
        using (FileStream s = new FileStream("path.txt", FileMode.Create))
        {
            await s.WriteAsync(buffer, 0, buffer.Length).ContinueWith(c => { /* ... */ });
        }
    }
}
```

## <a name="when-to-suppress-warnings"></a><span data-ttu-id="0d031-147">どのようなときに警告を抑制するか</span><span class="sxs-lookup"><span data-stu-id="0d031-147">When to suppress warnings</span></span>

<span data-ttu-id="0d031-148">ストリームベースのクラスでバッファーの読み取りまたは書き込み時のパフォーマンスの向上に関心がない場合は、この規則の違反を抑制することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="0d031-148">It's safe to suppress a violation of this rule if you're not concerned about improving performance when reading or writing buffers in stream-based classes.</span></span>

## <a name="see-also"></a><span data-ttu-id="0d031-149">関連項目</span><span class="sxs-lookup"><span data-stu-id="0d031-149">See also</span></span>

- [<span data-ttu-id="0d031-150">パフォーマンス ルール</span><span class="sxs-lookup"><span data-stu-id="0d031-150">Performance rules</span></span>](performance-warnings.md)
