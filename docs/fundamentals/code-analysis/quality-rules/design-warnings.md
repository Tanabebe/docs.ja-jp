---
title: デザイン規則 (コード分析)
description: コード分析デザイン規則について説明します。
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.designrules
helpviewer_keywords:
- design rules
- managed code analysis rules, design rules
- rules, design
author: gewarren
ms.author: gewarren
ms.openlocfilehash: 548e0eaaa6239a9b9ee6a08677cd720710bb48c2
ms.sourcegitcommit: 05d0087dfca85aac9ca2960f86c5efd218bf833f
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/30/2021
ms.locfileid: "99714132"
---
# <a name="design-rules"></a><span data-ttu-id="540a0-103">デザイン規則</span><span class="sxs-lookup"><span data-stu-id="540a0-103">Design rules</span></span>

<span data-ttu-id="540a0-104">デザイン規則は、[.NET Framework デザイン ガイドライン](../../../standard/design-guidelines/index.md)の順守をサポートします。</span><span class="sxs-lookup"><span data-stu-id="540a0-104">Design rules support adherence to the [.NET Framework design guidelines](../../../standard/design-guidelines/index.md).</span></span>

## <a name="in-this-section"></a><span data-ttu-id="540a0-105">このセクションの内容</span><span class="sxs-lookup"><span data-stu-id="540a0-105">In this section</span></span>

| <span data-ttu-id="540a0-106">ルール</span><span class="sxs-lookup"><span data-stu-id="540a0-106">Rule</span></span> | <span data-ttu-id="540a0-107">説明</span><span class="sxs-lookup"><span data-stu-id="540a0-107">Description</span></span> |
| - | - |
| [<span data-ttu-id="540a0-108">CA1000:ジェネリック型の静的メンバーを宣言しません</span><span class="sxs-lookup"><span data-stu-id="540a0-108">CA1000: Do not declare static members on generic types</span></span>](ca1000.md) | <span data-ttu-id="540a0-109">ジェネリック型の静的メンバーを呼び出すときには、その型の型引数も指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="540a0-109">When a static member of a generic type is called, the type argument must be specified for the type.</span></span> <span data-ttu-id="540a0-110">推論をサポートしないジェネリック インスタンス メンバーを呼び出すときには、そのメンバーに型引数を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="540a0-110">When a generic instance member that does not support inference is called, the type argument must be specified for the member.</span></span> <span data-ttu-id="540a0-111">この 2 つの場合、型引数を指定するときに使用される構文は異なりますが、混同される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="540a0-111">In these two cases, the syntax for specifying the type argument is different and easily confused.</span></span> |
| [<span data-ttu-id="540a0-112">CA1001:破棄可能なフィールドを所有する型は、破棄可能でなければなりません</span><span class="sxs-lookup"><span data-stu-id="540a0-112">CA1001: Types that own disposable fields should be disposable</span></span>](ca1001.md) | <span data-ttu-id="540a0-113">クラスが System.IDisposable 型であるインスタンス フィールドを宣言および実装していますが、IDisposable を実装していません。</span><span class="sxs-lookup"><span data-stu-id="540a0-113">A class declares and implements an instance field that is a System.IDisposable type and the class does not implement IDisposable.</span></span> <span data-ttu-id="540a0-114">IDisposable フィールドを宣言するクラスは間接的にアンマネージ リソースを所有しているため、IDisposable インターフェイスを実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="540a0-114">A class that declares an IDisposable field indirectly owns an unmanaged resource and should implement the IDisposable interface.</span></span> |
| [<span data-ttu-id="540a0-115">CA1002:ジェネリック リストを公開しません</span><span class="sxs-lookup"><span data-stu-id="540a0-115">CA1002: Do not expose generic lists</span></span>](ca1002.md) | <span data-ttu-id="540a0-116">System.Collections.Generic.List<(Of \<(T>)>) は継承ではなくパフォーマンスを目的としたジェネリック コレクションです。</span><span class="sxs-lookup"><span data-stu-id="540a0-116">System.Collections.Generic.List<(Of \<(T>)>) is a generic collection that is designed for performance, not inheritance.</span></span> <span data-ttu-id="540a0-117">このため、List には仮想メンバーは含まれません。</span><span class="sxs-lookup"><span data-stu-id="540a0-117">Therefore, List does not contain any virtual members.</span></span> <span data-ttu-id="540a0-118">代わりに、継承を目的としたジェネリック コレクションを公開する必要があります。</span><span class="sxs-lookup"><span data-stu-id="540a0-118">The generic collections that are designed for inheritance should be exposed instead.</span></span> |
| [<span data-ttu-id="540a0-119">CA1003:汎用イベント ハンドラーのインスタンスを使用します</span><span class="sxs-lookup"><span data-stu-id="540a0-119">CA1003: Use generic event handler instances</span></span>](ca1003.md) | <span data-ttu-id="540a0-120">型に void を返すデリゲートが含まれており、デリゲートのシグネチャに 2 つのパラメーター (1 つはオブジェクト、もう 1 つは EventArgs に割り当て可能な型) が含まれ、包含アセンブリの対象が .NET Framework 2.0. です。</span><span class="sxs-lookup"><span data-stu-id="540a0-120">A type contains a delegate that returns void, whose signature contains two parameters (the first an object and the second a type that is assignable to EventArgs), and the containing assembly targets .NET Framework 2.0.</span></span> |
| [<span data-ttu-id="540a0-121">CA1005:ジェネリック型でパラメーターを使用しすぎないでください</span><span class="sxs-lookup"><span data-stu-id="540a0-121">CA1005: Avoid excessive parameters on generic types</span></span>](ca1005.md) | <span data-ttu-id="540a0-122">ジェネリック型に含まれる型パラメーターが増えれば増えるほど、それぞれの型パラメーターが表す意味を調べることや覚えることが難しくなります。</span><span class="sxs-lookup"><span data-stu-id="540a0-122">The more type parameters a generic type contains, the more difficult it is to know and remember what each type parameter represents.</span></span> <span data-ttu-id="540a0-123">通常、List\<T> のように型パラメーターが 1 つの場合や、Dictionary\<TKey, TValue> のように型パラメーターが 2 つの場合、意味は明確です。</span><span class="sxs-lookup"><span data-stu-id="540a0-123">It is usually obvious with one type parameter, as in List\<T>, and in certain cases with two type parameters, as in Dictionary\<TKey, TValue>.</span></span> <span data-ttu-id="540a0-124">しかし、型パラメーターが 3 つ以上になると、ほとんどのユーザーには意味を把握することが困難になります。</span><span class="sxs-lookup"><span data-stu-id="540a0-124">However, if more than two type parameters exist, the difficulty becomes too great for most users.</span></span> |
| [<span data-ttu-id="540a0-125">CA1008:Enums は 0 値を含んでいなければなりません</span><span class="sxs-lookup"><span data-stu-id="540a0-125">CA1008: Enums should have zero value</span></span>](ca1008.md) | <span data-ttu-id="540a0-126">初期化されていない列挙型の既定値は、他の値型と同様に、ゼロです。</span><span class="sxs-lookup"><span data-stu-id="540a0-126">The default value of an uninitialized enumeration, just as other value types, is zero.</span></span> <span data-ttu-id="540a0-127">フラグではない属性が付いた列挙型では、ゼロの値を使用してメンバーを定義する必要があります。これは、既定値を有効な列挙値にするためです。</span><span class="sxs-lookup"><span data-stu-id="540a0-127">A nonflags attributed enumeration should define a member by using the value of zero so that the default value is a valid value of the enumeration.</span></span> <span data-ttu-id="540a0-128">FlagsAttribute 属性を適用した列挙型でゼロ値のメンバーを定義する場合、名前を "None" にして、列挙型に設定済みの値がないことを示します。</span><span class="sxs-lookup"><span data-stu-id="540a0-128">If an enumeration that has the FlagsAttribute attribute applied defines a zero-valued member, its name should be "None" to indicate that no values have been set in the enumeration.</span></span> |
| [<span data-ttu-id="540a0-129">CA1010:コレクションは、ジェネリック インターフェイスを実装しなければなりません</span><span class="sxs-lookup"><span data-stu-id="540a0-129">CA1010: Collections should implement generic interface</span></span>](ca1010.md) | <span data-ttu-id="540a0-130">コレクションの操作性を拡充するために、ジェネリック コレクション インターフェイスの 1 つを実装します。</span><span class="sxs-lookup"><span data-stu-id="540a0-130">To broaden the usability of a collection, implement one of the generic collection interfaces.</span></span> <span data-ttu-id="540a0-131">これにより、コレクションを使用してジェネリック コレクション型を設定できます。</span><span class="sxs-lookup"><span data-stu-id="540a0-131">Then the collection can be used to populate generic collection types.</span></span> |
| [<span data-ttu-id="540a0-132">CA1012:抽象型にはコンストラクターを含めません</span><span class="sxs-lookup"><span data-stu-id="540a0-132">CA1012: Abstract types should not have constructors</span></span>](ca1012.md) | <span data-ttu-id="540a0-133">抽象型上のコンストラクターは、派生型からのみ呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="540a0-133">Constructors on abstract types can be called only by derived types.</span></span> <span data-ttu-id="540a0-134">パブリック コンストラクターで型のインスタンスが作成され、抽象型のインスタンスは自分で作成できないため、パブリック コンストラクターが含まれる抽象型のデザインは不適切になります。</span><span class="sxs-lookup"><span data-stu-id="540a0-134">Because public constructors create instances of a type, and you cannot create instances of an abstract type, an abstract type that has a public constructor is incorrectly designed.</span></span> |
| [<span data-ttu-id="540a0-135">CA1014:アセンブリに CLSCompliantAttribute を設定します</span><span class="sxs-lookup"><span data-stu-id="540a0-135">CA1014: Mark assemblies with CLSCompliantAttribute</span></span>](ca1014.md) | <span data-ttu-id="540a0-136">共通言語仕様 (CLS) には、名前付けの制約、データ型、および規則が定義されています。アセンブリを複数のプログラミング言語で使用する場合、この仕様に準拠する必要があります。</span><span class="sxs-lookup"><span data-stu-id="540a0-136">The Common Language Specification (CLS) defines naming restrictions, data types, and rules to which assemblies must conform if they will be used across programming languages.</span></span> <span data-ttu-id="540a0-137">すべてのアセンブリに CLSCompliantAttribute を使用して、CLS への準拠を明示することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="540a0-137">Good design dictates that all assemblies explicitly indicate CLS compliance by using CLSCompliantAttribute.</span></span> <span data-ttu-id="540a0-138">この属性が使用されていないアセンブリは、CLS に準拠しません。</span><span class="sxs-lookup"><span data-stu-id="540a0-138">If this attribute is not present on an assembly, the assembly is not compliant.</span></span> |
| [<span data-ttu-id="540a0-139">CA1016:アセンブリに AssemblyVersionAttribute を設定します</span><span class="sxs-lookup"><span data-stu-id="540a0-139">CA1016: Mark assemblies with AssemblyVersionAttribute</span></span>](ca1016.md) | <span data-ttu-id="540a0-140">.NET では、バージョン番号を使用してアセンブリを一意に識別し、厳密な名前を持つアセンブリの型にバインドします。</span><span class="sxs-lookup"><span data-stu-id="540a0-140">.NET uses the version number to uniquely identify an assembly, and to bind to types in strongly named assemblies.</span></span> <span data-ttu-id="540a0-141">バージョン番号は、バージョンと発行者のポリシーと共に使用されます。</span><span class="sxs-lookup"><span data-stu-id="540a0-141">The version number is used together with version and publisher policy.</span></span> <span data-ttu-id="540a0-142">既定で、アプリケーションは、ビルドされたアセンブリのバージョンでのみ実行されます。</span><span class="sxs-lookup"><span data-stu-id="540a0-142">By default, applications run only with the assembly version with which they were built.</span></span> |
| [<span data-ttu-id="540a0-143">CA1017:アセンブリに ComVisibleAttribute を設定します</span><span class="sxs-lookup"><span data-stu-id="540a0-143">CA1017: Mark assemblies with ComVisibleAttribute</span></span>](ca1017.md) | <span data-ttu-id="540a0-144">ComVisibleAttribute 属性によって、COM クライアントからマネージド コードにアクセスする方法が決まります。</span><span class="sxs-lookup"><span data-stu-id="540a0-144">ComVisibleAttribute determines how COM clients access managed code.</span></span> <span data-ttu-id="540a0-145">アセンブリで COM の参照範囲を明示することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="540a0-145">Good design dictates that assemblies explicitly indicate COM visibility.</span></span> <span data-ttu-id="540a0-146">COM の参照範囲は、アセンブリ全体に設定し、個々の型と型のメンバー用にオーバーライドできます。</span><span class="sxs-lookup"><span data-stu-id="540a0-146">COM visibility can be set for the whole assembly and then overridden for individual types and type members.</span></span> <span data-ttu-id="540a0-147">この属性がない場合、アセンブリのコンテンツは COM クライアントから参照できます。</span><span class="sxs-lookup"><span data-stu-id="540a0-147">If this attribute is not present, the contents of the assembly are visible to COM clients.</span></span> |
| [<span data-ttu-id="540a0-148">CA1018:属性を AttributeUsageAttribute に設定します</span><span class="sxs-lookup"><span data-stu-id="540a0-148">CA1018: Mark attributes with AttributeUsageAttribute</span></span>](ca1018.md) | <span data-ttu-id="540a0-149">カスタム属性を定義する場合、AttributeUsageAttribute を使用してマークし、カスタム属性を適用できるソース コードの位置を示します。</span><span class="sxs-lookup"><span data-stu-id="540a0-149">When you define a custom attribute, mark it by using AttributeUsageAttribute to indicate where in the source code the custom attribute can be applied.</span></span> <span data-ttu-id="540a0-150">属性の意味と用途によって、コード内の有効な位置が決まります。</span><span class="sxs-lookup"><span data-stu-id="540a0-150">The meaning and intended usage of an attribute will determine its valid locations in code.</span></span> |
| [<span data-ttu-id="540a0-151">CA1019:属性引数にアクセサーを定義します</span><span class="sxs-lookup"><span data-stu-id="540a0-151">CA1019: Define accessors for attribute arguments</span></span>](ca1019.md) | <span data-ttu-id="540a0-152">属性では、対象に適用するときに必ず指定する必須の引数を定義できます。</span><span class="sxs-lookup"><span data-stu-id="540a0-152">Attributes can define mandatory arguments that must be specified when you apply the attribute to a target.</span></span> <span data-ttu-id="540a0-153">この引数は、コンストラクターに位置指定パラメーターで属性を指定できるようになるため、位置指定引数とも呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="540a0-153">These are also known as positional arguments because they are supplied to attribute constructors as positional parameters.</span></span> <span data-ttu-id="540a0-154">必須のすべての引数について、対応する読み取り専用のプロパティも属性で規定する必要があります。これは、引数値を実行時に取得できるようにするためです。</span><span class="sxs-lookup"><span data-stu-id="540a0-154">For every mandatory argument, the attribute should also provide a corresponding read-only property so that the value of the argument can be retrieved at execution time.</span></span> <span data-ttu-id="540a0-155">また、属性ではオプションの引数も定義できます。これは名前付き引数とも呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="540a0-155">Attributes can also define optional arguments, which are also known as named arguments.</span></span> <span data-ttu-id="540a0-156">この引数は、名前でコンストラクターに属性を指定するときに使用されます。また、対応する読み取り/書き込みプロパティが必要です。</span><span class="sxs-lookup"><span data-stu-id="540a0-156">These arguments are supplied to attribute constructors by name and should have a corresponding read/write property.</span></span> |
| [<span data-ttu-id="540a0-157">CA1021:out パラメーターを使用しません</span><span class="sxs-lookup"><span data-stu-id="540a0-157">CA1021: Avoid out parameters</span></span>](ca1021.md) | <span data-ttu-id="540a0-158">(out または ref を使用した) 型の参照渡しには、ポインターの使用経験、値型と参照型の違いの理解、および複数の戻り値を持つメソッドの処理が必要です。</span><span class="sxs-lookup"><span data-stu-id="540a0-158">Passing types by reference (using out or ref) requires experience with pointers, understanding how value types and reference types differ, and handling methods with multiple return values.</span></span> <span data-ttu-id="540a0-159">また、out パラメーターと ref パラメーターの違いはあまり理解されていません。</span><span class="sxs-lookup"><span data-stu-id="540a0-159">Also, the difference between out and ref parameters is not widely understood.</span></span> |
| [<span data-ttu-id="540a0-160">CA1024:適切な場所にプロパティを使用します</span><span class="sxs-lookup"><span data-stu-id="540a0-160">CA1024: Use properties where appropriate</span></span>](ca1024.md) | <span data-ttu-id="540a0-161">パブリック メソッドまたはプロテクト メソッドに、"Get" で始まる名前が付けられ、パラメーターは使用されていません。また、配列ではない値を返します。</span><span class="sxs-lookup"><span data-stu-id="540a0-161">A public or protected method has a name that starts with "Get", takes no parameters, and returns a value that is not an array.</span></span> <span data-ttu-id="540a0-162">このメソッドは、プロパティに変更できる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="540a0-162">The method might be a good candidate to become a property.</span></span> |
| [<span data-ttu-id="540a0-163">CA1027:列挙型を FlagsAttribute に設定します</span><span class="sxs-lookup"><span data-stu-id="540a0-163">CA1027: Mark enums with FlagsAttribute</span></span>](ca1027.md) | <span data-ttu-id="540a0-164">列挙型は、関連する名前付き定数が複数定義された値型です。</span><span class="sxs-lookup"><span data-stu-id="540a0-164">An enumeration is a value type that defines a set of related named constants.</span></span> <span data-ttu-id="540a0-165">名前付き定数を有意に結合できる場合、列挙型に FlagsAttribute を適用します。</span><span class="sxs-lookup"><span data-stu-id="540a0-165">Apply FlagsAttribute to an enumeration when its named constants can be meaningfully combined.</span></span> |
| [<span data-ttu-id="540a0-166">CA1028:列挙ストレージは Int32 でなければなりません</span><span class="sxs-lookup"><span data-stu-id="540a0-166">CA1028: Enum storage should be Int32</span></span>](ca1028.md) | <span data-ttu-id="540a0-167">列挙型は、関連する名前付き定数が複数定義された値型です。</span><span class="sxs-lookup"><span data-stu-id="540a0-167">An enumeration is a value type that defines a set of related named constants.</span></span> <span data-ttu-id="540a0-168">既定で、System.Int32 データ型は、定数値を格納するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="540a0-168">By default, the System.Int32 data type is used to store the constant value.</span></span> <span data-ttu-id="540a0-169">この基になる型を変更できる場合でも、ほとんどの場合、変更する必要はなく、推奨もされません。</span><span class="sxs-lookup"><span data-stu-id="540a0-169">Even though you can change this underlying type, it is not required or recommended for most scenarios.</span></span> |
| [<span data-ttu-id="540a0-170">CA1030:適切な場所にイベントを使用します</span><span class="sxs-lookup"><span data-stu-id="540a0-170">CA1030: Use events where appropriate</span></span>](ca1030.md) | <span data-ttu-id="540a0-171">この規則では、通常はイベントに使用される名前を持つメソッドを検出します。</span><span class="sxs-lookup"><span data-stu-id="540a0-171">This rule detects methods that have names that ordinarily would be used for events.</span></span> <span data-ttu-id="540a0-172">明示的に定義された状態変化に応答してメソッドが呼び出される場合、メソッドはイベント ハンドラーから呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="540a0-172">If a method is called in response to a clearly defined state change, the method should be invoked by an event handler.</span></span> <span data-ttu-id="540a0-173">メソッドを呼び出すオブジェクトは、メソッドを直接呼び出すのではなく、イベントを発生させる必要があります。</span><span class="sxs-lookup"><span data-stu-id="540a0-173">Objects that call the method should raise events instead of calling the method directly.</span></span> |
| [<span data-ttu-id="540a0-174">CA1031:一般的な例外の種類はキャッチしません</span><span class="sxs-lookup"><span data-stu-id="540a0-174">CA1031: Do not catch general exception types</span></span>](ca1031.md) | <span data-ttu-id="540a0-175">汎用的な例外はキャッチしないでください。</span><span class="sxs-lookup"><span data-stu-id="540a0-175">General exceptions should not be caught.</span></span> <span data-ttu-id="540a0-176">より具体的な例外をキャッチするか、汎用的な例外を catch ブロックの最後のステートメントでスローし直します。</span><span class="sxs-lookup"><span data-stu-id="540a0-176">Catch a more-specific exception, or rethrow the general exception as the last statement in the catch block.</span></span> |
| [<span data-ttu-id="540a0-177">CA1032:標準例外コンストラクターを実装します</span><span class="sxs-lookup"><span data-stu-id="540a0-177">CA1032: Implement standard exception constructors</span></span>](ca1032.md) | <span data-ttu-id="540a0-178">コンストラクターを完全に宣言していないと、例外を正しく処理するのが困難になります。</span><span class="sxs-lookup"><span data-stu-id="540a0-178">Failure to provide the full set of constructors can make it difficult to correctly handle exceptions.</span></span> |
| [<span data-ttu-id="540a0-179">CA1033:インターフェイス メソッドは、子型によって呼び出し可能でなければなりません</span><span class="sxs-lookup"><span data-stu-id="540a0-179">CA1033: Interface methods should be callable by child types</span></span>](ca1033.md) | <span data-ttu-id="540a0-180">シールされていない外部から参照できる型によって、パブリック インターフェイスを持つメソッドを明示的に実装しています。また、同じ名前を持つ外部から参照できる代替のメソッドがありません。</span><span class="sxs-lookup"><span data-stu-id="540a0-180">An unsealed externally visible type provides an explicit method implementation of a public interface and does not provide an alternative externally visible method that has the same name.</span></span> |
| [<span data-ttu-id="540a0-181">CA1034:入れ子にされた型を参照可能にすることはできません</span><span class="sxs-lookup"><span data-stu-id="540a0-181">CA1034: Nested types should not be visible</span></span>](ca1034.md) | <span data-ttu-id="540a0-182">入れ子にされた型とは、別の型のスコープ内で宣言された型のことです。</span><span class="sxs-lookup"><span data-stu-id="540a0-182">A nested type is a type that is declared in the scope of another type.</span></span> <span data-ttu-id="540a0-183">入れ子にされた型は、包含型のプライベート実装の詳細をカプセル化するときに便利です。</span><span class="sxs-lookup"><span data-stu-id="540a0-183">Nested types are useful to encapsulate private implementation details of the containing type.</span></span> <span data-ttu-id="540a0-184">このような用途なので、入れ子にされた型は外部から参照できないようにします。</span><span class="sxs-lookup"><span data-stu-id="540a0-184">Used for this purpose, nested types should not be externally visible.</span></span> |
| [<span data-ttu-id="540a0-185">CA1036:比較可能な型でメソッドをオーバーライドします</span><span class="sxs-lookup"><span data-stu-id="540a0-185">CA1036: Override methods on comparable types</span></span>](ca1036.md) | <span data-ttu-id="540a0-186">パブリック型またはプロテクト型で System.IComparable インターフェイスを実装しています。</span><span class="sxs-lookup"><span data-stu-id="540a0-186">A public or protected type implements the System.IComparable interface.</span></span> <span data-ttu-id="540a0-187">これによって、Object.Equals はオーバーライドされません。また、"等しい"、"等しくない"、"未満"、"より大きい" を示す言語固有の演算子はオーバーロードされません。</span><span class="sxs-lookup"><span data-stu-id="540a0-187">It does not override Object.Equals nor does it overload the language-specific operator for equality, inequality, less than, or greater than.</span></span> |
| [<span data-ttu-id="540a0-188">CA1040:空のインターフェイスは使用しません</span><span class="sxs-lookup"><span data-stu-id="540a0-188">CA1040: Avoid empty interfaces</span></span>](ca1040.md) | <span data-ttu-id="540a0-189">インターフェイスには、動作や使用のコントラクトを実現するメンバーが定義されます。</span><span class="sxs-lookup"><span data-stu-id="540a0-189">Interfaces define members that provide a behavior or usage contract.</span></span> <span data-ttu-id="540a0-190">インターフェイスで示される機能は、継承の階層構造内に型が存在するかどうかにかかわらず、どの型からも適用できます。</span><span class="sxs-lookup"><span data-stu-id="540a0-190">The functionality that is described by the interface can be adopted by any type, regardless of where the type appears in the inheritance hierarchy.</span></span> <span data-ttu-id="540a0-191">型ではインターフェイスのメンバーに実装することで、インターフェイスが実装されます。</span><span class="sxs-lookup"><span data-stu-id="540a0-191">A type implements an interface by providing implementations for the members of the interface.</span></span> <span data-ttu-id="540a0-192">空のインターフェイスではメンバーが定義されません。そのため、実装できるコントラクトも定義されません。</span><span class="sxs-lookup"><span data-stu-id="540a0-192">An empty interface does not define any members; therefore, it does not define a contract that can be implemented.</span></span> |
| [<span data-ttu-id="540a0-193">CA1041:ObsoleteAttribute メッセージを指定します</span><span class="sxs-lookup"><span data-stu-id="540a0-193">CA1041: Provide ObsoleteAttribute message</span></span>](ca1041.md) | <span data-ttu-id="540a0-194">型またはメンバーが System.ObsoleteAttribute 属性を使用してマークされていますが、この属性で ObsoleteAttribute.Message プロパティが指定されていません。</span><span class="sxs-lookup"><span data-stu-id="540a0-194">A type or member is marked by using a System.ObsoleteAttribute attribute that does not have its ObsoleteAttribute.Message property specified.</span></span> <span data-ttu-id="540a0-195">ObsoleteAttribute でマークされている型またはメンバーをコンパイルすると、属性の Message プロパティが表示されます。これにより、互換性のために残されている型またはメンバーに関するユーザー情報が表示されます。</span><span class="sxs-lookup"><span data-stu-id="540a0-195">When a type or member that is marked by using ObsoleteAttribute is compiled, the Message property of the attribute is displayed, which gives the user information about the obsolete type or member.</span></span> |
| [<span data-ttu-id="540a0-196">CA1043:インデクサーには整数または文字列引数を使用します</span><span class="sxs-lookup"><span data-stu-id="540a0-196">CA1043: Use integral or string argument for indexers</span></span>](ca1043.md) | <span data-ttu-id="540a0-197">インデクサー (つまり、インデックスされたプロパティ) では、インデックスに整数型または文字列型を使用します。</span><span class="sxs-lookup"><span data-stu-id="540a0-197">Indexers (that is, indexed properties) should use integral or string types for the index.</span></span> <span data-ttu-id="540a0-198">一般に、このような型はデータ構造のインデックス作成に使用され、ライブラリの操作性も改善されます。</span><span class="sxs-lookup"><span data-stu-id="540a0-198">These types are typically used for indexing data structures and they increase the usability of the library.</span></span> <span data-ttu-id="540a0-199">Object 型の使用は、デザイン時に特定の整数型または文字列型を指定できない場合に限定してください。</span><span class="sxs-lookup"><span data-stu-id="540a0-199">Use of the Object type should be restricted to those cases where the specific integral or string type cannot be specified at design time.</span></span> |
| [<span data-ttu-id="540a0-200">CA1044:プロパティを書き込み専用にすることはできません</span><span class="sxs-lookup"><span data-stu-id="540a0-200">CA1044: Properties should not be write only</span></span>](ca1044.md) | <span data-ttu-id="540a0-201">読み取り専用のプロパティは許容され、必要な場合もよくありますが、書き込み専用のプロパティを使用することはデザインのガイドラインで禁止されています。</span><span class="sxs-lookup"><span data-stu-id="540a0-201">Although it is acceptable and often necessary to have a read-only property, the design guidelines prohibit the use of write-only properties.</span></span> <span data-ttu-id="540a0-202">これは、値を設定できてもその値を参照できず、セキュリティが確保されないためです。</span><span class="sxs-lookup"><span data-stu-id="540a0-202">This is because letting a user set a value, and then preventing the user from viewing that value, does not provide any security.</span></span> <span data-ttu-id="540a0-203">また、読み取りアクセスがないと、共有オブジェクトのステータスを参照できないため、実用性が制限されます。</span><span class="sxs-lookup"><span data-stu-id="540a0-203">Also, without read access, the state of shared objects cannot be viewed, which limits their usefulness.</span></span> |
| [<span data-ttu-id="540a0-204">CA1045:型を参照によって渡しません</span><span class="sxs-lookup"><span data-stu-id="540a0-204">CA1045: Do not pass types by reference</span></span>](ca1045.md) | <span data-ttu-id="540a0-205">(out または ref を使用した) 型の参照渡しには、ポインターの使用経験、値型と参照型の違いの理解、および複数の戻り値を持つメソッドの処理が必要です。</span><span class="sxs-lookup"><span data-stu-id="540a0-205">Passing types by reference (using out or ref) requires experience with pointers, understanding how value types and reference types differ, and handling methods with multiple return values.</span></span> <span data-ttu-id="540a0-206">開発者全般に向けてライブラリをデザインする場合、ユーザーが out パラメーターまたは ref パラメーターの扱い方を習得することは期待しないでください。</span><span class="sxs-lookup"><span data-stu-id="540a0-206">Library architects who design for a general audience should not expect users to master working with out or ref parameters.</span></span> |
| [<span data-ttu-id="540a0-207">CA1046:参照型で、演算子 equals をオーバーロードしないでください</span><span class="sxs-lookup"><span data-stu-id="540a0-207">CA1046: Do not overload operator equals on reference types</span></span>](ca1046.md) | <span data-ttu-id="540a0-208">参照型の場合、等値演算子は既定の実装でほぼ問題がありません。</span><span class="sxs-lookup"><span data-stu-id="540a0-208">For reference types, the default implementation of the equality operator is almost always correct.</span></span> <span data-ttu-id="540a0-209">既定で、2 つの参照が等値と見なされるのは、同じオブジェクトを参照する場合のみです。</span><span class="sxs-lookup"><span data-stu-id="540a0-209">By default, two references are equal only if they point to the same object.</span></span> |
| [<span data-ttu-id="540a0-210">CA1047:シールド型の保護されたメンバーを宣言しません</span><span class="sxs-lookup"><span data-stu-id="540a0-210">CA1047: Do not declare protected members in sealed types</span></span>](ca1047.md) | <span data-ttu-id="540a0-211">型でプロテクト メンバーを宣言するのは、継承する型からメンバーにアクセスまたはオーバーライドできるようにするためです。</span><span class="sxs-lookup"><span data-stu-id="540a0-211">Types declare protected members so that inheriting types can access or override the member.</span></span> <span data-ttu-id="540a0-212">定義により、シールされた型から継承することはできません。これは、シールされた型のプロテクト メソッドを呼び出すことができないということを意味します。</span><span class="sxs-lookup"><span data-stu-id="540a0-212">By definition, sealed types cannot be inherited, which means that protected methods on sealed types cannot be called.</span></span> |
| [<span data-ttu-id="540a0-213">CA1050:名前空間で型を宣言します</span><span class="sxs-lookup"><span data-stu-id="540a0-213">CA1050: Declare types in namespaces</span></span>](ca1050.md) | <span data-ttu-id="540a0-214">型を名前空間内で宣言するのは、名前が衝突しないようにするためと、関連する型をオブジェクト階層形式で編成するためです。</span><span class="sxs-lookup"><span data-stu-id="540a0-214">Types are declared in namespaces to prevent name collisions and as a way to organize related types in an object hierarchy.</span></span> |
| [<span data-ttu-id="540a0-215">CA1051:参照可能なインスタンス フィールドを宣言しません</span><span class="sxs-lookup"><span data-stu-id="540a0-215">CA1051: Do not declare visible instance fields</span></span>](ca1051.md) | <span data-ttu-id="540a0-216">フィールドの主な用途は、実装の詳細にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="540a0-216">The primary use of a field should be as an implementation detail.</span></span> <span data-ttu-id="540a0-217">フィールドは private または internal にし、プロパティによって公開するようにします。</span><span class="sxs-lookup"><span data-stu-id="540a0-217">Fields should be private or internal and should be exposed by using properties.</span></span> |
| [<span data-ttu-id="540a0-218">CA1052:スタティック ホルダー型はシールドされていなければなりません</span><span class="sxs-lookup"><span data-stu-id="540a0-218">CA1052: Static holder types should be sealed</span></span>](ca1052.md) | <span data-ttu-id="540a0-219">パブリック型またはプロテクト型に静的メンバーしかなく、sealed (C#) または NotInheritable (Visual Basic) 修飾子を使用して宣言されていません。</span><span class="sxs-lookup"><span data-stu-id="540a0-219">A public or protected type contains only static members and is not declared by using the sealed (C#) or NotInheritable (Visual Basic) modifier.</span></span> <span data-ttu-id="540a0-220">継承を意図していない型は、sealed 修飾子を使用してマークし、基本型として使用できないようにします。</span><span class="sxs-lookup"><span data-stu-id="540a0-220">A type that is not meant to be inherited should be marked by using the sealed modifier to prevent its use as a base type.</span></span> |
| [<span data-ttu-id="540a0-221">CA1053:スタティック ホルダー型はコンストラクターを含むことはできません</span><span class="sxs-lookup"><span data-stu-id="540a0-221">CA1053: Static holder types should not have constructors</span></span>](ca1053.md) | <span data-ttu-id="540a0-222">パブリック型または入れ子になったパブリック型で、静的なメンバーのみが宣言されています。また、パブリックまたはプロテクトの既定のコンストラクターが含まれます。</span><span class="sxs-lookup"><span data-stu-id="540a0-222">A public or nested public type declares only static members and has a public or protected default constructor.</span></span> <span data-ttu-id="540a0-223">静的メンバーの呼び出しに型のインスタンスは必要ないため、コンストラクターは不要です。</span><span class="sxs-lookup"><span data-stu-id="540a0-223">The constructor is unnecessary because calling static members does not require an instance of the type.</span></span> <span data-ttu-id="540a0-224">安全性とセキュリティを確保するために、文字列引数を使用して文字列オーバーロードで URI (Uniform Resource Identifier) オーバーロードを呼び出してください。</span><span class="sxs-lookup"><span data-stu-id="540a0-224">The string overload should call the uniform resource identifier (URI) overload by using the string argument for safety and security.</span></span> |
| [<span data-ttu-id="540a0-225">CA1054:URI パラメーターを文字列にすることはできません</span><span class="sxs-lookup"><span data-stu-id="540a0-225">CA1054: URI parameters should not be strings</span></span>](ca1054.md) | <span data-ttu-id="540a0-226">メソッドで URI の文字列形式を使用する場合、対応するオーバーロードを宣言し、URI クラスのインスタンスを使用します。こうすることで、安全な方法でこのサービスを実現できます。</span><span class="sxs-lookup"><span data-stu-id="540a0-226">If a method takes a string representation of a URI, a corresponding overload should be provided that takes an instance of the URI class, which provides these services in a safe and secure manner.</span></span> |
| [<span data-ttu-id="540a0-227">CA1055:URI 戻り値を文字列にすることはできません</span><span class="sxs-lookup"><span data-stu-id="540a0-227">CA1055: URI return values should not be strings</span></span>](ca1055.md) | <span data-ttu-id="540a0-228">この規則では、メソッドは URI を返すと想定されます。</span><span class="sxs-lookup"><span data-stu-id="540a0-228">This rule assumes that the method returns a URI.</span></span> <span data-ttu-id="540a0-229">URI の文字列表現は解析エラーやエンコーディング エラーが発生しやすく、セキュリティ上の脆弱性の原因となる場合があります。</span><span class="sxs-lookup"><span data-stu-id="540a0-229">A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities.</span></span> <span data-ttu-id="540a0-230">System.Uri クラスを使用すると、安全な方法でこのサービスを実現できます。</span><span class="sxs-lookup"><span data-stu-id="540a0-230">The System.Uri class provides these services in a safe and secure manner.</span></span> |
| [<span data-ttu-id="540a0-231">CA1056:URI プロパティを文字列にすることはできません</span><span class="sxs-lookup"><span data-stu-id="540a0-231">CA1056: URI properties should not be strings</span></span>](ca1056.md) | <span data-ttu-id="540a0-232">この規則では、プロパティは URI を表すと想定されます。</span><span class="sxs-lookup"><span data-stu-id="540a0-232">This rule assumes that the property represents a URI.</span></span> <span data-ttu-id="540a0-233">URI の文字列表現は解析エラーやエンコーディング エラーが発生しやすく、セキュリティ上の脆弱性の原因となる場合があります。</span><span class="sxs-lookup"><span data-stu-id="540a0-233">A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities.</span></span> <span data-ttu-id="540a0-234">System.Uri クラスを使用すると、安全な方法でこのサービスを実現できます。</span><span class="sxs-lookup"><span data-stu-id="540a0-234">The System.Uri class provides these services in a safe and secure manner.</span></span> |
| [<span data-ttu-id="540a0-235">CA1058:型は、一定の基本型を拡張することはできません</span><span class="sxs-lookup"><span data-stu-id="540a0-235">CA1058: Types should not extend certain base types</span></span>](ca1058.md) | <span data-ttu-id="540a0-236">外部から参照可能な型では、特定の基本型が拡張されます。</span><span class="sxs-lookup"><span data-stu-id="540a0-236">An externally visible type extends certain base types.</span></span> <span data-ttu-id="540a0-237">別の型を使用してください。</span><span class="sxs-lookup"><span data-stu-id="540a0-237">Use one of the alternatives.</span></span> |
| [<span data-ttu-id="540a0-238">CA1060: P/Invoke を NativeMethods クラスに移動します</span><span class="sxs-lookup"><span data-stu-id="540a0-238">CA1060: Move P/Invokes to NativeMethods class</span></span>](ca1060.md) | <span data-ttu-id="540a0-239"><xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=fullName> でマークされているものなどのプラットフォーム呼び出しメソッド、または Visual Basic で Declare キーワードを使用して定義されているメソッドから、アンマネージド コードにアクセスしています。</span><span class="sxs-lookup"><span data-stu-id="540a0-239">Platform Invocation methods, such as those marked with the <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=fullName> or methods defined by using the Declare keyword in Visual Basic, access unmanaged code.</span></span> <span data-ttu-id="540a0-240">これらのメソッドは、NativeMethods、SafeNativeMethods、UnsafeNativeMethods の各クラスのいずれかに含まれる必要があります。</span><span class="sxs-lookup"><span data-stu-id="540a0-240">These methods should be of the NativeMethods, SafeNativeMethods, or UnsafeNativeMethods class.</span></span> |
| [<span data-ttu-id="540a0-241">CA1061:基底クラス メソッドを非表示にしません</span><span class="sxs-lookup"><span data-stu-id="540a0-241">CA1061: Do not hide base class methods</span></span>](ca1061.md) | <span data-ttu-id="540a0-242">派生メソッドのパラメーター シグネチャ内のある型が、基本メソッドのパラメーター シグネチャ内のそれに対応する型より弱く型指定されていることが、両者の唯一の相違点である場合、基本型内のメソッドが派生型内の同じ名前のメソッドによって隠ぺいされます。</span><span class="sxs-lookup"><span data-stu-id="540a0-242">A method in a base type is hidden by an identically named method in a derived type, when the parameter signature of the derived method differs only by types that are more weakly derived than the corresponding types in the parameter signature of the base method.</span></span> |
| [<span data-ttu-id="540a0-243">CA1062:パブリック メソッドの引数の検証</span><span class="sxs-lookup"><span data-stu-id="540a0-243">CA1062: Validate arguments of public methods</span></span>](ca1062.md) | <span data-ttu-id="540a0-244">外部から参照可能なメソッドに渡されるすべての参照引数について、null かどうかをチェックする必要があります。</span><span class="sxs-lookup"><span data-stu-id="540a0-244">All reference arguments that are passed to externally visible methods should be checked against null.</span></span> |
| [<span data-ttu-id="540a0-245">CA1063:IDisposable を正しく実装します</span><span class="sxs-lookup"><span data-stu-id="540a0-245">CA1063: Implement IDisposable correctly</span></span>](ca1063.md) | <span data-ttu-id="540a0-246">すべての IDisposable 型は、Dispose パターンを適切に実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="540a0-246">All IDisposable types should implement the Dispose pattern correctly.</span></span> |
| [<span data-ttu-id="540a0-247">CA1064:例外は public として設定する必要があります</span><span class="sxs-lookup"><span data-stu-id="540a0-247">CA1064: Exceptions should be public</span></span>](ca1064.md) | <span data-ttu-id="540a0-248">内部例外は、その内部スコープ内でのみ認識されます。</span><span class="sxs-lookup"><span data-stu-id="540a0-248">An internal exception is visible only inside its own internal scope.</span></span> <span data-ttu-id="540a0-249">内部スコープの外側にある例外は、基本例外を使用しなければキャッチできません。</span><span class="sxs-lookup"><span data-stu-id="540a0-249">After the exception falls outside the internal scope, only the base exception can be used to catch the exception.</span></span> <span data-ttu-id="540a0-250">内部例外が <xref:System.Exception?displayProperty=fullName>、<xref:System.SystemException?displayProperty=fullName>、または <xref:System.ApplicationException?displayProperty=fullName> を継承している場合、外部コードはその例外の処理に関する十分な情報を取得できません。</span><span class="sxs-lookup"><span data-stu-id="540a0-250">If the internal exception is inherited from <xref:System.Exception?displayProperty=fullName>, <xref:System.SystemException?displayProperty=fullName>, or <xref:System.ApplicationException?displayProperty=fullName>, the external code will not have sufficient information to know what to do with the exception.</span></span> |
| [<span data-ttu-id="540a0-251">CA1065:予期しない場所に例外を発生させません</span><span class="sxs-lookup"><span data-stu-id="540a0-251">CA1065: Do not raise exceptions in unexpected locations</span></span>](ca1065.md) | <span data-ttu-id="540a0-252">例外をスローしないはずのメソッドが例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="540a0-252">A method that is not expected to throw exceptions throws an exception.</span></span> |
| [<span data-ttu-id="540a0-253">CA1066: Equals をオーバーライドする際に IEquatable を実装します</span><span class="sxs-lookup"><span data-stu-id="540a0-253">CA1066: Implement IEquatable when overriding Equals</span></span>](ca1066.md) | <span data-ttu-id="540a0-254">値の型では、<xref:System.Object.Equals%2A> をオーバーライドしていますが、<xref:System.IEquatable%601>を実装していません。</span><span class="sxs-lookup"><span data-stu-id="540a0-254">A value type overrides <xref:System.Object.Equals%2A> method, but does not implement <xref:System.IEquatable%601>.</span></span> |
| [<span data-ttu-id="540a0-255">CA1067: IEquatable を実装するときに Equals をオーバーライドします</span><span class="sxs-lookup"><span data-stu-id="540a0-255">CA1067: Override Equals when implementing IEquatable</span></span>](ca1067.md) | <span data-ttu-id="540a0-256">型では <xref:System.IEquatable%601> を実装していますが、<xref:System.Object.Equals%2A> メソッドをオーバーライドしていません。</span><span class="sxs-lookup"><span data-stu-id="540a0-256">A type implements <xref:System.IEquatable%601>, but does not override <xref:System.Object.Equals%2A> method.</span></span> |
| [<span data-ttu-id="540a0-257">CA1068:CancellationToken パラメーターは最後に指定する必要があります</span><span class="sxs-lookup"><span data-stu-id="540a0-257">CA1068: CancellationToken parameters must come last</span></span>](ca1068.md) | <span data-ttu-id="540a0-258">メソッドに、最後のパラメーターではない CancellationToken パラメーターが指定されています。</span><span class="sxs-lookup"><span data-stu-id="540a0-258">A method has a CancellationToken parameter that is not the last parameter.</span></span> |
| [<span data-ttu-id="540a0-259">CA1069: 列挙型には重複する値を指定できません</span><span class="sxs-lookup"><span data-stu-id="540a0-259">CA1069: Enums should not have duplicate values</span></span>](ca1069.md) | <span data-ttu-id="540a0-260">列挙型に、同じ定数値が明示的に割り当てられている複数のメンバーがあります。</span><span class="sxs-lookup"><span data-stu-id="540a0-260">An enumeration has multiple members which are explicitly assigned the same constant value.</span></span> |
| [<span data-ttu-id="540a0-261">CA1070: イベント フィールドを virtual として宣言しません</span><span class="sxs-lookup"><span data-stu-id="540a0-261">CA1070: Do not declare event fields as virtual</span></span>](ca1070.md) | <span data-ttu-id="540a0-262">[フィールドのように使用するイベント](../../../csharp/event-pattern.md#defining-and-raising-field-like-events)が virtual として宣言されました。</span><span class="sxs-lookup"><span data-stu-id="540a0-262">A [field-like event](../../../csharp/event-pattern.md#defining-and-raising-field-like-events) was declared as virtual.</span></span> |
