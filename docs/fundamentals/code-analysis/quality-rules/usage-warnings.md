---
title: 使用規則 (コード分析)
description: コード分析の使用規則について説明します。
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.usagerules
helpviewer_keywords:
- rules, usage
- managed code analysis rules, usage rules
- usage rules
author: gewarren
ms.author: gewarren
ms.openlocfilehash: b05edde3c6faef39aa724dd49d159abe23d049f5
ms.sourcegitcommit: 42d436ebc2a7ee02fc1848c7742bc7d80e13fc2f
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/04/2021
ms.locfileid: "102102972"
---
# <a name="usage-rules"></a><span data-ttu-id="470e1-103">使い方の規則</span><span class="sxs-lookup"><span data-stu-id="470e1-103">Usage rules</span></span>

<span data-ttu-id="470e1-104">使用規則は、.NET の適切な使用をサポートします。</span><span class="sxs-lookup"><span data-stu-id="470e1-104">Usage rules support proper usage of .NET.</span></span>

## <a name="in-this-section"></a><span data-ttu-id="470e1-105">このセクションの内容</span><span class="sxs-lookup"><span data-stu-id="470e1-105">In this section</span></span>

|<span data-ttu-id="470e1-106">ルール</span><span class="sxs-lookup"><span data-stu-id="470e1-106">Rule</span></span>|<span data-ttu-id="470e1-107">説明</span><span class="sxs-lookup"><span data-stu-id="470e1-107">Description</span></span>|
|----------|-----------------|
|[<span data-ttu-id="470e1-108">CA1801:使用されていないパラメーターの確認</span><span class="sxs-lookup"><span data-stu-id="470e1-108">CA1801: Review unused parameters</span></span>](ca1801.md)|<span data-ttu-id="470e1-109">メソッドのシグネチャに、メソッドの本体で使用されていないパラメーターがあります。</span><span class="sxs-lookup"><span data-stu-id="470e1-109">A method signature includes a parameter that is not used in the method body.</span></span>|
|[<span data-ttu-id="470e1-110">CA1816:GC.SuppressFinalize を正しく呼び出します</span><span class="sxs-lookup"><span data-stu-id="470e1-110">CA1816: Call GC.SuppressFinalize correctly</span></span>](ca1816.md)|<span data-ttu-id="470e1-111">Dispose の実装であるメソッドがを呼び出さないか、 `GC.SuppressFinalize` または呼び出しの実装ではないメソッドである `Dispose` か、 `GC.SuppressFinalize` またはメソッドが `GC.SuppressFinalize` を呼び出し、(Visual Basic) 以外の値を渡してい `this` `Me` ます。</span><span class="sxs-lookup"><span data-stu-id="470e1-111">A method that is an implementation of Dispose does not call `GC.SuppressFinalize`; or a method that is not an implementation of `Dispose` calls `GC.SuppressFinalize`; or a method calls `GC.SuppressFinalize` and passes something other than `this` (`Me` in Visual Basic).</span></span>|
|[<span data-ttu-id="470e1-112">CA2200:スタック詳細を保持するために再度スローします</span><span class="sxs-lookup"><span data-stu-id="470e1-112">CA2200: Rethrow to preserve stack details</span></span>](ca2200.md)|<span data-ttu-id="470e1-113">例外が再スローされ、その例外が throw ステートメントで明示的に指定されています。</span><span class="sxs-lookup"><span data-stu-id="470e1-113">An exception is rethrown and the exception is explicitly specified in the throw statement.</span></span> <span data-ttu-id="470e1-114">throw ステートメントで例外を指定して例外が再スローされると、例外をスローした元のメソッドと現在のメソッドの間で呼び出されたメソッドの一覧は失われます。</span><span class="sxs-lookup"><span data-stu-id="470e1-114">If an exception is rethrown by specifying the exception in the throw statement, the list of method calls between the original method that threw the exception and the current method is lost.</span></span>|
|[<span data-ttu-id="470e1-115">CA2201:予約された例外の種類を発生させません</span><span class="sxs-lookup"><span data-stu-id="470e1-115">CA2201: Do not raise reserved exception types</span></span>](ca2201.md)|<span data-ttu-id="470e1-116">これにより、元のエラーの検出とデバッグが困難になります。</span><span class="sxs-lookup"><span data-stu-id="470e1-116">This makes the original error hard to detect and debug.</span></span>|
|[<span data-ttu-id="470e1-117">CA2207:値型のスタティック フィールドのインラインを初期化します</span><span class="sxs-lookup"><span data-stu-id="470e1-117">CA2207: Initialize value type static fields inline</span></span>](ca2207.md)|<span data-ttu-id="470e1-118">値型で明示的な静的コンストラクターを宣言しています。</span><span class="sxs-lookup"><span data-stu-id="470e1-118">A value type declares an explicit static constructor.</span></span> <span data-ttu-id="470e1-119">この規則違反を修正するには、静的データが宣言されたとき、および静的コンストラクターを削除するときに、静的データをすべて初期化します。</span><span class="sxs-lookup"><span data-stu-id="470e1-119">To fix a violation of this rule, initialize all static data when it is declared and remove the static constructor.</span></span>|
|[<span data-ttu-id="470e1-120">CA2208:引数の例外を正しくインスタンス化します</span><span class="sxs-lookup"><span data-stu-id="470e1-120">CA2208: Instantiate argument exceptions correctly</span></span>](ca2208.md)|<span data-ttu-id="470e1-121">ArgumentException またはそのクラスから派生した例外の種類の既定 (パラメーターなし) のコンストラクターに対して呼び出しが行われたか、ArgumentException またはそのクラスから派生した例外の種類のパラメーター付きのコンストラクターに不適切な文字列型の引数が渡されました。</span><span class="sxs-lookup"><span data-stu-id="470e1-121">A call is made to the default (parameterless) constructor of an exception type that is or derives from ArgumentException, or an incorrect string argument is passed to a parameterized constructor of an exception type that is or derives from ArgumentException.</span></span>|
|[<span data-ttu-id="470e1-122">CA2211:非定数フィールドは表示されません</span><span class="sxs-lookup"><span data-stu-id="470e1-122">CA2211: Non-constant fields should not be visible</span></span>](ca2211.md)|<span data-ttu-id="470e1-123">定数または読み取り専用ではない静的フィールドは、スレッドセーフではありません。</span><span class="sxs-lookup"><span data-stu-id="470e1-123">Static fields that are not constants or read-only are not thread-safe.</span></span> <span data-ttu-id="470e1-124">このようなフィールドへのアクセスは慎重に制御する必要があり、クラスオブジェクトへのアクセスを同期するための高度なプログラミング手法が必要です。</span><span class="sxs-lookup"><span data-stu-id="470e1-124">Access to such a field must be carefully controlled and requires advanced programming techniques for synchronizing access to the class object.</span></span>|
|[<span data-ttu-id="470e1-125">CA2213:破棄可能なフィールドは破棄されなければなりません</span><span class="sxs-lookup"><span data-stu-id="470e1-125">CA2213: Disposable fields should be disposed</span></span>](ca2213.md)|<span data-ttu-id="470e1-126">を実装する型は、 <xref:System.IDisposable?displayProperty=fullName> も実装する型のフィールドを宣言 `IDisposable` します。</span><span class="sxs-lookup"><span data-stu-id="470e1-126">A type that implements <xref:System.IDisposable?displayProperty=fullName> declares fields that are of types that also implement `IDisposable`.</span></span> <span data-ttu-id="470e1-127">`Dispose`フィールドのメソッドが、 `Dispose` 宣言する型のメソッドによって呼び出されていません。</span><span class="sxs-lookup"><span data-stu-id="470e1-127">The `Dispose` method of the field is not called by the `Dispose` method of the declaring type.</span></span>|
|[<span data-ttu-id="470e1-128">CA2214:コンストラクターのオーバーライド可能なメソッドを呼び出しません</span><span class="sxs-lookup"><span data-stu-id="470e1-128">CA2214: Do not call overridable methods in constructors</span></span>](ca2214.md)|<span data-ttu-id="470e1-129">コンストラクターが仮想メソッドを呼び出すと、そのメソッドを呼び出すインスタンスのコンストラクターが実行されていない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="470e1-129">When a constructor calls a virtual method, it is possible that the constructor for the instance that invokes the method has not executed.</span></span>|
|[<span data-ttu-id="470e1-130">CA2215:Dispose メソッドが基底クラスの Dispose を呼び出す必要があります</span><span class="sxs-lookup"><span data-stu-id="470e1-130">CA2215: Dispose methods should call base class dispose</span></span>](ca2215.md)|<span data-ttu-id="470e1-131">型が破棄可能な型から継承する場合は、 `Dispose` 独自のメソッドから基本型のメソッドを呼び出す必要があり `Dispose` ます。</span><span class="sxs-lookup"><span data-stu-id="470e1-131">If a type inherits from a disposable type, it must call the `Dispose` method of the base type from its own `Dispose` method.</span></span>|
|[<span data-ttu-id="470e1-132">CA2216:破棄可能な型はファイナライザーを宣言しなければなりません</span><span class="sxs-lookup"><span data-stu-id="470e1-132">CA2216: Disposable types should declare finalizer</span></span>](ca2216.md)|<span data-ttu-id="470e1-133">を実装し、 <xref:System.IDisposable?displayProperty=fullName> アンマネージリソースの使用を提案するフィールドを持つ型は、「」で説明されているように、ファイナライザーを実装しません `Object.Finalize` 。</span><span class="sxs-lookup"><span data-stu-id="470e1-133">A type that implements <xref:System.IDisposable?displayProperty=fullName>, and has fields that suggest the use of unmanaged resources, does not implement a finalizer as described by `Object.Finalize`.</span></span>|
|[<span data-ttu-id="470e1-134">CA2217:列挙型を FlagsAttribute に設定しません</span><span class="sxs-lookup"><span data-stu-id="470e1-134">CA2217: Do not mark enums with FlagsAttribute</span></span>](ca2217.md)|<span data-ttu-id="470e1-135">外部から参照できる列挙体はでマークされ、 `FlagsAttribute` 1 つ以上の値があります。この値は、列挙体で2つまたはその他の定義済みの値の組み合わせにはなりません。</span><span class="sxs-lookup"><span data-stu-id="470e1-135">An externally visible enumeration is marked with `FlagsAttribute`, and it has one or more values that are not powers of two or a combination of the other defined values on the enumeration.</span></span>|
|[<span data-ttu-id="470e1-136">CA2218:オーバーライドする Equals で GetHashCode をオーバーライドします</span><span class="sxs-lookup"><span data-stu-id="470e1-136">CA2218: Override GetHashCode on overriding Equals</span></span>](ca2218.md)|<span data-ttu-id="470e1-137">パブリック型はを <xref:System.Object.Equals%2A?displayProperty=fullName> オーバーライドしますが、をオーバーライドしません <xref:System.Object.GetHashCode%2A?displayProperty=fullName> 。</span><span class="sxs-lookup"><span data-stu-id="470e1-137">A public type overrides <xref:System.Object.Equals%2A?displayProperty=fullName> but does not override <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</span></span>|
|[<span data-ttu-id="470e1-138">CA2219:exception 句に例外を発生させないでください</span><span class="sxs-lookup"><span data-stu-id="470e1-138">CA2219: Do not raise exceptions in exception clauses</span></span>](ca2219.md)|<span data-ttu-id="470e1-139">finally 句または fault 句で例外が発生すると、アクティブな例外が新しい例外によって隠されます。</span><span class="sxs-lookup"><span data-stu-id="470e1-139">When an exception is raised in a finally or fault clause, the new exception hides the active exception.</span></span> <span data-ttu-id="470e1-140">filter 句で例外が発生すると、ランタイムがその例外を暗黙的にキャッチします。</span><span class="sxs-lookup"><span data-stu-id="470e1-140">When an exception is raised in a filter clause, the run time silently catches the exception.</span></span> <span data-ttu-id="470e1-141">これにより、元のエラーの検出とデバッグが困難になります。</span><span class="sxs-lookup"><span data-stu-id="470e1-141">This makes the original error hard to detect and debug.</span></span>|
|[<span data-ttu-id="470e1-142">CA2224:オーバーロードする演算子 equals で Equals をオーバーライドします</span><span class="sxs-lookup"><span data-stu-id="470e1-142">CA2224: Override equals on overloading operator equals</span></span>](ca2224.md)|<span data-ttu-id="470e1-143">パブリック型で等値演算子が実装されていますが、オーバーライドされていません <xref:System.Object.Equals%2A?displayProperty=fullName> 。</span><span class="sxs-lookup"><span data-stu-id="470e1-143">A public type implements the equality operator but doesn't override <xref:System.Object.Equals%2A?displayProperty=fullName>.</span></span>|
|[<span data-ttu-id="470e1-144">CA2225:演算子オーバーロードには名前付けされた代替が存在します</span><span class="sxs-lookup"><span data-stu-id="470e1-144">CA2225: Operator overloads have named alternates</span></span>](ca2225.md)|<span data-ttu-id="470e1-145">演算子のオーバーロードが検出され、予想される名前の代替メソッドが検出されませんでした。</span><span class="sxs-lookup"><span data-stu-id="470e1-145">An operator overload was detected, and the expected named alternative method was not found.</span></span> <span data-ttu-id="470e1-146">名前付き代替メンバーは、演算子と同じ機能へのアクセスを提供し、オーバーロードされた演算子をサポートしない言語でプログラミングする開発者向けに用意されています。</span><span class="sxs-lookup"><span data-stu-id="470e1-146">The named alternative member provides access to the same functionality as the operator, and is provided for developers who program in languages that do not support overloaded operators.</span></span>|
|[<span data-ttu-id="470e1-147">CA2226:演算子は対称型オーバーロードを含まなければなりません</span><span class="sxs-lookup"><span data-stu-id="470e1-147">CA2226: Operators should have symmetrical overloads</span></span>](ca2226.md)|<span data-ttu-id="470e1-148">型は等値演算子または非等値演算子を実装し、逆の演算子は実装しません。</span><span class="sxs-lookup"><span data-stu-id="470e1-148">A type implements the equality or inequality operator, and does not implement the opposite operator.</span></span>|
|[<span data-ttu-id="470e1-149">CA2227:Collection プロパティは読み取り専用でなければなりません</span><span class="sxs-lookup"><span data-stu-id="470e1-149">CA2227: Collection properties should be read only</span></span>](ca2227.md)|<span data-ttu-id="470e1-150">書き込み可能なコレクション プロパティにより、ユーザーはコレクションを異なるコレクションで置換できます。</span><span class="sxs-lookup"><span data-stu-id="470e1-150">A writable collection property allows a user to replace the collection with a different collection.</span></span> <span data-ttu-id="470e1-151">読み取り専用プロパティは、コレクションを置換できないようにしますが、個別のメンバーが設定されることは回避できません。</span><span class="sxs-lookup"><span data-stu-id="470e1-151">A read-only property stops the collection from being replaced but still allows the individual members to be set.</span></span>|
|[<span data-ttu-id="470e1-152">CA2229:シリアル化コンストラクターを実装します</span><span class="sxs-lookup"><span data-stu-id="470e1-152">CA2229: Implement serialization constructors</span></span>](ca2229.md)|<span data-ttu-id="470e1-153">この規則違反を修正するには、シリアル化コンストラクターを実装します。</span><span class="sxs-lookup"><span data-stu-id="470e1-153">To fix a violation of this rule, implement the serialization constructor.</span></span> <span data-ttu-id="470e1-154">シールされたクラスの場合、コンストラクターをプライベートにするか、プロテクトにします。</span><span class="sxs-lookup"><span data-stu-id="470e1-154">For a sealed class, make the constructor private; otherwise, make it protected.</span></span>|
|[<span data-ttu-id="470e1-155">CA2231:ValueType.Equals のオーバーライドで、演算子 equals をオーバーロードします</span><span class="sxs-lookup"><span data-stu-id="470e1-155">CA2231: Overload operator equals on overriding ValueType.Equals</span></span>](ca2231.md)|<span data-ttu-id="470e1-156">値型はをオーバーライドし `Object.Equals` ますが、等値演算子を実装しません。</span><span class="sxs-lookup"><span data-stu-id="470e1-156">A value type overrides `Object.Equals` but does not implement the equality operator.</span></span>|
|[<span data-ttu-id="470e1-157">CA2234:文字列の代わりに System.Uri オブジェクトを渡します</span><span class="sxs-lookup"><span data-stu-id="470e1-157">CA2234: Pass System.Uri objects instead of strings</span></span>](ca2234.md)|<span data-ttu-id="470e1-158">"uri"、"URI"、"urn"、"URN"、"url"、または "URL" という名前を持つ文字列パラメーターが指定されているメソッドに対して、呼び出しが行われました。</span><span class="sxs-lookup"><span data-stu-id="470e1-158">A call is made to a method that has a string parameter whose name contains "uri", "URI", "urn", "URN", "url", or "URL".</span></span>  <span data-ttu-id="470e1-159">メソッドの宣言する型に、パラメーターを持つ対応するメソッドオーバーロードが含まれてい <xref:System.Uri?displayProperty=fullName> ます。</span><span class="sxs-lookup"><span data-stu-id="470e1-159">The declaring type of the method contains a corresponding method overload that has a <xref:System.Uri?displayProperty=fullName> parameter.</span></span>|
|[<span data-ttu-id="470e1-160">CA2235:すべてのシリアル化不可能なフィールドを設定します</span><span class="sxs-lookup"><span data-stu-id="470e1-160">CA2235: Mark all non-serializable fields</span></span>](ca2235.md)|<span data-ttu-id="470e1-161">シリアル化できない型のインスタンス フィールドが、シリアル化できる型で宣言されています。</span><span class="sxs-lookup"><span data-stu-id="470e1-161">An instance field of a type that is not serializable is declared in a type that is serializable.</span></span>|
|[<span data-ttu-id="470e1-162">CA2237:ISerializable 型を SerializableAttribute に設定します</span><span class="sxs-lookup"><span data-stu-id="470e1-162">CA2237: Mark ISerializable types with SerializableAttribute</span></span>](ca2237.md)|<span data-ttu-id="470e1-163">共通言語ランタイムによってシリアル化可能として認識されるようにするには、型がインターフェイスの実装によってカスタムのシリアル化ルーチンを使用する場合でも、型は SerializableAttribute 属性でマークする必要があり `ISerializable` ます。</span><span class="sxs-lookup"><span data-stu-id="470e1-163">To be recognized by the common language runtime as serializable, types must be marked with the SerializableAttribute attribute even if the type uses a custom serialization routine through implementation of the `ISerializable` interface.</span></span>|
|[<span data-ttu-id="470e1-164">CA2241:書式設定メソッドに正しい引数を提供</span><span class="sxs-lookup"><span data-stu-id="470e1-164">CA2241: Provide correct arguments to formatting methods</span></span>](ca2241.md)|<span data-ttu-id="470e1-165">に渡された書式引数に、 <xref:System.String.Format%2A?displayProperty=nameWithType> 各オブジェクト引数に対応する書式項目が含まれていません。または、その逆も同様です。</span><span class="sxs-lookup"><span data-stu-id="470e1-165">The format argument passed to <xref:System.String.Format%2A?displayProperty=nameWithType> does not contain a format item that corresponds to each object argument, or vice versa.</span></span>|
|[<span data-ttu-id="470e1-166">CA2242:NaN に対して正しくテストします</span><span class="sxs-lookup"><span data-stu-id="470e1-166">CA2242: Test for NaN correctly</span></span>](ca2242.md)|<span data-ttu-id="470e1-167">この式は、またはに対して値をテストし `Single.Nan` `Double.Nan` ます。</span><span class="sxs-lookup"><span data-stu-id="470e1-167">This expression tests a value against `Single.Nan` or `Double.Nan`.</span></span> <span data-ttu-id="470e1-168">`Single.IsNan(Single)`値をテストするには、またはを使用し `Double.IsNan(Double)` ます。</span><span class="sxs-lookup"><span data-stu-id="470e1-168">Use `Single.IsNan(Single)` or `Double.IsNan(Double)` to test the value.</span></span>|
|[<span data-ttu-id="470e1-169">CA2243:属性文字列リテラルは、正しく解析する必要があります</span><span class="sxs-lookup"><span data-stu-id="470e1-169">CA2243: Attribute string literals should parse correctly</span></span>](ca2243.md)|<span data-ttu-id="470e1-170">属性の文字列リテラルパラメーターは、URL、GUID、またはバージョンに対して正しく解析されません。</span><span class="sxs-lookup"><span data-stu-id="470e1-170">An attribute's string literal parameter does not parse correctly for a URL, a GUID, or a version.</span></span>|
|[<span data-ttu-id="470e1-171">CA2244: インデックス付き要素の初期化を重複させません</span><span class="sxs-lookup"><span data-stu-id="470e1-171">CA2244: Do not duplicate indexed element initializations</span></span>](ca2244.md)|<span data-ttu-id="470e1-172">オブジェクト初期化子に、同じ定数インデックスを持つ複数のインデックス付き要素初期化子があります。</span><span class="sxs-lookup"><span data-stu-id="470e1-172">An object initializer has more than one indexed element initializer with the same constant index.</span></span> <span data-ttu-id="470e1-173">最後の初期化子以外はすべて冗長です。</span><span class="sxs-lookup"><span data-stu-id="470e1-173">All but the last initializer are redundant.</span></span>|
|[<span data-ttu-id="470e1-174">CA2245: プロパティをそれ自体に割り当てません</span><span class="sxs-lookup"><span data-stu-id="470e1-174">CA2245: Do not assign a property to itself</span></span>](ca2245.md)|<span data-ttu-id="470e1-175">プロパティが誤ってそれ自体に割り当てられました。</span><span class="sxs-lookup"><span data-stu-id="470e1-175">A property was accidentally assigned to itself.</span></span>|
|[<span data-ttu-id="470e1-176">CA2246: 同じステートメントにシンボルとそのメンバーを割り当てません</span><span class="sxs-lookup"><span data-stu-id="470e1-176">CA2246: Do not assign a symbol and its member in the same statement</span></span>](ca2246.md)|<span data-ttu-id="470e1-177">同じステートメントで、シンボルとそのメンバー (フィールドまたはプロパティ) を割り当てることは推奨されていません。</span><span class="sxs-lookup"><span data-stu-id="470e1-177">Assigning a symbol and its member, that is, a field or a property, in the same statement is not recommended.</span></span> <span data-ttu-id="470e1-178">メンバーアクセスが、割り当ての前にシンボルの古い値を使用するのか、またはこのステートメントの代入の新しい値を使用するのかは明確ではありません。</span><span class="sxs-lookup"><span data-stu-id="470e1-178">It is not clear if the member access was intended to use the symbol's old value prior to the assignment or the new value from the assignment in this statement.</span></span>|
|[<span data-ttu-id="470e1-179">CA2247:TaskCompletionSource コンストラクターに渡された引数は、TaskContinuationOptions 列挙型ではなく、TaskCreationOptions 列挙型にする必要があります</span><span class="sxs-lookup"><span data-stu-id="470e1-179">CA2247: Argument passed to TaskCompletionSource constructor should be TaskCreationOptions enum instead of TaskContinuationOptions enum</span></span>](ca2247.md)|<span data-ttu-id="470e1-180">Taskて Source には、タスクに格納されているオブジェクトの状態を取得する、基になるタスクとコンストラクターを制御する Task/Options を受け取るコンストラクターがあります。</span><span class="sxs-lookup"><span data-stu-id="470e1-180">TaskCompletionSource has constructors that take TaskCreationOptions that control the underlying Task, and constructors that take object state that's stored in the task.</span></span>  <span data-ttu-id="470e1-181">Task/options ではなく Task続行 Ationoptions を渡した場合、オプションが状態として扱われます。</span><span class="sxs-lookup"><span data-stu-id="470e1-181">Accidentally passing a TaskContinuationOptions instead of a TaskCreationOptions will result in the call treating the options as state.</span></span>|
|[<span data-ttu-id="470e1-182">CA2248: 正しい ' enum ' 引数を ' Enum. HasFlag ' に指定してください</span><span class="sxs-lookup"><span data-stu-id="470e1-182">CA2248: Provide correct 'enum' argument to 'Enum.HasFlag'</span></span>](ca2248.md)|<span data-ttu-id="470e1-183">メソッド呼び出しの引数として渡された列挙型 `HasFlag` が、呼び出し元の列挙型と異なります。</span><span class="sxs-lookup"><span data-stu-id="470e1-183">The enum type passed as an argument to the `HasFlag` method call is different from the calling enum type.</span></span>|
|[<span data-ttu-id="470e1-184">CA2249:String.IndexOf の代わりに String.Contains を使用することを検討します</span><span class="sxs-lookup"><span data-stu-id="470e1-184">CA2249: Consider using String.Contains instead of String.IndexOf</span></span>](ca2249.md)|<span data-ttu-id="470e1-185">結果を `string.IndexOf` 使用して部分文字列が存在するかどうかを確認するための呼び出しは、で置き換えることができ `string.Contains` ます。</span><span class="sxs-lookup"><span data-stu-id="470e1-185">Calls to `string.IndexOf` where the result is used to check for the presence or absence of a substring can be replaced by `string.Contains`.</span></span>|
