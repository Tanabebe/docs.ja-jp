---
title: 'CA2000: スコープが失われる前にオブジェクトを破棄する (コード分析)'
description: 'コード分析規則「CA2000: スコープが失われる前にオブジェクトを破棄する」について'
ms.date: 05/14/2019
ms.topic: reference
f1_keywords:
- CA2000
- Dispose objects before losing scope
- DisposeObjectsBeforeLosingScope
helpviewer_keywords:
- CA2000
- DisposeObjectsBeforeLosingScope
author: gewarren
ms.author: gewarren
dev_langs:
- CSharp
- VB
ms.openlocfilehash: 2e8f2d58ae8f8799fde51cc15522277cbc90988a
ms.sourcegitcommit: 05d0087dfca85aac9ca2960f86c5efd218bf833f
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/30/2021
ms.locfileid: "99792428"
---
# <a name="ca2000-dispose-objects-before-losing-scope"></a><span data-ttu-id="ddbdb-103">CA2000:スコープを失う前にオブジェクトを破棄</span><span class="sxs-lookup"><span data-stu-id="ddbdb-103">CA2000: Dispose objects before losing scope</span></span>

| | <span data-ttu-id="ddbdb-104">値</span><span class="sxs-lookup"><span data-stu-id="ddbdb-104">Value</span></span> |
|-|-|
| <span data-ttu-id="ddbdb-105">**ルール ID**</span><span class="sxs-lookup"><span data-stu-id="ddbdb-105">**Rule ID**</span></span> |<span data-ttu-id="ddbdb-106">CA2000</span><span class="sxs-lookup"><span data-stu-id="ddbdb-106">CA2000</span></span>|
| <span data-ttu-id="ddbdb-107">**カテゴリ**</span><span class="sxs-lookup"><span data-stu-id="ddbdb-107">**Category**</span></span> |[<span data-ttu-id="ddbdb-108">信頼性</span><span class="sxs-lookup"><span data-stu-id="ddbdb-108">Reliability</span></span>](reliability-warnings.md)|
| <span data-ttu-id="ddbdb-109">**修正が中断か中断なしであるか**</span><span class="sxs-lookup"><span data-stu-id="ddbdb-109">**Fix is breaking or non-breaking**</span></span> |<span data-ttu-id="ddbdb-110">なし</span><span class="sxs-lookup"><span data-stu-id="ddbdb-110">Non-breaking</span></span>|

## <a name="cause"></a><span data-ttu-id="ddbdb-111">原因</span><span class="sxs-lookup"><span data-stu-id="ddbdb-111">Cause</span></span>

<span data-ttu-id="ddbdb-112"><xref:System.IDisposable> 型のローカル オブジェクトが作成されていますが、そのオブジェクトに対するすべての参照がスコープ外になる前に、オブジェクトが破棄されていません。</span><span class="sxs-lookup"><span data-stu-id="ddbdb-112">A local object of an <xref:System.IDisposable> type is created, but the object is not disposed before all references to the object are out of scope.</span></span>

<span data-ttu-id="ddbdb-113">既定で、このルールではコードベース全体を分析しますが、これは[構成可能](#configure-code-to-analyze)です。</span><span class="sxs-lookup"><span data-stu-id="ddbdb-113">By default, this rule analyzes the entire codebase, but this is [configurable](#configure-code-to-analyze).</span></span>

## <a name="rule-description"></a><span data-ttu-id="ddbdb-114">規則の説明</span><span class="sxs-lookup"><span data-stu-id="ddbdb-114">Rule description</span></span>

<span data-ttu-id="ddbdb-115">破棄できるオブジェクトに対するすべての参照がスコープ外になる前に、オブジェクトが明示的に破棄されない場合、ガベージ コレクターでオブジェクトのファイナライザーが実行されるときに破棄されますが、タイミングは一定ではありません。</span><span class="sxs-lookup"><span data-stu-id="ddbdb-115">If a disposable object is not explicitly disposed before all references to it are out of scope, the object will be disposed at some indeterminate time when the garbage collector runs the finalizer of the object.</span></span> <span data-ttu-id="ddbdb-116">例外的なイベントが発生するとオブジェクトのファイナライザーを実行できないため、オブジェクトは明示的に破棄する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ddbdb-116">Because an exceptional event might occur that will prevent the finalizer of the object from running, the object should be explicitly disposed instead.</span></span>

## <a name="special-cases"></a><span data-ttu-id="ddbdb-117">特殊なケース</span><span class="sxs-lookup"><span data-stu-id="ddbdb-117">Special cases</span></span>

<span data-ttu-id="ddbdb-118">オブジェクトが破棄されていない場合でも、次の型のローカル オブジェクトに対して規則 CA2000 は適用されません。</span><span class="sxs-lookup"><span data-stu-id="ddbdb-118">Rule CA2000 does not fire for local objects of the following types even if the object is not disposed:</span></span>

- <xref:System.IO.Stream?displayProperty=nameWithType>
- <xref:System.IO.StringReader?displayProperty=nameWithType>
- <xref:System.IO.TextReader?displayProperty=nameWithType>
- <xref:System.IO.TextWriter?displayProperty=nameWithType>
- <xref:System.Resources.IResourceReader?displayProperty=nameWithType>

<span data-ttu-id="ddbdb-119">これらの型のオブジェクトをコンストラクターに渡し、それをフィールドに割り当てると、新しく構築された型への "*破棄の所有権の譲渡*" が行われます。</span><span class="sxs-lookup"><span data-stu-id="ddbdb-119">Passing an object of one of these types to a constructor and then assigning it to a field indicates a *dispose ownership transfer* to the newly constructed type.</span></span> <span data-ttu-id="ddbdb-120">つまり、新しく構築された型がオブジェクトの破棄を担当するようになります。</span><span class="sxs-lookup"><span data-stu-id="ddbdb-120">That is, the newly constructed type is now responsible for disposing of the object.</span></span> <span data-ttu-id="ddbdb-121">コードがこれらの型のいずれかのオブジェクトをコンストラクターに渡すと、そのオブジェクトへのすべての参照がスコープ外になる前に、オブジェクトが破棄されていない場合でも、規則 CA2000 の違反は発生しません。</span><span class="sxs-lookup"><span data-stu-id="ddbdb-121">If your code passes an object of one of these types to a constructor, no violation of rule CA2000 occurs even if the object is not disposed before all references to it are out of scope.</span></span>

## <a name="how-to-fix-violations"></a><span data-ttu-id="ddbdb-122">違反の修正方法</span><span class="sxs-lookup"><span data-stu-id="ddbdb-122">How to fix violations</span></span>

<span data-ttu-id="ddbdb-123">この規則違反を修正するには、オブジェクトに対するすべての参照がスコープ外になる前に、そのオブジェクトで <xref:System.IDisposable.Dispose%2A> を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="ddbdb-123">To fix a violation of this rule, call <xref:System.IDisposable.Dispose%2A> on the object before all references to it are out of scope.</span></span>

<span data-ttu-id="ddbdb-124">[`using` ステートメント](../../../csharp/language-reference/keywords/using-statement.md) (Visual Basic の場合は [`Using`](../../../visual-basic/language-reference/statements/using-statement.md)) を使用して、<xref:System.IDisposable> を実装するオブジェクトをラップすることができます。</span><span class="sxs-lookup"><span data-stu-id="ddbdb-124">You can use the [`using` statement](../../../csharp/language-reference/keywords/using-statement.md) ([`Using`](../../../visual-basic/language-reference/statements/using-statement.md) in Visual Basic) to wrap objects that implement <xref:System.IDisposable>.</span></span> <span data-ttu-id="ddbdb-125">この方法でラップされたオブジェクトは、`using` ブロックの終わりで自動的に破棄されます。</span><span class="sxs-lookup"><span data-stu-id="ddbdb-125">Objects that are wrapped in this manner are automatically disposed at the end of the `using` block.</span></span> <span data-ttu-id="ddbdb-126">ただし、次の状況は、`using` ステートメントを使用して処理することはできません。</span><span class="sxs-lookup"><span data-stu-id="ddbdb-126">However, the following situations should not or cannot be handled with a `using` statement:</span></span>

- <span data-ttu-id="ddbdb-127">破棄可能なオブジェクトを返すには、オブジェクトが `using` ブロックの外側の `try/finally` ブロック内に構築されている必要があります。</span><span class="sxs-lookup"><span data-stu-id="ddbdb-127">To return a disposable object, the object must constructed in a `try/finally` block outside of a `using` block.</span></span>

- <span data-ttu-id="ddbdb-128">`using` ステートメントのコンストラクターで、破棄可能なオブジェクトのメンバーを初期化しないでください。</span><span class="sxs-lookup"><span data-stu-id="ddbdb-128">Do not initialize members of a disposable object in the constructor of a `using` statement.</span></span>

- <span data-ttu-id="ddbdb-129">1 つだけの例外ハンドラーによって保護されているコンストラクターが [`using` ステートメントの取得部分](../../../csharp/language-reference/keywords/using-statement.md)で入れ子になっている場合、外側のコンストラクターでエラーが発生すると、入れ子になったコンストラクターによって作成されるオブジェクトが閉じられなくなる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="ddbdb-129">When constructors that are protected by only one exception handler are nested in the [acquisition part of a `using` statement](../../../csharp/language-reference/keywords/using-statement.md), a failure in the outer constructor can result in the object created by the nested constructor never being closed.</span></span> <span data-ttu-id="ddbdb-130">次の例では、<xref:System.IO.StreamReader> コンストラクターでエラーが発生すると、<xref:System.IO.FileStream> オブジェクトが閉じられなくなる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="ddbdb-130">In the following example, a failure in the <xref:System.IO.StreamReader> constructor can result in the <xref:System.IO.FileStream> object never being closed.</span></span> <span data-ttu-id="ddbdb-131">CA2000 は、この場合の規則違反にフラグを設定します。</span><span class="sxs-lookup"><span data-stu-id="ddbdb-131">CA2000 flags a violation of the rule in this case.</span></span>

   ```csharp
   using (StreamReader sr = new StreamReader(new FileStream("C:\myfile.txt", FileMode.Create)))
   { ... }
   ```

- <span data-ttu-id="ddbdb-132">動的オブジェクトは、シャドウ オブジェクトを使用して <xref:System.IDisposable> オブジェクトの破棄パターンを実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ddbdb-132">Dynamic objects should use a shadow object to implement the dispose pattern of <xref:System.IDisposable> objects.</span></span>

## <a name="when-to-suppress-warnings"></a><span data-ttu-id="ddbdb-133">どのようなときに警告を抑制するか</span><span class="sxs-lookup"><span data-stu-id="ddbdb-133">When to suppress warnings</span></span>

<span data-ttu-id="ddbdb-134">以下の場合を除き、この規則による警告は抑制しないでください。</span><span class="sxs-lookup"><span data-stu-id="ddbdb-134">Do not suppress a warning from this rule unless:</span></span>

- <span data-ttu-id="ddbdb-135">`Dispose` を呼び出すオブジェクトでメソッド (<xref:System.IO.Stream.Close%2A> など) を呼び出した。</span><span class="sxs-lookup"><span data-stu-id="ddbdb-135">You've called a method on your object that calls `Dispose`, such as <xref:System.IO.Stream.Close%2A></span></span>
- <span data-ttu-id="ddbdb-136">警告を発生させたメソッドが、オブジェクトをラップする <xref:System.IDisposable> オブジェクトを返す。</span><span class="sxs-lookup"><span data-stu-id="ddbdb-136">The method that raised the warning returns an <xref:System.IDisposable> object that wraps your object</span></span>
- <span data-ttu-id="ddbdb-137">割り当てメソッドに破棄の所有権がない。つまり、オブジェクトを破棄する責任が、メソッドで作成され、呼び出し元に返される別のオブジェクトまたはラッパーに移行されている。</span><span class="sxs-lookup"><span data-stu-id="ddbdb-137">The allocating method does not have dispose ownership; that is, the responsibility to dispose the object is transferred to another object or wrapper that's created in the method and returned to the caller</span></span>

## <a name="configure-code-to-analyze"></a><span data-ttu-id="ddbdb-138">分析するコードを構成する</span><span class="sxs-lookup"><span data-stu-id="ddbdb-138">Configure code to analyze</span></span>

<span data-ttu-id="ddbdb-139">次のオプションを使用して、コードベースのどの部分に対してこのルールを実行するかを構成します。</span><span class="sxs-lookup"><span data-stu-id="ddbdb-139">Use the following options to configure which parts of your codebase to run this rule on.</span></span>

- [<span data-ttu-id="ddbdb-140">特定のシンボルを除外する</span><span class="sxs-lookup"><span data-stu-id="ddbdb-140">Exclude specific symbols</span></span>](#exclude-specific-symbols)
- [<span data-ttu-id="ddbdb-141">特定の型とその派生型を除外する</span><span class="sxs-lookup"><span data-stu-id="ddbdb-141">Exclude specific types and their derived types</span></span>](#exclude-specific-types-and-their-derived-types)

<span data-ttu-id="ddbdb-142">これらのオプションを構成できる対象は、この規則だけ、すべての規則、このカテゴリ ([信頼性](reliability-warnings.md)) のすべての規則のいずれかです。</span><span class="sxs-lookup"><span data-stu-id="ddbdb-142">You can configure these options for just this rule, for all rules, or for all rules in this category ([Reliability](reliability-warnings.md)).</span></span> <span data-ttu-id="ddbdb-143">詳細については、「[コード品質規則の構成オプション](../code-quality-rule-options.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ddbdb-143">For more information, see [Code quality rule configuration options](../code-quality-rule-options.md).</span></span>

[!INCLUDE[excluded-symbol-names](~/includes/code-analysis/excluded-symbol-names.md)]

[!INCLUDE[excluded-type-names-with-derived-types](~/includes/code-analysis/excluded-type-names-with-derived-types.md)]

## <a name="related-rules"></a><span data-ttu-id="ddbdb-144">関連規則</span><span class="sxs-lookup"><span data-stu-id="ddbdb-144">Related rules</span></span>

- [<span data-ttu-id="ddbdb-145">CA2213:破棄可能なフィールドは破棄されなければなりません</span><span class="sxs-lookup"><span data-stu-id="ddbdb-145">CA2213: Disposable fields should be disposed</span></span>](ca2213.md)

## <a name="example-1"></a><span data-ttu-id="ddbdb-146">例 1</span><span class="sxs-lookup"><span data-stu-id="ddbdb-146">Example 1</span></span>

<span data-ttu-id="ddbdb-147">破棄可能なオブジェクトを返すメソッドを実装している場合は、catch ブロックのない try/finally ブロックを使用して、そのオブジェクトが確実に破棄されるようにします。</span><span class="sxs-lookup"><span data-stu-id="ddbdb-147">If you're implementing a method that returns a disposable object, use a try/finally block without a catch block to make sure that the object is disposed.</span></span> <span data-ttu-id="ddbdb-148">try/finally ブロックを使用することによって、障害点での例外の発生が可能になり、そのオブジェクトが確実に破棄されます。</span><span class="sxs-lookup"><span data-stu-id="ddbdb-148">By using a try/finally block, you allow exceptions to be raised at the fault point and make sure that object is disposed.</span></span>

<span data-ttu-id="ddbdb-149">OpenPort1 メソッドでは、ISerializable オブジェクトの SerialPort を開くための呼び出し、または SomeMethod の呼び出しが失敗する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="ddbdb-149">In the OpenPort1 method, the call to open the ISerializable object SerialPort or the call to SomeMethod can fail.</span></span> <span data-ttu-id="ddbdb-150">この実装では CA2000 警告は発生しません。</span><span class="sxs-lookup"><span data-stu-id="ddbdb-150">A CA2000 warning is raised on this implementation.</span></span>

<span data-ttu-id="ddbdb-151">OpenPort2 メソッドでは、次の 2 つの SerialPort オブジェクトが宣言され、null に設定されます。</span><span class="sxs-lookup"><span data-stu-id="ddbdb-151">In the OpenPort2 method, two SerialPort objects are declared and set to null:</span></span>

- <span data-ttu-id="ddbdb-152">`tempPort`。メソッド操作が成功しているかどうかをテストするのに使用されます。</span><span class="sxs-lookup"><span data-stu-id="ddbdb-152">`tempPort`, which is used to test that the method operations succeed.</span></span>

- <span data-ttu-id="ddbdb-153">`port`。メソッドの戻り値に使用されます。</span><span class="sxs-lookup"><span data-stu-id="ddbdb-153">`port`, which is used for the return value of the method.</span></span>

<span data-ttu-id="ddbdb-154">`tempPort` は、`try` ブロックで構築され、開かれます。その他必要な作業も同じ `try` ブロック内で実行されます。</span><span class="sxs-lookup"><span data-stu-id="ddbdb-154">The `tempPort` is constructed and opened in a `try` block, and any other required work is performed in the same `try` block.</span></span> <span data-ttu-id="ddbdb-155">`try` ブロックの最後に、開かれたポートが `port` オブジェクトに割り当てられ、このオブジェクトが返されます。`tempPort` オブジェクトは `null` に設定されます。</span><span class="sxs-lookup"><span data-stu-id="ddbdb-155">At the end of the `try` block, the opened port is assigned to the `port` object that will be returned and the `tempPort` object is set to `null`.</span></span>

<span data-ttu-id="ddbdb-156">`finally` ブロックは `tempPort` 値をチェックします。</span><span class="sxs-lookup"><span data-stu-id="ddbdb-156">The `finally` block checks the value of `tempPort`.</span></span> <span data-ttu-id="ddbdb-157">null でない場合、メソッド内の操作は失敗しています。`tempPort` は閉じられ、すべてのリソースが解放されます。</span><span class="sxs-lookup"><span data-stu-id="ddbdb-157">If it is not null, an operation in the method has failed, and `tempPort` is closed to make sure that any resources are released.</span></span> <span data-ttu-id="ddbdb-158">返されるオブジェクトには、メソッド操作が成功した場合、開かれた SerialPort オブジェクトが含まれます。メソッドの操作が失敗した場合は null になります。</span><span class="sxs-lookup"><span data-stu-id="ddbdb-158">The returned port object will contain the opened SerialPort object if the operations of the method succeeded, or it will be null if an operation failed.</span></span>

```csharp
public SerialPort OpenPort1(string portName)
{
   SerialPort port = new SerialPort(portName);
   port.Open();  //CA2000 fires because this might throw
   SomeMethod(); //Other method operations can fail
   return port;
}

public SerialPort OpenPort2(string portName)
{
   SerialPort tempPort = null;
   SerialPort port = null;
   try
   {
      tempPort = new SerialPort(portName);
      tempPort.Open();
      SomeMethod();
      //Add any other methods above this line
      port = tempPort;
      tempPort = null;

   }
   finally
   {
      if (tempPort != null)
      {
         tempPort.Close();
      }
   }
   return port;
}
```

```vb
Public Function OpenPort1(ByVal PortName As String) As SerialPort

   Dim port As New SerialPort(PortName)
   port.Open()    'CA2000 fires because this might throw
   SomeMethod()   'Other method operations can fail
   Return port

End Function

Public Function OpenPort2(ByVal PortName As String) As SerialPort

   Dim tempPort As SerialPort = Nothing
   Dim port As SerialPort = Nothing

   Try
      tempPort = New SerialPort(PortName)
      tempPort.Open()
      SomeMethod()
      'Add any other methods above this line
      port = tempPort
      tempPort = Nothing

   Finally
      If Not tempPort Is Nothing Then
         tempPort.Close()
      End If

   End Try

   Return port

End Function
```

## <a name="example-2"></a><span data-ttu-id="ddbdb-159">例 2</span><span class="sxs-lookup"><span data-stu-id="ddbdb-159">Example 2</span></span>

<span data-ttu-id="ddbdb-160">Visual Basic コンパイラは既定ですべての算術演算子のオーバーフローをチェックします。</span><span class="sxs-lookup"><span data-stu-id="ddbdb-160">By default, the Visual Basic compiler has all arithmetic operators check for overflow.</span></span> <span data-ttu-id="ddbdb-161">そのため、いずれかの Visual Basic 算術演算子で <xref:System.OverflowException> がスローされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="ddbdb-161">Therefore, any Visual Basic arithmetic operation might throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="ddbdb-162">これにより、CA2000 のような予期しない規則違反が発生する場合があります。</span><span class="sxs-lookup"><span data-stu-id="ddbdb-162">This could lead to unexpected violations in rules such as CA2000.</span></span> <span data-ttu-id="ddbdb-163">たとえば、次の CreateReader1 関数では、Visual Basic コンパイラが加算に対するオーバーフロー チェックを実行し、それが例外をスローすると StreamReader が破棄されなくなるので、CA2000 違反が発生します。</span><span class="sxs-lookup"><span data-stu-id="ddbdb-163">For example, the following CreateReader1 function will produce a CA2000 violation because the Visual Basic compiler is emitting an overflow checking instruction for the addition that could throw an exception that would cause the StreamReader not to be disposed.</span></span>

<span data-ttu-id="ddbdb-164">これを修正するには、プロジェクトで Visual Basic コンパイラによるオーバーフロー チェックの実施を無効にするか、または次の CreateReader2 関数のようにコードを変更します。</span><span class="sxs-lookup"><span data-stu-id="ddbdb-164">To fix this, you can disable the emitting of overflow checks by the Visual Basic compiler in your project or you can modify your code as in the following CreateReader2 function.</span></span>

<span data-ttu-id="ddbdb-165">オーバーフロー チェックの実施を無効にするには、ソリューション エクスプローラーでプロジェクト名を右クリックし、 **[プロパティ]** をクリックします。</span><span class="sxs-lookup"><span data-stu-id="ddbdb-165">To disable the emitting of overflow checks, right-click the project name in Solution Explorer and then click **Properties**.</span></span> <span data-ttu-id="ddbdb-166">**[コンパイル]** をクリックし、 **[詳細コンパイル オプション]** をクリックし、 **[整数オーバーフローのチェックを解除]** をオンにします。</span><span class="sxs-lookup"><span data-stu-id="ddbdb-166">Click **Compile**, click **Advanced Compile Options**, and then check **Remove integer overflow checks**.</span></span>

:::code language="vb" source="snippets/vb/all-rules/ca2000-dispose-objects-before-losing-scope-vboverflow_1.vb":::

## <a name="see-also"></a><span data-ttu-id="ddbdb-167">こちらもご覧ください</span><span class="sxs-lookup"><span data-stu-id="ddbdb-167">See also</span></span>

- <xref:System.IDisposable>
- [<span data-ttu-id="ddbdb-168">Dispose パターン</span><span class="sxs-lookup"><span data-stu-id="ddbdb-168">Dispose Pattern</span></span>](../../../standard/garbage-collection/implementing-dispose.md)
