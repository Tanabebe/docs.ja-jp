---
title: パフォーマンス規則 (コード分析)
description: コード分析のパフォーマンス規則について説明します。
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.performancerules
helpviewer_keywords:
- rules, performance
- performance rules
- performance, rules
- managed code analysis rules, performance rules
author: gewarren
ms.author: gewarren
ms.openlocfilehash: 4409cc46eb73f13f8e59d7a51899da27035bb6af
ms.sourcegitcommit: 05d0087dfca85aac9ca2960f86c5efd218bf833f
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/30/2021
ms.locfileid: "96591192"
---
# <a name="performance-rules"></a><span data-ttu-id="7fa1c-103">パフォーマンス ルール</span><span class="sxs-lookup"><span data-stu-id="7fa1c-103">Performance rules</span></span>

<span data-ttu-id="7fa1c-104">パフォーマンス規則は、高パフォーマンスのライブラリとアプリケーションをサポートします。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-104">Performance rules support high-performance libraries and applications.</span></span>

## <a name="in-this-section"></a><span data-ttu-id="7fa1c-105">このセクションの内容</span><span class="sxs-lookup"><span data-stu-id="7fa1c-105">In this section</span></span>

| <span data-ttu-id="7fa1c-106">ルール</span><span class="sxs-lookup"><span data-stu-id="7fa1c-106">Rule</span></span> | <span data-ttu-id="7fa1c-107">説明</span><span class="sxs-lookup"><span data-stu-id="7fa1c-107">Description</span></span> |
| - | - |
| [<span data-ttu-id="7fa1c-108">CA1802:適切な場所にリテラルを使用します</span><span class="sxs-lookup"><span data-stu-id="7fa1c-108">CA1802: Use Literals Where Appropriate</span></span>](ca1802.md) | <span data-ttu-id="7fa1c-109">フィールドが static および read-only (Visual Basic では Shared および ReadOnly) として宣言され、コンパイル時に計算できる値によって初期化されています。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-109">A field is declared static and read-only (Shared and ReadOnly in Visual Basic), and is initialized with a value that is computable at compile time.</span></span> <span data-ttu-id="7fa1c-110">対象フィールドに代入された値はコンパイル時に計算できるので、宣言を const (Visual Basic では Const) フィールドに変更して、値が実行時ではなくコンパイル時に計算されるようにします。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-110">Because the value that is assigned to the targeted field is computable at compile time, change the declaration to a const (Const in Visual Basic) field so that the value is computed at compile time instead of at run time.</span></span> |
| [<span data-ttu-id="7fa1c-111">CA1805: 不必要に初期化しない</span><span class="sxs-lookup"><span data-stu-id="7fa1c-111">CA1805: Do not initialize unnecessarily</span></span>](ca1805.md) | <span data-ttu-id="7fa1c-112">.NET ランタイムでは、コンストラクターを実行する前に参照型のすべてのフィールドを既定値に初期化します。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-112">The .NET runtime initializes all fields of reference types to their default values before running the constructor.</span></span> <span data-ttu-id="7fa1c-113">ほとんどの場合、フィールドを明示的に既定値に初期化することは冗長であり、メンテナンス コストが増加し、パフォーマンスが低下 (アセンブリのサイズの増加など) する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-113">In most cases, explicitly initializing a field to its default value is redundant, which adds to maintenance costs and may degrade performance (such as with increased assembly size).</span></span> |
| [<span data-ttu-id="7fa1c-114">CA1806:メソッドの結果を無視しない</span><span class="sxs-lookup"><span data-stu-id="7fa1c-114">CA1806: Do not ignore method results</span></span>](ca1806.md) | <span data-ttu-id="7fa1c-115">新しく作成されたオブジェクトが現在まで使用されていないか、新しい文字列を作成して返すメソッドが呼び出されて作成された新しい文字列が現在まで使用されていません。あるいは、コンポーネント オブジェクト モデル (COM) または P/Invoke メソッドから返された HRESULT またはエラー コードが現在まで使用されていません。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-115">A new object is created but never used, or a method that creates and returns a new string is called and the new string is never used, or a Component Object Model (COM) or P/Invoke method returns an HRESULT or error code that is never used.</span></span> |
| [<span data-ttu-id="7fa1c-116">CA1810:参照型の静的フィールドをインラインで初期化します</span><span class="sxs-lookup"><span data-stu-id="7fa1c-116">CA1810: Initialize reference type static fields inline</span></span>](ca1810.md) | <span data-ttu-id="7fa1c-117">型で明示的な静的コンストラクターを宣言すると、Just-In-Time (JIT) コンパイラが、静的コンストラクターが呼び出されたことを確認するために、型の静的メソッドと静的インスタンス コンストラクターに個別にチェックを追加します。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-117">When a type declares an explicit static constructor, the just-in-time (JIT) compiler adds a check to each static method and instance constructor of the type to make sure that the static constructor was previously called.</span></span> <span data-ttu-id="7fa1c-118">静的コンストラクターのチェックによってパフォーマンスが低下することがあります。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-118">Static constructor checks can decrease performance.</span></span> |
| [<span data-ttu-id="7fa1c-119">CA1812:インスタンス化されていない内部クラスを使用しません</span><span class="sxs-lookup"><span data-stu-id="7fa1c-119">CA1812: Avoid uninstantiated internal classes</span></span>](ca1812.md) | <span data-ttu-id="7fa1c-120">アセンブリ レベルの型のインスタンスが、アセンブリ内のコードから作成されません。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-120">An instance of an assembly-level type is not created by code in the assembly.</span></span> |
| [<span data-ttu-id="7fa1c-121">CA1813:アンシールド属性を使用しません</span><span class="sxs-lookup"><span data-stu-id="7fa1c-121">CA1813: Avoid unsealed attributes</span></span>](ca1813.md) | <span data-ttu-id="7fa1c-122">.NET には、カスタム属性を取得するメソッドが用意されています。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-122">.NET provides methods for retrieving custom attributes.</span></span> <span data-ttu-id="7fa1c-123">既定では、これらのメソッドで属性の継承階層が検索されます。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-123">By default, these methods search the attribute inheritance hierarchy.</span></span> <span data-ttu-id="7fa1c-124">属性をシールすると、継承階層の全体が検索されなくなるため、パフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-124">Sealing the attribute eliminates the search through the inheritance hierarchy and can improve performance.</span></span> |
| [<span data-ttu-id="7fa1c-125">CA1814:複数次元の配列ではなくジャグ配列を使用します</span><span class="sxs-lookup"><span data-stu-id="7fa1c-125">CA1814: Prefer jagged arrays over multidimensional</span></span>](ca1814.md) | <span data-ttu-id="7fa1c-126">ジャグ配列とは、その要素も配列である配列です。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-126">A jagged array is an array whose elements are arrays.</span></span> <span data-ttu-id="7fa1c-127">要素を構成する配列のサイズは異なってもよいため、データ セットによっては無駄な空間が少なくなります。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-127">The arrays that make up the elements can be of different sizes, which can result in less wasted space for some sets of data.</span></span> |
| [<span data-ttu-id="7fa1c-128">CA1815:equals および operator equals を値型でオーバーライドします</span><span class="sxs-lookup"><span data-stu-id="7fa1c-128">CA1815: Override equals and operator equals on value types</span></span>](ca1815.md) | <span data-ttu-id="7fa1c-129">値型の場合、Equals を継承した実装が Reflection ライブラリを使用して、すべてのフィールドの内容を比較します。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-129">For value types, the inherited implementation of Equals uses the Reflection library and compares the contents of all fields.</span></span> <span data-ttu-id="7fa1c-130">Reflection は計算コストが高いため、場合によってはすべてのフィールドで等値性を比較する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-130">Reflection is computationally expensive, and comparing every field for equality might be unnecessary.</span></span> <span data-ttu-id="7fa1c-131">ユーザーがインスタンスの比較または並べ替えを行うことや、ハッシュ テーブル キーとしてインスタンスを使用することが予想される場合には、値型に Equals を実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-131">If you expect users to compare or sort instances, or to use instances as hash table keys, your value type should implement Equals.</span></span> |
| [<span data-ttu-id="7fa1c-132">CA1819:プロパティは、配列を返すことはできません</span><span class="sxs-lookup"><span data-stu-id="7fa1c-132">CA1819: Properties should not return arrays</span></span>](ca1819.md) | <span data-ttu-id="7fa1c-133">プロパティが読み取り専用であっても、プロパティで返される配列は書き込みから保護されません。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-133">Arrays that are returned by properties are not write-protected, even if the property is read-only.</span></span> <span data-ttu-id="7fa1c-134">配列の改ざんを防ぐには、プロパティで配列のコピーを返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-134">To keep the array tamper-proof, the property must return a copy of the array.</span></span> <span data-ttu-id="7fa1c-135">一般に、このようなプロパティを呼び出すときのパフォーマンス低下は理解されません。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-135">Typically, users will not understand the adverse performance implications of calling such a property.</span></span> |
| [<span data-ttu-id="7fa1c-136">CA1820:文字列の長さを使用して空の文字列をテストします</span><span class="sxs-lookup"><span data-stu-id="7fa1c-136">CA1820: Test for empty strings using string length</span></span>](ca1820.md) | <span data-ttu-id="7fa1c-137">String.Length プロパティまたは String.IsNullOrEmpty メソッドを使用して文字列を比較する方法は、Equals を使用する場合よりもはるかに高速です。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-137">Comparing strings by using the String.Length property or the String.IsNullOrEmpty method is significantly faster than using Equals.</span></span> |
| [<span data-ttu-id="7fa1c-138">CA1821:空のファイナライザーを削除します</span><span class="sxs-lookup"><span data-stu-id="7fa1c-138">CA1821: Remove empty finalizers</span></span>](ca1821.md) | <span data-ttu-id="7fa1c-139">オブジェクトの有効期間の追跡に関連するパフォーマンス オーバーヘッドが増大するため、ファイナライザーは可能な限り使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-139">Whenever you can, avoid finalizers because of the additional performance overhead that is involved in tracking object lifetime.</span></span> <span data-ttu-id="7fa1c-140">空のファイナライザーを使用すると、オーバーヘッドが増大するだけで何の利点もありません。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-140">An empty finalizer incurs added overhead without any benefit.</span></span> |
| [<span data-ttu-id="7fa1c-141">CA1822:メンバーを static に設定します</span><span class="sxs-lookup"><span data-stu-id="7fa1c-141">CA1822: Mark members as static</span></span>](ca1822.md) | <span data-ttu-id="7fa1c-142">インスタンス データにアクセスしない、またはインスタンス メソッドを呼び出さないメンバーは、静的 (Visual Basic では Shared) としてマークできます。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-142">Members that do not access instance data or call instance methods can be marked as static (Shared in Visual Basic).</span></span> <span data-ttu-id="7fa1c-143">メソッドを静的としてマークすると、コンパイラはこれらのメンバーに対する非仮想呼び出しサイトを出力します。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-143">After you mark the methods as static, the compiler will emit nonvirtual call sites to these members.</span></span> <span data-ttu-id="7fa1c-144">パフォーマンス重視のコードでは、これにより大きくパフォーマンスを向上できます。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-144">This can give you a measurable performance gain for performance-sensitive code.</span></span> |
| [<span data-ttu-id="7fa1c-145">CA1823:使用されていないプライベート フィールドを使用しません</span><span class="sxs-lookup"><span data-stu-id="7fa1c-145">CA1823: Avoid unused private fields</span></span>](ca1823.md) | <span data-ttu-id="7fa1c-146">アセンブリ内でアクセスされていないと思われるプライベート フィールドが検出されました。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-146">Private fields were detected that do not appear to be accessed in the assembly.</span></span> |
| [<span data-ttu-id="7fa1c-147">CA1824:アセンブリを NeutralResourcesLanguageAttribute に設定します</span><span class="sxs-lookup"><span data-stu-id="7fa1c-147">CA1824: Mark assemblies with NeutralResourcesLanguageAttribute</span></span>](ca1824.md) | <span data-ttu-id="7fa1c-148">NeutralResourcesLanguage 属性は、リソース マネージャーに対し、アセンブリのニュートラル カルチャのリソースを表示するために使用した言語を通知します。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-148">The NeutralResourcesLanguage attribute informs the Resource Manager of the language that was used to display the resources of a neutral culture for an assembly.</span></span> <span data-ttu-id="7fa1c-149">これにより、読み込んだ最初のリソースに対する検索のパフォーマンスが向上し、ワーキング セットを縮小できます。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-149">This improves lookup performance for the first resource that you load and can reduce your working set.</span></span> |
| [<span data-ttu-id="7fa1c-150">CA1825:長さ 0 の配列割り当てを回避します</span><span class="sxs-lookup"><span data-stu-id="7fa1c-150">CA1825: Avoid zero-length array allocations</span></span>](ca1825.md) | <span data-ttu-id="7fa1c-151">長さ 0 の配列を初期化すると、不要なメモリ割り当てが発生します。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-151">Initializing a zero-length array leads to unnecessary memory allocation.</span></span> <span data-ttu-id="7fa1c-152">代わりに、<xref:System.Array.Empty%2A?displayProperty=nameWithType> を呼び出して、静的に割り当てられた空の配列インスタンスを使用してください。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-152">Instead, use the statically allocated empty array instance by calling <xref:System.Array.Empty%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="7fa1c-153">メモリ割り当ては、このメソッドのすべての呼び出しで共有されます。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-153">The memory allocation is shared across all invocations of this method.</span></span> |
| [<span data-ttu-id="7fa1c-154">CA1826:Linq の列挙可能なメソッドの代わりにプロパティを使用します</span><span class="sxs-lookup"><span data-stu-id="7fa1c-154">CA1826: Use property instead of Linq Enumerable method</span></span>](ca1826.md) | <span data-ttu-id="7fa1c-155"><xref:System.Linq.Enumerable> LINQ メソッドが同等のより効率的なプロパティをサポートする型で使用されました。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-155"><xref:System.Linq.Enumerable> LINQ method was used on a type that supports an equivalent, more efficient property.</span></span> |
| [<span data-ttu-id="7fa1c-156">CA1827:Any が使用できる場合は Count/LongCount を使用しません</span><span class="sxs-lookup"><span data-stu-id="7fa1c-156">CA1827: Do not use Count/LongCount when Any can be used</span></span>](ca1827.md) | <span data-ttu-id="7fa1c-157"><xref:System.Linq.Enumerable.Any%2A> メソッドの方が効率的な状況で、<xref:System.Linq.Enumerable.Count%2A> または <xref:System.Linq.Enumerable.LongCount%2A> メソッドが使用されました。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-157"><xref:System.Linq.Enumerable.Count%2A> or <xref:System.Linq.Enumerable.LongCount%2A> method was used where <xref:System.Linq.Enumerable.Any%2A> method would be more efficient.</span></span> |
| [<span data-ttu-id="7fa1c-158">CA1828:AnyAsync が使用できる場合は CountAsync/LongCountAsync を使用しません</span><span class="sxs-lookup"><span data-stu-id="7fa1c-158">CA1828: Do not use CountAsync/LongCountAsync when AnyAsync can be used</span></span>](ca1828.md) | <span data-ttu-id="7fa1c-159"><xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.AnyAsync%2A> メソッドの方が効率的な状況で、<xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.CountAsync%2A> または <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.LongCountAsync%2A> メソッドが使用されました。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-159"><xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.CountAsync%2A> or <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.LongCountAsync%2A> method was used where <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.AnyAsync%2A> method would be more efficient.</span></span> |
| [<span data-ttu-id="7fa1c-160">CA1829:Enumerable. Count メソッドではなく Length/Count プロパティを使用します</span><span class="sxs-lookup"><span data-stu-id="7fa1c-160">CA1829: Use Length/Count property instead of Enumerable.Count method</span></span>](ca1829.md) | <span data-ttu-id="7fa1c-161"><xref:System.Linq.Enumerable.Count%2A> LINQ メソッドが同等のより効率的な `Length` または `Count` プロパティをサポートする型で使用されました。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-161"><xref:System.Linq.Enumerable.Count%2A> LINQ method was used on a type that supports an equivalent, more efficient `Length` or `Count` property.</span></span> |
| [<span data-ttu-id="7fa1c-162">CA1830:StringBuilder の厳密に型指定された Append および Insert メソッドのオーバーロードをお勧めします</span><span class="sxs-lookup"><span data-stu-id="7fa1c-162">CA1830: Prefer strongly-typed Append and Insert method overloads on StringBuilder</span></span>](ca1830.md) | <span data-ttu-id="7fa1c-163"><xref:System.Text.StringBuilder.Append%2A> と <xref:System.Text.StringBuilder.Insert%2A> では、System.String を超える複数の型に対してオーバーロードを提供します。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-163"><xref:System.Text.StringBuilder.Append%2A> and <xref:System.Text.StringBuilder.Insert%2A> provide overloads for multiple types beyond System.String.</span></span>  <span data-ttu-id="7fa1c-164">可能であれば、ToString() と文字列ベースのオーバーロードを使用するよりも、厳密に型指定されたオーバーロードを優先して使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-164">When possible, prefer the strongly-typed overloads over using ToString() and the string-based overload.</span></span> |
| [<span data-ttu-id="7fa1c-165">CA1831: 該当する場合、文字列に範囲ベースのインデクサーの代わりに AsSpan を使用します</span><span class="sxs-lookup"><span data-stu-id="7fa1c-165">CA1831: Use AsSpan instead of Range-based indexers for string when appropriate</span></span>](ca1831.md) | <span data-ttu-id="7fa1c-166">文字列に対して範囲インデクサーを使用し、その値を ReadOnlySpan&lt;char&gt; 型に暗黙的に割り当てると、<xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> の代わりにメソッド <xref:System.String.Substring%2A?#System_String_Substring_System_Int32_System_Int32_> が使用されます。これにより、文字列の要求された部分のコピーが生成されます。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-166">When using a range-indexer on a string and implicitly assigning the value to a ReadOnlySpan&lt;char&gt; type, the method <xref:System.String.Substring%2A?#System_String_Substring_System_Int32_System_Int32_> will be used instead of <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_>, which produces a copy of requested portion of the string.</span></span> |
| [<span data-ttu-id="7fa1c-167">CA1832: 配列の ReadOnlySpan または ReadOnlyMemory 部分を取得するために、範囲ベースのインデクサーの代わりに AsSpan または AsMemory を使用します</span><span class="sxs-lookup"><span data-stu-id="7fa1c-167">CA1832: Use AsSpan or AsMemory instead of Range-based indexers for getting ReadOnlySpan or ReadOnlyMemory portion of an array</span></span>](ca1832.md) | <span data-ttu-id="7fa1c-168">配列に対して範囲インデクサーを使用し、その値を <xref:System.ReadOnlySpan%601> または <xref:System.ReadOnlyMemory%601> 型に暗黙的に割り当てると、<xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> の代わりにメソッド <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> が使用されます。これにより、配列の要求された部分のコピーが生成されます。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-168">When using a range-indexer on an array and implicitly assigning the value to a <xref:System.ReadOnlySpan%601> or <xref:System.ReadOnlyMemory%601> type, the method <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> will be used instead of <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_>, which produces a copy of requested portion of the array.</span></span> |
| [<span data-ttu-id="7fa1c-169">CA1833: 配列の Span または Memory 部分を取得するために、範囲ベースのインデクサーの代わりに AsSpan または AsMemory を使用します</span><span class="sxs-lookup"><span data-stu-id="7fa1c-169">CA1833: Use AsSpan or AsMemory instead of Range-based indexers for getting Span or Memory portion of an array</span></span>](ca1833.md) | <span data-ttu-id="7fa1c-170">配列に対して範囲インデクサーを使用し、その値を <xref:System.Span%601> または <xref:System.Memory%601> 型に暗黙的に割り当てると、<xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> の代わりにメソッド <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> が使用されます。これにより、配列の要求された部分のコピーが生成されます。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-170">When using a range-indexer on an array and implicitly assigning the value to a <xref:System.Span%601> or <xref:System.Memory%601> type, the method <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> will be used instead of <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_>, which produces a copy of requested portion of the array.</span></span> |
| [<span data-ttu-id="7fa1c-171">CA1834:1 文字の文字列に対して StringBuilder.Append(char) を使用する</span><span class="sxs-lookup"><span data-stu-id="7fa1c-171">CA1834: Use StringBuilder.Append(char) for single character strings</span></span>](ca1834.md) | <span data-ttu-id="7fa1c-172"><xref:System.Text.StringBuilder> には、引数として `char` を取る `Append` オーバーロードがあります。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-172"><xref:System.Text.StringBuilder> has an `Append` overload that takes a `char` as its argument.</span></span> <span data-ttu-id="7fa1c-173">パフォーマンスを向上させるため、`char` オーバーロードを呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-173">Prefer calling the `char` overload to improve performance.</span></span> |
| [<span data-ttu-id="7fa1c-174">CA1835: 'ReadAsync' および 'WriteAsync' で 'Memory' ベースのオーバーロードを優先的に使用します</span><span class="sxs-lookup"><span data-stu-id="7fa1c-174">CA1835: Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'</span></span>](ca1835.md) | <span data-ttu-id="7fa1c-175">'Stream' には、最初の引数として 'Memory&lt;Byte&gt;' を取る 'ReadAsync' オーバーロードと、最初の引数として 'ReadOnlyMemory&lt;Byte&gt;' を取る 'WriteAsync' オーバーロードがあります。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-175">'Stream' has a 'ReadAsync' overload that takes a 'Memory&lt;Byte&gt;' as the first argument, and a 'WriteAsync' overload that takes a 'ReadOnlyMemory&lt;Byte&gt;' as the first argument.</span></span> <span data-ttu-id="7fa1c-176">より効率的なメモリ ベースのオーバーロードを呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-176">Prefer calling the memory based overloads, which are more efficient.</span></span> |
| [<span data-ttu-id="7fa1c-177">CA1836: 使用可能な場合は、`Count` よりも `IsEmpty` を優先します</span><span class="sxs-lookup"><span data-stu-id="7fa1c-177">CA1836: Prefer `IsEmpty` over `Count` when available</span></span>](ca1836.md) | <span data-ttu-id="7fa1c-178">オブジェクトに項目が含まれているかどうかを確認するときは、`Count`、`Length`、<xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>、<xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> よりも効率的な `IsEmpty` プロパティを使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-178">Prefer `IsEmpty` property that is more efficient than `Count`, `Length`, <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> or <xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> to determine whether the object contains or not any items.</span></span> |
| [<span data-ttu-id="7fa1c-179">CA1837: `Process.GetCurrentProcess().Id` ではなく `Environment.ProcessId` を使用します</span><span class="sxs-lookup"><span data-stu-id="7fa1c-179">CA1837: Use `Environment.ProcessId` instead of `Process.GetCurrentProcess().Id`</span></span>](ca1837.md) | <span data-ttu-id="7fa1c-180">`Environment.ProcessId` は `Process.GetCurrentProcess().Id` よりも簡単かつ高速です。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-180">`Environment.ProcessId` is simpler and faster than `Process.GetCurrentProcess().Id`.</span></span> |
| [<span data-ttu-id="7fa1c-181">CA1838: P/Invokes に `StringBuilder` パラメーターを使用しません</span><span class="sxs-lookup"><span data-stu-id="7fa1c-181">CA1838: Avoid `StringBuilder` parameters for P/Invokes</span></span>](ca1838.md) | <span data-ttu-id="7fa1c-182">`StringBuilder` をマーシャリングすると、ネイティブ バッファーのコピーが常に作成され、1 回のマーシャリング操作に対して複数の割り当てが発生します。</span><span class="sxs-lookup"><span data-stu-id="7fa1c-182">Marshaling of `StringBuilder` always creates a native buffer copy, resulting in multiple allocations for one marshaling operation.</span></span> |
