---
description: '詳細情報: Visual Basic の新機能'
title: 新機能
ms.date: 10/24/2018
f1_keywords:
- VB.StartPage.WhatsNew
helpviewer_keywords:
- new features, Visual Basic
- what's new [Visual Basic]
- Visual Basic, what's new
ms.assetid: d7e97396-7f42-4873-a81c-4ebcc4b6ca02
ms.openlocfilehash: 1e5f7dec0476d0b7fbf09fa3b253d3d5dfedf426
ms.sourcegitcommit: e3cf8227573e13b8e1f4e3dc007404881cdafe47
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2021
ms.locfileid: "103190373"
---
# <a name="whats-new-for-visual-basic"></a><span data-ttu-id="1de85-103">Visual Basic の新機能</span><span class="sxs-lookup"><span data-stu-id="1de85-103">What's new for Visual Basic</span></span>

<span data-ttu-id="1de85-104">このトピックでは、Visual Basic の各バージョンの主要機能の名前と、言語の最新バージョンでの新機能および拡張機能の詳しい説明を一覧表示します。</span><span class="sxs-lookup"><span data-stu-id="1de85-104">This topic lists key feature names for each version of Visual Basic, with detailed descriptions of the new and enhanced features in the latest versions of the language.</span></span>

## <a name="current-version"></a><span data-ttu-id="1de85-105">現在のバージョン</span><span class="sxs-lookup"><span data-stu-id="1de85-105">Current version</span></span>

<span data-ttu-id="1de85-106">Visual Basic 16.9 / Visual Studio 2019 バージョン 16.9</span><span class="sxs-lookup"><span data-stu-id="1de85-106">Visual Basic 16.9 / Visual Studio 2019 version 16.9</span></span>\
<span data-ttu-id="1de85-107">新機能については、「[Visual Basic 16.9](#visual-basic-169)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1de85-107">For new features, see [Visual Basic 16.9](#visual-basic-169).</span></span>

<span data-ttu-id="1de85-108">最新の .NET SDK は [.NET のダウンロード ページ](https://dotnet.microsoft.com/download)でダウンロードできます。</span><span class="sxs-lookup"><span data-stu-id="1de85-108">You can download the latest .NET SDK from the [.NET downloads page](https://dotnet.microsoft.com/download).</span></span>

## <a name="previous-versions"></a><span data-ttu-id="1de85-109">以前のバージョン</span><span class="sxs-lookup"><span data-stu-id="1de85-109">Previous versions</span></span>

<span data-ttu-id="1de85-110">Visual Basic 16.0 / Visual Studio 2019 バージョン 16.0</span><span class="sxs-lookup"><span data-stu-id="1de85-110">Visual Basic 16.0 / Visual Studio 2019 version 16.0</span></span>\
<span data-ttu-id="1de85-111">新機能については、「[Visual Basic 16.0](#visual-basic-160)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1de85-111">For new features, see [Visual Basic 16.0](#visual-basic-160).</span></span>

<span data-ttu-id="1de85-112">Visual Basic 15.5 / Visual Studio 2017 バージョン 15.5</span><span class="sxs-lookup"><span data-stu-id="1de85-112">Visual Basic 15.5 / Visual Studio 2017 version 15.5</span></span>\
<span data-ttu-id="1de85-113">新機能については、「[Visual Basic 15.5](#visual-basic-155)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1de85-113">For new features, see [Visual Basic 15.5](#visual-basic-155).</span></span>

<span data-ttu-id="1de85-114">Visual Basic 15.3 / Visual Studio 2017 バージョン 15.3</span><span class="sxs-lookup"><span data-stu-id="1de85-114">Visual Basic 15.3 / Visual Studio 2017 version 15.3</span></span>\
<span data-ttu-id="1de85-115">新機能については、「[Visual Basic 15.3](#visual-basic-153)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1de85-115">For new features, see [Visual Basic 15.3](#visual-basic-153).</span></span>

<span data-ttu-id="1de85-116">Visual Basic 15 / Visual Studio 2017</span><span class="sxs-lookup"><span data-stu-id="1de85-116">Visual Basic 15 / Visual Studio 2017</span></span>\
<span data-ttu-id="1de85-117">新機能については、「[Visual Basic 2017](#visual-basic-15)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1de85-117">For new features, see [Visual Basic 2017](#visual-basic-15).</span></span>

<span data-ttu-id="1de85-118">Visual Basic / Visual Studio 2015</span><span class="sxs-lookup"><span data-stu-id="1de85-118">Visual Basic / Visual Studio 2015</span></span>\
<span data-ttu-id="1de85-119">新機能については、「[Visual Basic 14](#visual-basic-14)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1de85-119">For new features, see [Visual Basic 14](#visual-basic-14).</span></span>

<span data-ttu-id="1de85-120">Visual Basic / Visual Studio 2013</span><span class="sxs-lookup"><span data-stu-id="1de85-120">Visual Basic / Visual Studio 2013</span></span>\
<span data-ttu-id="1de85-121">.NET コンパイラ プラットフォーム ("Roslyn") のテクノロジのプレビュー</span><span class="sxs-lookup"><span data-stu-id="1de85-121">Technology previews of the .NET Compiler Platform ("Roslyn")</span></span>

<span data-ttu-id="1de85-122">Visual Basic / Visual Studio 2012</span><span class="sxs-lookup"><span data-stu-id="1de85-122">Visual Basic / Visual Studio 2012</span></span>\
<span data-ttu-id="1de85-123">`Async` と `await` のキーワード、反復子、呼び出し元情報属性</span><span class="sxs-lookup"><span data-stu-id="1de85-123">`Async` and `await` keywords, iterators, caller info attributes</span></span>

<span data-ttu-id="1de85-124">Visual Basic、Visual Studio 2010</span><span class="sxs-lookup"><span data-stu-id="1de85-124">Visual Basic, Visual Studio 2010</span></span>\
<span data-ttu-id="1de85-125">自動実装プロパティ、コレクション初期化子、暗黙的な行の連結、動的、ジェネリック co/負の分散、グローバル名前空間のアクセス</span><span class="sxs-lookup"><span data-stu-id="1de85-125">Auto-implemented properties, collection initializers, implicit line continuation, dynamic, generic co/contra variance, global namespace access</span></span>

<span data-ttu-id="1de85-126">Visual Basic / Visual Studio 2008</span><span class="sxs-lookup"><span data-stu-id="1de85-126">Visual Basic / Visual Studio 2008</span></span>\
<span data-ttu-id="1de85-127">統合言語クエリ (LINQ)、XML リテラル、ローカル型の推定、オブジェクト初期化子、匿名型、拡張メソッド、ローカル `var` 型推論、ラムダ式、 `if` 演算子、部分メソッド、null 許容値型</span><span class="sxs-lookup"><span data-stu-id="1de85-127">Language Integrated Query (LINQ), XML literals, local type inference, object initializers, anonymous types, extension methods, local `var` type inference, lambda expressions, `if` operator, partial methods, nullable value types</span></span>

<span data-ttu-id="1de85-128">Visual Basic / Visual Studio 2005</span><span class="sxs-lookup"><span data-stu-id="1de85-128">Visual Basic / Visual Studio 2005</span></span>\
<span data-ttu-id="1de85-129">`My` 型とヘルパーの種類 (アプリ、コンピューター、ファイル システム、ネットワークへのアクセス)</span><span class="sxs-lookup"><span data-stu-id="1de85-129">The `My` type and helper types (access to app, computer, files system, network)</span></span>

<span data-ttu-id="1de85-130">Visual Basic / Visual Studio .NET 2003</span><span class="sxs-lookup"><span data-stu-id="1de85-130">Visual Basic / Visual Studio .NET 2003</span></span>\
<span data-ttu-id="1de85-131">ビット シフト演算子、ループ変数宣言</span><span class="sxs-lookup"><span data-stu-id="1de85-131">Bit-shift operators, loop variable declaration</span></span>

<span data-ttu-id="1de85-132">Visual Basic / Visual Studio .NET 2002</span><span class="sxs-lookup"><span data-stu-id="1de85-132">Visual Basic / Visual Studio .NET 2002</span></span>\
<span data-ttu-id="1de85-133">Visual Basic .NET の最初のリリース</span><span class="sxs-lookup"><span data-stu-id="1de85-133">The first release of Visual Basic .NET</span></span>

## <a name="visual-basic-169"></a><span data-ttu-id="1de85-134">Visual Basic 16.9</span><span class="sxs-lookup"><span data-stu-id="1de85-134">Visual Basic 16.9</span></span>

<span data-ttu-id="1de85-135">Visual Basic 16.9 では、初期化専用プロパティを使用できます。</span><span class="sxs-lookup"><span data-stu-id="1de85-135">Visual Basic 16.9 enables consumption of init-only properties.</span></span>

## <a name="visual-basic-160"></a><span data-ttu-id="1de85-136">Visual Basic 16.0</span><span class="sxs-lookup"><span data-stu-id="1de85-136">Visual Basic 16.0</span></span>

<span data-ttu-id="1de85-137">Visual Basic 16.0 は、Visual Basic ランタイム (microsoft.visualbasic.dll) より多くの機能を .NET Core に多く提供することに重点を置いており、.NET Core に重点を置いた Visual Basic の最初のバージョンです。</span><span class="sxs-lookup"><span data-stu-id="1de85-137">Visual Basic 16.0 focuses on supplying more of the features of the Visual Basic Runtime (microsoft.visualbasic.dll) to .NET Core and is the first version of Visual Basic focused on .NET Core.</span></span> <span data-ttu-id="1de85-138">Visual Basic ランタイムの多くの部分は WinForms に依存しており、これらは Visual Basic の今後のバージョンで追加される予定です。</span><span class="sxs-lookup"><span data-stu-id="1de85-138">Many portions of the Visual Basic Runtime depend on WinForms and these will be added in a later version of Visual Basic.</span></span>

<span data-ttu-id="1de85-139">**ステートメント内のより多くの場所で許可されているコメント**</span><span class="sxs-lookup"><span data-stu-id="1de85-139">**Comments allowed in more places within statements**</span></span>

<span data-ttu-id="1de85-140">Visual Basic 15.8 以前のバージョンでは、空白行、ステートメントの最後、または暗黙的な行の継続が許可されるステートメント内の特定の場所でのみ、コメントが許可されます。</span><span class="sxs-lookup"><span data-stu-id="1de85-140">In Visual Basic 15.8 and earlier versions, comments are only allowed on blank lines, at the end of a statement, or in specific places within a statement where an implicit line continuation is allowed.</span></span> <span data-ttu-id="1de85-141">Visual Basic 16.0 以降では、コメントは、明示的な行継続の後と、スペースとその後にアンダースコアで始まる行のステートメント内でも使用できます。</span><span class="sxs-lookup"><span data-stu-id="1de85-141">Starting with Visual Basic 16.0, comments are also allowed after explicit line continuations and within a statement on a line beginning with a space followed by an underscore.</span></span>

```vb
Public Sub Main()
    cmd.CommandText = ' Comment is allowed here without _
        "SELECT * FROM Titles JOIN Publishers " _ ' This is a comment
        & "ON Publishers.PubId = Titles.PubID " _
 _ ' This is a comment on a line without code
        & "WHERE Publishers.State = 'CA'"
End Sub
```

<span data-ttu-id="1de85-142">**浮動小数点から整数への変換の最適化**</span><span class="sxs-lookup"><span data-stu-id="1de85-142">**Optimized floating-point to integer conversion**</span></span>

<span data-ttu-id="1de85-143">以前のバージョンの Visual Basic では、[倍精度浮動小数点型](../language-reference/data-types/double-data-type.md)と[単精度浮動小数点型](../language-reference/data-types/single-data-type.md)の値の整数への変換で比較的低いパフォーマンスが提供されていました。</span><span class="sxs-lookup"><span data-stu-id="1de85-143">In previous versions of Visual Basic, conversion of [Double](../language-reference/data-types/double-data-type.md) and [Single](../language-reference/data-types/single-data-type.md) values to integers offered relatively poor performance.</span></span> <span data-ttu-id="1de85-144">Visual Basic 15.8 では、次のいずれかのメソッドによって返された値を[固有の Visual Basic 整数変換の関数](../language-reference/functions/type-conversion-functions.md) (CByte、CShort、CInt、CLng、CSByte、CUShort、CUInt、CULng) の 1 つに渡すとき、または [Option Strict](../language-reference/statements/option-strict-statement.md) が `Off` に設定されているときに、値が整数型に暗黙的にキャストされる次のいずれかのメソッドによって返されるときに、浮動小数点の整数への変換のパフォーマンスが大幅に向上します。</span><span class="sxs-lookup"><span data-stu-id="1de85-144">Visual Basic 15.8 significantly enhances the performance of floating-point conversions to integers when you pass the value returned by any of the following methods to one of the [intrinsic Visual Basic integer conversion functions](../language-reference/functions/type-conversion-functions.md) (CByte, CShort, CInt, CLng, CSByte, CUShort, CUInt, CULng), or when the value returned by any of the following methods is implicitly cast to an integral type when [Option Strict](../language-reference/statements/option-strict-statement.md) is set to `Off`:</span></span>

- <xref:Microsoft.VisualBasic.Conversion.Fix(System.Double)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Fix(System.Object)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Fix(System.Single)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Int(System.Double)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Int(System.Object)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Int(System.Single)?displayProperty=nameWithType>
- <xref:System.Math.Ceiling(System.Double)?displayProperty=nameWithType>
- <xref:System.Math.Floor(System.Double)?displayProperty=nameWithType>
- <xref:System.Math.Round(System.Double)?displayProperty=nameWithType>
- <xref:System.Math.Truncate(System.Double)?displayProperty=nameWithType>

<span data-ttu-id="1de85-145">この最適化によって、コードをより速く実行できます。大きい数値の整数型への変換を行うコードでは、最大で 2 倍速くなります。</span><span class="sxs-lookup"><span data-stu-id="1de85-145">This optimization allows code to run faster -- up to twice as fast for code that does a large number of conversions to integer types.</span></span> <span data-ttu-id="1de85-146">次の例では、この最適化によって影響を受けるシンプルなメソッドの呼び出しを示しています。</span><span class="sxs-lookup"><span data-stu-id="1de85-146">The following example illustrates some simple method calls that are affected by this optimization:</span></span>

```vb
Dim s As Single = 173.7619
Dim d As Double = s

Dim i1 As Integer = CInt(Fix(s))               ' Result: 173
Dim b1 As Byte = CByte(Int(d))                 ' Result: 173
Dim s1 AS Short = CShort(Math.Truncate(s))     ' Result: 173
Dim i2 As Integer = CInt(Math.Ceiling(d))      ' Result: 174
Dim i3 As Integer = CInt(Math.Round(s))        ' Result: 174
```

<span data-ttu-id="1de85-147">これは、浮動小数点の値を四捨五入するのではなく、切り詰められることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="1de85-147">Note that this truncates rather than rounds floating-point values.</span></span>

## <a name="visual-basic-155"></a><span data-ttu-id="1de85-148">Visual Basic 15.5</span><span class="sxs-lookup"><span data-stu-id="1de85-148">Visual Basic 15.5</span></span>

[<span data-ttu-id="1de85-149">末尾以外の名前付き引数</span><span class="sxs-lookup"><span data-stu-id="1de85-149">Non-trailing named arguments</span></span>](../programming-guide/language-features/procedures/passing-arguments-by-position-and-by-name.md#mixing-arguments-by-position-and-by-name)

<span data-ttu-id="1de85-150">Visual Basic 15.3 以前のバージョンでは、位置と名前の両方による引数がメソッド呼び出しに含まれている場合、位置引数を名前付き引数より前に配置する必要がありました。</span><span class="sxs-lookup"><span data-stu-id="1de85-150">In Visual Basic 15.3 and earlier versions, when a method call included arguments both by position and by name, positional arguments had to precede named arguments.</span></span> <span data-ttu-id="1de85-151">Visual Basic 15.5 以降では、最後の位置引数までのすべての引数が正しい位置にある限り、位置引数と名前付き引数を任意の順序で配置できます。</span><span class="sxs-lookup"><span data-stu-id="1de85-151">Starting with Visual Basic 15.5, positional and named arguments can appear in any order as long as all arguments up to the last positional argument are in the correct position.</span></span> <span data-ttu-id="1de85-152">これは、コードを読みやすくするために名前付き引数を使用する場合に特に便利です。</span><span class="sxs-lookup"><span data-stu-id="1de85-152">This is particularly useful when named arguments are used to make code more readable.</span></span>

<span data-ttu-id="1de85-153">たとえば、次のメソッド呼び出しには、名前付き引数の間に 2 つの位置引数があります。</span><span class="sxs-lookup"><span data-stu-id="1de85-153">For example, the following method call has two positional arguments between a named argument.</span></span> <span data-ttu-id="1de85-154">名前付き引数では、値 19 が年齢を表していることが明確になります。</span><span class="sxs-lookup"><span data-stu-id="1de85-154">The named argument makes it clear that the value 19 represents an age.</span></span>

```vb
StudentInfo.Display("Mary", age:=19, #9/21/1998#)
```

[<span data-ttu-id="1de85-155">`Private Protected` メンバー アクセス修飾子</span><span class="sxs-lookup"><span data-stu-id="1de85-155">`Private Protected` member access modifier</span></span>](../language-reference/modifiers/private-protected.md)

<span data-ttu-id="1de85-156">この新しいキーワードの組み合わせでは、その親クラスのすべてのメンバーと、親クラスから派生した型でアクセスできるメンバーが定義されます。ただし、ここで言うアクセスする側が親アセンブリにも存在する場合に限られます。</span><span class="sxs-lookup"><span data-stu-id="1de85-156">This new keyword combination defines a member that is accessible by all members in its containing class as well as by types derived from the containing class, but only if they are also found in the containing assembly.</span></span> <span data-ttu-id="1de85-157">構造体は継承できないため、`Private Protected` はクラスのメンバーにのみ適用できます。</span><span class="sxs-lookup"><span data-stu-id="1de85-157">Because structures cannot be inherited, `Private Protected` can only be applied to the members of a class.</span></span>

<span data-ttu-id="1de85-158">**先頭の 16 進数/2 進数/8 進数の区切り記号**</span><span class="sxs-lookup"><span data-stu-id="1de85-158">**Leading hex/binary/octal separator**</span></span>

<span data-ttu-id="1de85-159">Visual Basic 2017 では、桁区切り記号としてアンダースコア文字 (`_`) のサポートが追加されました。</span><span class="sxs-lookup"><span data-stu-id="1de85-159">Visual Basic 2017 added support for the underscore character (`_`) as a digit separator.</span></span> <span data-ttu-id="1de85-160">Visual Basic 15.5 以降では、プレフィックスと 16 進数、2 進数、または 8 進数の間に先頭の区切り記号としてアンダースコア文字を使用することができます。</span><span class="sxs-lookup"><span data-stu-id="1de85-160">Starting with Visual Basic 15.5, you can use the underscore character as a leading separator between the prefix and hexadecimal, binary, or octal digits.</span></span> <span data-ttu-id="1de85-161">次の例では、3,271,948,384 を 16 進数として定義するために先頭の桁区切り記号を使用します。</span><span class="sxs-lookup"><span data-stu-id="1de85-161">The following example uses a leading digit separator to define 3,271,948,384 as a hexadecimal number:</span></span>

```vb
Dim number As Integer = &H_C305_F860
```

<span data-ttu-id="1de85-162">アンダースコア文字を先頭の区切り記号として使用するには、以下の要素を Visual Basic プロジェクト (\*.vbproj) ファイルに追加する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1de85-162">To use the underscore character as a leading separator, you must add the following element to your Visual Basic project (\*.vbproj) file:</span></span>

```xml
<PropertyGroup>
  <LangVersion>15.5</LangVersion>
</PropertyGroup>
```

## <a name="visual-basic-153"></a><span data-ttu-id="1de85-163">Visual Basic 15.3</span><span class="sxs-lookup"><span data-stu-id="1de85-163">Visual Basic 15.3</span></span>

[<span data-ttu-id="1de85-164">**名前付きタプルの推論**</span><span class="sxs-lookup"><span data-stu-id="1de85-164">**Named tuple inference**</span></span>](../programming-guide/language-features/data-types/tuples.md#inferred-tuple-element-names)

<span data-ttu-id="1de85-165">変数からタプル要素の値を割り当てる場合、Visual Basic は対応する変数名からタプル要素の名前を推論します。ユーザーがタプル要素に明示的に名前を付ける必要はありません。</span><span class="sxs-lookup"><span data-stu-id="1de85-165">When you assign the value of tuple elements from variables, Visual Basic infers the name of tuple elements from the corresponding variable names; you do not have to explicitly name a tuple element.</span></span> <span data-ttu-id="1de85-166">以下の例では、推論を使用して、`state`、`stateName`、`capital` という 3 つの名前付き要素のタプルを作成します。</span><span class="sxs-lookup"><span data-stu-id="1de85-166">The following example uses inference to create a tuple with three named elements, `state`, `stateName`, and `capital`.</span></span>

[!code-vb[Inferred tuple names](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/named-tuples/program.vb#2)]

<span data-ttu-id="1de85-167">**追加のコンパイラ スイッチ**</span><span class="sxs-lookup"><span data-stu-id="1de85-167">**Additional compiler switches**</span></span>

<span data-ttu-id="1de85-168">Visual Basic コマンド ライン コンパイラで、参照アセンブリの出力を制御する [ **-refout**](../reference/command-line-compiler/refout-compiler-option.md) と [ **-refonly**](../reference/command-line-compiler/refonly-compiler-option.md) のコンパイラ オプションがサポートされるようになりました。</span><span class="sxs-lookup"><span data-stu-id="1de85-168">The Visual Basic command-line compiler now supports the [**-refout**](../reference/command-line-compiler/refout-compiler-option.md) and [**-refonly**](../reference/command-line-compiler/refonly-compiler-option.md) compiler options to control the output of reference assemblies.</span></span> <span data-ttu-id="1de85-169">**-refout** は、参照アセンブリの出力ディレクトリを定義し、 **-refonly** はコンパイルで参照アセンブリだけが出力されるように指定します。</span><span class="sxs-lookup"><span data-stu-id="1de85-169">**-refout** defines the output directory of the reference assembly, and **-refonly** specifies that only a reference assembly is to be output by compilation.</span></span>

## <a name="visual-basic-15"></a><span data-ttu-id="1de85-170">Visual Basic 15</span><span class="sxs-lookup"><span data-stu-id="1de85-170">Visual Basic 15</span></span>

[<span data-ttu-id="1de85-171">**タプル**</span><span class="sxs-lookup"><span data-stu-id="1de85-171">**Tuples**</span></span>](../programming-guide/language-features/data-types/tuples.md)

<span data-ttu-id="1de85-172">タプルは軽量のデータ構造であり、最も一般的には、1 回のメソッド呼び出しで複数の値を返すために利用されます。</span><span class="sxs-lookup"><span data-stu-id="1de85-172">Tuples are a lightweight data structure that most commonly is used to return multiple values from a single method call.</span></span> <span data-ttu-id="1de85-173">通常、1 つのメソッドから複数の値を返すには、次のいずれかを行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="1de85-173">Ordinarily, to return multiple values from a method, you have to do one of the following:</span></span>

- <span data-ttu-id="1de85-174">カスタムの型を定義します (`Class` または `Structure`)。</span><span class="sxs-lookup"><span data-stu-id="1de85-174">Define a custom type (a `Class` or a `Structure`).</span></span> <span data-ttu-id="1de85-175">これは重量級のソリューションです。</span><span class="sxs-lookup"><span data-stu-id="1de85-175">This is a heavyweight solution.</span></span>

- <span data-ttu-id="1de85-176">メソッドから 1 つの値を返すことに加え、1 つまたは複数の `ByRef` パラメーターを定義します。</span><span class="sxs-lookup"><span data-stu-id="1de85-176">Define one or more `ByRef` parameters, in addition to returning a value from the method.</span></span>

<span data-ttu-id="1de85-177">Visual Basic はタプルに対応しているため、簡単にタプルを定義し、任意でその値にセマンティック名を割り当て、簡単にその値を取得できます。</span><span class="sxs-lookup"><span data-stu-id="1de85-177">Visual Basic's support for tuples lets you quickly define a tuple, optionally assign semantic names to its values, and quickly retrieve its values.</span></span> <span data-ttu-id="1de85-178">次の例では、<xref:System.Int32.TryParse%2A> メソッドの呼び出しをラップして、タプルを返します。</span><span class="sxs-lookup"><span data-stu-id="1de85-178">The following example wraps a call to the <xref:System.Int32.TryParse%2A> method and returns a tuple.</span></span>

[!code-vb[Tuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#2)]

<span data-ttu-id="1de85-179">メソッドを呼び出し、返されたタプルを処理できます。次のようなコードを利用します。</span><span class="sxs-lookup"><span data-stu-id="1de85-179">You can then call the method and handle the returned tuple with code like the following.</span></span>

[!code-vb[ReturnTuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#3)]

<span data-ttu-id="1de85-180">**バイナリ リテラルと桁区切り文字**</span><span class="sxs-lookup"><span data-stu-id="1de85-180">**Binary literals and digit separators**</span></span>

<span data-ttu-id="1de85-181">プレフィックスとして `&B` または `&b` を使用し、バイナリ リテラルを定義できます。</span><span class="sxs-lookup"><span data-stu-id="1de85-181">You can define a binary literal by using the prefix `&B` or `&b`.</span></span> <span data-ttu-id="1de85-182">さらに、下線文字 `_` を桁区切り文字として利用し、読みやすくすることができます。</span><span class="sxs-lookup"><span data-stu-id="1de85-182">In addition, you can use the underscore character, `_`, as a digit separator to enhance readability.</span></span> <span data-ttu-id="1de85-183">次の例では両方の機能を利用し、`Byte` 値を割り当て、10 進数、16 進数、2 進数として表示しています。</span><span class="sxs-lookup"><span data-stu-id="1de85-183">The following example uses both features to assign a `Byte` value and to display it as a decimal, hexadecimal, and binary number.</span></span>

[!code-vb[Binary](../../../samples/snippets/visualbasic/getting-started/bin-example.vb#1)]

<span data-ttu-id="1de85-184">詳細については、[Byte](../language-reference/data-types/byte-data-type.md#literal-assignments)、[Integer](../language-reference/data-types/integer-data-type.md#literal-assignments)、[Long](../language-reference/data-types/long-data-type.md#literal-assignments)、[Short](../language-reference/data-types/short-data-type.md#literal-assignments)、[SByte](../language-reference/data-types/sbyte-data-type.md#literal-assignments)、[UInteger](../language-reference/data-types/uinteger-data-type.md#literal-assignments)、[ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments)、[UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments) データ型の "Literal assignments" (リテラル割り当て) セクションをご覧ください。</span><span class="sxs-lookup"><span data-stu-id="1de85-184">For more information, see the "Literal assignments" section of the [Byte](../language-reference/data-types/byte-data-type.md#literal-assignments), [Integer](../language-reference/data-types/integer-data-type.md#literal-assignments), [Long](../language-reference/data-types/long-data-type.md#literal-assignments), [Short](../language-reference/data-types/short-data-type.md#literal-assignments), [SByte](../language-reference/data-types/sbyte-data-type.md#literal-assignments), [UInteger](../language-reference/data-types/uinteger-data-type.md#literal-assignments), [ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments), and [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments) data types.</span></span>

[<span data-ttu-id="1de85-185">**C# 参照戻り値のサポート**</span><span class="sxs-lookup"><span data-stu-id="1de85-185">**Support for C# reference return values**</span></span>](../programming-guide/language-features/procedures/ref-return-values.md)

<span data-ttu-id="1de85-186">C# 7.0 以降の C# は参照戻り値に対応しています。</span><span class="sxs-lookup"><span data-stu-id="1de85-186">Starting with C# 7.0, C# supports reference return values.</span></span> <span data-ttu-id="1de85-187">つまり、メソッドを呼び出して、参照により返された値を受け取るとき、参照の値が変わることがあります。</span><span class="sxs-lookup"><span data-stu-id="1de85-187">That is, when the calling method receives a value returned by reference, it can change the value of the reference.</span></span> <span data-ttu-id="1de85-188">Visual Basic の場合、参照戻り値でメソッドを作成することはできませんが、参照戻り値を利用したり、変更したりすることはできます。</span><span class="sxs-lookup"><span data-stu-id="1de85-188">Visual Basic does not allow you to author methods with reference return values, but it does allow you to consume and modify the reference return values.</span></span>

<span data-ttu-id="1de85-189">たとえば、C# で記述された次の `Sentence` クラスには、指定された部分文字列で始まる文の次の単語を探す `FindNext` メソッドが含まれています。</span><span class="sxs-lookup"><span data-stu-id="1de85-189">For example, the following `Sentence` class written in C# includes a `FindNext` method that finds the next word in a sentence that begins with a specified substring.</span></span> <span data-ttu-id="1de85-190">文字列は参照戻り値として返され、参照によりメソッドに渡される `Boolean` 変数は検索が成功したかどうかを示します。</span><span class="sxs-lookup"><span data-stu-id="1de85-190">The string is returned as a reference return value, and a `Boolean` variable passed by reference to the method indicates whether the search was successful.</span></span> <span data-ttu-id="1de85-191">これは、返された値を読み取ることに加えて、呼び出し元がそれを変更することもでき、その変更が `Sentence` クラスに反映されることを意味します。</span><span class="sxs-lookup"><span data-stu-id="1de85-191">This means that in addition to reading the returned value, the caller can also modify it, and that modification is reflected in the `Sentence` class.</span></span>

[!code-csharp[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-returns.cs)]

<span data-ttu-id="1de85-192">最も単純な形式では、次のようなコードを利用し、文中で見つかった単語を変更できます。</span><span class="sxs-lookup"><span data-stu-id="1de85-192">In its simplest form, you can modify the word found in the sentence by using code like the following.</span></span> <span data-ttu-id="1de85-193">メソッドに値を割り当てるのではなく、メソッドが返す式、つまり、参照戻り値に値を割り当てる点に注意してください。</span><span class="sxs-lookup"><span data-stu-id="1de85-193">Note that you are not assigning a value to the method, but rather to the expression that the method returns, which is the reference return value.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#1)]

<span data-ttu-id="1de85-194">しかしながらこのコードには問題があり、一致が見つからない場合、メソッドは最初の単語を返します。</span><span class="sxs-lookup"><span data-stu-id="1de85-194">A problem with this code, though, is that if a match is not found, the method returns the first word.</span></span> <span data-ttu-id="1de85-195">例では、`Boolean` 引数の値を調べて一致が見つかるかどうかを判断することがないため、一致がなければ最初の単語が変更されます。</span><span class="sxs-lookup"><span data-stu-id="1de85-195">Since the example does not examine the value of the `Boolean` argument to determine whether a match is found, it modifies the first word if there is no match.</span></span> <span data-ttu-id="1de85-196">次の例では、この問題が修正されています。一致がない場合、最初の単語をそれ自体で置換します。</span><span class="sxs-lookup"><span data-stu-id="1de85-196">The following example corrects this by replacing the first word with itself if there is no match.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#2)]

<span data-ttu-id="1de85-197">より良い解決策は、ヘルパー メソッドを利用し、参照によりヘルパー メソッドに参照戻り値を渡すことです。</span><span class="sxs-lookup"><span data-stu-id="1de85-197">A better solution is to use a helper method to which the reference return value is passed by reference.</span></span> <span data-ttu-id="1de85-198">ヘルパー メソッドは参照により渡された引数を変更できます。</span><span class="sxs-lookup"><span data-stu-id="1de85-198">The helper method can then modify the argument passed to it by reference.</span></span> <span data-ttu-id="1de85-199">次の例でこれを確認できます。</span><span class="sxs-lookup"><span data-stu-id="1de85-199">The following example does that.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return-helper.vb#1)]

<span data-ttu-id="1de85-200">詳細については、[参照戻り値](../programming-guide/language-features/procedures/ref-return-values.md)に関するページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="1de85-200">For more information, see [Reference Return Values](../programming-guide/language-features/procedures/ref-return-values.md).</span></span>

## <a name="visual-basic-14"></a><span data-ttu-id="1de85-201">Visual Basic 14</span><span class="sxs-lookup"><span data-stu-id="1de85-201">Visual Basic 14</span></span>

[<span data-ttu-id="1de85-202">NameOf</span><span class="sxs-lookup"><span data-stu-id="1de85-202">NameOf</span></span>](../language-reference/operators/nameof.md)

<span data-ttu-id="1de85-203">文字列をハードコーディングせずにエラー メッセージで使用するための型またはメンバーの非修飾文字列名を取得できます。</span><span class="sxs-lookup"><span data-stu-id="1de85-203">You can get the unqualified string name of a type or member for use in an error message without hard coding a string.</span></span>  <span data-ttu-id="1de85-204">これにより、リファクタリングするときにコードは正しい状態を保てます。</span><span class="sxs-lookup"><span data-stu-id="1de85-204">This allows your code to remain correct when refactoring.</span></span>  <span data-ttu-id="1de85-205">この機能は、またモデル-ビュー-コントローラーの MVC のリンクをフックし、プロパティ変更イベントを発生させるためにも役立ちます。</span><span class="sxs-lookup"><span data-stu-id="1de85-205">This feature is also useful for hooking up model-view-controller MVC links and firing property changed events.</span></span>

[<span data-ttu-id="1de85-206">文字列補間</span><span class="sxs-lookup"><span data-stu-id="1de85-206">String interpolation</span></span>](../programming-guide/language-features/strings/interpolated-strings.md)

<span data-ttu-id="1de85-207">文字列補間式を使用して、文字列を構築することができます。</span><span class="sxs-lookup"><span data-stu-id="1de85-207">You can use string interpolation expressions to construct strings.</span></span>  <span data-ttu-id="1de85-208">補間文字列式は、式が含まれているテンプレート文字列のように見えます。</span><span class="sxs-lookup"><span data-stu-id="1de85-208">An interpolated string expression looks like a template string that contains expressions.</span></span>  <span data-ttu-id="1de85-209">引数に関しては、補間文字列は[複合書式指定](../../standard/base-types/composite-formatting.md)より理解しやすくなっています。</span><span class="sxs-lookup"><span data-stu-id="1de85-209">An interpolated string is easier to understand with respect to arguments than [Composite Formatting](../../standard/base-types/composite-formatting.md).</span></span>

[<span data-ttu-id="1de85-210">Null 条件メンバー アクセスとインデックス作成</span><span class="sxs-lookup"><span data-stu-id="1de85-210">Null-conditional member access and indexing</span></span>](../language-reference/operators/null-conditional-operators.md)

<span data-ttu-id="1de85-211">メンバー アクセス (`?.`) またはインデックス (`?[]`) 操作を実行する前に、構文的に非常に簡単な方法で null をテストできます。</span><span class="sxs-lookup"><span data-stu-id="1de85-211">You can test for null in a very light syntactic way before performing a member access (`?.`) or index (`?[]`) operation.</span></span>  <span data-ttu-id="1de85-212">これらの演算子を使用すると、null チェックの処理のために記述するコードを少なくすることができます (特に、データ構造を下っていく場合)。</span><span class="sxs-lookup"><span data-stu-id="1de85-212">These operators help you write less code to handle null checks, especially for descending into data structures.</span></span>  <span data-ttu-id="1de85-213">左のオペランドまたはオブジェクト参照が null の場合、操作は null を返します。</span><span class="sxs-lookup"><span data-stu-id="1de85-213">If the left operand or object reference is null, the operations returns null.</span></span>

[<span data-ttu-id="1de85-214">複数行の文字列リテラル</span><span class="sxs-lookup"><span data-stu-id="1de85-214">Multi-line string literals</span></span>](../programming-guide/language-features/strings/string-basics.md)

<span data-ttu-id="1de85-215">文字列リテラルには、改行文字のシーケンスを含めることができます。</span><span class="sxs-lookup"><span data-stu-id="1de85-215">String literals can contain newline sequences.</span></span>  <span data-ttu-id="1de85-216">`<xml><![CDATA[...text with newlines...]]></xml>.Value` の使用に関する以前の次善策は不要になりました</span><span class="sxs-lookup"><span data-stu-id="1de85-216">You no longer need the old work around of using `<xml><![CDATA[...text with newlines...]]></xml>.Value`</span></span>

<span data-ttu-id="1de85-217">**コメント**</span><span class="sxs-lookup"><span data-stu-id="1de85-217">**Comments**</span></span>

<span data-ttu-id="1de85-218">暗黙的な行の連結の後の初期化子式内部、および LINQ 式項の間にコメントを入力できます。</span><span class="sxs-lookup"><span data-stu-id="1de85-218">You can put comments after implicit line continuations, inside initializer expressions, and among LINQ expression terms.</span></span>

<span data-ttu-id="1de85-219">**スマートな完全修飾名前解決**</span><span class="sxs-lookup"><span data-stu-id="1de85-219">**Smarter fully-qualified name resolution**</span></span>

<span data-ttu-id="1de85-220">`Threading.Thread.Sleep(1000)` などの特定のコードでは、以前 Visual Basic は名前空間 "Threading" を検索し、それが System.Threading と System.Windows.Threading の間であいまいであると判断し、エラーを報告していました。</span><span class="sxs-lookup"><span data-stu-id="1de85-220">Given code such as `Threading.Thread.Sleep(1000)`, Visual Basic used to look up the namespace "Threading", discover it was ambiguous between System.Threading and System.Windows.Threading, and then report an error.</span></span>  <span data-ttu-id="1de85-221">これらはどちらも Visual Basic で可能な名前空間であると見なすようになりました。</span><span class="sxs-lookup"><span data-stu-id="1de85-221">Visual Basic now considers both possible namespaces together.</span></span>  <span data-ttu-id="1de85-222">コンプリート リストを表示する場合、Visual Studio エディターは、コンプリート リストの両方の種類のメンバーを一覧表示します。</span><span class="sxs-lookup"><span data-stu-id="1de85-222">If you show the completion list, the Visual Studio editor lists members from both types in the completion list.</span></span>

<span data-ttu-id="1de85-223">**年が最初にくる日付リテラル**</span><span class="sxs-lookup"><span data-stu-id="1de85-223">**Year-first date literals**</span></span>

<span data-ttu-id="1de85-224">日付リテラルの形式として yyyy-mm-dd `#2015-03-17 16:10 PM#` を使用できます。</span><span class="sxs-lookup"><span data-stu-id="1de85-224">You can have date literals in yyyy-mm-dd format, `#2015-03-17 16:10 PM#`.</span></span>

<span data-ttu-id="1de85-225">**ReadOnly インターフェイスのプロパティ**</span><span class="sxs-lookup"><span data-stu-id="1de85-225">**Readonly interface properties**</span></span>

<span data-ttu-id="1de85-226">readwrite プロパティを使用して readonly インターフェイスのプロパティを実装できます。</span><span class="sxs-lookup"><span data-stu-id="1de85-226">You can implement readonly interface properties using a readwrite property.</span></span> <span data-ttu-id="1de85-227">このインターフェイスでは、最小限の機能が保証されています。これによって、実装するクラスでプロパティーが設定できなくなるということはありません。</span><span class="sxs-lookup"><span data-stu-id="1de85-227">The interface guarantees minimum functionality, and it does not stop an implementing class from allowing the property to be set.</span></span>

[<span data-ttu-id="1de85-228">TypeOf \<expr> IsNot \<type></span><span class="sxs-lookup"><span data-stu-id="1de85-228">TypeOf \<expr> IsNot \<type></span></span>](../language-reference/operators/typeof-operator.md)

<span data-ttu-id="1de85-229">コードを見やすくするために、`TypeOf` を `IsNot` とともに使用できるようになりました。</span><span class="sxs-lookup"><span data-stu-id="1de85-229">For more readability of your code, you can now use `TypeOf` with `IsNot`.</span></span>

[<span data-ttu-id="1de85-230">#Disable Warning \<ID> と #Enable Warning \<ID></span><span class="sxs-lookup"><span data-stu-id="1de85-230">#Disable Warning \<ID> and #Enable Warning \<ID></span></span>](../language-reference/directives/disable-enable.md)

<span data-ttu-id="1de85-231">ソース ファイル内の領域の特定の警告を無効化および有効化することができます。</span><span class="sxs-lookup"><span data-stu-id="1de85-231">You can disable and enable specific warnings for regions within a source file.</span></span>

<span data-ttu-id="1de85-232">**XML ドキュメント コメントの機能強化**</span><span class="sxs-lookup"><span data-stu-id="1de85-232">**XML doc comment improvements**</span></span>

<span data-ttu-id="1de85-233">ドキュメント コメントを記述する際、スマート エディターを取得し、パラメーター名の検証、`crefs` の適切な処理 (ジェネリック、演算子など)、色分け、リファクタリングのためのサポートを構築します。</span><span class="sxs-lookup"><span data-stu-id="1de85-233">When writing doc comments, you get smart editor and build support for validating parameter names, proper handling of `crefs` (generics, operators, etc.), colorizing, and refactoring.</span></span>

[<span data-ttu-id="1de85-234">部分モジュールとインターフェイスの定義</span><span class="sxs-lookup"><span data-stu-id="1de85-234">Partial module and interface definitions</span></span>](../language-reference/modifiers/partial.md)

<span data-ttu-id="1de85-235">クラスと構造体に加えて、部分モジュールとインターフェイスを宣言できます。</span><span class="sxs-lookup"><span data-stu-id="1de85-235">In addition to classes and structs, you can declare partial modules and interfaces.</span></span>

[<span data-ttu-id="1de85-236">メソッド本体内の #Region ディレクティブ</span><span class="sxs-lookup"><span data-stu-id="1de85-236">#Region directives inside method bodies</span></span>](../language-reference/directives/region-directive.md)

<span data-ttu-id="1de85-237">#Region…#End Region 区切り記号をファイルの任意の場所に挿入できます。関数内に装入することも、複数の関数本体に渡って挿入することもできます。</span><span class="sxs-lookup"><span data-stu-id="1de85-237">You can put #Region…#End Region delimiters anywhere in a file, inside functions, and even spanning across function bodies.</span></span>

[<span data-ttu-id="1de85-238">オーバーライドの定義は暗黙的オーバーロードです</span><span class="sxs-lookup"><span data-stu-id="1de85-238">Overrides definitions are implicitly overloads</span></span>](../language-reference/modifiers/overrides.md)

<span data-ttu-id="1de85-239">`Overrides` 修飾子を定義に追加する場合には、コンパイラが `Overloads`  を暗黙的に追加し、共通のケースで入力するコードを少なくできるようにします。</span><span class="sxs-lookup"><span data-stu-id="1de85-239">If you add the `Overrides` modifier to a definition, the compiler implicitly adds `Overloads` so that you can type less code in common cases.</span></span>

<span data-ttu-id="1de85-240">**属性の引数で使用できる CObj**</span><span class="sxs-lookup"><span data-stu-id="1de85-240">**CObj allowed in attributes arguments**</span></span>

<span data-ttu-id="1de85-241">以前、コンパイラーは、CObj(…) を属性の構築で使用するときにそれが定数でないというエラーを報告していました。</span><span class="sxs-lookup"><span data-stu-id="1de85-241">The compiler used to give an error that CObj(…) was not a constant when used in attribute constructions.</span></span>

<span data-ttu-id="1de85-242">**異なるインターフェイスからのあいまいなメソッドの宣言と使用**</span><span class="sxs-lookup"><span data-stu-id="1de85-242">**Declaring and consuming ambiguous methods from different interfaces**</span></span>

<span data-ttu-id="1de85-243">以前、以下のコードはエラーになり、`IMock` を宣言したり `GetDetails` を呼び出すことができなくなっていました (これらが C# で宣言されていた場合)。</span><span class="sxs-lookup"><span data-stu-id="1de85-243">Previously the following code yielded errors that prevented you from declaring `IMock` or from calling `GetDetails` (if these had been declared in C#):</span></span>

```vb
Interface ICustomer
  Sub GetDetails(x As Integer)
End Interface

Interface ITime
  Sub GetDetails(x As String)
End Interface

Interface IMock : Inherits ICustomer, ITime
  Overloads Sub GetDetails(x As Char)
End Interface

Interface IMock2 : Inherits ICustomer, ITime
End Interface
```

<span data-ttu-id="1de85-244">コンパイラーは通常のオーバーロード解決規則を使用して、呼び出しに最も適切な `GetDetails` を選択するようになりました。サンプルで示されているようなインターフェイスのリレーションシップを Visual Basic で宣言できるようになりました。</span><span class="sxs-lookup"><span data-stu-id="1de85-244">Now the compiler will use normal overload resolution rules to choose the most appropriate `GetDetails` to call, and you can declare interface relationships in Visual Basic like those shown in the sample.</span></span>

## <a name="see-also"></a><span data-ttu-id="1de85-245">関連項目</span><span class="sxs-lookup"><span data-stu-id="1de85-245">See also</span></span>

- [<span data-ttu-id="1de85-246">Visual Studio 2017 の新機能</span><span class="sxs-lookup"><span data-stu-id="1de85-246">What's New in Visual Studio 2017</span></span>](/visualstudio/ide/whats-new-visual-studio-2017)
- [<span data-ttu-id="1de85-247">Visual Studio 2019 の新機能</span><span class="sxs-lookup"><span data-stu-id="1de85-247">What's New in Visual Studio 2019</span></span>](/visualstudio/ide/whats-new-visual-studio-2019)
