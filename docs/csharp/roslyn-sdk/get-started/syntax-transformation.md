---
title: 構文変換の概要 (Roslyn API)
description: 構文ツリーの走査、クエリおよびウォークに関する概要。
ms.date: 06/01/2018
ms.custom: mvc
ms.openlocfilehash: f12727332256acd9bbe828b9149376080facd156
ms.sourcegitcommit: 652f62fc8f3ab6a264681b6eb5211ac7539bd115
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/30/2021
ms.locfileid: "105964823"
---
# <a name="get-started-with-syntax-transformation"></a><span data-ttu-id="cc1df-103">構文変換の概要</span><span class="sxs-lookup"><span data-stu-id="cc1df-103">Get started with syntax transformation</span></span>

<span data-ttu-id="cc1df-104">このチュートリアルは、「[構文解析の概要](syntax-analysis.md)」および「[セマンティック解析の概要](semantic-analysis.md)」クイック スタートで説明した概念と手法に基づいて作成されています。</span><span class="sxs-lookup"><span data-stu-id="cc1df-104">This tutorial builds on concepts and techniques explored in the [Get started with syntax analysis](syntax-analysis.md) and [Get started with semantic analysis](semantic-analysis.md) quickstarts.</span></span> <span data-ttu-id="cc1df-105">これらのクイック スタートをまだ完了していない場合は、このクイック スタートを始める前に完了する必要があります。</span><span class="sxs-lookup"><span data-stu-id="cc1df-105">If you haven't already, you should complete those quickstarts before beginning this one.</span></span>

<span data-ttu-id="cc1df-106">このクイック スタートでは、構文ツリーを作成および変換する手法を学習します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-106">In this quickstart, you explore techniques for creating and transforming syntax trees.</span></span> <span data-ttu-id="cc1df-107">前のクイック スタートで学習した手法と組み合わせて、初めてのコマンド ライン リファクタリングを作成します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-107">In combination with the techniques you learned in previous quickstarts, you create your first command-line refactoring!</span></span>

[!INCLUDE[interactive-note](~/includes/roslyn-installation.md)]

## <a name="immutability-and-the-net-compiler-platform"></a><span data-ttu-id="cc1df-108">不変性と .NET コンパイラ プラットフォーム</span><span class="sxs-lookup"><span data-stu-id="cc1df-108">Immutability and the .NET compiler platform</span></span>

<span data-ttu-id="cc1df-109">**不変性** は、.NET コンパイラ プラットフォームの基本原則です。</span><span class="sxs-lookup"><span data-stu-id="cc1df-109">**Immutability** is a fundamental tenet of the .NET compiler platform.</span></span> <span data-ttu-id="cc1df-110">不変データ構造は、作成後には変更できません。</span><span class="sxs-lookup"><span data-stu-id="cc1df-110">Immutable data structures can't be changed after they're created.</span></span> <span data-ttu-id="cc1df-111">不変データ構造は、複数のコンシューマーから安全かつ同時に共有、分析できます。</span><span class="sxs-lookup"><span data-stu-id="cc1df-111">Immutable data structures can be safely shared and analyzed by multiple consumers simultaneously.</span></span> <span data-ttu-id="cc1df-112">コンシューマーが、予期できない方法で別のコンシューマーに影響を及ぼす危険はありません。</span><span class="sxs-lookup"><span data-stu-id="cc1df-112">There's no danger that one consumer affects another in unpredictable ways.</span></span> <span data-ttu-id="cc1df-113">アナライザーには、ロックやその他のコンカレンシー手段は不要です。</span><span class="sxs-lookup"><span data-stu-id="cc1df-113">Your analyzer doesn't need locks or other concurrency measures.</span></span> <span data-ttu-id="cc1df-114">この規則は、構文ツリー、コンパイル、記号、セマンティック モデルなど、出現するすべてのデータ構造に当てはまります。</span><span class="sxs-lookup"><span data-stu-id="cc1df-114">This rule applies to syntax trees, compilations, symbols, semantic models, and every other data structure you encounter.</span></span> <span data-ttu-id="cc1df-115">既存の構造体を変更するのではなく、API は古いオブジェクトに対して指定された相違点に基づいて、新しいオブジェクトを作成します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-115">Instead of modifying existing structures, APIs create new objects based on specified differences to the old ones.</span></span> <span data-ttu-id="cc1df-116">この概念を構文ツリーに適用して、変換を使用して新しいツリーを作成します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-116">You apply this concept to syntax trees to create new trees using transformations.</span></span>

## <a name="create-and-transform-trees"></a><span data-ttu-id="cc1df-117">ツリーの作成と変換</span><span class="sxs-lookup"><span data-stu-id="cc1df-117">Create and transform trees</span></span>

<span data-ttu-id="cc1df-118">構文の変換では、2 つの方法のうち 1 つを選択します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-118">You choose one of two strategies for syntax transformations.</span></span> <span data-ttu-id="cc1df-119">**ファクトリ メソッド** は、置き換える特定のノードや、新しいコードを挿入する特定の場所を検索するときに最もよく使用されます。</span><span class="sxs-lookup"><span data-stu-id="cc1df-119">**Factory methods** are best used when you're searching for specific nodes to replace, or specific locations where you want to insert new code.</span></span> <span data-ttu-id="cc1df-120">**リライター** は、プロジェクト全体をスキャンして、置き換えるコード パターンを探す場合に最適です。</span><span class="sxs-lookup"><span data-stu-id="cc1df-120">**Rewriters** are best when you want to scan an entire project for code patterns that you want to replace.</span></span>

### <a name="create-nodes-with-factory-methods"></a><span data-ttu-id="cc1df-121">ファクトリ メソッドを使用してノードを作成する</span><span class="sxs-lookup"><span data-stu-id="cc1df-121">Create nodes with factory methods</span></span>

<span data-ttu-id="cc1df-122">最初の構文変換では、ファクトリ メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-122">The first syntax transformation demonstrates the factory methods.</span></span> <span data-ttu-id="cc1df-123">`using System.Collections;` ステートメントを `using System.Collections.Generic;` ステートメントで置き換えます。</span><span class="sxs-lookup"><span data-stu-id="cc1df-123">You're going to replace a `using System.Collections;` statement with a `using System.Collections.Generic;` statement.</span></span> <span data-ttu-id="cc1df-124">この例は、<xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> ファクトリ メソッドを使用して <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode?displayProperty=nameWithType> オブジェクトを作成する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="cc1df-124">This example demonstrates how you create <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode?displayProperty=nameWithType> objects using the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> factory methods.</span></span> <span data-ttu-id="cc1df-125">**ノード**、**トークン**、**トリビア** の各種類に対して、その種類のインスタンスを作成するファクトリ メソッドが用意されています。</span><span class="sxs-lookup"><span data-stu-id="cc1df-125">For each kind of **node**, **token**, or **trivia**, there's a factory method that creates an instance of that type.</span></span> <span data-ttu-id="cc1df-126">ボトムアップ方式でノードを階層的に構成して、構文ツリーを作成します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-126">You create syntax trees by composing nodes hierarchically in a bottom-up fashion.</span></span> <span data-ttu-id="cc1df-127">次に、既存のノードを作成した新しいツリーで置き換えることで、既存のプログラムを変換します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-127">Then, you'll transform the existing program by replacing existing nodes with the new tree you've created.</span></span>

<span data-ttu-id="cc1df-128">Visual Studio を起動し、新しい C# の **Stand-Alone Code Analysis Tool** プロジェクトを作成します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-128">Start Visual Studio, and create a new C# **Stand-Alone Code Analysis Tool** project.</span></span> <span data-ttu-id="cc1df-129">Visual Studio で、 **[ファイル]**  >  **[新規]**  >  **[プロジェクト]** の順に選択して、[新しいプロジェクト] ダイアログを表示します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-129">In Visual Studio, choose **File** > **New** > **Project** to display the New Project dialog.</span></span> <span data-ttu-id="cc1df-130">**[Visual C#]**  >  **[機能拡張]** で、 **[Stand-Alone Code Analysis Tool]** を選択します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-130">Under **Visual C#** > **Extensibility** choose a **Stand-Alone Code Analysis Tool**.</span></span> <span data-ttu-id="cc1df-131">このクイック スタートには 2 つのサンプル プロジェクトがあるため、ソリューションに「**SyntaxTransformationQuickStart**」、プロジェクトに「**ConstructionCS**」という名前を付けます。</span><span class="sxs-lookup"><span data-stu-id="cc1df-131">This quickstart has two example projects, so name the solution **SyntaxTransformationQuickStart**, and name the project **ConstructionCS**.</span></span> <span data-ttu-id="cc1df-132">**[OK]** をクリックします。</span><span class="sxs-lookup"><span data-stu-id="cc1df-132">Click **OK**.</span></span>

<span data-ttu-id="cc1df-133">このプロジェクトでは、<xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> クラスのメソッドを使用して、`System.Collections.Generic` 名前空間を表す <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType> を構築します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-133">This project uses the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> class methods to construct a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType> representing the `System.Collections.Generic` namespace.</span></span>

<span data-ttu-id="cc1df-134">`Program.cs` の先頭に、次の using ディレクティブを追加します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-134">Add the following using directive to the top of the `Program.cs`.</span></span>

[!code-csharp[import the SyntaxFactory class](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#StaticUsings "import the Syntax Factory class and the System.Console class")]

<span data-ttu-id="cc1df-135">`using System.Collections.Generic;` ステートメントを表すツリーをビルドするための **名前構文ノード** を作成します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-135">You'll create **name syntax nodes** to build the tree that represents the `using System.Collections.Generic;` statement.</span></span> <span data-ttu-id="cc1df-136"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> は、C# に現れる 4 つの型の基底クラスです。</span><span class="sxs-lookup"><span data-stu-id="cc1df-136"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> is the base class for four types of names that appear in C#.</span></span> <span data-ttu-id="cc1df-137">これらの 4 つの型の名前を組み合わせて、C# 言語中に出現するすべての名前を作成できます。</span><span class="sxs-lookup"><span data-stu-id="cc1df-137">You compose these four types of names together to create any name that can appear in the C# language:</span></span>

* <span data-ttu-id="cc1df-138"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>: `System` や `Microsoft` のような、単一のシンプルな名前を表します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-138"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>, which represents simple single identifier names like `System` and `Microsoft`.</span></span>
* <span data-ttu-id="cc1df-139"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax?displayProperty=nameWithType>: `List<int>` のような、ジェネリック型またはジェネリック メソッドの名前を表します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-139"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax?displayProperty=nameWithType>, which represents a generic type or method name such as `List<int>`.</span></span>
* <span data-ttu-id="cc1df-140"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax?displayProperty=nameWithType>: `System.IO` のような、`<left-name>.<right-identifier-or-generic-name>` 形式の修飾名を表します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-140"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax?displayProperty=nameWithType>, which represents a qualified name of the form `<left-name>.<right-identifier-or-generic-name>` such as `System.IO`.</span></span>
* <span data-ttu-id="cc1df-141"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax?displayProperty=nameWithType>: `LibraryV2::Foo` のような、アセンブリ外部エイリアスを使用した名前を表します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-141"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax?displayProperty=nameWithType>, which represents a name using an assembly extern alias such a `LibraryV2::Foo`.</span></span>

<span data-ttu-id="cc1df-142"><xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IdentifierName(System.String)> メソッドを使用して、<xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> ノードを作成します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-142">You use the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IdentifierName(System.String)> method to create a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> node.</span></span> <span data-ttu-id="cc1df-143">`Program.cs` で、`Main` メソッドに次のコードを追加します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-143">Add the following code in your `Main` method in `Program.cs`:</span></span>

[!code-csharp[create the system identifier](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateIdentifierName "Create and display the system name identifier")]

<span data-ttu-id="cc1df-144">上のコードでは、<xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> オブジェクトを作成して変数 `name` に割り当てます。</span><span class="sxs-lookup"><span data-stu-id="cc1df-144">The preceding code creates an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> object and assigns it to the variable `name`.</span></span> <span data-ttu-id="cc1df-145">Roslyn API の多くは、関連の型を使用しやすくするために基底クラスを返します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-145">Many of the Roslyn APIs return base classes to make it easier to work with related types.</span></span> <span data-ttu-id="cc1df-146"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> である変数 `name` は、<xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax> をビルドするときに再利用できます。</span><span class="sxs-lookup"><span data-stu-id="cc1df-146">The variable `name`, an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax>, can be reused as you build the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="cc1df-147">サンプルをビルドするときに、型の推定を使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="cc1df-147">Don't use type inference as you build the sample.</span></span> <span data-ttu-id="cc1df-148">このプロジェクトではそのステップを自動化します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-148">You'll automate that step in this project.</span></span>

<span data-ttu-id="cc1df-149">これで名前が作成されました。</span><span class="sxs-lookup"><span data-stu-id="cc1df-149">You've created the name.</span></span> <span data-ttu-id="cc1df-150">次に、<xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax> をビルドして、ツリー内にさらに多くのノードをビルドします。</span><span class="sxs-lookup"><span data-stu-id="cc1df-150">Now, it's time to build more nodes into the tree by building a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="cc1df-151">新しいツリーでは、`name` を名前の左側として使用し、`Collections` 名前空間の新しい <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> を <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax> の右側として使用します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-151">The new tree uses `name` as the left of the name, and a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> for the `Collections` namespace as the right side of the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="cc1df-152">`program.cs` に次のコードを追加します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-152">Add the following code to `program.cs`:</span></span>

[!code-csharp[create the collections identifier](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateQualifiedIdentifierName "Build the System.Collections identifier")]

<span data-ttu-id="cc1df-153">コードを再度実行し、結果を確認します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-153">Run the code again, and see the results.</span></span> <span data-ttu-id="cc1df-154">コードを表すノードのツリーをビルドします。</span><span class="sxs-lookup"><span data-stu-id="cc1df-154">You're building a tree of nodes that represents code.</span></span> <span data-ttu-id="cc1df-155">このパターンを繰り返して、名前空間 `System.Collections.Generic` の <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax> をビルドします。</span><span class="sxs-lookup"><span data-stu-id="cc1df-155">You'll continue this pattern to build the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax> for the namespace `System.Collections.Generic`.</span></span> <span data-ttu-id="cc1df-156">`Program.cs` に次のコードを追加します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-156">Add the following code to `Program.cs`:</span></span>

[!code-csharp[create the full identifier](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateFullNamespace "Build the System.Collections.Generic identifier")]

<span data-ttu-id="cc1df-157">プログラムを再度実行して、追加するコード用のツリーがビルドされたことを確認します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-157">Run the program again to see that you've built the tree for the code to add.</span></span>

### <a name="create-a-modified-tree"></a><span data-ttu-id="cc1df-158">変更されたツリーを作成する</span><span class="sxs-lookup"><span data-stu-id="cc1df-158">Create a modified tree</span></span>

<span data-ttu-id="cc1df-159">これで、1 つのステートメントを含む小さな構文ツリーがビルドされました。</span><span class="sxs-lookup"><span data-stu-id="cc1df-159">You've built a small syntax tree that contains one statement.</span></span> <span data-ttu-id="cc1df-160">新しいノードを作成するための API は、単一のステートメントや他の小規模なコード ブロックを作成するときに適した選択肢です。</span><span class="sxs-lookup"><span data-stu-id="cc1df-160">The APIs to create new nodes are the right choice to create single statements or other small code blocks.</span></span> <span data-ttu-id="cc1df-161">しかし、より大規模なコード ブロックをビルドするときは、ノードを置き換えたり既存のツリーにノードを挿入するためのメソッドを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="cc1df-161">However, to build larger blocks of code, you should use methods that replace nodes or insert nodes into an existing tree.</span></span> <span data-ttu-id="cc1df-162">すでに説明したように、構文ツリーは不変です。</span><span class="sxs-lookup"><span data-stu-id="cc1df-162">Remember that syntax trees are immutable.</span></span> <span data-ttu-id="cc1df-163">**構文 API** には、作成後に既存の構文ツリーを変更するメカニズムはありません。</span><span class="sxs-lookup"><span data-stu-id="cc1df-163">The **Syntax API** doesn't provide any mechanism for modifying an existing syntax tree after construction.</span></span> <span data-ttu-id="cc1df-164">その代わり、既存のツリーへの変更に基づいて新しいツリーを生成するメソッドが用意されています。</span><span class="sxs-lookup"><span data-stu-id="cc1df-164">Instead, it provides methods that produce new trees based on changes to existing ones.</span></span> <span data-ttu-id="cc1df-165">`With*` メソッドは、<xref:Microsoft.CodeAnalysis.SyntaxNode> から派生した具象クラス内、または <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions> クラスで宣言された拡張メソッド内で定義されます。</span><span class="sxs-lookup"><span data-stu-id="cc1df-165">`With*` methods are defined in concrete classes that derive from <xref:Microsoft.CodeAnalysis.SyntaxNode> or in extension methods declared in the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions> class.</span></span> <span data-ttu-id="cc1df-166">これらのメソッドは、既存のノードの子プロパティに変更を適用することで新しいノードを作成します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-166">These methods create a new node by applying changes to an existing node's child properties.</span></span> <span data-ttu-id="cc1df-167">さらに、<xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> 拡張メソッドを使用すると、サブツリー内の子孫ノードを置き換えることができます。</span><span class="sxs-lookup"><span data-stu-id="cc1df-167">Additionally, the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> extension method can be used to replace a descendent node in a subtree.</span></span> <span data-ttu-id="cc1df-168">このメソッドも、新しく作成された子ノードをポイントするように親を更新し、このプロセスをツリー全体で上位に向かって繰り返します (このプロセスを、ツリーの "_再スピン_" と呼びます)。</span><span class="sxs-lookup"><span data-stu-id="cc1df-168">This method also updates the parent to point to the newly created child and repeats this process up the entire tree - a process known as _re-spinning_ the tree.</span></span>

<span data-ttu-id="cc1df-169">次のステップでは、(小規模な) プログラム全体を表すツリーを作成した後で、それを変更します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-169">The next step is to create a tree that represents an entire (small) program and then modify it.</span></span> <span data-ttu-id="cc1df-170">`Program` クラスの先頭に次のコードを追加します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-170">Add the following code to the beginning of the `Program` class:</span></span>

[!code-csharp[create a parse tree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#DeclareSampleCode "Create a tree that represents a small program")]

> [!NOTE]
> <span data-ttu-id="cc1df-171">このコード例では、`System.Collections.Generic` 名前空間ではなく `System.Collections` 名前空間を使用します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-171">The example code uses the `System.Collections` namespace and not the `System.Collections.Generic` namespace.</span></span>

<span data-ttu-id="cc1df-172">次に、`Main` メソッドの末尾に、テキストを解析してツリーを作成する次のコードを追加します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-172">Next, add the following code to the bottom of the `Main` method to parse the text and create a tree:</span></span>

[!code-csharp[create a parse tree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateParseTree "Create a tree that represents a small program")]

<span data-ttu-id="cc1df-173">この例では、<xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)?displayProperty=NameWithType> メソッドを使用して、<xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> ノード内の名前を先ほどのコードで作成した名前に置き換えます。</span><span class="sxs-lookup"><span data-stu-id="cc1df-173">This example uses the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)?displayProperty=NameWithType> method to replace the name in a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> node with the one constructed in the preceding code.</span></span>

<span data-ttu-id="cc1df-174">名前 `System.Collections` を先ほどのコードで作成した名前に置き換えるには、<xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)> メソッドを使用して新しい <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> ノードを作成します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-174">Create a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> node using the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)> method to update the `System.Collections` name with the name you created in the preceding code.</span></span> <span data-ttu-id="cc1df-175">`Main` メソッドの末尾に次のコードを追加します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-175">Add the following code to the bottom of the `Main` method:</span></span>

[!code-csharp[create a new subtree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#BuildNewUsing "Create the subtree with the replaced namespace")]

<span data-ttu-id="cc1df-176">プログラムを実行し、出力を注意深く見てください。</span><span class="sxs-lookup"><span data-stu-id="cc1df-176">Run the program and look carefully at the output.</span></span> <span data-ttu-id="cc1df-177">ルート ツリーに `newUsing` が配置されていません。</span><span class="sxs-lookup"><span data-stu-id="cc1df-177">The `newUsing` hasn't been placed in the root tree.</span></span> <span data-ttu-id="cc1df-178">元のツリーは変更されていません。</span><span class="sxs-lookup"><span data-stu-id="cc1df-178">The original tree hasn't been changed.</span></span>

<span data-ttu-id="cc1df-179">新しいツリーを作成するために、<xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> 拡張メソッドを使用した次のコードを追加します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-179">Add the following code using the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> extension method to create a new tree.</span></span> <span data-ttu-id="cc1df-180">新しいツリーが、既存のインポートを更新された `newUsing` ノードで置き換えた結果として作成されます。</span><span class="sxs-lookup"><span data-stu-id="cc1df-180">The new tree is the result of replacing the existing import with the updated `newUsing` node.</span></span> <span data-ttu-id="cc1df-181">この新しいツリーを既存の `root` に割り当てます。</span><span class="sxs-lookup"><span data-stu-id="cc1df-181">You assign this new tree to the existing `root` variable:</span></span>

[!code-csharp[create a new root tree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#TransformTree "Create the transformed root tree with the replaced namespace")]

<span data-ttu-id="cc1df-182">再びプログラムを実行します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-182">Run the program again.</span></span> <span data-ttu-id="cc1df-183">今度は、ツリーに `System.Collections.Generic` 名前空間が正しくインポートされます。</span><span class="sxs-lookup"><span data-stu-id="cc1df-183">This time the tree now correctly imports the `System.Collections.Generic` namespace.</span></span>

### <a name="transform-trees-using-syntaxrewriters"></a><span data-ttu-id="cc1df-184">`SyntaxRewriters` を使用してツリーを変換する</span><span class="sxs-lookup"><span data-stu-id="cc1df-184">Transform trees using `SyntaxRewriters`</span></span>

<span data-ttu-id="cc1df-185">`With*` メソッドと <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> メソッドは、構文ツリーの個々のブランチを変換するのに便利な手段です。</span><span class="sxs-lookup"><span data-stu-id="cc1df-185">The `With*` and <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> methods provide convenient means to transform individual branches of a syntax tree.</span></span> <span data-ttu-id="cc1df-186"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> クラスは、構文ツリー上で複数の変換を実行します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-186">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> class performs multiple transformations on a syntax tree.</span></span> <span data-ttu-id="cc1df-187"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> クラスは <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor%601?displayProperty=nameWithType> のサブクラスです。</span><span class="sxs-lookup"><span data-stu-id="cc1df-187">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> class is a subclass of <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="cc1df-188"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> は、特定の型の <xref:Microsoft.CodeAnalysis.SyntaxNode> に変換を適用します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-188">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> applies a transformation to a specific type of <xref:Microsoft.CodeAnalysis.SyntaxNode>.</span></span> <span data-ttu-id="cc1df-189">構文ツリー内にその型が存在すれば、複数の型の <xref:Microsoft.CodeAnalysis.SyntaxNode> オブジェクトに変換を適用できます。</span><span class="sxs-lookup"><span data-stu-id="cc1df-189">You can apply transformations to multiple types of <xref:Microsoft.CodeAnalysis.SyntaxNode> objects wherever they appear in a syntax tree.</span></span> <span data-ttu-id="cc1df-190">このクイック スタートの 2 番目のプロジェクトでは、型の推定が使用される可能性があるすべての場所のローカル変数宣言に含まれる明示的な型を削除する、コマンド ライン リファクタリングを作成します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-190">The second project in this quickstart creates a command-line refactoring that removes explicit types in local variable declarations anywhere that type inference could be used.</span></span>

<span data-ttu-id="cc1df-191">新しい C# の **Stand-Alone Code Analysis Tool** プロジェクトを作成します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-191">Create a new C# **Stand-Alone Code Analysis Tool** project.</span></span> <span data-ttu-id="cc1df-192">Visual Studio で、`SyntaxTransformationQuickStart` ソリューション ノードを右クリックします。</span><span class="sxs-lookup"><span data-stu-id="cc1df-192">In Visual Studio, right-click the `SyntaxTransformationQuickStart` solution node.</span></span> <span data-ttu-id="cc1df-193">**[追加]**  >  **[新しいプロジェクト]** を選択して、 **[新しいプロジェクト] ダイアログ** を表示します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-193">Choose **Add** > **New Project** to display the **New Project dialog**.</span></span> <span data-ttu-id="cc1df-194">**[Visual C#]**  >  **[機能拡張]** で、 **[Stand-Alone Code Analysis Tool]** を選択します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-194">Under **Visual C#** > **Extensibility**, choose **Stand-Alone Code Analysis Tool**.</span></span> <span data-ttu-id="cc1df-195">プロジェクトに「`TransformationCS`」という名前を付けて、[OK] をクリックします。</span><span class="sxs-lookup"><span data-stu-id="cc1df-195">Name your project `TransformationCS` and click OK.</span></span>

<span data-ttu-id="cc1df-196">最初のステップは、変換を実行するための <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> から派生したクラスを作成することです。</span><span class="sxs-lookup"><span data-stu-id="cc1df-196">The first step is to create a class that derives from <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> to perform your transformations.</span></span> <span data-ttu-id="cc1df-197">新しいクラスのファイルをプロジェクトに追加します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-197">Add a new class file to the project.</span></span> <span data-ttu-id="cc1df-198">Visual Studio で、 **[プロジェクト]**  >  **[クラスの追加...]** を選択します。 **[新しい項目の追加]** ダイアログで、ファイル名として「`TypeInferenceRewriter.cs`」を入力します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-198">In Visual Studio, choose **Project** > **Add Class...**. In the **Add New Item** dialog type `TypeInferenceRewriter.cs` as the filename.</span></span>

<span data-ttu-id="cc1df-199">`TypeInferenceRewriter.cs` ファイルに次の using ディレクティブを追加します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-199">Add the following using directives to the `TypeInferenceRewriter.cs` file:</span></span>

[!code-csharp[add necessary usings](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#AddUsings "Add required usings")]

<span data-ttu-id="cc1df-200">次に、`TypeInferenceRewriter` クラスで <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> クラスを拡張します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-200">Next, make the `TypeInferenceRewriter` class extend the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> class:</span></span>

[!code-csharp[add base class](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#BaseClass "Add base class")]

<span data-ttu-id="cc1df-201">次のコードを追加して、<xref:Microsoft.CodeAnalysis.SemanticModel> を保持する読み取り専用の private フィールドを宣言し、コンストラクター内で初期化します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-201">Add the following code to declare a private read-only field to hold a <xref:Microsoft.CodeAnalysis.SemanticModel> and initialize it in the constructor.</span></span> <span data-ttu-id="cc1df-202">このフィールドは、後で型の推定を使用できる場所を特定するために必要になります。</span><span class="sxs-lookup"><span data-stu-id="cc1df-202">You will need this field later on to determine where type inference can be used:</span></span>

[!code-csharp[initialize members](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#Construction "Declare and initialize member variables")]

<span data-ttu-id="cc1df-203"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> メソッドをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="cc1df-203">Override the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> method:</span></span>

```csharp
public override SyntaxNode VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
{

}
```

> [!NOTE]
> <span data-ttu-id="cc1df-204">Roslyn API の多くは、返される実際の ランタイム型の基底クラスである戻り値の型を宣言します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-204">Many of the Roslyn APIs declare return types that are base classes of the actual runtime types returned.</span></span> <span data-ttu-id="cc1df-205">多くのシナリオでは、ノードが別の種類のノードに完全に置き換えられることがあり、削除される場合もあります。</span><span class="sxs-lookup"><span data-stu-id="cc1df-205">In many scenarios, one kind of node may be replaced by another kind of node entirely - or even removed.</span></span> <span data-ttu-id="cc1df-206">この例では、<xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> メソッドは <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> の派生型ではなく <xref:Microsoft.CodeAnalysis.SyntaxNode> を返します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-206">In this example, the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> method returns a <xref:Microsoft.CodeAnalysis.SyntaxNode>, instead of the derived type of   <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax>.</span></span> <span data-ttu-id="cc1df-207">このリライターは、既存のノードに基づいて新しい <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> ノードを返します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-207">This rewriter returns a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> node based on the existing one.</span></span>

<span data-ttu-id="cc1df-208">このクイック スタートでは、ローカル変数宣言を処理します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-208">This quickstart handles local variable declarations.</span></span> <span data-ttu-id="cc1df-209">これは `foreach` ループ、`for` ループ、LINQ 式、ラムダ式などの他の宣言にも拡張できます。</span><span class="sxs-lookup"><span data-stu-id="cc1df-209">You could extend it to other declarations such as `foreach` loops, `for` loops, LINQ expressions, and lambda expressions.</span></span> <span data-ttu-id="cc1df-210">さらに、このリライターは、次のような最も単純な形式の宣言しか変換しません。</span><span class="sxs-lookup"><span data-stu-id="cc1df-210">Furthermore this rewriter will only transform declarations of the simplest form:</span></span>

```csharp
Type variable = expression;
```

<span data-ttu-id="cc1df-211">自分で探究したい場合は、次のような変数宣言の型の完成したサンプルを拡張することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="cc1df-211">If you want to explore on your own, consider extending the finished sample for these types of variable declarations:</span></span>

```csharp
// Multiple variables in a single declaration.
Type variable1 = expression1,
     variable2 = expression2;
// No initializer.
Type variable;
```

<span data-ttu-id="cc1df-212">次のコードを `VisitLocalDeclarationStatement` メソッドの本体に追加して、これらの形式の宣言の書き換えをスキップするようにします。</span><span class="sxs-lookup"><span data-stu-id="cc1df-212">Add the following code to the body of the `VisitLocalDeclarationStatement` method to skip rewriting these forms of declarations:</span></span>

[!code-csharp[exclude other declarations](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#Exclusions "Exclude variables declarations not processed by this sample")]

<span data-ttu-id="cc1df-213">このメソッドは、`node` パラメーターを変更せずに返すことにより、書き換えが行われないことを示します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-213">The method indicates that no rewriting takes place by returning the `node` parameter unmodified.</span></span> <span data-ttu-id="cc1df-214">いずれの `if` 式も true でない場合、ノードは初期化で可能な宣言を表します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-214">If neither of those `if` expressions are true, the node represents a possible declaration with initialization.</span></span> <span data-ttu-id="cc1df-215">以下のステートメントを追加して、宣言で指定されている型の名前を抽出し、それを <xref:Microsoft.CodeAnalysis.SemanticModel> フィールドを使用してバインドして、型のシンボルを取得できるようにします。</span><span class="sxs-lookup"><span data-stu-id="cc1df-215">Add these statements to extract the type name specified in the declaration and bind it using the <xref:Microsoft.CodeAnalysis.SemanticModel> field to obtain a type symbol:</span></span>

[!code-csharp[extract type name](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#ExtractTypeSymbol "Extract the type name specified by the declaration")]

<span data-ttu-id="cc1df-216">さらに、次のステートメントを追加して、初期化子式をバインドします。</span><span class="sxs-lookup"><span data-stu-id="cc1df-216">Now, add this statement to bind the initializer expression:</span></span>

[!code-csharp[bind initializer](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#BindInitializer "Bind the initializer expressions")]

<span data-ttu-id="cc1df-217">最後に、次の `if` ステートメントを追加して、初期化子式の型が指定の型と一致した場合に既存の型名を `var` キーワードで置き換えるようにします。</span><span class="sxs-lookup"><span data-stu-id="cc1df-217">Finally, add the following `if` statement to replace the existing type name with the `var` keyword if the type of the initializer expression matches the type specified:</span></span>

[!code-csharp[ReplaceNode](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#ReplaceNode "Replace the initializer node")]

<span data-ttu-id="cc1df-218">宣言では初期化子式が基底クラスまたはインターフェイスにキャストされる場合があるので、この条件が必要です。</span><span class="sxs-lookup"><span data-stu-id="cc1df-218">The conditional is required because the declaration may cast the initializer expression to a base class or interface.</span></span> <span data-ttu-id="cc1df-219">必要な場合は、割り当ての左側の型と右側の型が一致しません。</span><span class="sxs-lookup"><span data-stu-id="cc1df-219">If that's desired, the types on the left and right-hand side of the assignment don't match.</span></span> <span data-ttu-id="cc1df-220">このようなケースで明示的な型を削除すると、プログラムのセマンティクスが変わってしまいます。</span><span class="sxs-lookup"><span data-stu-id="cc1df-220">Removing the explicit type in these cases would change the semantics of a program.</span></span> <span data-ttu-id="cc1df-221">`var` はコンテキスト キーワードであるため、`var` はキーワードではなく識別子として指定されます。</span><span class="sxs-lookup"><span data-stu-id="cc1df-221">`var` is specified as an identifier rather than a keyword because `var` is a contextual keyword.</span></span> <span data-ttu-id="cc1df-222">垂直方向の空白とインデントを維持するために、先頭および末尾のトリビア (空白) が古い型名から `var` キーワードへと転送されています。</span><span class="sxs-lookup"><span data-stu-id="cc1df-222">The leading and trailing trivia (white space) are transferred from the old type name to the `var` keyword to maintain vertical white space and indentation.</span></span> <span data-ttu-id="cc1df-223">型名は実際には宣言ステートメントの孫であるため、`With*` よりも `ReplaceNode` を使用して <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> を変換するほうが簡単です。</span><span class="sxs-lookup"><span data-stu-id="cc1df-223">It's simpler to use `ReplaceNode` rather than `With*` to transform the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> because the type name is actually the grandchild of the declaration statement.</span></span>

<span data-ttu-id="cc1df-224">これで `TypeInferenceRewriter` が完成しました。</span><span class="sxs-lookup"><span data-stu-id="cc1df-224">You've finished the `TypeInferenceRewriter`.</span></span> <span data-ttu-id="cc1df-225">`Program.cs` ファイルに戻って例を完成させましょう。</span><span class="sxs-lookup"><span data-stu-id="cc1df-225">Now return to your `Program.cs` file to finish the example.</span></span> <span data-ttu-id="cc1df-226">テスト用の <xref:Microsoft.CodeAnalysis.Compilation> を作成し、そこから <xref:Microsoft.CodeAnalysis.SemanticModel> を取得します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-226">Create a test <xref:Microsoft.CodeAnalysis.Compilation> and obtain the <xref:Microsoft.CodeAnalysis.SemanticModel> from it.</span></span> <span data-ttu-id="cc1df-227">その <xref:Microsoft.CodeAnalysis.SemanticModel> を使用して、`TypeInferenceRewriter` を試します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-227">Use that <xref:Microsoft.CodeAnalysis.SemanticModel> to try your `TypeInferenceRewriter`.</span></span> <span data-ttu-id="cc1df-228">このステップは最後に実行します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-228">You'll do this step last.</span></span> <span data-ttu-id="cc1df-229">それまでの間、テスト用のコンパイルを表すプレースホルダー変数を宣言しておきます。</span><span class="sxs-lookup"><span data-stu-id="cc1df-229">In the meantime declare a placeholder variable representing your test compilation:</span></span>

[!code-csharp[DeclareCompilation](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#DeclareTestCompilation "Declare the test compilation")]

<span data-ttu-id="cc1df-230">しばらくすると、`CreateTestCompilation` メソッドが存在しないことを通知するエラーの波線が表示されます。</span><span class="sxs-lookup"><span data-stu-id="cc1df-230">After pausing a moment, you should see an error squiggle appear reporting that no `CreateTestCompilation` method exists.</span></span> <span data-ttu-id="cc1df-231">**Ctrl + .** キーを押して電球を開き、Enter キーを押して **[メソッド スタブの生成]** コマンドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-231">Press **Ctrl+Period** to open the light-bulb and then press Enter to invoke the **Generate Method Stub** command.</span></span> <span data-ttu-id="cc1df-232">このコマンドにより、`Program` クラス内に `CreateTestCompilation` メソッドのメソッド スタブが生成されます。</span><span class="sxs-lookup"><span data-stu-id="cc1df-232">This command will generate a method stub for the `CreateTestCompilation` method in the `Program` class.</span></span> <span data-ttu-id="cc1df-233">このメソッドについては後で説明します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-233">You'll come back to fill in this method later:</span></span>

![C# 使用例からのメソッドの生成](./media/syntax-transformation/generate-from-usage.png)

<span data-ttu-id="cc1df-235">テスト用の <xref:Microsoft.CodeAnalysis.Compilation> 内の各 <xref:Microsoft.CodeAnalysis.SyntaxTree> を反復処理する次のコードを記述します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-235">Write the following code to iterate over each <xref:Microsoft.CodeAnalysis.SyntaxTree> in the test <xref:Microsoft.CodeAnalysis.Compilation>.</span></span> <span data-ttu-id="cc1df-236">処理ごとに、そのツリーの <xref:Microsoft.CodeAnalysis.SemanticModel> を持った 新しい `TypeInferenceRewriter` が初期化されます。</span><span class="sxs-lookup"><span data-stu-id="cc1df-236">For each one, initialize a new `TypeInferenceRewriter` with the <xref:Microsoft.CodeAnalysis.SemanticModel> for that tree:</span></span>

[!code-csharp[IterateTrees](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#IterateTrees "Iterate all the source trees in the test compilation")]

<span data-ttu-id="cc1df-237">作成した `foreach` ステートメント内に次のコードを追加して、各ソース ツリーで変換が実行されるようにします。</span><span class="sxs-lookup"><span data-stu-id="cc1df-237">Inside the `foreach` statement you created, add the following code to perform the transformation on each source tree.</span></span> <span data-ttu-id="cc1df-238">このコードは、何らかの編集が行われた場合に、変換された新しいツリーを条件付きで書き出します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-238">This code conditionally writes out the new transformed tree if any edits were made.</span></span> <span data-ttu-id="cc1df-239">リライターは、型の推定を使用して単純化される可能性があるローカル変数宣言が 1 つ以上見つかった場合にのみ、ツリーを変更します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-239">Your rewriter should only modify a tree if it encounters one or more local variable declarations that could be simplified using type inference:</span></span>

[!code-csharp[TransformTrees](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#TransformTrees "Transform and save any trees that are modified by the rewriter")]

<span data-ttu-id="cc1df-240">`File.WriteAllText` コードの下に波線が表示されるはずです。</span><span class="sxs-lookup"><span data-stu-id="cc1df-240">You should see squiggles under the `File.WriteAllText` code.</span></span> <span data-ttu-id="cc1df-241">電球を選択し、必要な `using System.IO;` ステートメントを追加します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-241">Select the light bulb, and add the necessary `using System.IO;` statement.</span></span>

<span data-ttu-id="cc1df-242">完了までもう少しです。</span><span class="sxs-lookup"><span data-stu-id="cc1df-242">You're almost done!</span></span> <span data-ttu-id="cc1df-243">最後の 1 ステップは、<xref:Microsoft.CodeAnalysis.Compilation> の作成です。</span><span class="sxs-lookup"><span data-stu-id="cc1df-243">There's one step left: creating a test <xref:Microsoft.CodeAnalysis.Compilation>.</span></span> <span data-ttu-id="cc1df-244">このクイック スタートでは型の推定を一度も使用していないので、テスト ケースとするには完璧です。</span><span class="sxs-lookup"><span data-stu-id="cc1df-244">Since you haven't been using type inference at all during this quickstart, it would have made a perfect test case.</span></span> <span data-ttu-id="cc1df-245">残念ながら、C# プロジェクト ファイルからコンパイルを作成する方法については、このチュートリアルの対象外です。</span><span class="sxs-lookup"><span data-stu-id="cc1df-245">Unfortunately, creating a Compilation from a C# project file is beyond the scope of this walkthrough.</span></span> <span data-ttu-id="cc1df-246">しかし幸いなことに、これまでの手順に慎重に従ってきたならば希望が持てます。</span><span class="sxs-lookup"><span data-stu-id="cc1df-246">But fortunately, if you've been following instructions carefully, there's hope.</span></span> <span data-ttu-id="cc1df-247">`CreateTestCompilation` メソッドの内容を次のコードに置き換えます。</span><span class="sxs-lookup"><span data-stu-id="cc1df-247">Replace the contents of the `CreateTestCompilation` method with the following code.</span></span> <span data-ttu-id="cc1df-248">このクイック スタートで説明したプロジェクトに偶然にも一致するテスト用コンパイルが作成されます。</span><span class="sxs-lookup"><span data-stu-id="cc1df-248">It creates a test compilation that coincidentally matches the project described in this quickstart:</span></span>

[!code-csharp[CreateTestCompilation](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#CreateTestCompilation "Create a test compilation using the code written for this quickstart.")]

<span data-ttu-id="cc1df-249">幸運を祈ってプロジェクトを実行しましょう。</span><span class="sxs-lookup"><span data-stu-id="cc1df-249">Cross your fingers and run the project.</span></span> <span data-ttu-id="cc1df-250">Visual Studio で、 **[デバッグ]**  >  **[デバッグの開始]** を選択します。</span><span class="sxs-lookup"><span data-stu-id="cc1df-250">In Visual Studio, choose **Debug** > **Start Debugging**.</span></span> <span data-ttu-id="cc1df-251">Visual Studio で、プロジェクト内のファイルが変更されたという通知が表示されるはずです。</span><span class="sxs-lookup"><span data-stu-id="cc1df-251">You should be prompted by Visual Studio that the files in your project have changed.</span></span> <span data-ttu-id="cc1df-252">**[すべてに適用]** をクリックして、変更されたファイルをリロードします。</span><span class="sxs-lookup"><span data-stu-id="cc1df-252">Click "**Yes to All**" to reload the modified files.</span></span> <span data-ttu-id="cc1df-253">それらを調べて成果を確認しましょう。</span><span class="sxs-lookup"><span data-stu-id="cc1df-253">Examine them to observe your awesomeness.</span></span> <span data-ttu-id="cc1df-254">明示的で冗長な型指定子がすべてなくなるとどれほどコードがすっきり見えるかに注目してください。</span><span class="sxs-lookup"><span data-stu-id="cc1df-254">Note how much cleaner the code looks without all those explicit and redundant type specifiers.</span></span>

<span data-ttu-id="cc1df-255">おめでとうございます!</span><span class="sxs-lookup"><span data-stu-id="cc1df-255">Congratulations!</span></span> <span data-ttu-id="cc1df-256">**コンパイラ API** を使用して、C# プロジェクト内のすべてのファイルで特定の構文パターンを検索し、それらのパターンに一致するソース コードのセマンティクスを分析して変換する独自のリファクタリングを作成できました。</span><span class="sxs-lookup"><span data-stu-id="cc1df-256">You've used the **Compiler APIs** to write your own refactoring that searches all files in a C# project for certain syntactic patterns, analyzes the semantics of source code that matches those patterns, and transforms it.</span></span> <span data-ttu-id="cc1df-257">これであなたも正式なリファクタリングの作成者です!</span><span class="sxs-lookup"><span data-stu-id="cc1df-257">You're now officially a refactoring author!</span></span>
