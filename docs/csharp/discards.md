---
title: 破棄 - C# ガイド
description: C# の破棄のサポートについて説明します。破棄は、未割り当てで破棄可能な変数です。また、破棄の使用例についても説明します。
ms.technology: csharp-fundamentals
ms.date: 09/22/2020
ms.openlocfilehash: eefa81d3bd8d56c9296e01533aaf93c4725323a3
ms.sourcegitcommit: 42d436ebc2a7ee02fc1848c7742bc7d80e13fc2f
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/04/2021
ms.locfileid: "102104953"
---
# <a name="discards---c-guide"></a><span data-ttu-id="3488e-103">破棄 - C# ガイド</span><span class="sxs-lookup"><span data-stu-id="3488e-103">Discards - C# Guide</span></span>

<span data-ttu-id="3488e-104">C# 7.0 以降では、C# で破棄がサポートされます。これらは、アプリケーション コードで意図的に使用しないプレースホルダー変数です。</span><span class="sxs-lookup"><span data-stu-id="3488e-104">Starting with C# 7.0, C# supports discards, which are placeholder variables that are intentionally unused in application code.</span></span> <span data-ttu-id="3488e-105">破棄は、未割り当ての変数と同等です。つまり、値がありません。</span><span class="sxs-lookup"><span data-stu-id="3488e-105">Discards are equivalent to unassigned variables; they don't have a value.</span></span> <span data-ttu-id="3488e-106">破棄によって、あなたのコードを読み取るコンパイラおよびその他のユーザーに対して、次のような意図が伝わります。あなたは式の結果を無視するつもりでした。</span><span class="sxs-lookup"><span data-stu-id="3488e-106">A discard communicates intent to the compiler and others that read your code: You intended to ignore the result of an expression.</span></span> <span data-ttu-id="3488e-107">あなたは、式の結果、タプル式の 1 つ以上のメンバー、メソッドの `out` パラメーター、またはパターン マッチング式のターゲットを無視したい可能性があります。</span><span class="sxs-lookup"><span data-stu-id="3488e-107">You may want to ignore the result of an expression, one or more members of a tuple expression, an `out` parameter to a method, or the target of a pattern matching expression.</span></span>

<span data-ttu-id="3488e-108">破棄変数は 1 つしかないため、その変数にストレージが割り当てられていない可能性もあります。</span><span class="sxs-lookup"><span data-stu-id="3488e-108">Because there's only a single discard variable, that variable may not even be allocated storage.</span></span> <span data-ttu-id="3488e-109">破棄すると、メモリ割り当てを減らすことができます。</span><span class="sxs-lookup"><span data-stu-id="3488e-109">Discards can reduce memory allocations.</span></span> <span data-ttu-id="3488e-110">破棄することで、コードの意図が明確になります。</span><span class="sxs-lookup"><span data-stu-id="3488e-110">Discards make the intent of your code clear.</span></span> <span data-ttu-id="3488e-111">そのため、読みやすさと保守容易性が向上します。</span><span class="sxs-lookup"><span data-stu-id="3488e-111">They enhance its readability and maintainability.</span></span>

<span data-ttu-id="3488e-112">変数を破棄と指定するには、変数名にアンダースコア (`_`) を指定します。</span><span class="sxs-lookup"><span data-stu-id="3488e-112">You indicate that a variable is a discard by assigning it the underscore (`_`) as its name.</span></span> <span data-ttu-id="3488e-113">たとえば、次のメソッド呼び出しでタプルが返され、1 つ目と 2 つ目の値は破棄です。</span><span class="sxs-lookup"><span data-stu-id="3488e-113">For example, the following method call returns a tuple in which the first and second values are discards.</span></span> <span data-ttu-id="3488e-114">`area` は、`GetCityInformation` によって返される 3 つ目のコンポーネントに設定された、以前に宣言された変数です。</span><span class="sxs-lookup"><span data-stu-id="3488e-114">`area` is a previously declared variable set to the third component returned by `GetCityInformation`:</span></span>

```csharp
(_, _, area) = city.GetCityInformation(cityName);
```

<span data-ttu-id="3488e-115">C# 9.0 以降では、破棄を使用して、ラムダ式の未使用の入力パラメーターを指定できます。</span><span class="sxs-lookup"><span data-stu-id="3488e-115">Beginning with C# 9.0, you can use discards to specify unused input parameters of a lambda expression.</span></span> <span data-ttu-id="3488e-116">詳細については、[ラムダ式](language-reference/operators/lambda-expressions.md)に関する記事の「[ラムダ式の入力パラメーター](language-reference/operators/lambda-expressions.md#input-parameters-of-a-lambda-expression)」セクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="3488e-116">For more information, see the [Input parameters of a lambda expression](language-reference/operators/lambda-expressions.md#input-parameters-of-a-lambda-expression) section of the [Lambda expressions](language-reference/operators/lambda-expressions.md) article.</span></span>

<span data-ttu-id="3488e-117">`_` が有効な破棄の場合、その値を取得しようとすると、または代入演算で使用しようとすると、"名前 '\_' は、現在のコンテキストに存在していません" というコンパイラ エラー CS0301 が生成されます。</span><span class="sxs-lookup"><span data-stu-id="3488e-117">When `_` is a valid discard, attempting to retrieve its value or use it in an assignment operation generates compiler error CS0301, "The name '\_' doesn't exist in the current context".</span></span> <span data-ttu-id="3488e-118">このエラーの原因は、`_` に値が割り当てられておらず、記憶域の場所も割り当てることができないことです。</span><span class="sxs-lookup"><span data-stu-id="3488e-118">This error is because `_` isn't assigned a value, and may not even be assigned a storage location.</span></span> <span data-ttu-id="3488e-119">実際の変数であれば、前の例のように、複数の値を破棄できません。</span><span class="sxs-lookup"><span data-stu-id="3488e-119">If it were an actual variable, you couldn't discard more than one value, as the previous example did.</span></span>

## <a name="tuple-and-object-deconstruction"></a><span data-ttu-id="3488e-120">タプルとオブジェクトの分解</span><span class="sxs-lookup"><span data-stu-id="3488e-120">Tuple and object deconstruction</span></span>

<span data-ttu-id="3488e-121">分解は、複数のタプルがあり、アプリケーション コードで一部のタプル要素を使用し、その他の要素を無視する場合に便利です。</span><span class="sxs-lookup"><span data-stu-id="3488e-121">Discards are useful in working with tuples when your application code uses some tuple elements but ignores others.</span></span> <span data-ttu-id="3488e-122">たとえば、次の `QueryCityDataForYears` メソッドは、市区町村名、その地域、年、市区町村のその年の人口、2 つ目の年、市区町村のその 2 つ目の年の人口というタプルを返します。</span><span class="sxs-lookup"><span data-stu-id="3488e-122">For example, the following `QueryCityDataForYears` method returns a tuple with the name of a city, its area, a year, the city's population for that year, a second year, and the city's population for that second year.</span></span> <span data-ttu-id="3488e-123">この例は、2 つの年の間に変化した人口数を示しています。</span><span class="sxs-lookup"><span data-stu-id="3488e-123">The example shows the change in population between those two years.</span></span> <span data-ttu-id="3488e-124">タプルから使用できるデータのうち、市区町村の地域は使用しません。また、指定時に市区町村名と 2 つの日付はわかっています。</span><span class="sxs-lookup"><span data-stu-id="3488e-124">Of the data available from the tuple, we're unconcerned with the city area, and we know the city name and the two dates at design-time.</span></span> <span data-ttu-id="3488e-125">そのため、タプルに格納されている 2 つの人口値のみが必要であり、残りの値は破棄対象として処理できます。</span><span class="sxs-lookup"><span data-stu-id="3488e-125">As a result, we're only interested in the two population values stored in the tuple, and can handle its remaining values as discards.</span></span>  

:::code language="csharp" source="snippets/discards/discard-tuple.cs" ID="DiscardTupleMember" :::

<span data-ttu-id="3488e-126">破棄を使用したタプルの分解の詳細については、「[タプルとその他の型の分解](deconstruct.md#deconstructing-tuple-elements-with-discards)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="3488e-126">For more information on deconstructing tuples with discards, see [Deconstructing tuples and other types](deconstruct.md#deconstructing-tuple-elements-with-discards).</span></span>

<span data-ttu-id="3488e-127">また、クラス、構造体、またはインターフェイスの `Deconstruct` メソッドを使用すると、オブジェクトから特定セットのデータを取得し、分解することもできます。</span><span class="sxs-lookup"><span data-stu-id="3488e-127">The `Deconstruct` method of a class, structure, or interface also allows you to retrieve and deconstruct a specific set of data from an object.</span></span> <span data-ttu-id="3488e-128">分解された値の一部のみが必要な場合は、破棄を使用できます。</span><span class="sxs-lookup"><span data-stu-id="3488e-128">You can use discards when you're interested in working with only a subset of the deconstructed values.</span></span> <span data-ttu-id="3488e-129">`Person` オブジェクトを 4 つの文字列 (名、姓、市区町村、州) に分解し、姓と州を破棄する例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="3488e-129">The following example deconstructs a `Person` object into four strings (the first and last names, the city, and the state), but discards the last name and the state.</span></span>

:::code language="csharp" source="snippets/discards/discard-class.cs" :::

<span data-ttu-id="3488e-130">破棄を使用したユーザー定義型の分解の詳細については、「[タプルとその他の型の分解](deconstruct.md#deconstructing-a-user-defined-type-with-discards)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="3488e-130">For more information on deconstructing user-defined types with discards, see [Deconstructing tuples and other types](deconstruct.md#deconstructing-a-user-defined-type-with-discards).</span></span>

## <a name="pattern-matching-with-switch"></a><span data-ttu-id="3488e-131">`switch` を使用したパターン マッチング</span><span class="sxs-lookup"><span data-stu-id="3488e-131">Pattern matching with `switch`</span></span>

<span data-ttu-id="3488e-132">"*破棄パターン*" は、[switch 式](language-reference/operators/switch-expression.md)を使用したパターン マッチングで使用できます。</span><span class="sxs-lookup"><span data-stu-id="3488e-132">The *discard pattern* can be used in pattern matching with the [switch expression](language-reference/operators/switch-expression.md).</span></span> <span data-ttu-id="3488e-133">`null` も含め、あらゆる式は常に破棄パターンと一致します。</span><span class="sxs-lookup"><span data-stu-id="3488e-133">Every expression, including `null`,  always matches the discard pattern.</span></span>

<span data-ttu-id="3488e-134">`switch` 式を使用して、オブジェクトが <xref:System.IFormatProvider> 実装を提供しているかどうかを判断し、オブジェクトが `null` かどうかをテストする `ProvidesFormatInfo` メソッドの定義例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="3488e-134">The following example defines a `ProvidesFormatInfo` method that uses a `switch` expression to determine whether an object provides an <xref:System.IFormatProvider> implementation and tests whether the object is `null`.</span></span> <span data-ttu-id="3488e-135">また、破棄パターンを使用して、その他の任意の型の null 以外のオブジェクトを処理します。</span><span class="sxs-lookup"><span data-stu-id="3488e-135">It also uses the discard pattern to handle non-null objects of any other type.</span></span>

:::code language="csharp" source="snippets/discards/discard-pattern2.cs" ID="DiscardSwitchExample" :::

## <a name="calls-to-methods-with-out-parameters"></a><span data-ttu-id="3488e-136">`out` パラメーターを使用したメソッドの呼び出し</span><span class="sxs-lookup"><span data-stu-id="3488e-136">Calls to methods with `out` parameters</span></span>

<span data-ttu-id="3488e-137">`Deconstruct` メソッドを呼び出してユーザー定義型 (クラス、構造体、またはインターフェイスのインスタンス) を分解する場合、個々の `out` 引数の値を破棄できます。</span><span class="sxs-lookup"><span data-stu-id="3488e-137">When calling the `Deconstruct` method to deconstruct a user-defined type (an instance of a class, structure, or interface), you can discard the values of individual `out` arguments.</span></span> <span data-ttu-id="3488e-138">また、`out` パラメーターを指定して任意のメソッドを呼び出すときに、`out` 引数の値を破棄することもできます</span><span class="sxs-lookup"><span data-stu-id="3488e-138">But you can also discard the value of `out` arguments when calling any method with an `out` parameter.</span></span>

<span data-ttu-id="3488e-139">次の例では、[DateTime.TryParse(String, out DateTime)](<xref:System.DateTime.TryParse(System.String,System.DateTime@)>) メソッドを呼び出して、現在のカルチャで日付の文字列表現が有効かどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="3488e-139">The following example calls the [DateTime.TryParse(String, out DateTime)](<xref:System.DateTime.TryParse(System.String,System.DateTime@)>) method to determine whether the string representation of a date is valid in the current culture.</span></span> <span data-ttu-id="3488e-140">この例では、日付文字列の検証のみが目的で、解析して日付を抽出する処理は行わないため、メソッドの `out` 引数は破棄されます。</span><span class="sxs-lookup"><span data-stu-id="3488e-140">Because the example is concerned only with validating the date string and not with parsing it to extract the date, the `out` argument to the method is a discard.</span></span>

:::code language="csharp" source="snippets/discards/discard-out1.cs" ID="DiscardOutParameter" :::

## <a name="a-standalone-discard"></a><span data-ttu-id="3488e-141">スタンドアロンの破棄</span><span class="sxs-lookup"><span data-stu-id="3488e-141">A standalone discard</span></span>

<span data-ttu-id="3488e-142">スタンドアロンの破棄を使用して、無視対象として任意の変数を指定できます。</span><span class="sxs-lookup"><span data-stu-id="3488e-142">You can use a standalone discard to indicate any variable that you choose to ignore.</span></span> <span data-ttu-id="3488e-143">一般的な用途の 1 つは、割り当てを使用して、引数が null でないことを確認することです。</span><span class="sxs-lookup"><span data-stu-id="3488e-143">One typical use is to use an assignment to ensure that an argument isn't null.</span></span> <span data-ttu-id="3488e-144">次のコードでは、破棄を使用して割り当てを強制しています。</span><span class="sxs-lookup"><span data-stu-id="3488e-144">The following code uses a discard to force an assignment.</span></span> <span data-ttu-id="3488e-145">代入の右側には [null 合体演算子](language-reference/operators/null-coalescing-operator.md)が使用され、引数が `null` の場合に <xref:System.ArgumentNullException?displayProperty=nameWithType> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="3488e-145">The right side of the assignment uses the [null coalescing operator](language-reference/operators/null-coalescing-operator.md) to throw an <xref:System.ArgumentNullException?displayProperty=nameWithType> when the argument is `null`.</span></span> <span data-ttu-id="3488e-146">このコードに割り当ての結果は不要なため、破棄されます。</span><span class="sxs-lookup"><span data-stu-id="3488e-146">The code doesn't need the result of the assignment, so it's discarded.</span></span> <span data-ttu-id="3488e-147">式によって null チェックが強制的に実行されます。</span><span class="sxs-lookup"><span data-stu-id="3488e-147">The expression forces a null check.</span></span> <span data-ttu-id="3488e-148">破棄を使用して、割り当ての結果は必要ではないか、使用されない、という意図を明確にします。</span><span class="sxs-lookup"><span data-stu-id="3488e-148">The discard clarifies your intent: the result of the assignment isn't needed or used.</span></span>

:::code language="csharp" source="snippets/discards/standalone-discard1.cs" ID="ArgNullCheck" :::

<span data-ttu-id="3488e-149">次の例では、スタンドアロンの破棄を使用して、非同期操作で返される <xref:System.Threading.Tasks.Task> オブジェクトを無視します。</span><span class="sxs-lookup"><span data-stu-id="3488e-149">The following example uses a standalone discard to ignore the <xref:System.Threading.Tasks.Task> object returned by an asynchronous operation.</span></span> <span data-ttu-id="3488e-150">タスクの割り当ての結果、この処理が完了するときにスローされる例外が抑制される効果があります。</span><span class="sxs-lookup"><span data-stu-id="3488e-150">Assigning the task has the effect of suppressing the exception that the operation throws as it is about to complete.</span></span> <span data-ttu-id="3488e-151">これにより、次のようなあなたの意図が明確になります。あなたは、`Task` を破棄し、その非同期操作から生成されるエラーを無視したいと考えています。</span><span class="sxs-lookup"><span data-stu-id="3488e-151">It makes your intent clear: You want to discard the `Task`, and ignore any errors generated from that asynchronous operation.</span></span>

:::code language="csharp" source="snippets/discards/standalone-discard1.cs" ID="SnippetDiscardTask" :::

<span data-ttu-id="3488e-152">タスクを破棄に割り当てないと、次のコードにより、コンパイラの警告が生成されます。</span><span class="sxs-lookup"><span data-stu-id="3488e-152">Without assigning the task to a discard, the following code generates a compiler warning:</span></span>

:::code language="csharp" source="snippets/discards/standalone-discard1.cs" ID="SnippetNoDiscardTask" :::

> [!NOTE]
> <span data-ttu-id="3488e-153">デバッガーを使用して上の 2 つのサンプルのいずれかを実行すると、例外がスローされたときにデバッガーによってプログラムが停止します。</span><span class="sxs-lookup"><span data-stu-id="3488e-153">If you run either of the preceding two samples using a debugger, the debugger will stop the program when the exception is thrown.</span></span> <span data-ttu-id="3488e-154">デバッガーがアタッチされていない場合、どちらの場合も例外は警告なしで無視されます。</span><span class="sxs-lookup"><span data-stu-id="3488e-154">Without a debugger attached, the exception is silently ignored in both cases.</span></span>

<span data-ttu-id="3488e-155">`_` は有効な識別子でもあります。</span><span class="sxs-lookup"><span data-stu-id="3488e-155">`_` is also a valid identifier.</span></span> <span data-ttu-id="3488e-156">サポートされるコンテキスト以外で `_` を使用すると、破棄対象ではなく、有効な変数として扱われます。</span><span class="sxs-lookup"><span data-stu-id="3488e-156">When used outside of a supported context, `_` is treated not as a discard but as a valid variable.</span></span> <span data-ttu-id="3488e-157">`_` という識別子が既にスコープ内にある場合、スタンドアロンの破棄として `_` を使用すると、次のような結果になります。</span><span class="sxs-lookup"><span data-stu-id="3488e-157">If an identifier named `_` is already in scope, the use of `_` as a standalone discard can result in:</span></span>

- <span data-ttu-id="3488e-158">意図した破棄の値を割り当てることで、スコープ内の `_` 変数の値が誤って変更される。</span><span class="sxs-lookup"><span data-stu-id="3488e-158">Accidental modification of the value of the in-scope `_` variable by assigning it the value of the intended discard.</span></span> <span data-ttu-id="3488e-159">次に例を示します。</span><span class="sxs-lookup"><span data-stu-id="3488e-159">For example:</span></span>
   :::code language="csharp" source="snippets/discards/standalone-discard2.cs" ID="VariableIdentifier" :::
- <span data-ttu-id="3488e-160">タイプ セーフに違反するコンパイラ エラーが発生する。</span><span class="sxs-lookup"><span data-stu-id="3488e-160">A compiler error for violating type safety.</span></span> <span data-ttu-id="3488e-161">次に例を示します。</span><span class="sxs-lookup"><span data-stu-id="3488e-161">For example:</span></span>
   :::code language="csharp" source="snippets/discards/standalone-discard2.cs" ID="VariableTypeInference" :::
- <span data-ttu-id="3488e-162">コンパイラ エラー CS0136 "ローカルまたはパラメーター '\_' は、その名前が外側のローカルのスコープでローカルやパラメーターの定義に使用されているため、このスコープでは宣言できません" が発生する。</span><span class="sxs-lookup"><span data-stu-id="3488e-162">Compiler error CS0136, "A local or parameter named '\_' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter."</span></span> <span data-ttu-id="3488e-163">次に例を示します。</span><span class="sxs-lookup"><span data-stu-id="3488e-163">For example:</span></span>
   :::code language="csharp" source="snippets/discards/standalone-discard2.cs" ID="CannotRedeclare" :::

## <a name="see-also"></a><span data-ttu-id="3488e-164">関連項目</span><span class="sxs-lookup"><span data-stu-id="3488e-164">See also</span></span>

- [<span data-ttu-id="3488e-165">タプルとその他の型の分解</span><span class="sxs-lookup"><span data-stu-id="3488e-165">Deconstructing tuples and other types</span></span>](deconstruct.md)
- [<span data-ttu-id="3488e-166">`is` キーワード</span><span class="sxs-lookup"><span data-stu-id="3488e-166">`is` keyword</span></span>](language-reference/keywords/is.md)
- [<span data-ttu-id="3488e-167">`switch` キーワード</span><span class="sxs-lookup"><span data-stu-id="3488e-167">`switch` keyword</span></span>](language-reference/keywords/switch.md)
