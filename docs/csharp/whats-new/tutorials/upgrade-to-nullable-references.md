---
title: null 許容参照型にアップグレードする
description: この高度なチュートリアルでは、null 許容参照型を使用して既存のコードを移行する方法を示します。
ms.date: 02/19/2019
ms.technology: csharp-null-safety
ms.custom: mvc
ms.openlocfilehash: dc254e8ca7b9451ab9374bc1ec650b8eaa9da861
ms.sourcegitcommit: c7f0beaa2bd66ebca86362ca17d673f7e8256ca6
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/23/2021
ms.locfileid: "104878917"
---
# <a name="tutorial-migrate-existing-code-with-nullable-reference-types"></a><span data-ttu-id="7c500-103">チュートリアル: null 許容参照型を使用して既存のコードを移行する</span><span class="sxs-lookup"><span data-stu-id="7c500-103">Tutorial: Migrate existing code with nullable reference types</span></span>

<span data-ttu-id="7c500-104">C# 8 には **null 許容参照型** が導入されています。これは、null 許容値型が値型を補完するのと同じように、参照型を補完するものです。</span><span class="sxs-lookup"><span data-stu-id="7c500-104">C# 8 introduces **nullable reference types**, which complement reference types the same way nullable value types complement value types.</span></span> <span data-ttu-id="7c500-105">型に `?` を追加することで、変数が **null 許容参照型** であることを宣言します。</span><span class="sxs-lookup"><span data-stu-id="7c500-105">You declare a variable to be a **nullable reference type** by appending a `?` to the type.</span></span> <span data-ttu-id="7c500-106">たとえば、`string?` は、null が許容される `string` を表します。</span><span class="sxs-lookup"><span data-stu-id="7c500-106">For example, `string?` represents a nullable `string`.</span></span> <span data-ttu-id="7c500-107">これらの新しい型を使用して、一部の変数では *常に値を持つ必要があり*、他の変数では *値が欠落することも可能である* という設計意図をさらに明確に示すことができます。</span><span class="sxs-lookup"><span data-stu-id="7c500-107">You can use these new types to more clearly express your design intent: some variables *must always have a value*, others *may be missing a value*.</span></span> <span data-ttu-id="7c500-108">参照型の既存の変数は、null 非許容参照型として解釈されます。</span><span class="sxs-lookup"><span data-stu-id="7c500-108">Any existing variables of a reference type would be interpreted as a non-nullable reference type.</span></span>

<span data-ttu-id="7c500-109">このチュートリアルでは、次の方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="7c500-109">In this tutorial, you'll learn how to:</span></span>

> [!div class="checklist"]
>
> - <span data-ttu-id="7c500-110">コードを操作するときに null 参照のチェックを有効にする。</span><span class="sxs-lookup"><span data-stu-id="7c500-110">Enable null reference checks as you work with code.</span></span>
> - <span data-ttu-id="7c500-111">null 値に関連するさまざまな警告を診断して修正する。</span><span class="sxs-lookup"><span data-stu-id="7c500-111">Diagnose and correct different warnings related to null values.</span></span>
> - <span data-ttu-id="7c500-112">null 許容が有効なコンテキストと null 許容が無効なコンテキストの間のインターフェイスを管理する。</span><span class="sxs-lookup"><span data-stu-id="7c500-112">Manage the interface between nullable enabled and nullable disabled contexts.</span></span>
> - <span data-ttu-id="7c500-113">null 許容注釈のコンテキストを制御する。</span><span class="sxs-lookup"><span data-stu-id="7c500-113">Control nullable annotation contexts.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="7c500-114">必須コンポーネント</span><span class="sxs-lookup"><span data-stu-id="7c500-114">Prerequisites</span></span>

<span data-ttu-id="7c500-115">お使いのコンピューターを、.NET Core が実行されるように設定する必要があります。C# 8.0 コンパイラも実行されるようにします。</span><span class="sxs-lookup"><span data-stu-id="7c500-115">You’ll need to set up your machine to run .NET Core, including the C# 8.0 compiler.</span></span> <span data-ttu-id="7c500-116">C# 8 コンパイラは [Visual Studio 2019 バージョン 16.3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019) または [.NET Core 3.0 SDK](https://dotnet.microsoft.com/download) 以降で使用できます。</span><span class="sxs-lookup"><span data-stu-id="7c500-116">The C# 8 compiler is available starting with [Visual Studio 2019 version 16.3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019) or [.NET Core 3.0 SDK](https://dotnet.microsoft.com/download).</span></span>

<span data-ttu-id="7c500-117">このチュートリアルでは、.NET と、C# と Visual Studio または .NET Core CLI のいずれかに精通していることを前提としています。</span><span class="sxs-lookup"><span data-stu-id="7c500-117">This tutorial assumes you're familiar with C# and .NET, including either Visual Studio or the .NET Core CLI.</span></span>

## <a name="explore-the-sample-application"></a><span data-ttu-id="7c500-118">サンプル アプリケーションを調べる</span><span class="sxs-lookup"><span data-stu-id="7c500-118">Explore the sample application</span></span>

<span data-ttu-id="7c500-119">これから移行するサンプル アプリケーションは、RSS フィード リーダー Web アプリです。</span><span class="sxs-lookup"><span data-stu-id="7c500-119">The sample application that you'll migrate is an RSS feed reader web app.</span></span> <span data-ttu-id="7c500-120">1 つの RSS フィードから読み取り、最新の記事の要約を表示します。</span><span class="sxs-lookup"><span data-stu-id="7c500-120">It reads from a single RSS feed and displays summaries for the most recent articles.</span></span> <span data-ttu-id="7c500-121">いずれかの記事を選択すると、そのサイトに移動できます。</span><span class="sxs-lookup"><span data-stu-id="7c500-121">You can select any of the articles to visit the site.</span></span> <span data-ttu-id="7c500-122">そのアプリケーションは比較的新しいものですが、null 許容参照型が有効になる前に書かれました。</span><span class="sxs-lookup"><span data-stu-id="7c500-122">The application is relatively new but was written before nullable reference types were available.</span></span> <span data-ttu-id="7c500-123">アプリケーションの設計上の決定では適切な原則が表されていましたが、この重要な言語機能は利用されていません。</span><span class="sxs-lookup"><span data-stu-id="7c500-123">The design decisions for the application represented sound principles, but don't take advantage of this important language feature.</span></span>

<span data-ttu-id="7c500-124">サンプル アプリケーションには、アプリの主要な機能を検証する単体テスト ライブラリが含まれています。</span><span class="sxs-lookup"><span data-stu-id="7c500-124">The sample application includes a unit test library that validates the major functionality of the app.</span></span> <span data-ttu-id="7c500-125">生成された警告に基づいて実装のいずれかを変更する場合、そのプロジェクトによって容易に安全なアップグレードを行うことができます。</span><span class="sxs-lookup"><span data-stu-id="7c500-125">That project will make it easier to upgrade safely, if you change any of the implementation based on the warnings generated.</span></span> <span data-ttu-id="7c500-126">GitHub の [dotnet/samples](https://github.com/dotnet/samples/tree/main/csharp/tutorials/nullable-reference-migration/start) リポジトリから、スタート コードをダウンロードすることができます。</span><span class="sxs-lookup"><span data-stu-id="7c500-126">You can download the starter code from the [dotnet/samples](https://github.com/dotnet/samples/tree/main/csharp/tutorials/nullable-reference-migration/start) GitHub repository.</span></span>

<span data-ttu-id="7c500-127">プロジェクト移行の目標は、新しい言語機能を利用して変数の null 値の許容についての意図を明確に表すこと、そしてと null 許容注釈コンテキストおよび null 許容警告コンテキストを `enabled` に設定したときにコンパイラで警告が生成されないような方法でそれを行うことです。</span><span class="sxs-lookup"><span data-stu-id="7c500-127">Your goal migrating a project should be to leverage the new language features so that you clearly express your intent on the nullability of variables, and do so in such a way that the compiler doesn't generate warnings when you have the nullable annotation context and nullable warning context set to `enabled`.</span></span>

## <a name="upgrade-the-projects-to-c-8"></a><span data-ttu-id="7c500-128">プロジェクトを C# 8 にアップグレードする</span><span class="sxs-lookup"><span data-stu-id="7c500-128">Upgrade the projects to C# 8</span></span>

<span data-ttu-id="7c500-129">最初のステップとして、移行タスクの範囲を決定します。</span><span class="sxs-lookup"><span data-stu-id="7c500-129">A good first step is to determine the scope of the migration task.</span></span> <span data-ttu-id="7c500-130">まず最初に、プロジェクトを C# 8.0 (またはそれ以降) にアップグレードします。</span><span class="sxs-lookup"><span data-stu-id="7c500-130">Start by upgrading the project to C# 8.0 (or newer).</span></span> <span data-ttu-id="7c500-131">Web プロジェクトと単体テスト プロジェクトの両方について、csproj ファイルの PropertyGroup に `LangVersion` 要素を追加します。</span><span class="sxs-lookup"><span data-stu-id="7c500-131">Add the `LangVersion` element to the PropertyGroup in both csproj files for the web project and the unit test project:</span></span>

```xml
<LangVersion>8.0</LangVersion>
```

<span data-ttu-id="7c500-132">言語バージョンをアップグレードすると C# 8.0 が選択されますが、null 許容注釈コンテキストまたは null 許容警告コンテキストは有効になりません。</span><span class="sxs-lookup"><span data-stu-id="7c500-132">Upgrading the language version selects C# 8.0, but does not enable the nullable annotation context or the nullable warning context.</span></span> <span data-ttu-id="7c500-133">プロジェクトをリビルドして、警告なしにビルドされることを確認します。</span><span class="sxs-lookup"><span data-stu-id="7c500-133">Rebuild the project to ensure that it builds without warnings.</span></span>

<span data-ttu-id="7c500-134">次に、null 許容注釈コンテキストを有効にして、警告がいくつ生成されるかを確認します。</span><span class="sxs-lookup"><span data-stu-id="7c500-134">A good next step is to turn on the nullable annotation context and see how many warnings are generated.</span></span> <span data-ttu-id="7c500-135">ソリューションの両方の csproj ファイルで、`LangVersion` 要素のすぐ下に次の要素を追加します。</span><span class="sxs-lookup"><span data-stu-id="7c500-135">Add the following element to both csproj files in the solution, directly under the `LangVersion` element:</span></span>

```xml
<Nullable>enable</Nullable>
```

<span data-ttu-id="7c500-136">テスト ビルドを行い、警告の一覧に注目します。</span><span class="sxs-lookup"><span data-stu-id="7c500-136">Do a test build, and notice the warning list.</span></span> <span data-ttu-id="7c500-137">この小さいアプリケーションでは 5 つのコンパイラ警告が生成されるので、null 許容注釈コンテキストを有効にしたまま、プロジェクト全体の警告の修正を始めます。</span><span class="sxs-lookup"><span data-stu-id="7c500-137">In this small application, the compiler generates five warnings, so it's likely you'd leave the nullable annotation context enabled and start fixing warnings for the entire project.</span></span>

<span data-ttu-id="7c500-138">そのような戦略は、小さいプロジェクトに対してのみ機能します。</span><span class="sxs-lookup"><span data-stu-id="7c500-138">That strategy works only for smaller projects.</span></span> <span data-ttu-id="7c500-139">大きいプロジェクトでは、コードベース全体の null 許容注釈コンテキストを有効にすると生成される警告の数が多く、体系的に警告を修正することは困難です。</span><span class="sxs-lookup"><span data-stu-id="7c500-139">For any larger projects, the number of warnings generated by enabling the nullable annotation context for the entire codebase makes it harder to fix the warnings systematically.</span></span> <span data-ttu-id="7c500-140">大規模なエンタープライズ プロジェクトでは、一度に 1 つのプロジェクトを移行するのが普通です。</span><span class="sxs-lookup"><span data-stu-id="7c500-140">For larger enterprise projects, you'll often want to migrate one project at a time.</span></span> <span data-ttu-id="7c500-141">各プロジェクトでは、一度に 1 つのクラスまたはファイルを移行します。</span><span class="sxs-lookup"><span data-stu-id="7c500-141">In each project, migrate one class or file at a time.</span></span>

## <a name="warnings-help-discover-original-design-intent"></a><span data-ttu-id="7c500-142">元の設計意図の発見に役立つ警告</span><span class="sxs-lookup"><span data-stu-id="7c500-142">Warnings help discover original design intent</span></span>

<span data-ttu-id="7c500-143">複数の警告が生成されているクラスが 2 つあります。</span><span class="sxs-lookup"><span data-stu-id="7c500-143">There are two classes that generate multiple warnings.</span></span> <span data-ttu-id="7c500-144">`NewsStoryViewModel` クラスから始めます。</span><span class="sxs-lookup"><span data-stu-id="7c500-144">Start with the `NewsStoryViewModel` class.</span></span> <span data-ttu-id="7c500-145">作業を行っているコードのセクションに警告の範囲を制限できるように、両方の csproj ファイルから `Nullable` 要素を削除します。</span><span class="sxs-lookup"><span data-stu-id="7c500-145">Remove the `Nullable` element from both csproj files so that you can limit the scope of warnings to the sections of code you're working with.</span></span> <span data-ttu-id="7c500-146">*NewsStoryViewModel.cs* ファイルを開き、次のディレクティブを追加して `NewsStoryViewModel` に対して null 許容注釈コンテキストを有効にし、そのクラス定義の後で元に戻します。</span><span class="sxs-lookup"><span data-stu-id="7c500-146">Open the *NewsStoryViewModel.cs* file and add the following directives to enable the nullable annotation context for the `NewsStoryViewModel` and restore it following that class definition:</span></span>

```csharp
#nullable enable
public class NewsStoryViewModel
{
    public DateTimeOffset Published { get; set; }
    public string Title { get; set; }
    public string Uri { get; set; }
}
#nullable restore
```

<span data-ttu-id="7c500-147">これら 2 つのディレクティブは、移行作業の対象を絞るのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="7c500-147">These two directives help you focus your migration efforts.</span></span> <span data-ttu-id="7c500-148">null 許容の警告は、今まさに作業を行っているコードの領域に対して生成されます。</span><span class="sxs-lookup"><span data-stu-id="7c500-148">The nullable warnings are generated for the area of code you're actively working on.</span></span> <span data-ttu-id="7c500-149">プロジェクト全体の警告を有効にする準備ができるまで、それをオンのままにします。</span><span class="sxs-lookup"><span data-stu-id="7c500-149">You'll leave them on until you're ready to turn on the warnings for the entire project.</span></span> <span data-ttu-id="7c500-150">後でプロジェクト全体の null 許容注釈を有効にしたときに、誤ってコンテキストを無効にしないように、`disable` 値ではなく `restore` を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="7c500-150">You should use the `restore` rather than `disable` value so that you don't accidentally disable the context later when you've turned on nullable annotations for the entire project.</span></span> <span data-ttu-id="7c500-151">プロジェクト全体の null 許容注釈コンテキストを有効にした後は、そのプロジェクトからすべての `#nullable` プラグマを削除できます。</span><span class="sxs-lookup"><span data-stu-id="7c500-151">Once you've turned on the nullable annotation context for the entire project, you can remove all the `#nullable` pragmas from that project.</span></span>

<span data-ttu-id="7c500-152">`NewsStoryViewModel` クラスはデータ転送オブジェクト (DTO) であり、プロパティのうち 2 つは読み取り/書き込み文字列です。</span><span class="sxs-lookup"><span data-stu-id="7c500-152">The `NewsStoryViewModel` class is a data transfer object (DTO) and two of the properties are read/write strings:</span></span>

[!code-csharp[InitialViewModel](~/samples/snippets/csharp/tutorials/nullable-reference-migration/start/SimpleFeedReader/ViewModels/NewsStoryViewModel.cs#StarterViewModel)]

<span data-ttu-id="7c500-153">これら 2 つのプロパティが、`CS8618` "null 非許容型のプロパティが初期化されていません" の原因になっています。</span><span class="sxs-lookup"><span data-stu-id="7c500-153">These two properties cause `CS8618`, "Non-nullable property is uninitialized".</span></span> <span data-ttu-id="7c500-154">`NewsStoryViewModel` が構築されるときに、どちらの `string` プロパティも既定値が `null` になっているので、それははっきりわかります。</span><span class="sxs-lookup"><span data-stu-id="7c500-154">That's clear enough: both `string` properties have the default value of `null` when a `NewsStoryViewModel` is constructed.</span></span> <span data-ttu-id="7c500-155">重要なのは、`NewsStoryViewModel` オブジェクトの構築方法を明らかにすることです。</span><span class="sxs-lookup"><span data-stu-id="7c500-155">What's important to discover is how `NewsStoryViewModel` objects are constructed.</span></span> <span data-ttu-id="7c500-156">このクラスを調べても、`null` 値が設計の一部なのかどうか、またはこれらのオブジェクトは作成されるたび null 以外の値に設定されるのかどうかはわかりません。</span><span class="sxs-lookup"><span data-stu-id="7c500-156">Looking at this class, you can't tell if the `null` value is part of the design, or if these objects are set to non-null values whenever one is created.</span></span> <span data-ttu-id="7c500-157">ニュース記事は、`NewsService` クラスの `GetNews` メソッドで作成されます。</span><span class="sxs-lookup"><span data-stu-id="7c500-157">The news stories are created in the `GetNews` method of the `NewsService` class:</span></span>

[!code-csharp[StarterCreateNewsItem](~/samples/snippets/csharp/tutorials/nullable-reference-migration/start/SimpleFeedReader/Services/NewsService.cs#CreateNewsItem)]

<span data-ttu-id="7c500-158">上記のコード ブロックでは多くのことが行われています。</span><span class="sxs-lookup"><span data-stu-id="7c500-158">There's quite a bit going on in the preceding block of code.</span></span> <span data-ttu-id="7c500-159">このアプリケーションでは、[AutoMapper](https://automapper.org/) NuGet パッケージを使用して、`ISyndicationItem` からニュース項目を作成しています。</span><span class="sxs-lookup"><span data-stu-id="7c500-159">This application uses the [AutoMapper](https://automapper.org/) NuGet package to construct a news item from an `ISyndicationItem`.</span></span> <span data-ttu-id="7c500-160">ニュース記事の項目が構築され、その 1 つのステートメントでプロパティが設定されることはわかっています。</span><span class="sxs-lookup"><span data-stu-id="7c500-160">You've discovered that the news story items are constructed and the properties are set in that one statement.</span></span> <span data-ttu-id="7c500-161">つまり、`NewsStoryViewModel` の設計では、これらのプロパティが `null` 値になってはならないことが示されています。</span><span class="sxs-lookup"><span data-stu-id="7c500-161">That means the design for the `NewsStoryViewModel` indicates that these properties should never have the `null` value.</span></span> <span data-ttu-id="7c500-162">これらのプロパティは、**null 非許容参照型** にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="7c500-162">These properties should be **nonnullable reference types**.</span></span> <span data-ttu-id="7c500-163">それが、元の設計意図を最も適切に表しています。</span><span class="sxs-lookup"><span data-stu-id="7c500-163">That best expresses the original design intent.</span></span> <span data-ttu-id="7c500-164">実際、 は、null 値以外で正しくインスタンス化されて "`NewsStoryViewModel` *います*"。</span><span class="sxs-lookup"><span data-stu-id="7c500-164">In fact, any `NewsStoryViewModel` *is* correctly instantiated with non-null values.</span></span> <span data-ttu-id="7c500-165">これにより、次の初期化コードが有効な修正になります。</span><span class="sxs-lookup"><span data-stu-id="7c500-165">That makes the following initialization code a valid fix:</span></span>

```csharp
public class NewsStoryViewModel
{
    public DateTimeOffset Published { get; set; }
    public string Title { get; set; } = default!;
    public string Uri { get; set; } = default!;
}
```

<span data-ttu-id="7c500-166">`string` 型の場合は `null` である `default` を `Title` および `Uri` に割り当てても、プログラムの実行時の動作は変わりません。</span><span class="sxs-lookup"><span data-stu-id="7c500-166">The assignment of `Title` and `Uri` to `default` which is `null` for the `string` type doesn't change the runtime behavior of the program.</span></span> <span data-ttu-id="7c500-167">`NewsStoryViewModel` はやはり null 値で構築されますが、コンパイラの警告は報告されなくなります。</span><span class="sxs-lookup"><span data-stu-id="7c500-167">The `NewsStoryViewModel` is still constructed with null values, but now the compiler reports no warnings.</span></span> <span data-ttu-id="7c500-168">**null 許容演算子** (`default` 式の後の `!` 文字) は、その前の式が null ではないことをコンパイラに指示します。</span><span class="sxs-lookup"><span data-stu-id="7c500-168">The **null-forgiving operator**, the `!` character following the `default` expression tells the compiler that the preceding expression is not null.</span></span> <span data-ttu-id="7c500-169">この手法は、他の変更によってコード ベースへのはるかに大きな変更が強制されるときは便利である可能性がありますが、このアプリケーションでは比較的高速で、かつより優れた解決策があります。すべてのプロパティがコンストラクターで設定される場合は、`NewsStoryViewModel` を不変型にしてください。</span><span class="sxs-lookup"><span data-stu-id="7c500-169">This technique may be expedient when other changes force much larger changes to a code base, but in this application there is a relatively quick and better solution: Make the `NewsStoryViewModel` an immutable type where all the properties are set in the constructor.</span></span> <span data-ttu-id="7c500-170">`NewsStoryViewModel` を次のように変更します。</span><span class="sxs-lookup"><span data-stu-id="7c500-170">Make the following changes to the `NewsStoryViewModel`:</span></span>

[!code-csharp[FinishedViewModel](~/samples/snippets/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader/ViewModels/NewsStoryViewModel.cs#FinishedViewModel)]

<span data-ttu-id="7c500-171">それを行った後は、プロパティを設定するのではなくコンストラクターを使用するように、AutoMapper を構成するコードを更新する必要があります。</span><span class="sxs-lookup"><span data-stu-id="7c500-171">Once that's done, you need to update the code that configures the AutoMapper so that it uses the constructor rather than setting properties.</span></span> <span data-ttu-id="7c500-172">`NewsService.cs` を開き、ファイルの最後にある次のコードを探します。</span><span class="sxs-lookup"><span data-stu-id="7c500-172">Open `NewsService.cs` and look for the following code at the bottom of the file:</span></span>

[!code-csharp[StarterAutoMapper](~/samples/snippets/csharp/tutorials/nullable-reference-migration/start/SimpleFeedReader/Services/NewsService.cs#ConfigureAutoMapper)]

<span data-ttu-id="7c500-173">そのコードでは、`ISyndicationItem` オブジェクトのプロパティが `NewsStoryViewModel` プロパティにマップされています。</span><span class="sxs-lookup"><span data-stu-id="7c500-173">That code maps properties of the `ISyndicationItem` object to the `NewsStoryViewModel` properties.</span></span> <span data-ttu-id="7c500-174">AutoMapper では代わりにコンストラクターを使用してマッピングを提供する必要があります。</span><span class="sxs-lookup"><span data-stu-id="7c500-174">You want the AutoMapper to provide the mapping using a constructor instead.</span></span> <span data-ttu-id="7c500-175">上記のコードを次のような AutoMapper 構成に置き換えます。</span><span class="sxs-lookup"><span data-stu-id="7c500-175">Replace the above code with the following automapper configuration:</span></span>

[!code-csharp[FinishedViewModel](~/samples/snippets/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader/Services/NewsService.cs#ConfigureAutoMapper)]

<span data-ttu-id="7c500-176">このクラスは小さく、注意深く調べたので、このクラスの宣言の上にある `#nullable enable` ディレクティブを有効にする必要があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="7c500-176">Notice that because this class is small, and you've examined carefully, you should turn on the `#nullable enable` directive above this class declaration.</span></span> <span data-ttu-id="7c500-177">コンストラクターを変更すると何かが壊れる可能性があるため、続行する前に、すべてのテストを実行し、アプリケーションをテストすることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="7c500-177">The change to the constructor could have broken something, so it's worthwhile to run all the tests and test the application before moving on.</span></span>

<span data-ttu-id="7c500-178">最初の一連の変更では、変数を `null` に設定してはならないことが元の設計で示されていたことを検出する方法を示しました。</span><span class="sxs-lookup"><span data-stu-id="7c500-178">The first set of changes showed you how to discover when the original design indicated that variables shouldn't be set to `null`.</span></span> <span data-ttu-id="7c500-179">その手法は、**Correct by Construction (構築からの正しさ)** と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="7c500-179">The technique is referred to as **correct by construction**.</span></span> <span data-ttu-id="7c500-180">構築するときに、オブジェクトとそのプロパティを `null` にできないことを宣言します。</span><span class="sxs-lookup"><span data-stu-id="7c500-180">You declare that an object and its properties cannot be `null` when it's constructed.</span></span> <span data-ttu-id="7c500-181">コンパイラのフロー分析により、構築後にそれらのプロパティが `null` に設定されていないことが保証されます。</span><span class="sxs-lookup"><span data-stu-id="7c500-181">The compiler's flow analysis provides assurance that those properties aren't set to `null` after construction.</span></span> <span data-ttu-id="7c500-182">このコンストラクターは外部のコードによって呼び出され、そのコードでは **null 許容が認識されていない** ことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="7c500-182">Note that this constructor is called by external code, and that code is **nullable oblivious**.</span></span> <span data-ttu-id="7c500-183">新しい構文では、実行時のチェックは提供されません。</span><span class="sxs-lookup"><span data-stu-id="7c500-183">The new syntax doesn't provide runtime checking.</span></span> <span data-ttu-id="7c500-184">外部のコードによって、コンパイラのフロー分析が回避される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="7c500-184">External code might circumvent the compiler's flow analysis.</span></span>

<span data-ttu-id="7c500-185">クラスの構造によって、意図に対する別の手掛かりが提供されている場合があります。</span><span class="sxs-lookup"><span data-stu-id="7c500-185">Other times, the structure of a class provides different clues to the intent.</span></span> <span data-ttu-id="7c500-186">*Pages* フォルダーの *Error.cshtml.cs* ファイルを開きます。</span><span class="sxs-lookup"><span data-stu-id="7c500-186">Open the *Error.cshtml.cs* file in the *Pages* folder.</span></span> <span data-ttu-id="7c500-187">`ErrorViewModel` には、次のコードが含まれています。</span><span class="sxs-lookup"><span data-stu-id="7c500-187">The `ErrorViewModel` contains the following code:</span></span>

[!code-csharp[StarterErrorModel](~/samples/snippets/csharp/tutorials/nullable-reference-migration/start/SimpleFeedReader/Pages/Error.cshtml.cs#StartErrorModel)]

<span data-ttu-id="7c500-188">クラス宣言の前に `#nullable enable` ディレクティブを追加し、後に `#nullable restore` ディレクティブを追加します。</span><span class="sxs-lookup"><span data-stu-id="7c500-188">Add the `#nullable enable` directive before the class declaration, and a `#nullable restore` directive after it.</span></span> <span data-ttu-id="7c500-189">`RequestId` が初期化されていないことを示す警告を 1 つ受け取ります。</span><span class="sxs-lookup"><span data-stu-id="7c500-189">You'll get one warning that `RequestId` is not initialized.</span></span> <span data-ttu-id="7c500-190">クラスを調べることで、場合によっては `RequestId` プロパティを null にする必要があると判断します。</span><span class="sxs-lookup"><span data-stu-id="7c500-190">By looking at the class, you should decide that the `RequestId` property should be null in some cases.</span></span> <span data-ttu-id="7c500-191">`ShowRequestId` プロパティの存在は、欠落値があってもかまわないことを示します。</span><span class="sxs-lookup"><span data-stu-id="7c500-191">The existence of the `ShowRequestId` property indicates that missing values are possible.</span></span> <span data-ttu-id="7c500-192">`null` が有効なので、`string` 型に `?` を追加して、`RequestId` プロパティは "*null 許容参照型*" であることを示します。</span><span class="sxs-lookup"><span data-stu-id="7c500-192">Because `null` is valid, add the `?` on the `string` type to indicate the `RequestId` property is a *nullable reference type*.</span></span> <span data-ttu-id="7c500-193">最終的なクラスは次の例のようになります。</span><span class="sxs-lookup"><span data-stu-id="7c500-193">The final class looks like the following example:</span></span>

[!code-csharp[FinishedErrorModel](~/samples/snippets/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader/Pages/Error.cshtml.cs#ErrorModel)]

<span data-ttu-id="7c500-194">プロパティの使用方法を調べると、関連するページで、マークアップでレンダリングする前にプロパティが null かどうか確認されていることがわかります。</span><span class="sxs-lookup"><span data-stu-id="7c500-194">Check for the uses of the property, and you see that in the associated page, the property is checked for null before rendering it in markup.</span></span> <span data-ttu-id="7c500-195">それは null 許容参照型の安全な使用方法なので、このクラスについては終了します。</span><span class="sxs-lookup"><span data-stu-id="7c500-195">That's a safe use of a nullable reference type, so you're done with this class.</span></span>

## <a name="fixing-nulls-causes-change"></a><span data-ttu-id="7c500-196">null の修正による変更</span><span class="sxs-lookup"><span data-stu-id="7c500-196">Fixing nulls causes change</span></span>

<span data-ttu-id="7c500-197">ある一連の警告を修正すると、関連するコードで新しい警告が発生することがよくあります。</span><span class="sxs-lookup"><span data-stu-id="7c500-197">Frequently, the fix for one set of warnings creates new warnings in related code.</span></span> <span data-ttu-id="7c500-198">`index.cshtml.cs` クラスを修正することによって、警告の動作を見てみましょう。</span><span class="sxs-lookup"><span data-stu-id="7c500-198">Let's see the warnings in action by fixing the `index.cshtml.cs` class.</span></span> <span data-ttu-id="7c500-199">`index.cshtml.cs` ファイルを開いてコードを調べます。</span><span class="sxs-lookup"><span data-stu-id="7c500-199">Open the `index.cshtml.cs` file and examine the code.</span></span> <span data-ttu-id="7c500-200">このファイルには、索引ページに対する分離コードが含まれます。</span><span class="sxs-lookup"><span data-stu-id="7c500-200">This file contains the code behind for the index page:</span></span>

[!code-csharp[StarterIndexModel](~/samples/snippets/csharp/tutorials/nullable-reference-migration/start/SimpleFeedReader/Pages/Index.cshtml.cs#IndexModelStart)]

<span data-ttu-id="7c500-201">`#nullable enable` ディレクティブを追加すると、2 つの警告が表示されます。</span><span class="sxs-lookup"><span data-stu-id="7c500-201">Add the `#nullable enable` directive and you'll see two warnings.</span></span> <span data-ttu-id="7c500-202">`ErrorText` プロパティも `NewsItems` プロパティも初期化されていません。</span><span class="sxs-lookup"><span data-stu-id="7c500-202">Neither the `ErrorText` property nor the `NewsItems` property is initialized.</span></span> <span data-ttu-id="7c500-203">このクラスを調べれば、両方のプロパティを null 許容参照型にすべきであることがわかるでしょう。どちらにもプライベート セッターがあります。</span><span class="sxs-lookup"><span data-stu-id="7c500-203">An examination of this class would lead you to believe that both properties should be nullable reference types: Both have private setters.</span></span> <span data-ttu-id="7c500-204">厳密に 1 つだけが、`OnGet` メソッドで割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="7c500-204">Exactly one is assigned in the `OnGet` method.</span></span> <span data-ttu-id="7c500-205">変更する前に、両方のプロパティのコンシューマーを確認します。</span><span class="sxs-lookup"><span data-stu-id="7c500-205">Before making changes, look at the consumers of both properties.</span></span> <span data-ttu-id="7c500-206">ページ自体では、エラーのマークアップが生成される前に、`ErrorText` で null が確認されています。</span><span class="sxs-lookup"><span data-stu-id="7c500-206">In the page itself, the `ErrorText` is checked against null before generating markup for any errors.</span></span> <span data-ttu-id="7c500-207">`NewsItems` コレクションは `null` に対して確認され、項目が含まれることが確認されます。</span><span class="sxs-lookup"><span data-stu-id="7c500-207">The `NewsItems` collection is checked against `null`, and checked to ensure the collection has items.</span></span> <span data-ttu-id="7c500-208">簡単に修正するには、両方のプロパティを null 許容参照型にします。</span><span class="sxs-lookup"><span data-stu-id="7c500-208">A quick fix would be to make both properties nullable reference types.</span></span> <span data-ttu-id="7c500-209">より適切な修正方法は、コレクションを null 非許容参照型にして、ニュースを取得するときに既存のコレクションに項目を追加することです。</span><span class="sxs-lookup"><span data-stu-id="7c500-209">A better fix would be to make the collection a nonnullable reference type, and add items to the existing collection when retrieving news.</span></span> <span data-ttu-id="7c500-210">最初の修正として、`ErrorText` の `string` 型に `?` を追加します。</span><span class="sxs-lookup"><span data-stu-id="7c500-210">The first fix is to add the `?` to the `string` type for the `ErrorText`:</span></span>

[!code-csharp[UpdateErrorText](~/samples/snippets/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader/Pages/Index.cshtml.cs#UpdateErrorText)]

<span data-ttu-id="7c500-211">`ErrorText` プロパティに対するすべてのアクセスは null チェックによって既に保護されているので、その変更は他のコードには反映されません。</span><span class="sxs-lookup"><span data-stu-id="7c500-211">That change won't ripple through other code, because any access to the `ErrorText` property was already guarded by null checks.</span></span> <span data-ttu-id="7c500-212">次に、`NewsItems` リストを初期化し、プロパティのセッターを削除して、読み取り専用のプロパティにします。</span><span class="sxs-lookup"><span data-stu-id="7c500-212">Next, initialize the `NewsItems` list and remove the property setter, making it a readonly property:</span></span>

[!code-csharp[InitializeNewsItems](~/samples/snippets/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader/Pages/Index.cshtml.cs#InitializeNewsItems)]

<span data-ttu-id="7c500-213">それによって警告は修正されますが、エラーが発生するようになります。</span><span class="sxs-lookup"><span data-stu-id="7c500-213">That fixed the warning but introduced an error.</span></span> <span data-ttu-id="7c500-214">`NewsItems` リストは **Correct by Construction** になっていますが、`OnGet` でリストを設定するコードを、新しい API と一致するように変更する必要があります。</span><span class="sxs-lookup"><span data-stu-id="7c500-214">The `NewsItems` list is now **correct by construction**, but the code that sets the list in `OnGet` must change to match the new API.</span></span> <span data-ttu-id="7c500-215">割り当ての代わりに、`AddRange` を呼び出して既存のリストにニュース項目を追加します。</span><span class="sxs-lookup"><span data-stu-id="7c500-215">Instead of an assignment, call `AddRange` to add the news items to the existing list:</span></span>

[!code-csharp[AddRange](~/samples/snippets/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader/Pages/Index.cshtml.cs#AddRange)]

<span data-ttu-id="7c500-216">割り当ての代わりに `AddRange` を使用するということは、`GetNews` メソッドで `List` ではなく `IEnumerable` を返すことができることを意味します。</span><span class="sxs-lookup"><span data-stu-id="7c500-216">Using `AddRange` instead of an assignment means that the `GetNews` method can return an `IEnumerable` instead of a `List`.</span></span> <span data-ttu-id="7c500-217">それによって 1 つの割り当てが保存されます。</span><span class="sxs-lookup"><span data-stu-id="7c500-217">That saves one allocation.</span></span> <span data-ttu-id="7c500-218">次のコード サンプルで示すように、メソッドのシグネチャを変更し、`ToList` の呼び出しを削除します。</span><span class="sxs-lookup"><span data-stu-id="7c500-218">Change the signature of the method, and remove the `ToList` call, as shown in the following code sample:</span></span>

[!code-csharp[GetNews](~/samples/snippets/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader/Services/NewsService.cs#GetNewsFinished)]

<span data-ttu-id="7c500-219">シグネチャを変更すると、テストの 1 つにも影響があります。</span><span class="sxs-lookup"><span data-stu-id="7c500-219">Changing the signature breaks one of tests as well.</span></span> <span data-ttu-id="7c500-220">`SimpleFeedReader.Tests` プロジェクトの `Services` フォルダーの `NewsServiceTests.cs` ファイルを開きます。</span><span class="sxs-lookup"><span data-stu-id="7c500-220">Open the `NewsServiceTests.cs` file in the `Services` folder of the `SimpleFeedReader.Tests` project.</span></span> <span data-ttu-id="7c500-221">`Returns_News_Stories_Given_Valid_Uri` テストに移動し、`result` 変数の型を `IEnumerable<NewsItem>` に変更します。</span><span class="sxs-lookup"><span data-stu-id="7c500-221">Navigate to the `Returns_News_Stories_Given_Valid_Uri` test and change the type of the `result` variable to `IEnumerable<NewsItem>`.</span></span> <span data-ttu-id="7c500-222">型を変更すると `Count` プロパティを使用できなくなるので、`Assert` の `Count` プロパティを `Any()` の呼び出しに置き換えます。</span><span class="sxs-lookup"><span data-stu-id="7c500-222">Changing the type means the `Count` property is no longer available, so replace the `Count` property in the `Assert` with a call to `Any()`:</span></span>

[!code-csharp[FixTests](~/samples/snippets/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader.Tests/Services/NewsServiceTests.cs#FixTestSignature)]

<span data-ttu-id="7c500-223">ファイルの先頭に `using System.Linq` ステートメントを追加する必要もあります。</span><span class="sxs-lookup"><span data-stu-id="7c500-223">You'll need to add a `using System.Linq` statement to the beginning of the file as well.</span></span>

<span data-ttu-id="7c500-224">この一連の変更では、ジェネリック インスタンス化を含むコードを更新するときの特別な考慮事項に注目しています。</span><span class="sxs-lookup"><span data-stu-id="7c500-224">This set of changes highlights special consideration when updating code that includes generic instantiations.</span></span> <span data-ttu-id="7c500-225">リストとリスト内の null 非許容型の要素の両方です。</span><span class="sxs-lookup"><span data-stu-id="7c500-225">Both the list and the elements in the list of non-nullable types.</span></span> <span data-ttu-id="7c500-226">どちらか一方または両方が、null 許容型である可能性があります。</span><span class="sxs-lookup"><span data-stu-id="7c500-226">Either or both could be nullable types.</span></span> <span data-ttu-id="7c500-227">以下のすべての宣言が許容されます。</span><span class="sxs-lookup"><span data-stu-id="7c500-227">All the following declarations are allowed:</span></span>

- <span data-ttu-id="7c500-228">`List<NewsStoryViewModel>`: null 非許容ビュー モデルのを null 非許容リスト。</span><span class="sxs-lookup"><span data-stu-id="7c500-228">`List<NewsStoryViewModel>`: nonnullable list of nonullable view models.</span></span>
- <span data-ttu-id="7c500-229">`List<NewsStoryViewModel?>`: null 許容ビュー モデルのを null 非許容リスト。</span><span class="sxs-lookup"><span data-stu-id="7c500-229">`List<NewsStoryViewModel?>`: nonnullable list of nullable view models.</span></span>
- <span data-ttu-id="7c500-230">`List<NewsStoryViewModel>?`: null 非許容ビュー モデルのを null 許容リスト。</span><span class="sxs-lookup"><span data-stu-id="7c500-230">`List<NewsStoryViewModel>?`: nullable list of nonnullable view models.</span></span>
- <span data-ttu-id="7c500-231">`List<NewsStoryViewModel?>?`: null 許容ビュー モデルのを null 許容リスト。</span><span class="sxs-lookup"><span data-stu-id="7c500-231">`List<NewsStoryViewModel?>?`: nullable list of nullable view models.</span></span>

## <a name="interfaces-with-external-code"></a><span data-ttu-id="7c500-232">外部コードとのインターフェイス</span><span class="sxs-lookup"><span data-stu-id="7c500-232">Interfaces with external code</span></span>

<span data-ttu-id="7c500-233">`NewsService` クラスを変更したので、そのクラスの `#nullable enable` 注釈を有効にします。</span><span class="sxs-lookup"><span data-stu-id="7c500-233">You've made changes to the `NewsService` class, so turn on the `#nullable enable` annotation for that class.</span></span> <span data-ttu-id="7c500-234">これにより、新しい警告が生成されることはありません。</span><span class="sxs-lookup"><span data-stu-id="7c500-234">This won't generate any new warnings.</span></span> <span data-ttu-id="7c500-235">ただし、クラスを注意深く調べることは、コンパイラのフロー分析に含まれるいくつかの制限を明らかにするのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="7c500-235">However, careful examination of the class helps to illustrate some of the limitations of the compiler's flow analysis.</span></span> <span data-ttu-id="7c500-236">コンストラクターを調べます。</span><span class="sxs-lookup"><span data-stu-id="7c500-236">Examine the constructor:</span></span>

[!code-csharp[ServiceConstructor](~/samples/snippets/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader/Services/NewsService.cs#ServiceConstructor)]

<span data-ttu-id="7c500-237">`IMapper` パラメーターは、null 非許容参照として型指定されています。</span><span class="sxs-lookup"><span data-stu-id="7c500-237">The `IMapper` parameter is typed as a nonnullable reference.</span></span> <span data-ttu-id="7c500-238">それは ASP.NET Core インフラストラクチャ コードで呼び出されるため、`IMapper` が null にはならないということは、コンパイラには実際にはわかりません。</span><span class="sxs-lookup"><span data-stu-id="7c500-238">It's called by ASP.NET Core infrastructure code, so the compiler doesn't really know that the `IMapper` will never be null.</span></span> <span data-ttu-id="7c500-239">ASP.NET Core の既定の依存関係挿入 (DI) コンテナーでは、コードが正しくなるよう、必要なサービスを解決できない場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="7c500-239">The default ASP.NET Core dependency injection (DI) container throws an exception if it can't resolve a necessary service, so the code is correct.</span></span> <span data-ttu-id="7c500-240">null 許容注釈コンテキストを有効にしてコードをコンパイルした場合でも、コンパイラではパブリック API のすべての呼び出しを検証することはできません。</span><span class="sxs-lookup"><span data-stu-id="7c500-240">The compiler can't validate all calls to your public APIs, even if your code is compiled with nullable annotation contexts enabled.</span></span> <span data-ttu-id="7c500-241">さらに、null 許容参照型がまだ使用されていないプロジェクトで、ライブラリが使用される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="7c500-241">Furthermore, your libraries may be consumed by projects that have not yet opted into using nullable reference types.</span></span> <span data-ttu-id="7c500-242">null 非許容型として宣言されている場合でも、パブリック API への入力を検証してください。</span><span class="sxs-lookup"><span data-stu-id="7c500-242">Validate inputs to public APIs even though you've declared them as nonnullable types.</span></span>

## <a name="get-the-code"></a><span data-ttu-id="7c500-243">コードの入手</span><span class="sxs-lookup"><span data-stu-id="7c500-243">Get the code</span></span>

<span data-ttu-id="7c500-244">最初のテスト コンパイルで明らかになった警告を修正したので、今度は両方のプロジェクトで null 許容注釈コンテキストを有効にできます。</span><span class="sxs-lookup"><span data-stu-id="7c500-244">You've fixed the warnings you identified in the initial test compile, so now you can turn on the nullable annotation context for both projects.</span></span> <span data-ttu-id="7c500-245">プロジェクトをリビルドします。コンパイラで警告は報告されません。</span><span class="sxs-lookup"><span data-stu-id="7c500-245">Rebuild the projects; the compiler reports no warnings.</span></span> <span data-ttu-id="7c500-246">[dotnet/samples](https://github.com/dotnet/samples/tree/main/csharp/tutorials/nullable-reference-migration/finished) GitHub リポジトリで、完成したプロジェクトのコードを入手できます。</span><span class="sxs-lookup"><span data-stu-id="7c500-246">You can get the code for the finished project in the [dotnet/samples](https://github.com/dotnet/samples/tree/main/csharp/tutorials/nullable-reference-migration/finished) GitHub repository.</span></span>

<span data-ttu-id="7c500-247">null 許容参照型をサポートする新しい機能を使用すると、コードでの `null` 値の処理方法に関する潜在的なエラーを発見して修正するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="7c500-247">The new features that support nullable reference types help you find and fix potential errors in how you handle `null` values in your code.</span></span> <span data-ttu-id="7c500-248">null 許容注釈コンテキストを有効にすると、null にできない変数と、null 値を含むことができる変数に関する、設計の意図を表すことができます。</span><span class="sxs-lookup"><span data-stu-id="7c500-248">Enabling the nullable annotation context allows you to express your design intent: some variables should never be null, other variables may contain null values.</span></span> <span data-ttu-id="7c500-249">これらの機能を使用すると、設計意図を簡単に宣言できるようになります。</span><span class="sxs-lookup"><span data-stu-id="7c500-249">These features make it easier for you to declare your design intent.</span></span> <span data-ttu-id="7c500-250">同様に、null 許容警告コンテキストでは、その意図に違反しているときに警告を発行するようコンパイラに指示されます。</span><span class="sxs-lookup"><span data-stu-id="7c500-250">Similarly, the nullable warning context instructs the compiler to issue warnings when you have violated that intent.</span></span> <span data-ttu-id="7c500-251">それらの警告を参考にすると、より回復性が高く、実行中に `NullReferenceException` がスローされる可能性が低くなるように、コードを更新できます。</span><span class="sxs-lookup"><span data-stu-id="7c500-251">Those warnings guide you to make updates that make your code more resilient and less likely to throw a `NullReferenceException` during execution.</span></span> <span data-ttu-id="7c500-252">コードの局所的な領域に注目して移行を行うことができ、それ以外のコードベースは変更されないように、これらのコンテキストの範囲を制御できます。</span><span class="sxs-lookup"><span data-stu-id="7c500-252">You can control the scope of these contexts so that you can focus on local areas of code to migrate while the remaining codebase is untouched.</span></span> <span data-ttu-id="7c500-253">実際には、この移行タスクを、クラスに対する定期的なメンテナンスの一部にすることができます。</span><span class="sxs-lookup"><span data-stu-id="7c500-253">In practice, you can make this migration task a part of regular maintenance to your classes.</span></span> <span data-ttu-id="7c500-254">このチュートリアルでは、null 許容参照型を使用するようにアプリケーションを移行するプロセスを示しました。</span><span class="sxs-lookup"><span data-stu-id="7c500-254">This tutorial demonstrated the process to migrate an application to use nullable reference types.</span></span> <span data-ttu-id="7c500-255">このプロセスのさらに大きな実際の例については、[Jon Skeet](https://github.com/jskeet) が [NodaTime](https://github.com/nodatime/nodatime/pull/1240/commits) に null 許容参照型を組み込むために行った PR を調べてください。</span><span class="sxs-lookup"><span data-stu-id="7c500-255">You can explore a larger real-world example of this process by examining the PR [Jon Skeet](https://github.com/jskeet) made to incorporate nullable reference types into [NodaTime](https://github.com/nodatime/nodatime/pull/1240/commits).</span></span> <span data-ttu-id="7c500-256">また、[Entity Framework Core の null 許容参照型の使用](/ef/core/miscellaneous/nullable-reference-types)に関するページで、Entity Framework Core で null 許容参照型を使用する手法を確認することもできます。</span><span class="sxs-lookup"><span data-stu-id="7c500-256">Or just In addition, you can learn techniques for using nullable reference types with Entity Framework Core in [Entity Framework Core - Working with nullable reference types](/ef/core/miscellaneous/nullable-reference-types).</span></span>
