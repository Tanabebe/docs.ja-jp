---
title: C# 9.0 の新機能 - C# ガイド
description: C# 9.0 で使用できる新しい機能の概要を説明します。
ms.date: 04/07/2021
ms.openlocfilehash: c2189d2db175a40c24d6a41d20f2ae2d9384513b
ms.sourcegitcommit: e7e0921d0a10f85e9cb12f8b87cc1639a6c8d3fe
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/09/2021
ms.locfileid: "107255338"
---
# <a name="whats-new-in-c-90"></a><span data-ttu-id="bbdbf-103">C# 9.0 の新機能</span><span class="sxs-lookup"><span data-stu-id="bbdbf-103">What's new in C# 9.0</span></span>

<span data-ttu-id="bbdbf-104">C# 9.0 によって、C# 言語に次の機能と機能強化が追加されています。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-104">C# 9.0 adds the following features and enhancements to the C# language:</span></span>

- [<span data-ttu-id="bbdbf-105">レコード</span><span class="sxs-lookup"><span data-stu-id="bbdbf-105">Records</span></span>](#record-types)
- [<span data-ttu-id="bbdbf-106">init 専用セッター</span><span class="sxs-lookup"><span data-stu-id="bbdbf-106">Init only setters</span></span>](#init-only-setters)
- [<span data-ttu-id="bbdbf-107">最上位レベルのステートメント</span><span class="sxs-lookup"><span data-stu-id="bbdbf-107">Top-level statements</span></span>](#top-level-statements)
- [<span data-ttu-id="bbdbf-108">パターン マッチングの拡張機能</span><span class="sxs-lookup"><span data-stu-id="bbdbf-108">Pattern matching enhancements</span></span>](#pattern-matching-enhancements)
- [<span data-ttu-id="bbdbf-109">パフォーマンスと相互運用</span><span class="sxs-lookup"><span data-stu-id="bbdbf-109">Performance and interop</span></span>](#performance-and-interop)
  - <span data-ttu-id="bbdbf-110">ネイティブ サイズの整数</span><span class="sxs-lookup"><span data-stu-id="bbdbf-110">Native sized integers</span></span>
  - <span data-ttu-id="bbdbf-111">関数ポインター</span><span class="sxs-lookup"><span data-stu-id="bbdbf-111">Function pointers</span></span>
  - <span data-ttu-id="bbdbf-112">localsinit フラグの出力を抑制する</span><span class="sxs-lookup"><span data-stu-id="bbdbf-112">Suppress emitting localsinit flag</span></span>
- [<span data-ttu-id="bbdbf-113">適合性と完成度の機能</span><span class="sxs-lookup"><span data-stu-id="bbdbf-113">Fit and finish features</span></span>](#fit-and-finish-features)
  - <span data-ttu-id="bbdbf-114">ターゲット型の`new` 式</span><span class="sxs-lookup"><span data-stu-id="bbdbf-114">Target-typed `new` expressions</span></span>
  - <span data-ttu-id="bbdbf-115">静的な匿名関数</span><span class="sxs-lookup"><span data-stu-id="bbdbf-115">static anonymous functions</span></span>
  - <span data-ttu-id="bbdbf-116">ターゲットにより型指定された条件式</span><span class="sxs-lookup"><span data-stu-id="bbdbf-116">Target-typed conditional expressions</span></span>
  - <span data-ttu-id="bbdbf-117">共変の戻り値の型</span><span class="sxs-lookup"><span data-stu-id="bbdbf-117">Covariant return types</span></span>
  - <span data-ttu-id="bbdbf-118">`foreach` ループの拡張機能 `GetEnumerator` サポート</span><span class="sxs-lookup"><span data-stu-id="bbdbf-118">Extension `GetEnumerator` support for `foreach` loops</span></span>
  - <span data-ttu-id="bbdbf-119">ラムダ ディスカード パラメーター</span><span class="sxs-lookup"><span data-stu-id="bbdbf-119">Lambda discard parameters</span></span>
  - <span data-ttu-id="bbdbf-120">ローカル関数の属性</span><span class="sxs-lookup"><span data-stu-id="bbdbf-120">Attributes on local functions</span></span>
- [<span data-ttu-id="bbdbf-121">コード ジェネレーターのサポート</span><span class="sxs-lookup"><span data-stu-id="bbdbf-121">Support for code generators</span></span>](#support-for-code-generators)
  - <span data-ttu-id="bbdbf-122">モジュールの初期化子</span><span class="sxs-lookup"><span data-stu-id="bbdbf-122">Module initializers</span></span>
  - <span data-ttu-id="bbdbf-123">部分メソッドの新機能</span><span class="sxs-lookup"><span data-stu-id="bbdbf-123">New features for partial methods</span></span>

<span data-ttu-id="bbdbf-124">C# 9.0 は **.NET 5** でサポートされています。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-124">C# 9.0 is supported on **.NET 5**.</span></span> <span data-ttu-id="bbdbf-125">詳細については、「[C# 言語のバージョン管理](../language-reference/configure-language-version.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-125">For more information, see [C# language versioning](../language-reference/configure-language-version.md).</span></span>

<span data-ttu-id="bbdbf-126">最新の .NET SDK は [.NET のダウンロード ページ](https://dotnet.microsoft.com/download)でダウンロードできます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-126">You can download the latest .NET SDK from the [.NET downloads page](https://dotnet.microsoft.com/download).</span></span>

## <a name="record-types"></a><span data-ttu-id="bbdbf-127">レコードの種類</span><span class="sxs-lookup"><span data-stu-id="bbdbf-127">Record types</span></span>

<span data-ttu-id="bbdbf-128">C# 9.0 では、"***レコード型***" が導入されています。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-128">C# 9.0 introduces ***record types***.</span></span> <span data-ttu-id="bbdbf-129">`record` キーワードを使用して、データをカプセル化するための組み込み機能を提供する参照型を定義します。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-129">You use the `record` keyword to define a reference type that provides built-in functionality for encapsulating data.</span></span> <span data-ttu-id="bbdbf-130">位置指定パラメーターまたは標準のプロパティ構文を使用して、不変のプロパティを持つレコード型を作成できます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-130">You can create record types with immutable properties by using positional parameters or standard property syntax:</span></span>

:::code language="csharp" source="../language-reference/builtin-types/snippets/shared/RecordType.cs" id="PositionalRecord":::
:::code language="csharp" source="../language-reference/builtin-types/snippets/shared/RecordType.cs" id="ImmutableRecord":::

<span data-ttu-id="bbdbf-131">また、変更可能なプロパティとフィールドを使用してレコード型を作成することもできます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-131">You can also create record types with mutable properties and fields:</span></span>

:::code language="csharp" source="../language-reference/builtin-types/snippets/shared/RecordType.cs" id="MutableRecord":::

<span data-ttu-id="bbdbf-132">レコードは変更可能ですが、これらは主に不変のデータ モデルをサポートすることを目的としています。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-132">While records can be mutable, they are primarily intended for supporting immutable data models.</span></span> <span data-ttu-id="bbdbf-133">レコード型には次の機能があります。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-133">The record type offers the following features:</span></span>

* [<span data-ttu-id="bbdbf-134">不変プロパティを持つ参照型を作成するための簡潔な構文</span><span class="sxs-lookup"><span data-stu-id="bbdbf-134">Concise syntax for creating a reference type with immutable properties</span></span>](#positional-syntax-for-property-definition)
* <span data-ttu-id="bbdbf-135">データ中心の参照型に役立つビヘイビアー:</span><span class="sxs-lookup"><span data-stu-id="bbdbf-135">Behavior useful for a data-centric reference type:</span></span>
  * [<span data-ttu-id="bbdbf-136">値の等価性</span><span class="sxs-lookup"><span data-stu-id="bbdbf-136">Value equality</span></span>](#value-equality)
  * [<span data-ttu-id="bbdbf-137">非破壊的な変化の簡潔な構文</span><span class="sxs-lookup"><span data-stu-id="bbdbf-137">Concise syntax for nondestructive mutation</span></span>](#nondestructive-mutation)
  * [<span data-ttu-id="bbdbf-138">表示用の組み込みの書式設定</span><span class="sxs-lookup"><span data-stu-id="bbdbf-138">Built-in formatting for display</span></span>](#built-in-formatting-for-display)
* [<span data-ttu-id="bbdbf-139">継承階層のサポート</span><span class="sxs-lookup"><span data-stu-id="bbdbf-139">Support for inheritance hierarchies</span></span>](#inheritance)

<span data-ttu-id="bbdbf-140">[構造型](../language-reference/builtin-types/struct.md)を使用して、値の等価性があり、ビヘイビアーがほとんどない、またはまったくないデータ中心の型を設計することができます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-140">You can use [structure types](../language-reference/builtin-types/struct.md) to design data-centric types that provide value equality and little or no behavior.</span></span> <span data-ttu-id="bbdbf-141">ただし、比較的大規模なデータ モデルの場合、構造体型にはいくつかの欠点があります。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-141">But for relatively large data models, structure types have some disadvantages:</span></span>

* <span data-ttu-id="bbdbf-142">継承はサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-142">They don't support inheritance.</span></span>
* <span data-ttu-id="bbdbf-143">値の等価性を決定する場合には効率的ではありません。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-143">They're less efficient at determining value equality.</span></span> <span data-ttu-id="bbdbf-144">値型の場合、<xref:System.ValueType.Equals%2A?displayProperty=nameWithType> メソッドによってリフレクションが使用され、すべてのフィールドが検索されます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-144">For value types, the <xref:System.ValueType.Equals%2A?displayProperty=nameWithType> method uses reflection to find all fields.</span></span> <span data-ttu-id="bbdbf-145">レコードの場合、コンパイラによって `Equals` メソッドが生成されます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-145">For records, the compiler generates the `Equals` method.</span></span> <span data-ttu-id="bbdbf-146">実際のところ、レコードでの値の等価性の実装は、多少は高速です。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-146">In practice, the implementation of value equality in records is measurably faster.</span></span>
* <span data-ttu-id="bbdbf-147">すべてのインスタンスにすべてのデータの完全なコピーがあるため、一部のシナリオではより多くのメモリが使用されます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-147">They use more memory in some scenarios, since every instance has a complete copy of all of the data.</span></span> <span data-ttu-id="bbdbf-148">レコード型は[参照型](../language-reference/builtin-types/reference-types.md)であるため、レコード インスタンスにはデータへの参照のみが含まれます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-148">Record types are [reference types](../language-reference/builtin-types/reference-types.md), so a record instance contains only a reference to the data.</span></span>

### <a name="positional-syntax-for-property-definition"></a><span data-ttu-id="bbdbf-149">プロパティ定義の位置指定構文</span><span class="sxs-lookup"><span data-stu-id="bbdbf-149">Positional syntax for property definition</span></span>

<span data-ttu-id="bbdbf-150">位置指定パラメーターを使用すると、レコードのプロパティを宣言し、インスタンスを作成するときにプロパティ値を初期化できます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-150">You can use positional parameters to declare properties of a record and to initialize the property values when you create an instance:</span></span>

:::code language="csharp" source="../language-reference/builtin-types/snippets/shared/RecordType.cs" id="InstantiatePositional":::

<span data-ttu-id="bbdbf-151">プロパティ定義に位置指定構文を使用すると、コンパイラにより、以下が作成されます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-151">When you use the positional syntax for property definition, the compiler creates:</span></span>

* <span data-ttu-id="bbdbf-152">レコード宣言で指定される各位置指定パラメーターのパブリック init 専用自動実装プロパティ。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-152">A public init-only auto-implemented property for each positional parameter provided in the record declaration.</span></span> <span data-ttu-id="bbdbf-153">[init 専用](../language-reference/keywords/init.md)プロパティは、コンストラクターで、またはプロパティ初期化子を使用して設定できます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-153">An [init-only](../language-reference/keywords/init.md) property can only be set in the constructor or by using a property initializer.</span></span>
* <span data-ttu-id="bbdbf-154">パラメーターがレコード宣言の位置指定パラメーターと一致するプライマリ コンストラクター。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-154">A primary constructor whose parameters match the positional parameters on the record declaration.</span></span>
* <span data-ttu-id="bbdbf-155">レコード宣言で指定された各定位置指定パラメーターの `out` パラメーターを使用する `Deconstruct` メソッド。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-155">A `Deconstruct` method with an `out` parameter for each positional parameter provided in the record declaration.</span></span>

<span data-ttu-id="bbdbf-156">詳細については、レコードに関する C# 言語リファレンスの記事の[位置指定構文](../language-reference/builtin-types/record.md#positional-syntax-for-property-definition)に関するセクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-156">For more information, see [Positional syntax](../language-reference/builtin-types/record.md#positional-syntax-for-property-definition) in the C# language reference article about records.</span></span>

### <a name="immutability"></a><span data-ttu-id="bbdbf-157">不変性</span><span class="sxs-lookup"><span data-stu-id="bbdbf-157">Immutability</span></span>

<span data-ttu-id="bbdbf-158">レコード型は必ずしも不変ではありません。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-158">A record type is not necessarily immutable.</span></span> <span data-ttu-id="bbdbf-159">`readonly` ではない `set` アクセサーとフィールドを使用してプロパティを宣言できます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-159">You can declare properties with `set` accessors and fields that aren't `readonly`.</span></span> <span data-ttu-id="bbdbf-160">ただし、レコードは変更可能ですが、不変のデータ モデルを簡単に作成できます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-160">But while records can be mutable, they make it easier to create immutable data models.</span></span> <span data-ttu-id="bbdbf-161">位置指定構文を使用して作成したプロパティは変更できません。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-161">Properties that you create by using positional syntax are immutable.</span></span>

<span data-ttu-id="bbdbf-162">不変性は、データ中心の型をスレッドセーフにする必要がある場合、またはハッシュ テーブル内でハッシュ コードを同じにしたい場合に役立ちます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-162">Immutability can be useful when you want a data-centric type to be thread-safe or a hash code to remain the same in a hash table.</span></span> <span data-ttu-id="bbdbf-163">メソッドに参照によって引数を渡すときに発生するバグを防ぐことができます。また、メソッドによって引数の値が予期せず変更されることがあります。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-163">It can prevent bugs that happen when you pass an argument by reference to a method, and the method unexpectedly changes the argument value.</span></span>

<span data-ttu-id="bbdbf-164">レコード型に固有の機能は、コンパイラによって合成されたメソッドによって実装されます。このようなメソッドのいずれを使用してオブジェクトの状態を変更しても、不変性は損なわれません。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-164">The features unique to record types are implemented by compiler-synthesized methods, and none of these methods compromises immutability by modifying object state.</span></span>

### <a name="value-equality"></a><span data-ttu-id="bbdbf-165">値の等価性</span><span class="sxs-lookup"><span data-stu-id="bbdbf-165">Value equality</span></span>

<span data-ttu-id="bbdbf-166">値の等価性とは、型が一致し、かつプロパティおよびフィールドの値がすべて一致する場合にレコード型の 2 つの変数が等しいことを意味します。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-166">Value equality means that two variables of a record type are equal if the types match and all property and field values match.</span></span> <span data-ttu-id="bbdbf-167">その他の参照型の場合、等価性は ID を意味します。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-167">For other reference types, equality means identity.</span></span> <span data-ttu-id="bbdbf-168">つまり、参照型の 2 つの変数は、同じオブジェクトを参照する場合、等しいことになります。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-168">That is, two variables of a reference type are equal if they refer to the same object.</span></span>

<span data-ttu-id="bbdbf-169">次の例は、レコード型の値が等しいことを示しています。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-169">The following example illustrates value equality of record types:</span></span>

:::code language="csharp" source="../language-reference/builtin-types/snippets/shared/RecordType.cs" id="Equality":::

<span data-ttu-id="bbdbf-170">`class` 型では、等価性メソッドと演算子を手動でオーバーライドして値の等価性を実現できますが、そのコードの開発とテストには時間がかかり、エラーが発生しやすいものです。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-170">In `class` types, you could manually override equality methods and operators to achieve value equality, but developing and testing that code would be time-consuming and error-prone.</span></span> <span data-ttu-id="bbdbf-171">この機能を組み込むと、プロパティまたはフィールドが追加または変更されたときにカスタムのオーバーライド コードの更新を忘れたことで発生するバグを防ぐことができます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-171">Having this functionality built-in prevents bugs that would result from forgetting to update custom override code when properties or fields are added or changed.</span></span>

<span data-ttu-id="bbdbf-172">詳細については、レコードに関する C# 言語リファレンスの記事の「[値の等価性](../language-reference/builtin-types/record.md#value-equality)」セクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-172">For more information, see [Value equality](../language-reference/builtin-types/record.md#value-equality) in the C# language reference article about records.</span></span>

### <a name="nondestructive-mutation"></a><span data-ttu-id="bbdbf-173">非破壊な変化</span><span class="sxs-lookup"><span data-stu-id="bbdbf-173">Nondestructive mutation</span></span>

<span data-ttu-id="bbdbf-174">レコード インスタンスの不変プロパティを変更する必要がある場合は、`with` 式を使用して "*非破壊的な変化*" を実現できます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-174">If you need to mutate immutable properties of a record instance, you can use a `with` expression to achieve *nondestructive mutation*.</span></span> <span data-ttu-id="bbdbf-175">`with` 式を使用すると、指定したプロパティとフィールドが変更された、既存のレコード インスタンスのコピーである新しいレコード インスタンスが作成されます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-175">A `with` expression makes a new record instance that is a copy of an existing record instance, with specified properties and fields modified.</span></span> <span data-ttu-id="bbdbf-176">次の例に示すように、[オブジェクト初期化子](../programming-guide/classes-and-structs/object-and-collection-initializers.md)構文を使用して、変更する値を指定します。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-176">You use [object initializer](../programming-guide/classes-and-structs/object-and-collection-initializers.md) syntax to specify the values to be changed, as shown in the following example:</span></span>

:::code language="csharp" source="../language-reference/builtin-types/snippets/shared/RecordType.cs" id="WithExpressions":::

<span data-ttu-id="bbdbf-177">詳細については、レコードに関する C# 言語リファレンスの記事の「[非破壊な変化](../language-reference/builtin-types/record.md#nondestructive-mutation)」セクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-177">For more information, see [Nondestructive mutation](../language-reference/builtin-types/record.md#nondestructive-mutation) in the C# language reference article about records.</span></span>

### <a name="built-in-formatting-for-display"></a><span data-ttu-id="bbdbf-178">表示用の組み込みの書式設定</span><span class="sxs-lookup"><span data-stu-id="bbdbf-178">Built-in formatting for display</span></span>

<span data-ttu-id="bbdbf-179">レコード型には、パブリック プロパティとフィールドの名前と値を表示する、コンパイラによって生成された <xref:System.Object.ToString%2A> メソッドがあります。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-179">Record types have a compiler-generated <xref:System.Object.ToString%2A> method that displays the names and values of public properties and fields.</span></span> <span data-ttu-id="bbdbf-180">`ToString` メソッドからは、次の形式の文字列が返されます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-180">The `ToString` method returns a string of the following format:</span></span>

> <span data-ttu-id="bbdbf-181">\<record type name> { \<property name> = \<value>, \<property name> = \<value>, ...}</span><span class="sxs-lookup"><span data-stu-id="bbdbf-181">\<record type name> { \<property name> = \<value>, \<property name> = \<value>, ...}</span></span>

<span data-ttu-id="bbdbf-182">参照型の場合、プロパティ値ではなく、プロパティから参照されるオブジェクトの型名が表示されます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-182">For reference types, the type name of the object that the property refers to is displayed instead of the property value.</span></span> <span data-ttu-id="bbdbf-183">次の例では、配列は参照型であるため、実際の配列要素値ではなく `System.String[]` が表示されます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-183">In the following example, the array is a reference type, so `System.String[]` is displayed instead of the actual array element values:</span></span>

```
Person { FirstName = Nancy, LastName = Davolio, ChildNames = System.String[] }
```

<span data-ttu-id="bbdbf-184">詳細については、レコードに関する C# 言語リファレンスの記事の[組み込みの書式設定](../language-reference/builtin-types/record.md#built-in-formatting-for-display)に関するセクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-184">For more information, see [Built-in formatting](../language-reference/builtin-types/record.md#built-in-formatting-for-display) in the C# language reference article about records.</span></span>

### <a name="inheritance"></a><span data-ttu-id="bbdbf-185">継承</span><span class="sxs-lookup"><span data-stu-id="bbdbf-185">Inheritance</span></span>

<span data-ttu-id="bbdbf-186">レコードは、別のレコードから継承できます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-186">A record can inherit from another record.</span></span> <span data-ttu-id="bbdbf-187">ただし、レコードはクラスから継承できません。また、クラスはレコードから継承できません。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-187">However, a record can't inherit from a class, and a class can't inherit from a record.</span></span>

<span data-ttu-id="bbdbf-188">次の例は、位置指定プロパティ構文を使用した継承を示しています。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-188">The following example illustrates inheritance with positional property syntax:</span></span>

:::code language="csharp" source="../language-reference/builtin-types/snippets/shared/RecordType.cs" id="PositionalInheritance":::

<span data-ttu-id="bbdbf-189">2 つのレコード変数が等しくなるには、ランタイム型が等しくなければなりません。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-189">For two record variables to be equal, the run-time type must be equal.</span></span> <span data-ttu-id="bbdbf-190">含まれている変数型は異なっていていても構いません。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-190">The types of the containing variables might be different.</span></span> <span data-ttu-id="bbdbf-191">これを次のコード例に示します。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-191">This is illustrated in the following code example:</span></span>

:::code language="csharp" source="../language-reference/builtin-types/snippets/shared/RecordType.cs" id="InheritanceEquality":::

<span data-ttu-id="bbdbf-192">この例では、すべてのインスタンスが同じプロパティであり、同じプロパティ値です。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-192">In the example, all instances have the same properties and the same property values.</span></span> <span data-ttu-id="bbdbf-193">どちらも `Person` 型の変数ですが、`student == teacher` は、`False` を返します。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-193">But `student == teacher` returns `False` although both are `Person`-type variables.</span></span> <span data-ttu-id="bbdbf-194">一方は `Person` 変数、もう一方は `Student` 変数ですが、`student == student2` は、`True` を返します。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-194">And `student == student2` returns `True` although one is a `Person` variable and one is a `Student` variable.</span></span>

<span data-ttu-id="bbdbf-195">次の例に示すように、派生型と基本データ型の両方のすべてのパブリック プロパティとフィールドが `ToString` の出力に含まれます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-195">All public properties and fields of both derived and base types are included in the `ToString` output, as shown in the following example:</span></span>

:::code language="csharp" source="../language-reference/builtin-types/snippets/shared/RecordType.cs" id="ToStringInheritance":::

<span data-ttu-id="bbdbf-196">詳細については、レコードに関する C# 言語リファレンスの記事の「[継承](../language-reference/builtin-types/record.md#inheritance)」セクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-196">For more information, see [Inheritance](../language-reference/builtin-types/record.md#inheritance) in the C# language reference article about records.</span></span>

## <a name="init-only-setters"></a><span data-ttu-id="bbdbf-197">init 専用セッター</span><span class="sxs-lookup"><span data-stu-id="bbdbf-197">Init only setters</span></span>

<span data-ttu-id="bbdbf-198">"***init 専用セッター***" によって、オブジェクトのメンバーを初期化するための一貫した構文が提供されます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-198">***Init only setters*** provide consistent syntax to initialize members of an object.</span></span> <span data-ttu-id="bbdbf-199">プロパティ初期化子を使用すると、どの値によってどのプロパティが設定されているかが明確にされます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-199">Property initializers make it clear which value is setting which property.</span></span> <span data-ttu-id="bbdbf-200">欠点は、それらのプロパティが設定可能である必要があることです。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-200">The downside is that those properties must be settable.</span></span> <span data-ttu-id="bbdbf-201">C# 9.0 以降では、プロパティとインデクサーに対して `set` アクセサーの代わりに `init` アクセサーを作成できます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-201">Starting with C# 9.0, you can create `init` accessors instead of `set` accessors for properties and indexers.</span></span> <span data-ttu-id="bbdbf-202">呼び出し元により、プロパティ初期化子構文を使用して作成式でこれらの値を設定することができますが、構築が完了するとそれらのプロパティは読み取り専用になります。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-202">Callers can use property initializer syntax to set these values in creation expressions, but those properties are readonly once construction has completed.</span></span> <span data-ttu-id="bbdbf-203">init 専用セッターによって、状態を変更するためのウィンドウが提供されます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-203">Init only setters provide a window to change state.</span></span> <span data-ttu-id="bbdbf-204">構築フェーズが終了すると、そのウィンドウは閉じます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-204">That window closes when the construction phase ends.</span></span> <span data-ttu-id="bbdbf-205">プロパティ初期化子と with 式の完了を含め、すべての初期化の後で、構築フェーズは実質的に終了します。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-205">The construction phase effectively ends after all initialization, including property initializers and with-expressions have completed.</span></span>

<span data-ttu-id="bbdbf-206">`init` 専用セッターは、記述する任意の型で宣言できます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-206">You can declare `init` only setters in any type you write.</span></span> <span data-ttu-id="bbdbf-207">たとえば、次の構造体では、気象監視構造体が定義されています。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-207">For example, the following struct defines a weather observation structure:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/WeatherObservation.cs" ID="DeclareWeatherObservation":::

<span data-ttu-id="bbdbf-208">呼び出し元は、プロパティ初期化子構文を使用して値を設定できますが、それでも不変性は維持されます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-208">Callers can use property initializer syntax to set the values, while still preserving the immutability:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/WeatherObservation.cs" ID="UseWeatherObservation":::

<span data-ttu-id="bbdbf-209">初期化後に監視を変更しようとすると、コンパイラ エラーが発生します。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-209">An attempt to change an observation after initialization results in a compiler error:</span></span>

```csharp
// Error! CS8852.
now.TemperatureInCelsius = 18;
```

<span data-ttu-id="bbdbf-210">init 専用セッターは、派生クラスから基底クラスのプロパティを設定する場合に便利です。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-210">Init only setters can be useful to set base class properties from derived classes.</span></span> <span data-ttu-id="bbdbf-211">また、基底クラスのヘルパーを使用して派生プロパティを設定することもできます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-211">They can also set derived properties through helpers in a base class.</span></span> <span data-ttu-id="bbdbf-212">位置指定レコードによって、init 専用セッターを使用してプロパティが宣言されます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-212">Positional records declare properties using init only setters.</span></span> <span data-ttu-id="bbdbf-213">これらのセッターは、with 式で使用されます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-213">Those setters are used in with-expressions.</span></span> <span data-ttu-id="bbdbf-214">定義する任意の `class`、`struct` または `record` に対して、init 専用セッターを宣言できます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-214">You can declare init only setters for any `class`, `struct`, or `record` you define.</span></span>

<span data-ttu-id="bbdbf-215">詳細については、「[init (C# リファレンス)](../language-reference/keywords/init.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-215">For more information, see [init (C# Reference)](../language-reference/keywords/init.md).</span></span>

## <a name="top-level-statements"></a><span data-ttu-id="bbdbf-216">最上位レベルのステートメント</span><span class="sxs-lookup"><span data-stu-id="bbdbf-216">Top-level statements</span></span>

<span data-ttu-id="bbdbf-217">"***最上位レベル ステートメント***" により、多くのアプリケーションから不要な手続きが削除されます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-217">***Top-level statements*** remove unnecessary ceremony from many applications.</span></span> <span data-ttu-id="bbdbf-218">正規の "Hello World!"</span><span class="sxs-lookup"><span data-stu-id="bbdbf-218">Consider the canonical "Hello World!"</span></span> <span data-ttu-id="bbdbf-219">プログラムについて考えます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-219">program:</span></span>

```csharp
using System;

namespace HelloWorld
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
        }
    }
}
```

<span data-ttu-id="bbdbf-220">何かを行うコード行は 1 つだけです。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-220">There's only one line of code that does anything.</span></span> <span data-ttu-id="bbdbf-221">最上位レベル ステートメントを使用すると、そのすべての定型句を、`using` ディレクティブと処理を行う 1 行に置き換えることができます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-221">With top-level statements, you can replace all that boilerplate with the `using` directive and the single line that does the work:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/Program.cs" ID="TopLevelStatements":::

<span data-ttu-id="bbdbf-222">1 行だけのプログラムが必要な場合は、`using` ディレクティブを削除し、完全修飾型名を使用することができます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-222">If you wanted a one-line program, you could remove the `using` directive and use the fully qualified type name:</span></span>

```csharp
System.Console.WriteLine("Hello World!");
```

<span data-ttu-id="bbdbf-223">最上位レベル ステートメントを使用できるのは、アプリケーション内の 1 つのファイルだけです。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-223">Only one file in your application may use top-level statements.</span></span> <span data-ttu-id="bbdbf-224">コンパイラにより、複数のソース ファイルで最上位レベル ステートメントが検出されると、エラーになります。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-224">If the compiler finds top-level statements in multiple source files, it's an error.</span></span> <span data-ttu-id="bbdbf-225">また、最上位レベル ステートメントを、宣言されたプログラム エントリ ポイント メソッド (通常は `Main` メソッド) と組み合わせても、エラーになります。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-225">It's also an error if you combine top-level statements with a declared program entry point method, typically a `Main` method.</span></span> <span data-ttu-id="bbdbf-226">ある程度まで、その 1 つのファイルに、通常は `Program` クラスの `Main` メソッドに含まれるステートメントが含まれているものと考えることができます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-226">In a sense, you can think that one file contains the statements that would normally be in the `Main` method of a `Program` class.</span></span>  

<span data-ttu-id="bbdbf-227">この機能の最も一般的な用途の 1 つは、教材の作成です。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-227">One of the most common uses for this feature is creating teaching materials.</span></span> <span data-ttu-id="bbdbf-228">C# の開発初心者は、正規の "Hello World!" を</span><span class="sxs-lookup"><span data-stu-id="bbdbf-228">Beginner C# developers can write the canonical "Hello World!"</span></span> <span data-ttu-id="bbdbf-229">1 行または 2 行のコードで作成できます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-229">in one or two lines of code.</span></span> <span data-ttu-id="bbdbf-230">余分な手続きは必要ありません。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-230">None of the extra ceremony is needed.</span></span> <span data-ttu-id="bbdbf-231">一方、経験豊富な開発者は、この機能の多くの用途を見つけることができます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-231">However, seasoned developers will find many uses for this feature as well.</span></span> <span data-ttu-id="bbdbf-232">最上位レベル ステートメントを使用すると、Jupyter Notebook で提供されるものと同様の実験用にスクリプトに似たエクスペリエンスを有効にできます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-232">Top-level statements enable a script-like experience for experimentation similar to what Jupyter notebooks provide.</span></span> <span data-ttu-id="bbdbf-233">最上位レベル ステートメントは、小規模なコンソール プログラムとユーティリティに最適です。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-233">Top-level statements are great for small console programs and utilities.</span></span> <span data-ttu-id="bbdbf-234">[Azure Functions](/azure/azure-functions/) は、最上位レベル ステートメントに最適なユース ケースです。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-234">[Azure Functions](/azure/azure-functions/) is an ideal use case for top-level statements.</span></span>

<span data-ttu-id="bbdbf-235">最も重要なのは、最上位レベル ステートメントでアプリケーションのスコープや複雑さが制限されないことです。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-235">Most importantly, top-level statements don't limit your application's scope or complexity.</span></span> <span data-ttu-id="bbdbf-236">それらのステートメントでは、任意の .NET クラスにアクセスしたり、使用したりできます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-236">Those statements can access or use any .NET class.</span></span> <span data-ttu-id="bbdbf-237">また、コマンド ライン引数や戻り値の使用も制限されません。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-237">They also don't limit your use of command-line arguments or return values.</span></span> <span data-ttu-id="bbdbf-238">最上位レベル ステートメントでは、`args` という名前の文字列の配列にアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-238">Top-level statements can access an array of strings named `args`.</span></span> <span data-ttu-id="bbdbf-239">最上位レベル ステートメントで整数値が返される場合、その値は、合成された `Main` メソッドからの整数のリターン コードになります。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-239">If the top-level statements return an integer value, that value becomes the integer return code from a synthesized `Main` method.</span></span> <span data-ttu-id="bbdbf-240">最上位レベル ステートメントには、非同期式を含めることができます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-240">The top-level statements may contain async expressions.</span></span> <span data-ttu-id="bbdbf-241">その場合、合成されたエントリ ポイントからは `Task` または `Task<int>` が返されます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-241">In that case, the synthesized entry point returns a `Task`, or `Task<int>`.</span></span>

<span data-ttu-id="bbdbf-242">詳細については、「[最上位レベルのステートメント (C# プログラミング ガイド)](../programming-guide/main-and-command-args/top-level-statements.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-242">For more information, see [Top-level statements](../programming-guide/main-and-command-args/top-level-statements.md) in the C# Programming Guide.</span></span>

## <a name="pattern-matching-enhancements"></a><span data-ttu-id="bbdbf-243">パターン マッチングの拡張機能</span><span class="sxs-lookup"><span data-stu-id="bbdbf-243">Pattern matching enhancements</span></span>

<span data-ttu-id="bbdbf-244">C# 9 には、新しいパターン マッチングの機能強化が含まれています。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-244">C# 9 includes new pattern matching improvements:</span></span>

- <span data-ttu-id="bbdbf-245">"***型パターン***" は、変数が型である場合に一致します</span><span class="sxs-lookup"><span data-stu-id="bbdbf-245">***Type patterns*** match a variable is a type</span></span>
- <span data-ttu-id="bbdbf-246">"***かっこで囲まれたパターン***" では、パターンの組み合わせの優先順位が適用または強調されます</span><span class="sxs-lookup"><span data-stu-id="bbdbf-246">***Parenthesized patterns*** enforce or emphasize the precedence of pattern combinations</span></span>
- <span data-ttu-id="bbdbf-247">"***接続的 `and` パターン***" では、両方のパターンが一致することが要求されます</span><span class="sxs-lookup"><span data-stu-id="bbdbf-247">***Conjunctive `and` patterns*** require both patterns to match</span></span>
- <span data-ttu-id="bbdbf-248">"***離接的 `or` パターン***" では、どちらかのパターンが一致することが要求されます</span><span class="sxs-lookup"><span data-stu-id="bbdbf-248">***Disjunctive `or` patterns*** require either pattern to match</span></span>
- <span data-ttu-id="bbdbf-249">"***否定的 `not` パターン***" では、パターンが一致しないことが要求されます</span><span class="sxs-lookup"><span data-stu-id="bbdbf-249">***Negated `not` patterns*** require that a pattern doesn't match</span></span>
- <span data-ttu-id="bbdbf-250">"***関係パターン***" では、入力が定数より小さい、より大きい、以下、または以上であることが要求されます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-250">***Relational patterns*** require the input be less than, greater than, less than or equal, or greater than or equal to a given constant.</span></span>

<span data-ttu-id="bbdbf-251">これらのパターンにより、パターンの構文が豊富になります。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-251">These patterns enrich the syntax for patterns.</span></span> <span data-ttu-id="bbdbf-252">次のような例を考えてみてください。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-252">Consider these examples:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PatternUtilities.cs" ID="IsLetterPattern":::

<span data-ttu-id="bbdbf-253">省略可能なかっこを使用して、`and` が `or` より優先順位が高いことを明確にします。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-253">With optional parentheses to make it clear that `and` has higher precedence than `or`:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PatternUtilities.cs" ID="IsLetterOrSeparatorPattern":::

<span data-ttu-id="bbdbf-254">最も一般的な使用方法の 1 つは、null チェックの新しい構文です。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-254">One of the most common uses is a new syntax for a null check:</span></span>

```csharp
if (e is not null)
{
    // ...
}
```

<span data-ttu-id="bbdbf-255">これらのパターンのいずれも、パターンが許可される任意のコンテキスト (`is` パターン式、`switch` 式、入れ子になったパターン、`switch` ステートメントの `case` ラベルのパターン) で使用できます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-255">Any of these patterns can be used in any context where patterns are allowed: `is` pattern expressions, `switch` expressions, nested patterns, and the pattern of a `switch` statement's `case` label.</span></span>

<span data-ttu-id="bbdbf-256">詳細については、「[パターン (C# リファレンス)](../language-reference/operators/patterns.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-256">For more information, see [Patterns (C# reference)](../language-reference/operators/patterns.md).</span></span>

<span data-ttu-id="bbdbf-257">詳細については、「[パターン](../language-reference/operators/patterns.md)」の記事の「[リレーショナル パターン](../language-reference/operators/patterns.md#relational-patterns)」と「[論理パターン](../language-reference/operators/patterns.md#logical-patterns)」のセクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-257">For more information, see the [Relational patterns](../language-reference/operators/patterns.md#relational-patterns) and [Logical patterns](../language-reference/operators/patterns.md#logical-patterns) sections of the [Patterns](../language-reference/operators/patterns.md) article.</span></span>

## <a name="performance-and-interop"></a><span data-ttu-id="bbdbf-258">パフォーマンスと相互運用</span><span class="sxs-lookup"><span data-stu-id="bbdbf-258">Performance and interop</span></span>

<span data-ttu-id="bbdbf-259">3 つの新機能により、高パフォーマンスを必要とするネイティブ相互運用および低レベル ライブラリのサポートが向上します (ネイティブ サイズの整数、関数ポインター、`localsinit` フラグの省略)。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-259">Three new features improve support for native interop and low-level libraries that require high performance: native sized integers, function pointers, and omitting the `localsinit` flag.</span></span>

<span data-ttu-id="bbdbf-260">ネイティブ サイズの整数 `nint` と `nuint` は整数型です。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-260">Native sized integers, `nint` and `nuint`, are integer types.</span></span> <span data-ttu-id="bbdbf-261">これらは、基になる型 <xref:System.IntPtr?displayProperty=nameWithType> および <xref:System.UIntPtr?displayProperty=nameWithType> によって表されます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-261">They're expressed by the underlying types <xref:System.IntPtr?displayProperty=nameWithType> and <xref:System.UIntPtr?displayProperty=nameWithType>.</span></span> <span data-ttu-id="bbdbf-262">コンパイラによって、これらの型に対する追加の変換と操作がネイティブ int として公開されます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-262">The compiler surfaces additional conversions and operations for these types as native ints.</span></span> <span data-ttu-id="bbdbf-263">ネイティブ サイズの整数では、`MaxValue` または `MinValue` のプロパティが定義されます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-263">Native sized integers define properties for `MaxValue` or `MinValue`.</span></span> <span data-ttu-id="bbdbf-264">これらの値は、ターゲット コンピューターでの整数のネイティブ サイズに依存するため、コンパイル時の定数として表すことはできません。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-264">These values can't be expressed as compile-time constants because they depend on the native size of an integer on the target machine.</span></span> <span data-ttu-id="bbdbf-265">これらの値は実行時に読み取り専用になります。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-265">Those values are readonly at runtime.</span></span> <span data-ttu-id="bbdbf-266">`nint` に対する定数値は、[`int.MinValue` ..</span><span class="sxs-lookup"><span data-stu-id="bbdbf-266">You can use constant values for `nint` in the range [`int.MinValue` ..</span></span> <span data-ttu-id="bbdbf-267">`int.MaxValue`].</span><span class="sxs-lookup"><span data-stu-id="bbdbf-267">`int.MaxValue`].</span></span> <span data-ttu-id="bbdbf-268">`nuint` に対する定数値は、[`uint.MinValue` ..</span><span class="sxs-lookup"><span data-stu-id="bbdbf-268">You can use constant values for `nuint` in the range [`uint.MinValue` ..</span></span> <span data-ttu-id="bbdbf-269">`uint.MaxValue`].</span><span class="sxs-lookup"><span data-stu-id="bbdbf-269">`uint.MaxValue`].</span></span> <span data-ttu-id="bbdbf-270">コンパイラによって、<xref:System.Int32?displayProperty=nameWithType> 型と <xref:System.UInt32?displayProperty=nameWithType> 型を使用するすべての単項演算子と二項演算子に対して、定数の折りたたみが実行されます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-270">The compiler performs constant folding for all unary and binary operators using the <xref:System.Int32?displayProperty=nameWithType> and <xref:System.UInt32?displayProperty=nameWithType> types.</span></span> <span data-ttu-id="bbdbf-271">結果が 32 ビットに収まらない場合、演算は実行時に実行され、定数とは見なされません。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-271">If the result doesn't fit in 32 bits, the operation is executed at runtime and isn't considered a constant.</span></span> <span data-ttu-id="bbdbf-272">ネイティブ サイズの整数を使用すると、整数演算が広く使用されており、最速のパフォーマンスを実現する必要があるシナリオで、パフォーマンスを向上させることができます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-272">Native sized integers can increase performance in scenarios where integer math is used extensively and needs to have the fastest performance possible.</span></span> <span data-ttu-id="bbdbf-273">詳細については、[`nint` と `nuint` 型](../language-reference/builtin-types/nint-nuint.md)に関するページを参照してください</span><span class="sxs-lookup"><span data-stu-id="bbdbf-273">For more information, see [`nint` and `nuint` types](../language-reference/builtin-types/nint-nuint.md)</span></span>

<span data-ttu-id="bbdbf-274">関数ポインターでは、IL オペコード `ldftn` および `calli` にアクセスするための簡単な構文が提供されます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-274">Function pointers provide an easy syntax to access the IL opcodes `ldftn` and `calli`.</span></span> <span data-ttu-id="bbdbf-275">関数ポインターは、新しい `delegate*` 構文を使用して宣言できます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-275">You can declare function pointers using new `delegate*` syntax.</span></span> <span data-ttu-id="bbdbf-276">`delegate*` 型はポインター型です。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-276">A `delegate*` type is a pointer type.</span></span> <span data-ttu-id="bbdbf-277">`Invoke()` メソッドで `callvirt` が使用されるデリゲートとは異なり、`delegate*` 型の呼び出しでは `calli` が使用されます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-277">Invoking the `delegate*` type uses `calli`, in contrast to a delegate that uses `callvirt` on the `Invoke()` method.</span></span> <span data-ttu-id="bbdbf-278">構文的には、呼び出しは同じです。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-278">Syntactically, the invocations are identical.</span></span> <span data-ttu-id="bbdbf-279">関数ポインターの呼び出しでは、`managed` の呼び出し規約が使用されます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-279">Function pointer invocation uses the `managed` calling convention.</span></span> <span data-ttu-id="bbdbf-280">`unmanaged` の呼び出し規約が必要であることを宣言するには、`delegate*` 構文の後に `unmanaged` キーワードを追加します。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-280">You add the `unmanaged` keyword after the `delegate*` syntax to declare that you want the `unmanaged` calling convention.</span></span> <span data-ttu-id="bbdbf-281">その他の呼び出し規約は、`delegate*` 宣言の属性を使用して指定できます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-281">Other calling conventions can be specified using attributes on the `delegate*` declaration.</span></span> <span data-ttu-id="bbdbf-282">詳細については、「[アンセーフ コードとポインター型](../language-reference/unsafe-code.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-282">For more information, see [Unsafe code and pointer types](../language-reference/unsafe-code.md).</span></span>

<span data-ttu-id="bbdbf-283">最後に、<xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute?displayProperty=nameWithType> を追加することで、`localsinit` フラグを生成しないようコンパイラに指示することができます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-283">Finally, you can add the <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute?displayProperty=nameWithType> to instruct the compiler not to emit the `localsinit` flag.</span></span> <span data-ttu-id="bbdbf-284">このフラグは、すべてのローカル変数をゼロで初期化するように CLR に指示します。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-284">This flag instructs the CLR to zero-initialize all local variables.</span></span> <span data-ttu-id="bbdbf-285">1\.0 から、`localsinit` フラグが C# に対する既定の動作でした。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-285">The `localsinit` flag has been the default behavior for C# since 1.0.</span></span> <span data-ttu-id="bbdbf-286">しかし、一部のシナリオでは、ゼロによる初期化を追加すると、パフォーマンスに大きく影響する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-286">However, the extra zero-initialization may have measurable performance impact in some scenarios.</span></span> <span data-ttu-id="bbdbf-287">特に、`stackalloc` を使用する場合です。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-287">In particular, when you use `stackalloc`.</span></span> <span data-ttu-id="bbdbf-288">そのような場合は、<xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute> を追加できます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-288">In those cases, you can add the <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute>.</span></span> <span data-ttu-id="bbdbf-289">1 つのメソッドまたはプロパティに、または `class`、`struct`、`interface` に、さらにはモジュールに対してさえも、それを追加できます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-289">You may add it to a single method or property, or to a `class`, `struct`, `interface`, or even a module.</span></span> <span data-ttu-id="bbdbf-290">この属性は `abstract` メソッドに影響しません。実装用に生成されたコードに影響します。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-290">This attribute doesn't affect `abstract` methods; it affects the code generated for the implementation.</span></span> <span data-ttu-id="bbdbf-291">詳細については、「[`SkipLocalsInit` 属性](../language-reference/attributes/general.md#skiplocalsinit-attribute)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-291">For more information, see [`SkipLocalsInit` attribute](../language-reference/attributes/general.md#skiplocalsinit-attribute).</span></span>

<span data-ttu-id="bbdbf-292">これらの機能により、一部のシナリオでパフォーマンスを向上させることができます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-292">These features can improve performance in some scenarios.</span></span> <span data-ttu-id="bbdbf-293">導入前と導入後の両方で慎重にベンチマークを行った後でのみ、使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-293">They should be used only after careful benchmarking both before and after adoption.</span></span> <span data-ttu-id="bbdbf-294">ネイティブ サイズの整数に関するコードは、複数のターゲット プラットフォームで、異なる整数サイズを使用して、テストする必要があります。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-294">Code involving native sized integers must be tested on multiple target platforms with different integer sizes.</span></span> <span data-ttu-id="bbdbf-295">その他の機能には、アンセーフ コードが必要です。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-295">The other features require unsafe code.</span></span>

## <a name="fit-and-finish-features"></a><span data-ttu-id="bbdbf-296">適合性と完成度の機能</span><span class="sxs-lookup"><span data-stu-id="bbdbf-296">Fit and finish features</span></span>

<span data-ttu-id="bbdbf-297">他の多くの機能は、コードをより効率的に記述するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-297">Many of the other features help you write code more efficiently.</span></span> <span data-ttu-id="bbdbf-298">C# 9.0 では、作成されるオブジェクトの型が既にわかっている場合、[`new` 式](../language-reference/operators/new-operator.md)で型を省略できます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-298">In C# 9.0, you can omit the type in a [`new` expression](../language-reference/operators/new-operator.md) when the created object's type is already known.</span></span> <span data-ttu-id="bbdbf-299">最も一般的な使用方法は、フィールドの宣言です。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-299">The most common use is in field declarations:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="WeatherStationField":::

<span data-ttu-id="bbdbf-300">ターゲット型の `new` は、メソッドへの引数として渡す新しいオブジェクトを作成する必要がある場合にも使用できます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-300">Target-typed `new` can also be used when you need to create a new object to pass as an argument to a method.</span></span> <span data-ttu-id="bbdbf-301">次のようなシグネチャを持つ `ForecastFor()` メソッドについて考えます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-301">Consider a `ForecastFor()` method with the following signature:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="ForecastSignature":::

<span data-ttu-id="bbdbf-302">これを、次のように呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-302">You could call it as follows:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="TargetTypeNewArgument":::

<span data-ttu-id="bbdbf-303">この機能のもう 1 つの便利な用途は、init 専用プロパティと組み合わせて、新しいオブジェクトを初期化する場合です。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-303">Another nice use for this feature is to combine it with init only properties to initialize a new object:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="InitWeatherStation":::

<span data-ttu-id="bbdbf-304">`return new();` ステートメントを使用することで、既定のコンストラクターによって作成されたインスタンスを返すことができます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-304">You can return an instance created by the default constructor using a `return new();` statement.</span></span>

<span data-ttu-id="bbdbf-305">同様の機能により、[条件式](../language-reference/operators/conditional-operator.md)の対象となる型の解決が向上します。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-305">A similar feature improves the target type resolution of [conditional expressions](../language-reference/operators/conditional-operator.md).</span></span> <span data-ttu-id="bbdbf-306">この変更により、2 つの式の間で暗黙的な変換を行う必要はありませんが、どちらもターゲット型への暗黙的な変換を行うことができます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-306">With this change, the two expressions need not have an implicit conversion from one to the other, but may both have implicit conversions to a target type.</span></span> <span data-ttu-id="bbdbf-307">多くの場合、この変更に気付くことはありません。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-307">You likely won't notice this change.</span></span> <span data-ttu-id="bbdbf-308">気付くとすれば、以前はキャストを必要としたり、コンパイルされなかったりした一部の条件式が、機能するようになることです。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-308">What you will notice is that some conditional expressions that previously required casts or wouldn't compile now just work.</span></span>

<span data-ttu-id="bbdbf-309">C# 9.0 以降では、`static` 修飾子を[ラムダ式](../language-reference/operators/lambda-expressions.md)または[匿名メソッド](../language-reference/operators/delegate-operator.md)に追加できます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-309">Starting in C# 9.0, you can add the `static` modifier to [lambda expressions](../language-reference/operators/lambda-expressions.md) or [anonymous methods](../language-reference/operators/delegate-operator.md).</span></span> <span data-ttu-id="bbdbf-310">静的なラムダ式は、`static` ローカル関数に似ています。静的ラムダまたは匿名メソッドでは、ローカル変数またはインスタンスの状態をキャプチャできません。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-310">Static lambda expressions are analogous to the `static` local functions: a static lambda or anonymous method can't capture local variables or instance state.</span></span> <span data-ttu-id="bbdbf-311">`static` 修飾子により、誤って他の変数がキャプチャされることがなくなります。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-311">The `static` modifier prevents accidentally capturing other variables.</span></span>

<span data-ttu-id="bbdbf-312">共変の戻り値の型を使用すると、[override](../language-reference/keywords/override.md) メソッドの戻り値の型を柔軟に指定できます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-312">Covariant return types provide flexibility for the return types of [override](../language-reference/keywords/override.md) methods.</span></span> <span data-ttu-id="bbdbf-313">override メソッドは、オーバーライドされた基本メソッドの戻り値の型から派生した型を返すことができます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-313">An override method can return a type derived from the return type of the overridden base method.</span></span> <span data-ttu-id="bbdbf-314">これは、レコードや、仮想クローンまたはファクトリ メソッドをサポートするその他の型に役立ちます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-314">This can be useful for records and for other types that support virtual clone or factory methods.</span></span>

<span data-ttu-id="bbdbf-315">また、[`foreach` ループ](../language-reference/keywords/foreach-in.md)によって、それ以外の方法で `foreach` パターンを満たす拡張メソッド `GetEnumerator` が認識され、使用されます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-315">In addition, the [`foreach` loop](../language-reference/keywords/foreach-in.md) will recognize and use an extension method `GetEnumerator` that otherwise satisfies the `foreach` pattern.</span></span> <span data-ttu-id="bbdbf-316">この変更は、非同期パターンやパターンベースの分解など、他のパターンベースのコンストラクションと `foreach` の間に整合性があることを意味します。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-316">This change means `foreach` is consistent with other pattern-based constructions such as the async pattern, and pattern-based deconstruction.</span></span> <span data-ttu-id="bbdbf-317">実際、この変更は、あらゆる型に `foreach` サポートを追加できることを意味します。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-317">In practice, this change means you can add `foreach` support to any type.</span></span> <span data-ttu-id="bbdbf-318">それの使用は、設計においてオブジェクトの列挙に意味があるときのみに限定してください。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-318">You should limit its use to when enumerating an object makes sense in your design.</span></span>

<span data-ttu-id="bbdbf-319">次に、ラムダ式に対するパラメーターとして破棄を使用できます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-319">Next, you can use discards as parameters to lambda expressions.</span></span> <span data-ttu-id="bbdbf-320">このようにすると、引数の名前付けを避けることができ、コンパイラではその使用を避けることができます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-320">This convenience enables you to avoid naming the argument, and the compiler may avoid using it.</span></span> <span data-ttu-id="bbdbf-321">任意の引数に対して `_` を使用します。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-321">You use the `_` for any argument.</span></span> <span data-ttu-id="bbdbf-322">詳細については、[ラムダ式](../language-reference/operators/lambda-expressions.md)に関する記事の「[ラムダ式の入力パラメーター](../language-reference/operators/lambda-expressions.md#input-parameters-of-a-lambda-expression)」セクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-322">For more information, see the [Input parameters of a lambda expression](../language-reference/operators/lambda-expressions.md#input-parameters-of-a-lambda-expression) section of the [Lambda expressions](../language-reference/operators/lambda-expressions.md) article.</span></span>

<span data-ttu-id="bbdbf-323">ようやく、[ローカル関数](../programming-guide/classes-and-structs/local-functions.md)に属性を適用できるようになりました。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-323">Finally, you can now apply attributes to [local functions](../programming-guide/classes-and-structs/local-functions.md).</span></span> <span data-ttu-id="bbdbf-324">たとえば、[null 許容属性の注釈](../language-reference/attributes/nullable-analysis.md)をローカル関数に適用できます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-324">For example, you can apply [nullable attribute annotations](../language-reference/attributes/nullable-analysis.md) to local functions.</span></span>

## <a name="support-for-code-generators"></a><span data-ttu-id="bbdbf-325">コード ジェネレーターのサポート</span><span class="sxs-lookup"><span data-stu-id="bbdbf-325">Support for code generators</span></span>

<span data-ttu-id="bbdbf-326">2 つの最終機能では、C# コード ジェネレーターがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-326">Two final features support C# code generators.</span></span> <span data-ttu-id="bbdbf-327">C# コード ジェネレーターは、roslyn アナライザーまたはコード修正と同じように記述できるコンポーネントです。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-327">C# code generators are a component you can write that is similar to a roslyn analyzer or code fix.</span></span> <span data-ttu-id="bbdbf-328">違いは、コード ジェネレーターでは、コードが分析され、コンパイル プロセスの一環として新しいソース コード ファイルが記述されることです。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-328">The difference is that code generators analyze code and write new source code files as part of the compilation process.</span></span> <span data-ttu-id="bbdbf-329">一般的なコード ジェネレーターでは、属性またはその他の規則がコードで検索されます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-329">A typical code generator searches code for attributes or other conventions.</span></span>

<span data-ttu-id="bbdbf-330">コード ジェネレーターにより、Roslyn 分析 API を使用して属性または他のコード要素が読み取られます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-330">A code generator reads attributes or other code elements using the Roslyn analysis APIs.</span></span> <span data-ttu-id="bbdbf-331">その情報を基にして、コンパイルに新しいコードが追加されます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-331">From that information, it adds new code to the compilation.</span></span> <span data-ttu-id="bbdbf-332">ソース ジェネレーターではコードが追加されるだけで、コンパイル中の既存のコードの変更は許可されていません。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-332">Source generators can only add code; they aren't allowed to modify any existing code in the compilation.</span></span>

<span data-ttu-id="bbdbf-333">コード ジェネレーターに対して追加された 2 つの機能は、"***部分メソッド構文** _" の拡張機能と、"_*_モジュール初期化子_\*\*" です。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-333">The two features added for code generators are extensions to ***partial method syntax** _, and _*_module initializers_\*\*.</span></span> <span data-ttu-id="bbdbf-334">1 つ目は、部分メソッドに対する変更です。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-334">First, the changes to partial methods.</span></span> <span data-ttu-id="bbdbf-335">C# 9.0 より前の部分メソッドは `private` ですが、アクセス修飾子を指定することはできず、戻り値は `void` で、`out` パラメーターを持つことはできません。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-335">Before C# 9.0, partial methods are `private` but can't specify an access modifier, have a `void` return, and can't have `out` parameters.</span></span> <span data-ttu-id="bbdbf-336">これらの制限は、メソッドの実装を提供しないと、コンパイラによって部分メソッドのすべての呼び出しが削除されることを意味しました。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-336">These restrictions meant that if no method implementation is provided, the compiler removes all calls to the partial method.</span></span> <span data-ttu-id="bbdbf-337">C# 9.0 ではこれらの制限はなくなりましたが、部分メソッドの宣言には実装が必要です。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-337">C# 9.0 removes these restrictions, but requires that partial method declarations have an implementation.</span></span> <span data-ttu-id="bbdbf-338">コード ジェネレーターで、その実装を提供できます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-338">Code generators can provide that implementation.</span></span> <span data-ttu-id="bbdbf-339">破壊的変更が発生しないよう、コンパイラでは、アクセス修飾子を持たないすべての部分メソッドは、古い規則に従うものと見なされます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-339">To avoid introducing a breaking change, the compiler considers any partial method without an access modifier to follow the old rules.</span></span> <span data-ttu-id="bbdbf-340">部分メソッドに `private` アクセス修飾子が含まれている場合、その部分メソッドは新しい規則によって制御されます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-340">If the partial method includes the `private` access modifier, the new rules govern that partial method.</span></span> <span data-ttu-id="bbdbf-341">詳細については、「[partial メソッド (C# リファレンス)](../language-reference/keywords/partial-method.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-341">For more information, see [partial method (C# Reference)](../language-reference/keywords/partial-method.md).</span></span>

<span data-ttu-id="bbdbf-342">コード ジェネレーターの 2 つ目の新機能は、"***モジュール初期化子***" です。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-342">The second new feature for code generators is ***module initializers***.</span></span> <span data-ttu-id="bbdbf-343">モジュール初期化子は、<xref:System.Runtime.CompilerServices.ModuleInitializerAttribute> 属性が関連付けられているメソッドです。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-343">Module initializers are methods that have the <xref:System.Runtime.CompilerServices.ModuleInitializerAttribute> attribute attached to them.</span></span> <span data-ttu-id="bbdbf-344">これらのメソッドは、全体モジュール内の他のフィールド アクセスまたはメソッド呼び出しの前にランタイムによって呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-344">These methods will be called by the runtime before any other field access or method invocation within the entire module.</span></span> <span data-ttu-id="bbdbf-345">モジュール初期化子メソッドは次のようなものです。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-345">A module initializer method:</span></span>

- <span data-ttu-id="bbdbf-346">静的でなければなりません</span><span class="sxs-lookup"><span data-stu-id="bbdbf-346">Must be static</span></span>
- <span data-ttu-id="bbdbf-347">パラメーターなしである必要があります</span><span class="sxs-lookup"><span data-stu-id="bbdbf-347">Must be parameterless</span></span>
- <span data-ttu-id="bbdbf-348">void を返す必要があります</span><span class="sxs-lookup"><span data-stu-id="bbdbf-348">Must return void</span></span>
- <span data-ttu-id="bbdbf-349">ジェネリック メソッドであってはなりません</span><span class="sxs-lookup"><span data-stu-id="bbdbf-349">Must not be a generic method</span></span>
- <span data-ttu-id="bbdbf-350">ジェネリック クラスに含まれていてはなりません</span><span class="sxs-lookup"><span data-stu-id="bbdbf-350">Must not be contained in a generic class</span></span>
- <span data-ttu-id="bbdbf-351">それを含むモジュールからアクセスできる必要があります</span><span class="sxs-lookup"><span data-stu-id="bbdbf-351">Must be accessible from the containing module</span></span>

<span data-ttu-id="bbdbf-352">最後の項目は事実上、メソッドとそれを含んでいるクラスが internal または public である必要があることを意味します。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-352">That last bullet point effectively means the method and its containing class must be internal or public.</span></span> <span data-ttu-id="bbdbf-353">メソッドをローカル関数にすることはできません。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-353">The method can't be a local function.</span></span> <span data-ttu-id="bbdbf-354">詳細については、「[`ModuleInitializer` 属性](../language-reference/attributes/general.md#moduleinitializer-attribute)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="bbdbf-354">For more information, see [`ModuleInitializer` attribute](../language-reference/attributes/general.md#moduleinitializer-attribute).</span></span>
