---
title: プロパティの使用 - C# プログラミング ガイド
description: これらの例では、C# でのプロパティの使用を示します。 get アクセサーと set アクセサーによる読み取りおよび書き込みアクセスの実装方法について確認し、プロパティへの使用について説明します。
ms.date: 07/20/2015
helpviewer_keywords:
- set accessor [C#]
- get accessor [C#]
- properties [C#], about properties
ms.assetid: f7f67b05-0983-4cdb-96af-1855d24c967c
ms.openlocfilehash: 16ff0f02db9640ad8cfe41fce9ce954cb75b4e08
ms.sourcegitcommit: e3cf8227573e13b8e1f4e3dc007404881cdafe47
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2021
ms.locfileid: "103190334"
---
# <a name="using-properties-c-programming-guide"></a><span data-ttu-id="8fc9b-104">プロパティの使用 (C# プログラミング ガイド)</span><span class="sxs-lookup"><span data-stu-id="8fc9b-104">Using Properties (C# Programming Guide)</span></span>

<span data-ttu-id="8fc9b-105">プロパティは、フィールドとメソッドの両方の側面を結合します。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-105">Properties combine aspects of both fields and methods.</span></span> <span data-ttu-id="8fc9b-106">オブジェクトのユーザーにとってプロパティは、プロパティへのアクセスに同じ構文を必要とするフィールドのように見えます。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-106">To the user of an object, a property appears to be a field, accessing the property requires the same syntax.</span></span> <span data-ttu-id="8fc9b-107">クラスの実装者にとってプロパティは、[get](../../language-reference/keywords/get.md) アクセサーと [set](../../language-reference/keywords/set.md) アクセサーの両方またはいずれかを表す 1 つまたは 2 つのコード ブロックです。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-107">To the implementer of a class, a property is one or two code blocks, representing a [get](../../language-reference/keywords/get.md) accessor and/or a [set](../../language-reference/keywords/set.md) accessor.</span></span> <span data-ttu-id="8fc9b-108">`get` アクセサーのコード ブロックはプロパティが読み取られる時に実行され、`set` アクセサーのコード ブロックはプロパティに新しい値が割り当てられるときに実行されます。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-108">The code block for the `get` accessor is executed when the property is read; the code block for the `set` accessor is executed when the property is assigned a new value.</span></span> <span data-ttu-id="8fc9b-109">`set` アクセサーのないプロパティは読み取り専用と見なされます。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-109">A property without a `set` accessor is considered read-only.</span></span> <span data-ttu-id="8fc9b-110">`get` アクセサーのないプロパティは書き込み専用と見なされます。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-110">A property without a `get` accessor is considered write-only.</span></span> <span data-ttu-id="8fc9b-111">両方のアクセサーを持つプロパティは、読み取り/書き込みです。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-111">A property that has both accessors is read-write.</span></span> <span data-ttu-id="8fc9b-112">C# 9 以降では、`init` アクセサーを `set` アクセサーの代わりに使用し、プロパティを読み取り専用にできます。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-112">In C# 9 and later, you can use an `init` accessor instead of a `set` accessor to make the property read-only.</span></span>

<span data-ttu-id="8fc9b-113">フィールドとは異なり、プロパティは変数には分類されません。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-113">Unlike fields, properties are not classified as variables.</span></span> <span data-ttu-id="8fc9b-114">そのため、プロパティを [ref](../../language-reference/keywords/ref.md) または [out](../../language-reference/keywords/out-parameter-modifier.md) パラメーターとして渡すことはできません。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-114">Therefore, you cannot pass a property as a [ref](../../language-reference/keywords/ref.md) or [out](../../language-reference/keywords/out-parameter-modifier.md) parameter.</span></span>

<span data-ttu-id="8fc9b-115">プロパティには次のようなさまざまな用途があります。変更を許可する前にデータを検証したり、データをそのデータが実際に他のソース (データベースなど) から取得されるクラスで透過的に公開したり、イベントの発生や他のフィールドの値を変更するなど、データが変更されたときに、アクションを実行したりすることができます。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-115">Properties have many uses: they can validate data before allowing a change; they can transparently expose data on a class where that data is actually retrieved from some other source, such as a database; they can take an action when data is changed, such as raising an event, or changing the value of other fields.</span></span>

<span data-ttu-id="8fc9b-116">プロパティはクラス ブロックで宣言できます。フィールドのアクセス レベル、プロパティの型、プロパティの名前、`get` アクセサーと `set` アクセサーの両方またはいずれかを宣言するコード ブロックの順で指定します。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-116">Properties are declared in the class block by specifying the access level of the field, followed by the type of the property, followed by the name of the property, and followed by a code block that declares a `get`-accessor and/or a `set` accessor.</span></span> <span data-ttu-id="8fc9b-117">次に例を示します。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-117">For example:</span></span>

[!code-csharp[csProgGuideProperties#7](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideProperties/CS/Properties.cs#7)]

<span data-ttu-id="8fc9b-118">この例では、`set` アクセサーが `Month` が 1 から 12 までの値に設定されていることを確認できるように、`Month` がプロパティとして宣言されています。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-118">In this example, `Month` is declared as a property so that the `set` accessor can make sure that the `Month` value is set between 1 and 12.</span></span> <span data-ttu-id="8fc9b-119">`Month` プロパティは、プライベート フィールドを使用して実際の値を追跡します。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-119">The `Month` property uses a private field to track the actual value.</span></span> <span data-ttu-id="8fc9b-120">プロパティのデータの実際の場所は、プロパティの "バッキング ストア" と呼ばれることがよくあります。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-120">The real location of a property's data is often referred to as the property's "backing store."</span></span> <span data-ttu-id="8fc9b-121">プロパティがプライベート フィールドをバッキング ストアとして使用するのは一般的なことです。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-121">It is common for properties to use private fields as a backing store.</span></span> <span data-ttu-id="8fc9b-122">フィールドは、プロパティを呼び出すことでのみ変更できるようにするため、プライベートとマークされます。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-122">The field is marked private in order to make sure that it can only be changed by calling the property.</span></span> <span data-ttu-id="8fc9b-123">パブリックおよびプライベートのアクセス制限の詳細については、「[アクセス修飾子](./access-modifiers.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-123">For more information about public and private access restrictions, see [Access Modifiers](./access-modifiers.md).</span></span>

<span data-ttu-id="8fc9b-124">自動実装プロパティは、単純なプロパティ宣言の簡単な構文を提供します。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-124">Auto-implemented properties provide simplified syntax for simple property declarations.</span></span> <span data-ttu-id="8fc9b-125">詳細については、「[自動実装プロパティ](auto-implemented-properties.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-125">For more information, see [Auto-Implemented Properties](auto-implemented-properties.md).</span></span>

## <a name="the-get-accessor"></a><span data-ttu-id="8fc9b-126">get アクセサー</span><span class="sxs-lookup"><span data-stu-id="8fc9b-126">The get accessor</span></span>

<span data-ttu-id="8fc9b-127">`get` アクセサーの本体は、メソッドの本体と似ています。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-127">The body of the `get` accessor resembles that of a method.</span></span> <span data-ttu-id="8fc9b-128">プロパティの型の値を返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-128">It must return a value of the property type.</span></span> <span data-ttu-id="8fc9b-129">`get` アクセサーの実行は、フィールドの値を読み取ることに相当します。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-129">The execution of the `get` accessor is equivalent to reading the value of the field.</span></span> <span data-ttu-id="8fc9b-130">たとえば、`get` アクセサーからプライベート変数を返し、最適化が有効になっている場合、`get` アクセサー メソッドへの呼び出しはコンパイラによってインライン化されるため、メソッド呼び出しのオーバーヘッドはありません。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-130">For example, when you are returning the private variable from the `get` accessor and optimizations are enabled, the call to the `get` accessor method is inlined by the compiler so there is no method-call overhead.</span></span> <span data-ttu-id="8fc9b-131">ただし、仮想 `get` アクセサー メソッドはインライン化できません。これは、コンパイラがコンパイル時にどのメソッドが実際に実行時に呼び出されるかを認識しないからです。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-131">However, a virtual `get` accessor method cannot be inlined because the compiler does not know at compile-time which method may actually be called at run time.</span></span> <span data-ttu-id="8fc9b-132">次に、プライベート フィールド `_name` の値を返す `get` アクセサーを示します。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-132">The following is a `get` accessor that returns the value of a private field `_name`:</span></span>

[!code-csharp[csProgGuideProperties#8](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideProperties/CS/Properties.cs#8)]

<span data-ttu-id="8fc9b-133">プロパティを参照するとき、割り当ての対象を除き、`get` アクセサーがプロパティの値を読み取るために呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-133">When you reference the property, except as the target of an assignment, the `get` accessor is invoked to read the value of the property.</span></span> <span data-ttu-id="8fc9b-134">次に例を示します。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-134">For example:</span></span>

[!code-csharp[csProgGuideProperties#9](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideProperties/CS/Properties.cs#9)]

<span data-ttu-id="8fc9b-135">`get` アクセサーは [return](../../language-reference/keywords/return.md) または [throw](../../language-reference/keywords/throw.md) ステートメントで終わる必要があります。コントロールはアクセサー本体をフロー オフすることはできません。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-135">The `get` accessor must end in a [return](../../language-reference/keywords/return.md) or [throw](../../language-reference/keywords/throw.md) statement, and control cannot flow off the accessor body.</span></span>

<span data-ttu-id="8fc9b-136">`get` アクセサーを使用してオブジェクトの状態を変更するのは、悪いプログラミング スタイルです。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-136">It is a bad programming style to change the state of the object by using the `get` accessor.</span></span> <span data-ttu-id="8fc9b-137">たとえば、次のアクセサーでは、`_number` フィールドにアクセスされるたびにオブジェクトの状態が変更される副作用が発生します。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-137">For example, the following accessor produces the side effect of changing the state of the object every time that the `_number` field is accessed.</span></span>

[!code-csharp[csProgGuideProperties#10](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideProperties/CS/Properties.cs#10)]

<span data-ttu-id="8fc9b-138">`get` アクセサーは、フィールド値を返すまたは計算してから返すために使用できます。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-138">The `get` accessor can be used to return the field value or to compute it and return it.</span></span> <span data-ttu-id="8fc9b-139">次に例を示します。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-139">For example:</span></span>

[!code-csharp[csProgGuideProperties#11](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideProperties/CS/Properties.cs#11)]

<span data-ttu-id="8fc9b-140">前のコード セグメントで `Name` プロパティに値を割り当てない場合、値 `NA` が返されます。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-140">In the previous code segment, if you do not assign a value to the `Name` property, it will return the value `NA`.</span></span>

## <a name="the-set-accessor"></a><span data-ttu-id="8fc9b-141">set アクセサー</span><span class="sxs-lookup"><span data-stu-id="8fc9b-141">The set accessor</span></span>

<span data-ttu-id="8fc9b-142">`set` アクセサーは、戻り値の型が [void](../../language-reference/builtin-types/void.md) のメソッドと似ています。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-142">The `set` accessor resembles a method whose return type is [void](../../language-reference/builtin-types/void.md).</span></span> <span data-ttu-id="8fc9b-143">型がプロパティの型の `value` と呼ばれる暗黙のパラメーターを使用します。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-143">It uses an implicit parameter called `value`, whose type is the type of the property.</span></span> <span data-ttu-id="8fc9b-144">次の例では、`set` アクセサーが `Name` プロパティに追加されます。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-144">In the following example, a `set` accessor is added to the `Name` property:</span></span>

[!code-csharp[csProgGuideProperties#12](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideProperties/CS/Properties.cs#12)]

<span data-ttu-id="8fc9b-145">プロパティに値を割り当てるときに、新しい値を提供する引数を使用して `set` アクセサーが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-145">When you assign a value to the property, the `set` accessor is invoked by using an argument that provides the new value.</span></span> <span data-ttu-id="8fc9b-146">次に例を示します。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-146">For example:</span></span>

[!code-csharp[csProgGuideProperties#13](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideProperties/CS/Properties.cs#13)]

<span data-ttu-id="8fc9b-147">`set` アクセサーでローカル変数の宣言に暗黙のパラメーター名 `value` を使用すると、エラーになります。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-147">It is an error to use the implicit parameter name, `value`, for a local variable declaration in a `set` accessor.</span></span>

## <a name="the-init-accessor"></a><span data-ttu-id="8fc9b-148">init アクセサー</span><span class="sxs-lookup"><span data-stu-id="8fc9b-148">The init accessor</span></span>

<span data-ttu-id="8fc9b-149">`init` アクセサーを作成するコードは、`set` の代わりに `init` キーワードを使用するという点を除き、`set` アクセサーを作成するコードと同じです。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-149">The code to create an `init` accessor is the same as the code to create a `set` accessor except that you use the `init` keyword instead of `set`.</span></span> <span data-ttu-id="8fc9b-150">`init` アクセサーはコンストラクター内で使用するか、[オブジェクト初期化子](object-and-collection-initializers.md)で使用するしかないというところが違います。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-150">The difference is that the `init` accessor can only be used in the constructor or by using an [object-initializer](object-and-collection-initializers.md).</span></span>

## <a name="remarks"></a><span data-ttu-id="8fc9b-151">解説</span><span class="sxs-lookup"><span data-stu-id="8fc9b-151">Remarks</span></span>

<span data-ttu-id="8fc9b-152">プロパティは `public`、`private`、`protected`、`internal`、`protected internal`、`private protected` のいずれかでマークできます。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-152">Properties can be marked as `public`, `private`, `protected`, `internal`, `protected internal`, or `private protected`.</span></span> <span data-ttu-id="8fc9b-153">これらのアクセス修飾子により、クラスのユーザーがプロパティにアクセスできる方法が定義されます。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-153">These access modifiers define how users of the class can access the property.</span></span> <span data-ttu-id="8fc9b-154">同じプロパティの `get` と `set` アクセサーは、異なるアクセス修飾子を持つことができます。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-154">The `get` and `set` accessors for the same property may have different access modifiers.</span></span> <span data-ttu-id="8fc9b-155">たとえば、`get` を `public` にして、型の外部からの読み取り専用アクセスを許可して、`set` を `private` または `protected` にすることができます。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-155">For example, the `get` may be `public` to allow read-only access from outside the type, and the `set` may be `private` or `protected`.</span></span> <span data-ttu-id="8fc9b-156">詳細については、「[アクセス修飾子](./access-modifiers.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-156">For more information, see [Access Modifiers](./access-modifiers.md).</span></span>

<span data-ttu-id="8fc9b-157">`static` キーワードを使用して、プロパティを静的プロパティとして宣言できます。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-157">A property may be declared as a static property by using the `static` keyword.</span></span> <span data-ttu-id="8fc9b-158">その場合、クラスのインスタンスが存在しなくても、呼び出し元がいつでもプロパティを使用できるようになります。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-158">This makes the property available to callers at any time, even if no instance of the class exists.</span></span> <span data-ttu-id="8fc9b-159">詳細については、「[静的クラスと静的クラス メンバー](./static-classes-and-static-class-members.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-159">For more information, see [Static Classes and Static Class Members](./static-classes-and-static-class-members.md).</span></span>

<span data-ttu-id="8fc9b-160">プロパティは、[virtual](../../language-reference/keywords/virtual.md) キーワードを使用して仮想プロパティとしてマークできます。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-160">A property may be marked as a virtual property by using the [virtual](../../language-reference/keywords/virtual.md) keyword.</span></span> <span data-ttu-id="8fc9b-161">その場合、派生クラスでは、[override](../../language-reference/keywords/override.md) キーワードを使用してプロパティの動作をオーバーライドできます。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-161">This enables derived classes to override the property behavior by using the [override](../../language-reference/keywords/override.md) keyword.</span></span> <span data-ttu-id="8fc9b-162">これらのオプションの詳細については、「[継承](inheritance.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-162">For more information about these options, see [Inheritance](inheritance.md).</span></span>

<span data-ttu-id="8fc9b-163">仮想プロパティをオーバーライドするプロパティは、[sealed](../../language-reference/keywords/sealed.md) にすることもできます。その場合、派生クラスでは、プロパティが仮想でなくなります。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-163">A property overriding a virtual property can also be [sealed](../../language-reference/keywords/sealed.md), specifying that for derived classes it is no longer virtual.</span></span> <span data-ttu-id="8fc9b-164">最後に、プロパティは[抽象](../../language-reference/keywords/abstract.md)として宣言できます。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-164">Lastly, a property can be declared [abstract](../../language-reference/keywords/abstract.md).</span></span> <span data-ttu-id="8fc9b-165">つまり、クラスに実装はなく、派生クラスが独自の実装を記述する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-165">This means that there is no implementation in the class, and derived classes must write their own implementation.</span></span> <span data-ttu-id="8fc9b-166">これらのオプションの詳細については、「[抽象クラスとシール クラス、およびクラス メンバー](abstract-and-sealed-classes-and-class-members.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-166">For more information about these options, see [Abstract and Sealed Classes and Class Members](abstract-and-sealed-classes-and-class-members.md).</span></span>
  
> [!NOTE]
> <span data-ttu-id="8fc9b-167">[静的](../../language-reference/keywords/static.md)プロパティのアクセサーで[virtual](../../language-reference/keywords/virtual.md)、[abstract](../../language-reference/keywords/abstract.md)、または [override](../../language-reference/keywords/override.md) 修飾子を使用すると、エラーになります。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-167">It is an error to use a [virtual](../../language-reference/keywords/virtual.md), [abstract](../../language-reference/keywords/abstract.md), or [override](../../language-reference/keywords/override.md) modifier on an accessor of a [static](../../language-reference/keywords/static.md) property.</span></span>

## <a name="examples"></a><span data-ttu-id="8fc9b-168">例</span><span class="sxs-lookup"><span data-stu-id="8fc9b-168">Examples</span></span>

<span data-ttu-id="8fc9b-169">この例では、インスタンス、静的、および読み取り専用のプロパティを示します。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-169">This example demonstrates instance, static, and read-only properties.</span></span> <span data-ttu-id="8fc9b-170">キーボードから従業員の名前を受け取り、`NumberOfEmployees` を 1 だけインクリメントし、従業員の名前と番号を表示します。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-170">It accepts the name of the employee from the keyboard, increments `NumberOfEmployees` by 1, and displays the Employee name and number.</span></span>

[!code-csharp[csProgGuideProperties#2](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideProperties/CS/Properties.cs#2)]

## <a name="hidden-property-example"></a><span data-ttu-id="8fc9b-171">プロパティ非表示の例</span><span class="sxs-lookup"><span data-stu-id="8fc9b-171">Hidden property example</span></span>

<span data-ttu-id="8fc9b-172">この例では、派生クラスで同じ名前を持つ別のプロパティによって非表示にされている基底クラスのプロパティにアクセスする方法を示します。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-172">This example demonstrates how to access a property in a base class that is hidden by another property that has the same name in a derived class:</span></span>

[!code-csharp[csProgGuideProperties#3](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideProperties/CS/Properties.cs#3)]

<span data-ttu-id="8fc9b-173">前の例で重要な点を次に示します。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-173">The following are important points in the previous example:</span></span>

- <span data-ttu-id="8fc9b-174">派生クラスのプロパティ `Name` により基底クラス内のプロパティ `Name` が非表示になっています。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-174">The property `Name` in the derived class hides the property `Name` in the base class.</span></span> <span data-ttu-id="8fc9b-175">このような場合、`new` 修飾子は派生クラスのプロパティの宣言で使用されます。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-175">In such a case, the `new` modifier is used in the declaration of the property in the derived class:</span></span>

     [!code-csharp[csProgGuideProperties#4](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideProperties/CS/Properties.cs#4)]  

- <span data-ttu-id="8fc9b-176">キャスト `(Employee)` は基底クラスで非表示のプロパティにアクセスするために使用されます。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-176">The cast `(Employee)` is used to access the hidden property in the base class:</span></span>

     [!code-csharp[csProgGuideProperties#5](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideProperties/CS/Properties.cs#5)]

     <span data-ttu-id="8fc9b-177">メンバーを非表示にする詳細については、「[new 修飾子](../../language-reference/keywords/new-modifier.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-177">For more information about hiding members, see the [new Modifier](../../language-reference/keywords/new-modifier.md).</span></span>

## <a name="override-property-example"></a><span data-ttu-id="8fc9b-178">プロパティ オーバーライドの例</span><span class="sxs-lookup"><span data-stu-id="8fc9b-178">Override property example</span></span>

<span data-ttu-id="8fc9b-179">この例では、`Cube` と `Square` の 2 つのクラスが抽象クラス `Shape` を実装し、その抽象 `Area` プロパティをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-179">In this example, two classes, `Cube` and `Square`, implement an abstract class, `Shape`, and override its abstract `Area` property.</span></span> <span data-ttu-id="8fc9b-180">プロパティでの [override](../../language-reference/keywords/override.md) 修飾子の使用に注意してください。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-180">Note the use of the [override](../../language-reference/keywords/override.md) modifier on the properties.</span></span> <span data-ttu-id="8fc9b-181">プログラムは、入力として辺を受け入れ、四角形と立方体の面積を計算します。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-181">The program accepts the side as an input and calculates the areas for the square and cube.</span></span> <span data-ttu-id="8fc9b-182">プログラムはまた、入力として面積を受け入れ、四角形と立方体の対応する辺を計算します。</span><span class="sxs-lookup"><span data-stu-id="8fc9b-182">It also accepts the area as an input and calculates the corresponding side for the square and cube.</span></span>

[!code-csharp[csProgGuideProperties#6](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideProperties/CS/Properties.cs#6)]

## <a name="see-also"></a><span data-ttu-id="8fc9b-183">関連項目</span><span class="sxs-lookup"><span data-stu-id="8fc9b-183">See also</span></span>

- [<span data-ttu-id="8fc9b-184">C# プログラミング ガイド</span><span class="sxs-lookup"><span data-stu-id="8fc9b-184">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="8fc9b-185">プロパティ</span><span class="sxs-lookup"><span data-stu-id="8fc9b-185">Properties</span></span>](properties.md)
- [<span data-ttu-id="8fc9b-186">インターフェイスのプロパティ</span><span class="sxs-lookup"><span data-stu-id="8fc9b-186">Interface Properties</span></span>](interface-properties.md)
- [<span data-ttu-id="8fc9b-187">自動実装プロパティ</span><span class="sxs-lookup"><span data-stu-id="8fc9b-187">Auto-Implemented Properties</span></span>](auto-implemented-properties.md)
