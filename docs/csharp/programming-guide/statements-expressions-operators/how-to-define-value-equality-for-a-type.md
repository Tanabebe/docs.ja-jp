---
title: クラスまたは構造体の値の等価性を定義する方法 - C# プログラミング ガイド
description: クラスまたは構造体の値の等価性を定義する方法について説明します。 コード例を参照し、使用可能なリソースをご確認ください。
ms.date: 03/26/2021
helpviewer_keywords:
- overriding Equals method [C#]
- object equivalence [C#]
- Equals method [C#], overriding
- value equality [C#]
- equivalence [C#]
ms.assetid: 4084581e-b931-498b-9534-cf7ef5b68690
ms.openlocfilehash: fd8e1e14650a836178534b44dc332215c0d0586a
ms.sourcegitcommit: 109507b6c16704ed041efe9598c70cd3438a9fbc
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/31/2021
ms.locfileid: "106079454"
---
# <a name="how-to-define-value-equality-for-a-class-or-struct-c-programming-guide"></a><span data-ttu-id="91d39-104">クラスまたは構造体の値の等価性を定義する方法 (C# プログラミング ガイド)</span><span class="sxs-lookup"><span data-stu-id="91d39-104">How to define value equality for a class or struct (C# Programming Guide)</span></span>

<span data-ttu-id="91d39-105">[レコード](../classes-and-structs/records.md)を使用すると、値の等価性が自動的に実装されます。</span><span class="sxs-lookup"><span data-stu-id="91d39-105">[Records](../classes-and-structs/records.md) automatically implement value equality.</span></span> <span data-ttu-id="91d39-106">ご利用の型によって、データをモデル化する場合や値の同等性を実装する必要がある場合は、`class` ではなく `record` を定義することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="91d39-106">Consider defining a `record` instead of a `class` when your type models data and should implement value equality.</span></span>

<span data-ttu-id="91d39-107">クラスまたは構造体を定義する場合は、型に値の等価性 (同値) のカスタム定義を作成することが有用かどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="91d39-107">When you define a class or struct, you decide whether it makes sense to create a custom definition of value equality (or equivalence) for the type.</span></span> <span data-ttu-id="91d39-108">通常、値の等価性を実装するのは、その型のオブジェクトをコレクションに追加する予定である場合、またはそれらの主な目的が一連のフィールドまたはプロパティを格納することである場合です。</span><span class="sxs-lookup"><span data-stu-id="91d39-108">Typically, you implement value equality when you expect to add objects of the type to a collection, or when their primary purpose is to store a set of fields or properties.</span></span> <span data-ttu-id="91d39-109">値の等価性は、型のすべてのフィールドおよびプロパティの比較に基づいて定義できます。また、サブセットに基づいて定義することもできます。</span><span class="sxs-lookup"><span data-stu-id="91d39-109">You can base your definition of value equality on a comparison of all the fields and properties in the type, or you can base the definition on a subset.</span></span>

<span data-ttu-id="91d39-110">いずれの場合も、クラスおよび構造体の両方について、等価性を保証する 5 つの条件に従って実装する必要があります (次のルールの場合、`x`、`y`、`z` が null ではないと想定しています)。</span><span class="sxs-lookup"><span data-stu-id="91d39-110">In either case, and in both classes and structs, your implementation should follow the five guarantees of equivalence (for the following rules, assume that `x`, `y` and `z` are not null):</span></span>  
  
1. <span data-ttu-id="91d39-111">再帰プロパティ: `x.Equals(x)` から `true` が返されます。</span><span class="sxs-lookup"><span data-stu-id="91d39-111">The reflexive property: `x.Equals(x)` returns `true`.</span></span>
  
2. <span data-ttu-id="91d39-112">対称プロパティ: `x.Equals(y)` から、`y.Equals(x)` と同じ値が返されます。</span><span class="sxs-lookup"><span data-stu-id="91d39-112">The symmetric property: `x.Equals(y)` returns the same value as `y.Equals(x)`.</span></span>
  
3. <span data-ttu-id="91d39-113">推移性プロパティ: `(x.Equals(y) && y.Equals(z))` から `true` が返される場合は、`x.Equals(z)` からは `true` が返されます。</span><span class="sxs-lookup"><span data-stu-id="91d39-113">The transitive property: if `(x.Equals(y) && y.Equals(z))` returns `true`, then `x.Equals(z)` returns `true`.</span></span>
  
4. <span data-ttu-id="91d39-114">`x.Equals(y)` が連続して呼び出された場合は、x と y によって参照されるオブジェクトが変更されていない限り、同じ値を返します。</span><span class="sxs-lookup"><span data-stu-id="91d39-114">Successive invocations of `x.Equals(y)` return the same value as long as the objects referenced by x and y aren't modified.</span></span>  
  
5. <span data-ttu-id="91d39-115">非 null 値は null と等しくありません。</span><span class="sxs-lookup"><span data-stu-id="91d39-115">Any non-null value isn't equal to null.</span></span> <span data-ttu-id="91d39-116">そのため、`x` が null である場合は、`x.Equals(y)` から例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="91d39-116">However, `x.Equals(y)` throws an exception when `x` is null.</span></span> <span data-ttu-id="91d39-117">それにより、`Equals` の引数に基づき、ルール 1 または 2 が破られます。</span><span class="sxs-lookup"><span data-stu-id="91d39-117">That breaks rules 1 or 2, depending on the argument to `Equals`.</span></span>

<span data-ttu-id="91d39-118">構造体を定義すると、<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> メソッドの <xref:System.ValueType?displayProperty=nameWithType> オーバーライドから継承された値の等価性が既定で実装されます。</span><span class="sxs-lookup"><span data-stu-id="91d39-118">Any struct that you define already has a default implementation of value equality that it inherits from the <xref:System.ValueType?displayProperty=nameWithType> override of the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="91d39-119">この実装では、リフレクションを使用して、型のフィールドとプロパティをすべて調べます。</span><span class="sxs-lookup"><span data-stu-id="91d39-119">This implementation uses reflection to examine all the fields and properties in the type.</span></span> <span data-ttu-id="91d39-120">この実装によって正しい結果が生成されますが、その型専用に記述したカスタム実装と比較すると、処理にかなり時間がかかります。</span><span class="sxs-lookup"><span data-stu-id="91d39-120">Although this implementation produces correct results, it is relatively slow compared to a custom implementation that you write specifically for the type.</span></span>  
  
<span data-ttu-id="91d39-121">値の等価性に関する実装の詳細は、クラスと構造体で異なりますが、</span><span class="sxs-lookup"><span data-stu-id="91d39-121">The implementation details for value equality are different for classes and structs.</span></span> <span data-ttu-id="91d39-122">等価性を実装するための基本的な手順については、両方とも同じです。</span><span class="sxs-lookup"><span data-stu-id="91d39-122">However, both classes and structs require the same basic steps for implementing equality:</span></span>  
  
1. <span data-ttu-id="91d39-123">[仮想](../../language-reference/keywords/virtual.md) <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> メソッドをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="91d39-123">Override the [virtual](../../language-reference/keywords/virtual.md) <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="91d39-124">ほとんどの場合、`bool Equals( object obj )` の実装には、<xref:System.IEquatable%601?displayProperty=nameWithType> インターフェイスの実装である型固有の `Equals` メソッドを呼び出すだけで済みます</span><span class="sxs-lookup"><span data-stu-id="91d39-124">In most cases, your implementation of `bool Equals( object obj )` should just call into the type-specific `Equals` method that is the implementation of the <xref:System.IEquatable%601?displayProperty=nameWithType> interface.</span></span> <span data-ttu-id="91d39-125">(手順 2 を参照)。</span><span class="sxs-lookup"><span data-stu-id="91d39-125">(See step 2.)</span></span>  
  
2. <span data-ttu-id="91d39-126">型固有の `Equals` メソッドを指定して、<xref:System.IEquatable%601?displayProperty=nameWithType> インターフェイスを実装します。</span><span class="sxs-lookup"><span data-stu-id="91d39-126">Implement the <xref:System.IEquatable%601?displayProperty=nameWithType> interface by providing a type-specific `Equals` method.</span></span> <span data-ttu-id="91d39-127">ここで実際の等価性の比較を実行します。</span><span class="sxs-lookup"><span data-stu-id="91d39-127">This is where the actual equivalence comparison is performed.</span></span> <span data-ttu-id="91d39-128">たとえば、型のフィールドを 1 ～ 2 個だけ比較することで等価性を定義できます。</span><span class="sxs-lookup"><span data-stu-id="91d39-128">For example, you might decide to define equality by comparing only one or two fields in your type.</span></span> <span data-ttu-id="91d39-129">`Equals` から例外をスローしないでください。</span><span class="sxs-lookup"><span data-stu-id="91d39-129">Don't throw exceptions from `Equals`.</span></span> <span data-ttu-id="91d39-130">継承によって関連付けられているクラスの場合:</span><span class="sxs-lookup"><span data-stu-id="91d39-130">For classes that are related by inheritance:</span></span>

   * <span data-ttu-id="91d39-131">このメソッドはクラスで宣言されているフィールドのみを調べます。</span><span class="sxs-lookup"><span data-stu-id="91d39-131">This method should examine only fields that are declared in the class.</span></span> <span data-ttu-id="91d39-132">基底クラスに含まれるフィールドを調べるには、`base.Equals` を呼び出す必要があります</span><span class="sxs-lookup"><span data-stu-id="91d39-132">It should call `base.Equals` to examine fields that are in the base class.</span></span> <span data-ttu-id="91d39-133">(型が <xref:System.Object> から直接継承されている場合は、`base.Equals` を呼び出さないでください。<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> の <xref:System.Object> 実装によって、参照の等価性チェックが実行されるためです)。</span><span class="sxs-lookup"><span data-stu-id="91d39-133">(Don't call `base.Equals` if the type inherits directly from <xref:System.Object>, because the <xref:System.Object> implementation of <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> performs a reference equality check.)</span></span>

   * <span data-ttu-id="91d39-134">比較対象の変数の実行時の型が同じである場合にのみ、2 つの変数は等しいと見なされます。</span><span class="sxs-lookup"><span data-stu-id="91d39-134">Two variables should be deemed equal only if the run-time types of the variables being compared are the same.</span></span> <span data-ttu-id="91d39-135">また、変数の実行時とコンパイル時の型が異なる場合は、実行時の型の `Equals` メソッドの `IEquatable` 実装を必ず使用してください。</span><span class="sxs-lookup"><span data-stu-id="91d39-135">Also, make sure that the `IEquatable` implementation of the `Equals` method for the run-time type is used if the run-time and compile-time types of a variable are different.</span></span> <span data-ttu-id="91d39-136">実行時の型が常に正しく比較されるようにするための方法の 1 つは、`sealed` クラスにのみ `IEquatable` を実装することです。</span><span class="sxs-lookup"><span data-stu-id="91d39-136">One strategy for making sure run-time types are always compared correctly is to implement `IEquatable` only in `sealed` classes.</span></span> <span data-ttu-id="91d39-137">詳細については、この記事で後述する「[クラスの例](#class-example)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="91d39-137">For more information, see the [class example](#class-example) later in this article.</span></span>
  
3. <span data-ttu-id="91d39-138">推奨、ただし省略可能: [==](../../language-reference/operators/equality-operators.md#equality-operator-) および [!=](../../language-reference/operators/equality-operators.md#inequality-operator-) 演算子をオーバーロードします。</span><span class="sxs-lookup"><span data-stu-id="91d39-138">Optional but recommended: Overload the [==](../../language-reference/operators/equality-operators.md#equality-operator-) and [!=](../../language-reference/operators/equality-operators.md#inequality-operator-) operators.</span></span>  
  
4. <span data-ttu-id="91d39-139">値の等価性を持つ 2 つのオブジェクトによって同じハッシュ コードが生成されるように、<xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> をオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="91d39-139">Override <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> so that two objects that have value equality produce the same hash code.</span></span>  
  
5. <span data-ttu-id="91d39-140">省略可能:"大なり" または "小なり" の定義をサポートするには、型に対して <xref:System.IComparable%601> インターフェイスを実装したうえで、[<=](../../language-reference/operators/comparison-operators.md#less-than-or-equal-operator-) および [>=](../../language-reference/operators/comparison-operators.md#greater-than-or-equal-operator-) 演算子をオーバーロードします。</span><span class="sxs-lookup"><span data-stu-id="91d39-140">Optional: To support definitions for "greater than" or "less than," implement the <xref:System.IComparable%601> interface for your type, and also overload the [<=](../../language-reference/operators/comparison-operators.md#less-than-or-equal-operator-) and [>=](../../language-reference/operators/comparison-operators.md#greater-than-or-equal-operator-) operators.</span></span>  

> [!NOTE]
> <span data-ttu-id="91d39-141">C# 9.0 以降、レコードを利用し、不要な定型コードなしで値の等価性セマンティクスを取得できます。</span><span class="sxs-lookup"><span data-stu-id="91d39-141">Starting in C# 9.0, you can use records to get value equality semantics without any unnecessary boilerplate code.</span></span>

## <a name="class-example"></a><span data-ttu-id="91d39-142">クラスの例</span><span class="sxs-lookup"><span data-stu-id="91d39-142">Class example</span></span>

<span data-ttu-id="91d39-143">次の例は、クラス (参照型) で値の等価性を実装する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="91d39-143">The following example shows how to implement value equality in a class (reference type).</span></span>

:::code language="csharp" source="snippets/how-to-define-value-equality-for-a-type/ValueEqualityClass/Program.cs":::

<span data-ttu-id="91d39-144">クラス (参照型) の場合、両方の <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> メソッドの既定の実装で、参照の等価性の比較は実行されますが、値の等価性のチェックは実行されません。</span><span class="sxs-lookup"><span data-stu-id="91d39-144">On classes (reference types), the default implementation of both <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> methods performs a reference equality comparison, not a value equality check.</span></span> <span data-ttu-id="91d39-145">実装が仮想メソッドをオーバーライドする場合、その目的は、仮想メソッドに値の等価性のセマンティクスを提供することです。</span><span class="sxs-lookup"><span data-stu-id="91d39-145">When an implementer overrides the virtual method, the purpose is to give it value equality semantics.</span></span>

<span data-ttu-id="91d39-146">`==` 演算子と `!=` 演算子は、オーバーロードされなくてもクラスで使用できます。</span><span class="sxs-lookup"><span data-stu-id="91d39-146">The `==` and `!=` operators can be used with classes even if the class does not overload them.</span></span> <span data-ttu-id="91d39-147">ただし、既定の動作として参照の等価性のチェックが実行されます。</span><span class="sxs-lookup"><span data-stu-id="91d39-147">However, the default behavior is to perform a reference equality check.</span></span> <span data-ttu-id="91d39-148">クラスで `Equals` メソッドをオーバーロードする場合は、`==` 演算子と `!=` 演算子をオーバーロードすることをお勧めしますが、必須ではありません。</span><span class="sxs-lookup"><span data-stu-id="91d39-148">In a class, if you overload the `Equals` method, you should overload the `==` and `!=` operators, but it is not required.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="91d39-149">前のコード例では、すべての継承シナリオが期待どおりに処理されるとは限りません。</span><span class="sxs-lookup"><span data-stu-id="91d39-149">The preceding example code may not handle every inheritance scenario the way you expect.</span></span> <span data-ttu-id="91d39-150">次のコードがあるとします。</span><span class="sxs-lookup"><span data-stu-id="91d39-150">Consider the following code:</span></span>
>
> ```csharp
> TwoDPoint p1 = new ThreeDPoint(1, 2, 3);
> TwoDPoint p2 = new ThreeDPoint(1, 2, 4);
> Console.WriteLine(p1.Equals(p2)); // output: True
> ```
>
> <span data-ttu-id="91d39-151">このコードを実行すると、`z` の値が異なるにもかかわらず、`p1` は `p2` に等しいと報告されます。</span><span class="sxs-lookup"><span data-stu-id="91d39-151">This code reports that `p1` equals `p2` despite the difference in `z` values.</span></span> <span data-ttu-id="91d39-152">この違いが無視される理由は、コンパイルではコンパイル時の型に基づいて `IEquatable` の `TwoDPoint` 実装のみが選択されることにあります。</span><span class="sxs-lookup"><span data-stu-id="91d39-152">The difference is ignored because the compiler picks the `TwoDPoint` implementation of `IEquatable` based on the compile-time type.</span></span>
>
> <span data-ttu-id="91d39-153">`record` 型の組み込み値が等価である場合、このようなシナリオは正しく処理されます。</span><span class="sxs-lookup"><span data-stu-id="91d39-153">The built-in value equality of `record` types handles scenarios like this correctly.</span></span> <span data-ttu-id="91d39-154">`TwoDPoint` と `ThreeDPoint` の型が `record` であるならば、`p1.Equals(p2)` の結果は `False` になります。</span><span class="sxs-lookup"><span data-stu-id="91d39-154">If `TwoDPoint` and `ThreeDPoint` were `record` types, the result of `p1.Equals(p2)` would be `False`.</span></span> <span data-ttu-id="91d39-155">詳細については、[`record` 型の継承階層の等価性](../../language-reference/builtin-types/record.md#equality-in-inheritance-hierarchies)に関するページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="91d39-155">For more information, see [Equality in `record` type inheritance hierarchies](../../language-reference/builtin-types/record.md#equality-in-inheritance-hierarchies).</span></span>

## <a name="struct-example"></a><span data-ttu-id="91d39-156">構造体の例</span><span class="sxs-lookup"><span data-stu-id="91d39-156">Struct example</span></span>

<span data-ttu-id="91d39-157">次の例は、構造体 (値型) で値の等価性を実装する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="91d39-157">The following example shows how to implement value equality in a struct (value type):</span></span>

:::code language="csharp" source="snippets/how-to-define-value-equality-for-a-type/ValueEqualityStruct/Program.cs":::
  
<span data-ttu-id="91d39-158">構造体の場合、<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> (<xref:System.ValueType?displayProperty=nameWithType> でオーバーライドされるバージョン) の既定の実装で、リフレクションを使用して値の等価性のチェックが実行され、型のすべてのフィールドの値が比較されます。</span><span class="sxs-lookup"><span data-stu-id="91d39-158">For structs, the default implementation of <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> (which is the overridden version in <xref:System.ValueType?displayProperty=nameWithType>) performs a value equality check by using reflection to compare the values of every field in the type.</span></span> <span data-ttu-id="91d39-159">実装が構造体の仮想 `Equals` メソッドをオーバーライドする場合、その目的は、値の等価性のチェックをより効率的に実行することと、オプションで、構造体のフィールドまたはプロパティの一部のサブセットに基づいて比較を行うことです。</span><span class="sxs-lookup"><span data-stu-id="91d39-159">When an implementer overrides the virtual `Equals` method in a struct, the purpose is to provide a more efficient means of performing the value equality check and optionally to base the comparison on some subset of the struct's field or properties.</span></span>
  
<span data-ttu-id="91d39-160">[==](../../language-reference/operators/equality-operators.md#equality-operator-) および [!=](../../language-reference/operators/equality-operators.md#inequality-operator-) 演算子を使用して構造体で操作することは、その構造体によってそれらの演算子が明示的にオーバーロードされない限り、不可能です。</span><span class="sxs-lookup"><span data-stu-id="91d39-160">The [==](../../language-reference/operators/equality-operators.md#equality-operator-) and [!=](../../language-reference/operators/equality-operators.md#inequality-operator-) operators can't operate on a struct unless the struct explicitly overloads them.</span></span>

## <a name="see-also"></a><span data-ttu-id="91d39-161">関連項目</span><span class="sxs-lookup"><span data-stu-id="91d39-161">See also</span></span>

- [<span data-ttu-id="91d39-162">等価比較</span><span class="sxs-lookup"><span data-stu-id="91d39-162">Equality comparisons</span></span>](equality-comparisons.md)
- [<span data-ttu-id="91d39-163">C# プログラミング ガイド</span><span class="sxs-lookup"><span data-stu-id="91d39-163">C# programming guide</span></span>](../index.md)
