---
title: C# プログラムの構成要素
description: C# メンバー、式、およびステートメントについて説明します。 型には、作成するメンバーが含まれます。 これらのメンバーは、ステートメントおよび式から構築されます。
ms.date: 08/06/2020
ms.openlocfilehash: 79ba391a6c4c6dc453f6c6e07107e4dd831e111d
ms.sourcegitcommit: f0fc5db7bcbf212e46933e9cf2d555bb82666141
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/17/2021
ms.locfileid: "100582957"
---
# <a name="program-building-blocks"></a><span data-ttu-id="b7e19-105">プログラムの構成要素</span><span class="sxs-lookup"><span data-stu-id="b7e19-105">Program building blocks</span></span>

<span data-ttu-id="b7e19-106">前の記事で説明した型は、次の構成要素を使用して構築されています: ["\***メンバー** _"](../programming-guide/classes-and-structs/members.md)、["_\*_式_\*_"、"_ \*_ステートメント_\*\*"](../programming-guide/statements-expressions-operators/index.md)。</span><span class="sxs-lookup"><span data-stu-id="b7e19-106">The types described in the previous article are built using these building blocks: [\***members** _](../programming-guide/classes-and-structs/members.md), [_*_expressions_*_, and _ *_statements_*\*](../programming-guide/statements-expressions-operators/index.md).</span></span>

## <a name="members"></a><span data-ttu-id="b7e19-107">メンバー</span><span class="sxs-lookup"><span data-stu-id="b7e19-107">Members</span></span>

<span data-ttu-id="b7e19-108">`class` のメンバーは、"***静的メンバー** _" または "_*_インスタンス メンバー_\*\*" です。</span><span class="sxs-lookup"><span data-stu-id="b7e19-108">The members of a `class` are either ***static members** _ or _*_instance members_\*\*.</span></span> <span data-ttu-id="b7e19-109">静的メンバーはクラスに属しており、インスタンス メンバーはオブジェクト (クラスのインスタンス) に属しています。</span><span class="sxs-lookup"><span data-stu-id="b7e19-109">Static members belong to classes, and instance members belong to objects (instances of classes).</span></span>

<span data-ttu-id="b7e19-110">クラスに格納できるメンバーの種類の概要を次の一覧に示します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-110">The following list provides an overview of the kinds of members a class can contain.</span></span>

- <span data-ttu-id="b7e19-111">**定数**: クラスに関連付けられている定数値</span><span class="sxs-lookup"><span data-stu-id="b7e19-111">**Constants**: Constant values associated with the class</span></span>
- <span data-ttu-id="b7e19-112">**フィールド**: クラスに関連付けられている変数</span><span class="sxs-lookup"><span data-stu-id="b7e19-112">**Fields**:  Variables that are associated of the class</span></span>
- <span data-ttu-id="b7e19-113">**メソッド**: クラスによって実行可能なアクション</span><span class="sxs-lookup"><span data-stu-id="b7e19-113">**Methods**:  Actions that can be performed by the class</span></span>
- <span data-ttu-id="b7e19-114">**[プロパティ]** :クラスの名前付きプロパティの読み取りと書き込みに関連付けられているアクション</span><span class="sxs-lookup"><span data-stu-id="b7e19-114">**Properties**: Actions associated with reading and writing named properties of the class</span></span>
- <span data-ttu-id="b7e19-115">**インデクサー**: 配列など、クラスのインスタンスのインデックス作成に関連付けられているアクション</span><span class="sxs-lookup"><span data-stu-id="b7e19-115">**Indexers**: Actions associated with indexing instances of the class like an array</span></span>
- <span data-ttu-id="b7e19-116">**イベント**:クラスによって生成可能な通知</span><span class="sxs-lookup"><span data-stu-id="b7e19-116">**Events**: Notifications that can be generated by the class</span></span>
- <span data-ttu-id="b7e19-117">**演算子**: クラスによってサポートされている変換と式の演算子</span><span class="sxs-lookup"><span data-stu-id="b7e19-117">**Operators**: Conversions and expression operators supported by the class</span></span>
- <span data-ttu-id="b7e19-118">**コンストラクター**: クラスのインスタンスまたはクラス自体を初期化するために必要なアクション</span><span class="sxs-lookup"><span data-stu-id="b7e19-118">**Constructors**: Actions required to initialize instances of the class or the class itself</span></span>
- <span data-ttu-id="b7e19-119">**ファイナライザー**: クラスのインスタンスが完全に破棄される前に実行されるアクション</span><span class="sxs-lookup"><span data-stu-id="b7e19-119">**Finalizers**: Actions performed before instances of the class are permanently discarded</span></span>
- <span data-ttu-id="b7e19-120">**型**: クラスで宣言される、入れ子にされた型</span><span class="sxs-lookup"><span data-stu-id="b7e19-120">**Types**: Nested types declared by the class</span></span>

## <a name="accessibility"></a><span data-ttu-id="b7e19-121">ユーザー補助</span><span class="sxs-lookup"><span data-stu-id="b7e19-121">Accessibility</span></span>

<span data-ttu-id="b7e19-122">クラスの各メンバーにはアクセシビリティが関連付けられています。アクセシビリティにより、メンバーへのアクセスが可能なプログラムのテキストの範囲が制御されます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-122">Each member of a class has an associated accessibility, which controls the regions of program text that can access the member.</span></span> <span data-ttu-id="b7e19-123">アクセシビリティには 6 つの有効な形式があります。</span><span class="sxs-lookup"><span data-stu-id="b7e19-123">There are six possible forms of accessibility.</span></span> <span data-ttu-id="b7e19-124">アクセス修飾子の概要を次に示します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-124">The access modifiers are summarized below.</span></span>

- <span data-ttu-id="b7e19-125">`public`:アクセスは制限されません。</span><span class="sxs-lookup"><span data-stu-id="b7e19-125">`public`: Access isn't limited.</span></span>
- <span data-ttu-id="b7e19-126">`private`:アクセスはこのクラスに制限されます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-126">`private`: Access is limited to this class.</span></span>
- <span data-ttu-id="b7e19-127">`protected`:アクセスは、このクラスまたはこのクラスから派生したクラスに制限されます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-127">`protected`: Access is limited to this class or classes derived from this class.</span></span>
- <span data-ttu-id="b7e19-128">`internal`: 現在のアセンブリ (`.exe` または `.dll`) にアクセスが制限されます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-128">`internal`: Access is limited to the current assembly (`.exe` or `.dll`).</span></span>
- <span data-ttu-id="b7e19-129">`protected internal`: アクセスは、このクラス、このクラスから派生したクラス、または同じアセンブリ内のクラスに制限されます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-129">`protected internal`: Access is limited to this class, classes derived from this class, or classes within the same assembly.</span></span>
- <span data-ttu-id="b7e19-130">`private protected`: アクセスは、このクラスまたは同じアセンブリ内のこの型から派生されたクラスに制限されます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-130">`private protected`: Access is limited to this class or classes derived from this type within the same assembly.</span></span>

## <a name="fields"></a><span data-ttu-id="b7e19-131">フィールド</span><span class="sxs-lookup"><span data-stu-id="b7e19-131">Fields</span></span>

<span data-ttu-id="b7e19-132">"*フィールド*" は、クラスまたはクラスのインスタンスに関連付けられている変数です。</span><span class="sxs-lookup"><span data-stu-id="b7e19-132">A *field* is a variable that is associated with a class or with an instance of a class.</span></span>

<span data-ttu-id="b7e19-133">static 修飾子で宣言されているフィールドは、静的フィールドを定義します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-133">A field declared with the static modifier defines a static field.</span></span> <span data-ttu-id="b7e19-134">静的フィールドは、格納場所を 1 つだけ識別します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-134">A static field identifies exactly one storage location.</span></span> <span data-ttu-id="b7e19-135">クラスのインスタンスがいくつ作成されても、静的フィールドのコピーは 1 つだけです。</span><span class="sxs-lookup"><span data-stu-id="b7e19-135">No matter how many instances of a class are created, there's only ever one copy of a static field.</span></span>

<span data-ttu-id="b7e19-136">static 修飾子なしで宣言されているフィールドは、インスタンス フィールドを定義します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-136">A field declared without the static modifier defines an instance field.</span></span> <span data-ttu-id="b7e19-137">クラスの各インスタンスには、そのクラスのすべてのインスタンス フィールドの個別のコピーが含まれています。</span><span class="sxs-lookup"><span data-stu-id="b7e19-137">Every instance of a class contains a separate copy of all the instance fields of that class.</span></span>

<span data-ttu-id="b7e19-138">次の例では、`Color` クラスの各インスタンスに、インスタンス フィールド `R`、`G`、`B` の個別のコピーが含まれていますが、静的フィールド `Black`、`White`、`Red`、`Green`、`Blue` のコピーは 1 つだけです。</span><span class="sxs-lookup"><span data-stu-id="b7e19-138">In the following example, each instance of the `Color` class has a separate copy of the `R`, `G`, and `B` instance fields, but there's only one copy of the `Black`, `White`, `Red`, `Green`, and `Blue` static fields:</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ColorClassDefinition":::

<span data-ttu-id="b7e19-139">前述の例のように、`readonly` 修飾子を使用して "*読み取り専用フィールド*" を宣言できます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-139">As shown in the previous example, *read-only fields* may be declared with a `readonly` modifier.</span></span> <span data-ttu-id="b7e19-140">読み取り専用フィールドへの割り当ては、フィールドの宣言の一部として、または同じクラスのコンストラクター内でのみ可能です。</span><span class="sxs-lookup"><span data-stu-id="b7e19-140">Assignment to a read-only field can only occur as part of the field’s declaration or in a constructor in the same class.</span></span>

## <a name="methods"></a><span data-ttu-id="b7e19-141">メソッド</span><span class="sxs-lookup"><span data-stu-id="b7e19-141">Methods</span></span>

<span data-ttu-id="b7e19-142">"*メソッド*" は、オブジェクトまたはクラスによって実行可能な計算またはアクションを実装するメンバーです。</span><span class="sxs-lookup"><span data-stu-id="b7e19-142">A *method* is a member that implements a computation or action that can be performed by an object or class.</span></span> <span data-ttu-id="b7e19-143">"*静的メソッド*" にはクラスを通じてアクセスします。</span><span class="sxs-lookup"><span data-stu-id="b7e19-143">*Static methods* are accessed through the class.</span></span> <span data-ttu-id="b7e19-144">"*インスタンス メソッド*" にはクラスのインスタンスを通じてアクセスします。</span><span class="sxs-lookup"><span data-stu-id="b7e19-144">*Instance methods* are accessed through instances of the class.</span></span>

<span data-ttu-id="b7e19-145">メソッドには、メソッドに渡される値または変数参照を表す "*パラメーター*" の一覧が含まれている場合があります。</span><span class="sxs-lookup"><span data-stu-id="b7e19-145">Methods may have a list of *parameters*, which represent values or variable references passed to the method.</span></span> <span data-ttu-id="b7e19-146">メソッドには、メソッドによって計算され返される値の型を指定する "*戻り値の型*" が含まれます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-146">Methods have a *return type*, which specifies the type of the value computed and returned by the method.</span></span> <span data-ttu-id="b7e19-147">メソッドによって値が返されない場合、メソッドの戻り値の型は `void` です。</span><span class="sxs-lookup"><span data-stu-id="b7e19-147">A method’s return type is `void` if it doesn't return a value.</span></span>

<span data-ttu-id="b7e19-148">型と同様に、メソッドには型パラメーターのセットを含めることができます。その場合、メソッドの呼び出し時に型引数を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b7e19-148">Like types, methods may also have a set of type parameters, for which type arguments must be specified when the method is called.</span></span> <span data-ttu-id="b7e19-149">型引数は、型とは異なり、多くの場合メソッド呼び出しの引数から推論できます。型引数を明示的に指定する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="b7e19-149">Unlike types, the type arguments can often be inferred from the arguments of a method call and need not be explicitly given.</span></span>

<span data-ttu-id="b7e19-150">メソッドの "*シグネチャ*" は、メソッドが宣言されているクラス内で一意である必要があります。</span><span class="sxs-lookup"><span data-stu-id="b7e19-150">The *signature* of a method must be unique in the class in which the method is declared.</span></span> <span data-ttu-id="b7e19-151">メソッドのシグネチャは、メソッドの名前と、型パラメーターの数と、そのパラメーターの数、修飾子、および型とで構成されます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-151">The signature of a method consists of the name of the method, the number of type parameters, and the number, modifiers, and types of its parameters.</span></span> <span data-ttu-id="b7e19-152">メソッドのシグネチャに戻り値の型は含まれません。</span><span class="sxs-lookup"><span data-stu-id="b7e19-152">The signature of a method doesn't include the return type.</span></span>

<span data-ttu-id="b7e19-153">メソッド本体が単一の式である場合は、次の例に示すように、コンパクトな式形式を使用してメソッドを定義できます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-153">When a method body is a single expression, the method can be defined using a compact expression format, as shown in the following example:</span></span>

```csharp
public override string ToString() => "This is an object";
```

### <a name="parameters"></a><span data-ttu-id="b7e19-154">パラメーター</span><span class="sxs-lookup"><span data-stu-id="b7e19-154">Parameters</span></span>

<span data-ttu-id="b7e19-155">パラメーターは、値または変数参照をメソッドに渡すために使用されます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-155">Parameters are used to pass values or variable references to methods.</span></span> <span data-ttu-id="b7e19-156">メソッドのパラメーターは、メソッドの呼び出し時に指定する "*引数*" から実際の値を取得します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-156">The parameters of a method get their actual values from the *arguments* that are specified when the method is invoked.</span></span> <span data-ttu-id="b7e19-157">値パラメーター、参照パラメーター、出力パラメーター、およびパラメーター配列の 4 種類のパラメーターがあります。</span><span class="sxs-lookup"><span data-stu-id="b7e19-157">There are four kinds of parameters: value parameters, reference parameters, output parameters, and parameter arrays.</span></span>

<span data-ttu-id="b7e19-158">"*値パラメーター*" は、入力引数を渡すために使われます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-158">A *value parameter* is used for passing input arguments.</span></span> <span data-ttu-id="b7e19-159">値パラメーターは、パラメーターに渡された引数からその初期値を取得するローカル変数に相当します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-159">A value parameter corresponds to a local variable that gets its initial value from the argument that was passed for the parameter.</span></span> <span data-ttu-id="b7e19-160">値パラメーターに対する変更は、パラメーターに渡された引数には影響を与えません。</span><span class="sxs-lookup"><span data-stu-id="b7e19-160">Modifications to a value parameter don't affect the argument that was passed for the parameter.</span></span>

<span data-ttu-id="b7e19-161">値パラメーターは省略可能であり、既定値を指定すると、対応する引数を省略できます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-161">Value parameters can be optional, by specifying a default value so that corresponding arguments can be omitted.</span></span>

<span data-ttu-id="b7e19-162">"*参照パラメーター*" は、参照によって引数を渡すために使われます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-162">A *reference parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="b7e19-163">参照パラメーターに渡される引数は、明確な値を持つ変数である必要があります。</span><span class="sxs-lookup"><span data-stu-id="b7e19-163">The argument passed for a reference parameter must be a variable with a definite value.</span></span> <span data-ttu-id="b7e19-164">メソッドの実行中に、参照パラメーターは引数の変数と同じ格納場所を表します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-164">During execution of the method, the reference parameter represents the same storage location as the argument variable.</span></span> <span data-ttu-id="b7e19-165">参照パラメーターは、`ref` 修飾子で宣言されます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-165">A reference parameter is declared with the `ref` modifier.</span></span> <span data-ttu-id="b7e19-166">`ref` パラメーターの使用例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-166">The following example shows the use of `ref` parameters.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="RefExample":::

<span data-ttu-id="b7e19-167">"*出力パラメーター*" は、参照によって引数を渡すために使われます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-167">An *output parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="b7e19-168">参照パラメーターに似ていますが、呼び出し元が提供する引数に値を明示的に割り当てる必要がない点が異なります。</span><span class="sxs-lookup"><span data-stu-id="b7e19-168">It's similar to a reference parameter, except that it doesn't require that you explicitly assign a value to the caller-provided argument.</span></span> <span data-ttu-id="b7e19-169">出力パラメーターは、`out` 修飾子で宣言されます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-169">An output parameter is declared with the `out` modifier.</span></span> <span data-ttu-id="b7e19-170">次の例では、C# 7 で導入された構文を使っている `out` パラメーターを示します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-170">The following example shows the use of `out` parameters using the syntax introduced in C# 7.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="OutExample":::

<span data-ttu-id="b7e19-171">"*パラメーター配列*" は、引数の変数の数をメソッドに渡せるようにします。</span><span class="sxs-lookup"><span data-stu-id="b7e19-171">A *parameter array* permits a variable number of arguments to be passed to a method.</span></span> <span data-ttu-id="b7e19-172">パラメーター配列は、`params` 修飾子で宣言されます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-172">A parameter array is declared with the `params` modifier.</span></span> <span data-ttu-id="b7e19-173">パラメーター配列として使用できるのは、メソッドの最後のパラメーターのみです。パラメーター配列の型は、1 次元配列の型である必要があります。</span><span class="sxs-lookup"><span data-stu-id="b7e19-173">Only the last parameter of a method can be a parameter array, and the type of a parameter array must be a single-dimensional array type.</span></span> <span data-ttu-id="b7e19-174"><xref:System.Console?displayProperty=nameWithType> クラスの `Write` および `WriteLine` メソッドは、パラメーター配列の使用方法の好例です。</span><span class="sxs-lookup"><span data-stu-id="b7e19-174">The `Write` and `WriteLine` methods of the <xref:System.Console?displayProperty=nameWithType> class are good examples of parameter array usage.</span></span> <span data-ttu-id="b7e19-175">これらのメソッドは次のように宣言されます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-175">They're declared as follows.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ConsoleExtract":::

<span data-ttu-id="b7e19-176">パラメーター配列を使用するメソッド内では、パラメーター配列は、配列型の通常のパラメーターとまったく同じように動作します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-176">Within a method that uses a parameter array, the parameter array behaves exactly like a regular parameter of an array type.</span></span> <span data-ttu-id="b7e19-177">ただし、パラメーター配列を使用するメソッドの呼び出しでは、パラメーター配列の型の 1 つの引数またはパラメーター配列の要素型の任意の数の引数を渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-177">However, in an invocation of a method with a parameter array, it's possible to pass either a single argument of the parameter array type or any number of arguments of the element type of the parameter array.</span></span> <span data-ttu-id="b7e19-178">後者の場合、配列インスタンスが自動的に作成され、指定した引数を使用して初期化されます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-178">In the latter case, an array instance is automatically created and initialized with the given arguments.</span></span> <span data-ttu-id="b7e19-179">次のような例があるとします。</span><span class="sxs-lookup"><span data-stu-id="b7e19-179">This example</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UseParamsArgs":::

<span data-ttu-id="b7e19-180">これは、次の記述と同じです。</span><span class="sxs-lookup"><span data-stu-id="b7e19-180">is equivalent to writing the following.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="CompilerParams":::

### <a name="method-body-and-local-variables"></a><span data-ttu-id="b7e19-181">メソッドの本体とローカル変数</span><span class="sxs-lookup"><span data-stu-id="b7e19-181">Method body and local variables</span></span>

<span data-ttu-id="b7e19-182">メソッドの本体では、メソッドの呼び出し時に実行するステートメントを指定します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-182">A method’s body specifies the statements to execute when the method is invoked.</span></span>

<span data-ttu-id="b7e19-183">メソッドの本体は、メソッドの呼び出しに固有の変数を宣言できます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-183">A method body can declare variables that are specific to the invocation of the method.</span></span> <span data-ttu-id="b7e19-184">このような変数は "*ローカル変数*" と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-184">Such variables are called *local variables*.</span></span> <span data-ttu-id="b7e19-185">ローカル変数宣言は、型名、変数名、および (場合によっては) 初期値を指定します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-185">A local variable declaration specifies a type name, a variable name, and possibly an initial value.</span></span> <span data-ttu-id="b7e19-186">次の例では、初期値 0 を使用してローカル変数 `i` を宣言し、初期値を使用せずにローカル変数 `j` を宣言します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-186">The following example declares a local variable `i` with an initial value of zero and a local variable `j` with no initial value.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="SquaresClass":::

<span data-ttu-id="b7e19-187">C# では、ローカル変数の値を取得する前に、ローカル変数を "*明示的に割り当てる*" 必要があります。</span><span class="sxs-lookup"><span data-stu-id="b7e19-187">C# requires a local variable to be *definitely assigned* before its value can be obtained.</span></span> <span data-ttu-id="b7e19-188">たとえば、前述の `i` の宣言に初期値が含まれていなかった場合、コンパイラによって後での `i` の使用に対するエラーが報告されます。これは、プログラム内のそれらのポイントで `i` が明示的に割り当てられていないためです。</span><span class="sxs-lookup"><span data-stu-id="b7e19-188">For example, if the declaration of the previous `i` didn't include an initial value, the compiler would report an error for the later usages of `i` because `i` wouldn't be definitely assigned at those points in the program.</span></span>

<span data-ttu-id="b7e19-189">メソッドでは、`return` ステートメントを使用して、呼び出し元に制御を戻すことができます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-189">A method can use `return` statements to return control to its caller.</span></span> <span data-ttu-id="b7e19-190">`void` を返すメソッドの場合、`return` ステートメントでは式を指定できません。</span><span class="sxs-lookup"><span data-stu-id="b7e19-190">In a method returning `void`, `return` statements can't specify an expression.</span></span> <span data-ttu-id="b7e19-191">void 以外を返すメソッドの場合、`return` ステートメントは戻り値を計算する式を含める必要があります。</span><span class="sxs-lookup"><span data-stu-id="b7e19-191">In a method returning non-void, `return` statements must include an expression that computes the return value.</span></span>

### <a name="static-and-instance-methods"></a><span data-ttu-id="b7e19-192">静的メソッドとインスタンス メソッド</span><span class="sxs-lookup"><span data-stu-id="b7e19-192">Static and instance methods</span></span>

<span data-ttu-id="b7e19-193">`static` 修飾子で宣言されているメソッドは "*静的メソッド*" です。</span><span class="sxs-lookup"><span data-stu-id="b7e19-193">A method declared with a `static` modifier is a *static method*.</span></span> <span data-ttu-id="b7e19-194">静的メソッドは、特定のインスタンスでは動作せず、静的メンバーにのみ直接アクセスできます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-194">A static method doesn't operate on a specific instance and can only directly access static members.</span></span>

<span data-ttu-id="b7e19-195">`static` 修飾子なしで宣言されているメソッドは "*インスタンス メソッド*" です。</span><span class="sxs-lookup"><span data-stu-id="b7e19-195">A method declared without a `static` modifier is an *instance method*.</span></span> <span data-ttu-id="b7e19-196">インスタンス メソッドは、特定のインスタンスで動作し、静的メンバーとインスタンス メンバーの両方にアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-196">An instance method operates on a specific instance and can access both static and instance members.</span></span> <span data-ttu-id="b7e19-197">インスタンス メソッドが呼び出されたインスタンスには、`this` として明示的にアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-197">The instance on which an instance method was invoked can be explicitly accessed as `this`.</span></span> <span data-ttu-id="b7e19-198">静的メソッドで `this` を参照するとエラーになります。</span><span class="sxs-lookup"><span data-stu-id="b7e19-198">It's an error to refer to `this` in a static method.</span></span>

<span data-ttu-id="b7e19-199">次の `Entity` クラスには、静的メンバーとインスタンス メンバーの両方があります。</span><span class="sxs-lookup"><span data-stu-id="b7e19-199">The following `Entity` class has both static and instance members.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="EntityClass":::

<span data-ttu-id="b7e19-200">各 `Entity` インスタンスには、シリアル番号 (およびここに表示されていないその他の情報) が含まれています。</span><span class="sxs-lookup"><span data-stu-id="b7e19-200">Each `Entity` instance contains a serial number (and presumably some other information that isn't shown here).</span></span> <span data-ttu-id="b7e19-201">`Entity` コンストラクターは (インスタンス メソッドと同様に)、次に使用可能なシリアル番号を持つ新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-201">The `Entity` constructor (which is like an instance method) initializes the new instance with the next available serial number.</span></span> <span data-ttu-id="b7e19-202">コンストラクターはインスタンス メンバーであるため、`_serialNo` インスタンス フィールドと `s_nextSerialNo` 静的フィールドの両方にアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-202">Because the constructor is an instance member, it's permitted to access both the `_serialNo` instance field and the `s_nextSerialNo` static field.</span></span>

<span data-ttu-id="b7e19-203">静的メソッドである `GetNextSerialNo` と `SetNextSerialNo` は `s_nextSerialNo` 静的フィールドにアクセスできますが、`_serialNo` インスタンス フィールドに直接アクセスするとエラーになります。</span><span class="sxs-lookup"><span data-stu-id="b7e19-203">The `GetNextSerialNo` and `SetNextSerialNo` static methods can access the `s_nextSerialNo` static field, but it would be an error for them to directly access the `_serialNo` instance field.</span></span>

<span data-ttu-id="b7e19-204">`Entity` クラスの使用例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-204">The following example shows the use of the `Entity` class.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UsingEntity":::

<span data-ttu-id="b7e19-205">静的メソッドである `SetNextSerialNo` と `GetNextSerialNo` はクラスで呼び出されますが、`GetSerialNo` インスタンス メソッドはクラスのインスタンスで呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-205">The `SetNextSerialNo` and `GetNextSerialNo` static methods are invoked on the class whereas the `GetSerialNo` instance method is invoked on instances of the class.</span></span>

### <a name="virtual-override-and-abstract-methods"></a><span data-ttu-id="b7e19-206">仮想メソッド、オーバーライド メソッド、および抽象メソッド</span><span class="sxs-lookup"><span data-stu-id="b7e19-206">Virtual, override, and abstract methods</span></span>

<span data-ttu-id="b7e19-207">インスタンス メソッドの宣言に `virtual` 修飾子が含まれている場合、そのメソッドは "*仮想メソッド*" と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-207">When an instance method declaration includes a `virtual` modifier, the method is said to be a *virtual method*.</span></span> <span data-ttu-id="b7e19-208">virtual 修飾子が存在しない場合、そのメソッドは "*非仮想メソッド*" と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-208">When no virtual modifier is present, the method is said to be a *nonvirtual method*.</span></span>

<span data-ttu-id="b7e19-209">仮想メソッドが呼び出されると、その呼び出しが行われるインスタンスの "*実行時の型*" によって、呼び出す実際のメソッドの実装が決定します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-209">When a virtual method is invoked, the *run-time type* of the instance for which that invocation takes place determines the actual method implementation to invoke.</span></span> <span data-ttu-id="b7e19-210">非仮想メソッドの呼び出しでは、インスタンスの "*コンパイル時の型*" が決定要因です。</span><span class="sxs-lookup"><span data-stu-id="b7e19-210">In a nonvirtual method invocation, the *compile-time type* of the instance is the determining factor.</span></span>

<span data-ttu-id="b7e19-211">仮想メソッドは派生クラスで "*オーバーライド*" できます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-211">A virtual method can be *overridden* in a derived class.</span></span> <span data-ttu-id="b7e19-212">インスタンス メソッドの宣言に override 修飾子が含まれている場合、メソッドは、同じシグネチャを持つ継承された仮想メソッドをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="b7e19-212">When an instance method declaration includes an override modifier, the method overrides an inherited virtual method with the same signature.</span></span> <span data-ttu-id="b7e19-213">仮想メソッドの宣言には新しいメソッドが導入されています。</span><span class="sxs-lookup"><span data-stu-id="b7e19-213">A virtual method declaration introduces a new method.</span></span> <span data-ttu-id="b7e19-214">オーバーライド メソッドの宣言では、そのメソッドの新しい実装を提供することで既存の継承された仮想メソッドを特殊化します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-214">An override method declaration specializes an existing inherited virtual method by providing a new implementation of that method.</span></span>

<span data-ttu-id="b7e19-215">"*抽象メソッド*" は、実装のない仮想メソッドです。</span><span class="sxs-lookup"><span data-stu-id="b7e19-215">An *abstract method* is a virtual method with no implementation.</span></span> <span data-ttu-id="b7e19-216">抽象メソッドは `abstract` 修飾子を使用して宣言され、抽象クラス内でのみ許可されます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-216">An abstract method is declared with the `abstract` modifier and is permitted only in an abstract class.</span></span> <span data-ttu-id="b7e19-217">抽象メソッドは、すべての非抽象派生クラスでオーバーライドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b7e19-217">An abstract method must be overridden in every non-abstract derived class.</span></span>

<span data-ttu-id="b7e19-218">次の例では、式ツリー ノードを表す抽象クラス `Expression`、および定数、変数参照、算術演算の式ツリー ノードを実装する 3 つの派生クラス `Constant`、`VariableReference`、`Operation` を宣言します </span><span class="sxs-lookup"><span data-stu-id="b7e19-218">The following example declares an abstract class, `Expression`, which represents an expression tree node, and three derived classes, `Constant`, `VariableReference`, and `Operation`, which implement expression tree nodes for constants, variable references, and arithmetic operations.</span></span> <span data-ttu-id="b7e19-219">(この例は、式ツリー型に似ていますが、関連はありません)。</span><span class="sxs-lookup"><span data-stu-id="b7e19-219">(This example is similar to, but not related to the expression tree types).</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="WorkingWithExpressions":::

<span data-ttu-id="b7e19-220">前述の 4 つのクラスは、算術式をモデル化するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-220">The previous four classes can be used to model arithmetic expressions.</span></span> <span data-ttu-id="b7e19-221">たとえば、これらのクラスのインスタンスを使用して、式 `x + 3` を次のように表すことができます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-221">For example, using instances of these classes, the expression `x + 3` can be represented as follows.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UseExpressions":::

<span data-ttu-id="b7e19-222">`Expression` インスタンスの `Evaluate` メソッドが呼び出され、指定された式を評価して `double` 値を生成します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-222">The `Evaluate` method of an `Expression` instance is invoked to evaluate the given expression and produce a `double` value.</span></span> <span data-ttu-id="b7e19-223">このメソッドは、変数の名前 (エントリのキーとして) と値 (エントリの値として) が格納されている `Dictionary` 引数を受け取ります。</span><span class="sxs-lookup"><span data-stu-id="b7e19-223">The method takes a `Dictionary` argument that contains variable names (as keys of the entries) and values (as values of the entries).</span></span> <span data-ttu-id="b7e19-224">`Evaluate` は抽象メソッドなので、`Expression` から派生した非抽象クラスでは、`Evaluate` をオーバーライドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b7e19-224">Because `Evaluate` is an abstract method, non-abstract classes derived from `Expression` must override `Evaluate`.</span></span>

<span data-ttu-id="b7e19-225">`Evaluate` の `Constant` の実装は、格納された定数を単に返します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-225">A `Constant`'s implementation of `Evaluate` simply returns the stored constant.</span></span> <span data-ttu-id="b7e19-226">`VariableReference` の実装は、ディクショナリで変数名を検索し、結果の値を返します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-226">A `VariableReference`'s implementation looks up the variable name in the dictionary and returns the resulting value.</span></span> <span data-ttu-id="b7e19-227">`Operation` の実装は、(`Evaluate` メソッドを再帰的に呼び出すことによって) まず左と右のオペランドを評価し、指定された算術演算を実行します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-227">An `Operation`'s implementation first evaluates the left and right operands (by recursively invoking their `Evaluate` methods) and then performs the given arithmetic operation.</span></span>

<span data-ttu-id="b7e19-228">次のプログラムでは、`Expression` クラスを使用して、式 `x * (y + 2)` の異なる値の `x` と `y` を評価します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-228">The following program uses the `Expression` classes to evaluate the expression `x * (y + 2)` for different values of `x` and `y`.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UsingExpressions":::

### <a name="method-overloading"></a><span data-ttu-id="b7e19-229">メソッドのオーバーロード</span><span class="sxs-lookup"><span data-stu-id="b7e19-229">Method overloading</span></span>

<span data-ttu-id="b7e19-230">メソッドの "*オーバーロード*" では、メソッドのシグネチャが一意であれば、同じクラス内の複数のメソッドに同じ名前を付けることができます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-230">Method *overloading* permits multiple methods in the same class to have the same name as long as they have unique signatures.</span></span> <span data-ttu-id="b7e19-231">オーバーロードされたメソッドの呼び出しをコンパイルする場合、コンパイラは "*オーバーロードの解決*" を使用して、呼び出すメソッドを決定します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-231">When compiling an invocation of an overloaded method, the compiler uses *overload resolution* to determine the specific method to invoke.</span></span> <span data-ttu-id="b7e19-232">オーバーロードの解決では、引数に最適なメソッドが 1 つ検索されます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-232">Overload resolution finds the one method that best matches the arguments.</span></span> <span data-ttu-id="b7e19-233">最適な一致が 1 つも見つからない場合は、エラーが報告されます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-233">If no single best match can be found, an error is reported.</span></span> <span data-ttu-id="b7e19-234">次の例は、オーバーロードの解決が有効な場合を示しています。</span><span class="sxs-lookup"><span data-stu-id="b7e19-234">The following example shows overload resolution in effect.</span></span> <span data-ttu-id="b7e19-235">`UsageExample` メソッド内の各呼び出しのコメントは、呼び出されるメソッドを示しています。</span><span class="sxs-lookup"><span data-stu-id="b7e19-235">The comment for each invocation in the `UsageExample` method shows which method is invoked.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="Overloading":::

<span data-ttu-id="b7e19-236">この例に示すように、引数をパラメーターの厳密な型および型引数に明示的にキャストすることにより、特定のメソッドを常に選択できます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-236">As shown by the example, a particular method can always be selected by explicitly casting the arguments to the exact parameter types and type arguments.</span></span>

## <a name="other-function-members"></a><span data-ttu-id="b7e19-237">その他の関数メンバー</span><span class="sxs-lookup"><span data-stu-id="b7e19-237">Other function members</span></span>

<span data-ttu-id="b7e19-238">実行可能コードが含まれるメンバーは、クラスの "*関数メンバー*" と総称されます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-238">Members that contain executable code are collectively known as the *function members* of a class.</span></span> <span data-ttu-id="b7e19-239">前のセクションでは、関数メンバーの主な種類であるメソッドについて説明しました。</span><span class="sxs-lookup"><span data-stu-id="b7e19-239">The preceding section describes methods, which are the primary types of function members.</span></span> <span data-ttu-id="b7e19-240">ここでは、C# でサポートされるその他の種類の関数メンバー (コンストラクター、プロパティ、インデクサー、イベント、演算子、およびファイナライザー) について説明します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-240">This section describes the other kinds of function members supported by C#: constructors, properties, indexers, events, operators, and finalizers.</span></span>

<span data-ttu-id="b7e19-241">次の例では、オブジェクトの拡張可能なリストを実装する、`MyList<T>` と呼ばれるジェネリック クラスを示します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-241">The following example shows a generic class called `MyList<T>`, which implements a growable list of objects.</span></span> <span data-ttu-id="b7e19-242">このクラスには、最も一般的な種類の関数メンバーの例がいくつか含まれています。</span><span class="sxs-lookup"><span data-stu-id="b7e19-242">The class contains several examples of the most common kinds of function members.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListExample":::

### <a name="constructors"></a><span data-ttu-id="b7e19-243">コンストラクター</span><span class="sxs-lookup"><span data-stu-id="b7e19-243">Constructors</span></span>

<span data-ttu-id="b7e19-244">C# は、インスタンス コンストラクターと静的コンストラクターの両方をサポートします。</span><span class="sxs-lookup"><span data-stu-id="b7e19-244">C# supports both instance and static constructors.</span></span> <span data-ttu-id="b7e19-245">"*インスタンス コンストラクター*" は、クラスのインスタンスを初期化するために必要なアクションを実装するメンバーです。</span><span class="sxs-lookup"><span data-stu-id="b7e19-245">An *instance constructor* is a member that implements the actions required to initialize an instance of a class.</span></span> <span data-ttu-id="b7e19-246">"*静的コンストラクター*" は、クラスを最初に読み込むときに、そのクラス自体を初期化するために必要なアクションを実装するメンバーです。</span><span class="sxs-lookup"><span data-stu-id="b7e19-246">A *static constructor* is a member that implements the actions required to initialize a class itself when it's first loaded.</span></span>

<span data-ttu-id="b7e19-247">コンストラクターは、戻り値の型がなく、含んでいるクラスと同じ名前を持つメソッドのように宣言されます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-247">A constructor is declared like a method with no return type and the same name as the containing class.</span></span> <span data-ttu-id="b7e19-248">コンストラクターの宣言に `static` 修飾子が含まれている場合は、静的コンストラクターが宣言されます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-248">If a constructor declaration includes a `static` modifier, it declares a static constructor.</span></span> <span data-ttu-id="b7e19-249">それ以外の場合は、インスタンス コンストラクターが宣言されます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-249">Otherwise, it declares an instance constructor.</span></span>

<span data-ttu-id="b7e19-250">インスタンス コンストラクターはオーバーロード可能であり、省略可能なパラメーターを指定できます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-250">Instance constructors can be overloaded and can have optional parameters.</span></span> <span data-ttu-id="b7e19-251">たとえば、`MyList<T>` クラスでは、1 つの省略可能な `int` パラメータ―を伴う 1 つのインスタンス コンストラクターを宣言します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-251">For example, the `MyList<T>` class declares one instance constructor with a single optional `int` parameter.</span></span> <span data-ttu-id="b7e19-252">インスタンス コンストラクターは、`new` 演算子を使用して呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-252">Instance constructors are invoked using the `new` operator.</span></span> <span data-ttu-id="b7e19-253">次のステートメントは、`MyList` クラスのコンストラクターを使用して、2 つの `MyList<string>` インスタンスを割り当てます (省略可能な引数を使用した場合と使用していない場合の両方を示します)。</span><span class="sxs-lookup"><span data-stu-id="b7e19-253">The following statements allocate two `MyList<string>` instances using the constructor of the `MyList` class with and without the optional argument.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="CreateLists":::

<span data-ttu-id="b7e19-254">他のメンバーとは異なり、インスタンス コンストラクターは継承されません。</span><span class="sxs-lookup"><span data-stu-id="b7e19-254">Unlike other members, instance constructors aren't inherited.</span></span> <span data-ttu-id="b7e19-255">クラスには、そのクラス内で実際に宣言されたコンストラクター以外のインスタンス コンストラクターはありません。</span><span class="sxs-lookup"><span data-stu-id="b7e19-255">A class has no instance constructors other than those constructors actually declared in the class.</span></span> <span data-ttu-id="b7e19-256">クラスのインスタンス コンストラクターが指定されていない場合は、パラメーターなしの空のコンストラクターが自動的に指定されます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-256">If no instance constructor is supplied for a class, then an empty one with no parameters is automatically provided.</span></span>

### <a name="properties"></a><span data-ttu-id="b7e19-257">プロパティ</span><span class="sxs-lookup"><span data-stu-id="b7e19-257">Properties</span></span>

<span data-ttu-id="b7e19-258">"*プロパティ*" は、フィールドが自然に拡張したものです。</span><span class="sxs-lookup"><span data-stu-id="b7e19-258">*Properties* are a natural extension of fields.</span></span> <span data-ttu-id="b7e19-259">フィールドとプロパティはどちらも型が関連付けられている名前付きのメンバーであり、それらにアクセスするための構文は同じです。</span><span class="sxs-lookup"><span data-stu-id="b7e19-259">Both are named members with associated types, and the syntax for accessing fields and properties is the same.</span></span> <span data-ttu-id="b7e19-260">ただし、フィールドとは異なり、プロパティは格納場所を表しません。</span><span class="sxs-lookup"><span data-stu-id="b7e19-260">However, unlike fields, properties don't denote storage locations.</span></span> <span data-ttu-id="b7e19-261">その代わりに、プロパティには、値の読み取りまたは書き込みの際に実行されるステートメントを指定する "*アクセサー*" があります。</span><span class="sxs-lookup"><span data-stu-id="b7e19-261">Instead, properties have *accessors* that specify the statements executed when their values are read or written.</span></span>

<span data-ttu-id="b7e19-262">プロパティはフィールドのように宣言されますが、宣言はセミコロンで終わるのではなく、区切り記号 `{` と `}` の間に記述する get アクセサーまたは set アクセサーで終わる点が異なります。</span><span class="sxs-lookup"><span data-stu-id="b7e19-262">A property is declared like a field, except that the declaration ends with a get accessor or a set accessor written between the delimiters `{` and `}` instead of ending in a semicolon.</span></span> <span data-ttu-id="b7e19-263">get アクセサーと set アクセサーの両方があるプロパティは、"*読み取り/書き込みプロパティ*" です。</span><span class="sxs-lookup"><span data-stu-id="b7e19-263">A property that has both a get accessor and a set accessor is a *read-write property*.</span></span> <span data-ttu-id="b7e19-264">get アクセサーのみがあるプロパティは、"*読み取り専用*" プロパティです。</span><span class="sxs-lookup"><span data-stu-id="b7e19-264">A property that has only a get accessor is a *read-only property*.</span></span> <span data-ttu-id="b7e19-265">set アクセサーのみがあるプロパティは、"*書き込み専用*" プロパティです。</span><span class="sxs-lookup"><span data-stu-id="b7e19-265">A property that has only a set accessor is a *write-only property*.</span></span>

<span data-ttu-id="b7e19-266">get アクセサーは、プロパティの型の戻り値を持つパラメーターなしのメソッドに相当します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-266">A get accessor corresponds to a parameterless method with a return value of the property type.</span></span> <span data-ttu-id="b7e19-267">set アクセサーは、1 つのパラメーターの名前付きの値を持ち、戻り値の型を持たないメソッドに相当します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-267">A set accessor corresponds to a method with a single parameter named value and no return type.</span></span> <span data-ttu-id="b7e19-268">get アクセサーは、プロパティの値を計算します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-268">The get accessor computes the value of the property.</span></span> <span data-ttu-id="b7e19-269">set アクセサーは、プロパティの新しい値を提供します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-269">The set accessor provides a new value for the property.</span></span> <span data-ttu-id="b7e19-270">プロパティが代入のターゲットである場合、あるいは `++` または `--` のオペランドである場合は、set アクセサーが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-270">When the property is the target of an assignment, or the operand of `++` or `--`, the set accessor is invoked.</span></span> <span data-ttu-id="b7e19-271">プロパティが参照されるその他のケースでは、get アクセサーが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-271">In other cases where the property is referenced, the get accessor is invoked.</span></span>

<span data-ttu-id="b7e19-272">`MyList<T>` クラスは 2 つのプロパティ (`Count` と `Capacity`) を宣言します。これらは、それぞれ読み取り専用プロパティと読み取り/書き込みプロパティです。</span><span class="sxs-lookup"><span data-stu-id="b7e19-272">The `MyList<T>` class declares two properties, `Count` and `Capacity`, which are read-only and read-write, respectively.</span></span> <span data-ttu-id="b7e19-273">次のコードは、これらのプロパティの使用例です。</span><span class="sxs-lookup"><span data-stu-id="b7e19-273">The following code is an example of use of these properties:</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="AccessProperties":::

<span data-ttu-id="b7e19-274">フィールドおよびメソッドと同様に、C# はインスタンス プロパティと静的プロパティの両方をサポートします。</span><span class="sxs-lookup"><span data-stu-id="b7e19-274">Similar to fields and methods, C# supports both instance properties and static properties.</span></span> <span data-ttu-id="b7e19-275">静的プロパティは static 修飾子で宣言され、インスタンス プロパティは修飾子なしで宣言されます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-275">Static properties are declared with the static modifier, and instance properties are declared without it.</span></span>

<span data-ttu-id="b7e19-276">プロパティのアクセサーは仮想にすることができます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-276">The accessor(s) of a property can be virtual.</span></span> <span data-ttu-id="b7e19-277">プロパティの宣言に `virtual`、`abstract`、または `override` の各修飾子が含まれている場合、その宣言はプロパティのアクセサーに適用されます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-277">When a property declaration includes a `virtual`, `abstract`, or `override` modifier, it applies to the accessor(s) of the property.</span></span>

### <a name="indexers"></a><span data-ttu-id="b7e19-278">インデクサー</span><span class="sxs-lookup"><span data-stu-id="b7e19-278">Indexers</span></span>

<span data-ttu-id="b7e19-279">"*インデクサー*" は、配列と同じ方法でオブジェクトのインデックスを作成できるようにするメンバーです。</span><span class="sxs-lookup"><span data-stu-id="b7e19-279">An *indexer* is a member that enables objects to be indexed in the same way as an array.</span></span> <span data-ttu-id="b7e19-280">インデクサーはプロパティのように宣言されますが、メンバーの名前が、`this` の後に区切り記号 `[` と `]` でパラメーター リストを囲んだものになる点が異なります。</span><span class="sxs-lookup"><span data-stu-id="b7e19-280">An indexer is declared like a property except that the name of the member is `this` followed by a parameter list written between the delimiters `[` and `]`.</span></span> <span data-ttu-id="b7e19-281">パラメーターは、インデクサーのアクセサーで使用できます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-281">The parameters are available in the accessor(s) of the indexer.</span></span> <span data-ttu-id="b7e19-282">プロパティと同様に、読み取り/書き込み、読み取り専用、および書き込み専用のインデクサーを使用できます。また、インデクサーのアクセサーを仮想にすることができます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-282">Similar to properties, indexers can be read-write, read-only, and write-only, and the accessor(s) of an indexer can be virtual.</span></span>

<span data-ttu-id="b7e19-283">`MyList<T>` クラスは、`int` パラメーターを受け取る 1 つの読み取り/書き込みインデクサーを宣言します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-283">The `MyList<T>` class declares a single read-write indexer that takes an `int` parameter.</span></span> <span data-ttu-id="b7e19-284">インデクサーを使用すると、`int` 値を持つ `MyList<T>` インスタンスのインデックスを作成できます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-284">The indexer makes it possible to index `MyList<T>` instances with `int` values.</span></span> <span data-ttu-id="b7e19-285">次に例を示します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-285">For example:</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListAccess":::

<span data-ttu-id="b7e19-286">インデクサーはオーバーロードすることができます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-286">Indexers can be overloaded.</span></span> <span data-ttu-id="b7e19-287">パラメーターの数または型が異なる限り、クラスでは複数のインデクサーを宣言できます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-287">A class can declare multiple indexers as long as the number or types of their parameters differ.</span></span>

### <a name="events"></a><span data-ttu-id="b7e19-288">events</span><span class="sxs-lookup"><span data-stu-id="b7e19-288">Events</span></span>

<span data-ttu-id="b7e19-289">"*イベント*" は、クラスまたはオブジェクトで通知を提供できるようにするメンバーです。</span><span class="sxs-lookup"><span data-stu-id="b7e19-289">An *event* is a member that enables a class or object to provide notifications.</span></span> <span data-ttu-id="b7e19-290">イベントはフィールドのように宣言されますが、`event` キーワードが宣言に含まれており、型がデリゲート型でなければならない点が異なります。</span><span class="sxs-lookup"><span data-stu-id="b7e19-290">An event is declared like a field except that the declaration includes an `event` keyword and the type must be a delegate type.</span></span>

<span data-ttu-id="b7e19-291">イベント メンバーを宣言するクラス内では、イベントはデリゲート型のフィールドと同じように動作します (イベントが抽象イベントでなく、アクセサーを宣言しない場合)。</span><span class="sxs-lookup"><span data-stu-id="b7e19-291">Within a class that declares an event member, the event behaves just like a field of a delegate type (provided the event isn't abstract and doesn't declare accessors).</span></span> <span data-ttu-id="b7e19-292">フィールドは、イベントに追加されたイベント ハンドラーを表すデリゲートへの参照を格納します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-292">The field stores a reference to a delegate that represents the event handlers that have been added to the event.</span></span> <span data-ttu-id="b7e19-293">イベント ハンドラーが存在しない場合、フィールドは `null` です。</span><span class="sxs-lookup"><span data-stu-id="b7e19-293">If no event handlers are present, the field is `null`.</span></span>

<span data-ttu-id="b7e19-294">`MyList<T>` クラスは、`Changed` という 1 つのイベント メンバーを宣言します。このメンバーは新しい項目がリストに追加されたことを示します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-294">The `MyList<T>` class declares a single event member called `Changed`, which indicates that a new item has been added to the list.</span></span> <span data-ttu-id="b7e19-295">Changed イベントは `OnChanged` 仮想メソッドによって発生します。このメソッドは、最初にイベントが `null` であるかどうか (ハンドラーが存在しないこと) を確認します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-295">The Changed event is raised by the `OnChanged` virtual method, which first checks whether the event is `null` (meaning that no handlers are present).</span></span> <span data-ttu-id="b7e19-296">イベントを発生させるという概念は、イベントによって表されるデリゲートの呼び出しとまったく同じです。</span><span class="sxs-lookup"><span data-stu-id="b7e19-296">The notion of raising an event is precisely equivalent to invoking the delegate represented by the event.</span></span> <span data-ttu-id="b7e19-297">イベントを発生させるための特殊な言語コンストラクトはありません。</span><span class="sxs-lookup"><span data-stu-id="b7e19-297">There are no special language constructs for raising events.</span></span>

<span data-ttu-id="b7e19-298">クライアントは、"*イベント ハンドラー*" を使用してイベントに対応します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-298">Clients react to events through *event handlers*.</span></span> <span data-ttu-id="b7e19-299">イベント ハンドラーは、`+=` 演算子を使用してアタッチされ、`-=` 演算子を使用して削除されます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-299">Event handlers are attached using the `+=` operator and removed using the `-=` operator.</span></span> <span data-ttu-id="b7e19-300">次の例では、`MyList<string>` の `Changed` イベントにイベント ハンドラーをアタッチします。</span><span class="sxs-lookup"><span data-stu-id="b7e19-300">The following example attaches an event handler to the `Changed` event of a `MyList<string>`.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="RespondToEvents":::

<span data-ttu-id="b7e19-301">イベントの基になる記憶域の制御が求められる高度なシナリオでは、イベントの宣言で `add` アクセサーと `remove` アクセサーを明示的に指定できます。これらは、プロパティの `set` アクセサーに似ています。</span><span class="sxs-lookup"><span data-stu-id="b7e19-301">For advanced scenarios where control of the underlying storage of an event is desired, an event declaration can explicitly provide `add` and `remove` accessors, which are similar to the `set` accessor of a property.</span></span>

### <a name="operators"></a><span data-ttu-id="b7e19-302">オペレーター</span><span class="sxs-lookup"><span data-stu-id="b7e19-302">Operators</span></span>

<span data-ttu-id="b7e19-303">"*演算子*" は、クラスのインスタンスに特定の式の演算子を適用する意味を定義するメンバーです。</span><span class="sxs-lookup"><span data-stu-id="b7e19-303">An *operator* is a member that defines the meaning of applying a particular expression operator to instances of a class.</span></span> <span data-ttu-id="b7e19-304">単項演算子、2 項演算子、および変換演算子の 3 種類を定義できます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-304">Three kinds of operators can be defined: unary operators, binary operators, and conversion operators.</span></span> <span data-ttu-id="b7e19-305">すべての演算子は `public` および `static` として宣言する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b7e19-305">All operators must be declared as `public` and `static`.</span></span>

<span data-ttu-id="b7e19-306">`MyList<T>` クラスでは、`operator ==` と `operator !=` の 2 つの演算子を宣言します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-306">The `MyList<T>` class declares two operators, `operator ==` and `operator !=`.</span></span> <span data-ttu-id="b7e19-307">これらのオーバーライドされた演算子は、これらの演算子を `MyList` インスタンスに適用する式に新しい意味を与えます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-307">These overridden operators give new meaning to expressions that apply those operators to `MyList` instances.</span></span> <span data-ttu-id="b7e19-308">具体的には、`Equals` メソッドを使用して含まれている各オブジェクトを比較する際に、演算子が 2 つの `MyList<T>` インスタンスの等価性を定義します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-308">Specifically, the operators define equality of two `MyList<T>` instances as comparing each of the contained objects using their `Equals` methods.</span></span> <span data-ttu-id="b7e19-309">次の例では、`==` 演算子を使用して 2 つの `MyList<int>` インスタンスを比較します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-309">The following example uses the `==` operator to compare two `MyList<int>` instances.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListAddition":::

<span data-ttu-id="b7e19-310">最初の `Console.WriteLine` は `True` を出力します。これは、2 つのリストに、同じ値を持つ同じ数のオブジェクトが同じ順序で含まれているためです。</span><span class="sxs-lookup"><span data-stu-id="b7e19-310">The first `Console.WriteLine` outputs `True` because the two lists contain the same number of objects with the same values in the same order.</span></span> <span data-ttu-id="b7e19-311">`MyList<T>` で `operator ==` が定義されていない場合は、`a` と `b` が異なる `MyList<int>` インスタンスを参照するため、最初の `Console.WriteLine` は `False` を出力します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-311">Had `MyList<T>` not defined `operator ==`, the first `Console.WriteLine` would have output `False` because `a` and `b` reference different `MyList<int>` instances.</span></span>

### <a name="finalizers"></a><span data-ttu-id="b7e19-312">ファイナライザー</span><span class="sxs-lookup"><span data-stu-id="b7e19-312">Finalizers</span></span>

<span data-ttu-id="b7e19-313">"*ファイナライザー*" は、クラスのインスタンスを最終処理するために必要なアクションを実装するメンバーです。</span><span class="sxs-lookup"><span data-stu-id="b7e19-313">A *finalizer* is a member that implements the actions required to finalize an instance of a class.</span></span> <span data-ttu-id="b7e19-314">通常、アンマネージド リソースを解放するにはファイナライザーが必要です。</span><span class="sxs-lookup"><span data-stu-id="b7e19-314">Typically, a finalizer is needed to release unmanaged resources.</span></span> <span data-ttu-id="b7e19-315">ファイナライザーではパラメーターとアクセシビリティ修飾子を使用できません。また、ファイナライザーを明示的に呼び出すことはできません。</span><span class="sxs-lookup"><span data-stu-id="b7e19-315">Finalizers can't have parameters, they can't have accessibility modifiers, and they can't be invoked explicitly.</span></span> <span data-ttu-id="b7e19-316">インスタンスのファイナライザーは、ガベージ コレクション中に自動的に呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-316">The finalizer for an instance is invoked automatically during garbage collection.</span></span> <span data-ttu-id="b7e19-317">詳細については、[ファイナライザー](../programming-guide/classes-and-structs/destructors.md)に関する記事を参照してください。</span><span class="sxs-lookup"><span data-stu-id="b7e19-317">For more details, see the article on [finalizers](../programming-guide/classes-and-structs/destructors.md).</span></span>

<span data-ttu-id="b7e19-318">ガベージ コレクターは、オブジェクトを収集してファイナライザーを実行するタイミングを決定する際に広く許容されます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-318">The garbage collector is allowed wide latitude in deciding when to collect objects and run finalizers.</span></span> <span data-ttu-id="b7e19-319">具体的には、ファイナライザーの呼び出しのタイミングは確定的ではなく、ファイナライザーは任意のスレッドで実行される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b7e19-319">Specifically, the timing of finalizer invocations isn't deterministic, and finalizers may be executed on any thread.</span></span> <span data-ttu-id="b7e19-320">これらの理由およびそれ以外の理由のため、他のソリューションが実現できない場合にのみ、クラスはファイナライザーを実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b7e19-320">For these and other reasons, classes should implement finalizers only when no other solutions are feasible.</span></span>

<span data-ttu-id="b7e19-321">`using` ステートメントは、オブジェクトを破棄するためのより適切な方法を提供します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-321">The `using` statement provides a better approach to object destruction.</span></span>

## <a name="expressions"></a><span data-ttu-id="b7e19-322">式</span><span class="sxs-lookup"><span data-stu-id="b7e19-322">Expressions</span></span>

<span data-ttu-id="b7e19-323">"*式*" は "*オペランド*" と "*演算子*" で構成されます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-323">*Expressions* are constructed from *operands* and *operators*.</span></span> <span data-ttu-id="b7e19-324">式の演算子は、オペランドに適用する演算を表します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-324">The operators of an expression indicate which operations to apply to the operands.</span></span> <span data-ttu-id="b7e19-325">演算子の例として、`+`、`-`、`*`、`/`、および `new` などがあります。</span><span class="sxs-lookup"><span data-stu-id="b7e19-325">Examples of operators include `+`, `-`, `*`, `/`, and `new`.</span></span> <span data-ttu-id="b7e19-326">オペランドの例としては、リテラル、フィールド、ローカル変数、式などがあります。</span><span class="sxs-lookup"><span data-stu-id="b7e19-326">Examples of operands include literals, fields, local variables, and expressions.</span></span>

<span data-ttu-id="b7e19-327">式に複数の演算子が含まれている場合、演算子の "*優先順位*" によって、個々の演算子を評価する順序が制御されます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-327">When an expression contains multiple operators, the *precedence* of the operators controls the order in which the individual operators are evaluated.</span></span> <span data-ttu-id="b7e19-328">たとえば、式 `x + y * z` の評価は `x + (y * z)` ですが、これは `*` 演算子が `+` 演算子より高い優先順位だからです。</span><span class="sxs-lookup"><span data-stu-id="b7e19-328">For example, the expression `x + y * z` is evaluated as `x + (y * z)` because the `*` operator has higher precedence than the `+` operator.</span></span>

<span data-ttu-id="b7e19-329">1 つのオペランドが同じ優先順位を持つ 2 つの演算子の間で発生した場合、演算子の *結合性* によって演算が実行される順序が決定されます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-329">When an operand occurs between two operators with the same precedence, the *associativity* of the operators controls the order in which the operations are performed:</span></span>

* <span data-ttu-id="b7e19-330">代入演算子および null 合体演算子を除くすべてのバイナリ演算子は、"*左からの結合*"、つまり演算は左から右に実行されます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-330">Except for the assignment and null-coalescing operators, all binary operators are *left-associative*, meaning that operations are performed from left to right.</span></span> <span data-ttu-id="b7e19-331">たとえば、`x + y + z` は `(x + y) + z` と評価されます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-331">For example, `x + y + z` is evaluated as `(x + y) + z`.</span></span>
* <span data-ttu-id="b7e19-332">代入演算子、null 合体 `??` および `??=` 演算子、および条件演算子 `?:` は、"*右からの結合*"、つまり演算は右から左に実行されます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-332">The assignment operators, the null-coalescing `??` and `??=` operators, and the conditional operator `?:` are *right-associative*, meaning that operations are performed from right to left.</span></span> <span data-ttu-id="b7e19-333">たとえば、`x = y = z` は `x = (y = z)` と評価されます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-333">For example, `x = y = z` is evaluated as `x = (y = z)`.</span></span>

<span data-ttu-id="b7e19-334">優先順位と結合性は、かっこを使用して制御することができます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-334">Precedence and associativity can be controlled using parentheses.</span></span> <span data-ttu-id="b7e19-335">たとえば、`x + y * z` は最初に `y` と `z` を掛け、そして結果を `x` に足しますが、`(x + y) * z` では最初に `x` と `y` を足してから `z` を掛けます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-335">For example, `x + y * z` first multiplies `y` by `z` and then adds the result to `x`, but `(x + y) * z` first adds `x` and `y` and then multiplies the result by `z`.</span></span>

<span data-ttu-id="b7e19-336">ほとんどの演算子は [*オーバーロード*](../language-reference/operators/operator-overloading.md)できます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-336">Most operators can be [*overloaded*](../language-reference/operators/operator-overloading.md).</span></span> <span data-ttu-id="b7e19-337">演算子をオーバーロードすると、ユーザー定義演算子の実装を、1 つまたは両方のオペランドがユーザー定義のクラスまたは構造体型である演算子に指定することができます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-337">Operator overloading permits user-defined operator implementations to be specified for operations where one or both of the operands are of a user-defined class or struct type.</span></span>

<span data-ttu-id="b7e19-338">C# では、[算術](../language-reference/operators/arithmetic-operators.md)、[論理](../language-reference/operators/boolean-logical-operators.md)、[ビットごとやシフト](../language-reference/operators/bitwise-and-shift-operators.md)の演算に加えて、[等値](../language-reference/operators/equality-operators.md)や[順序](../language-reference/operators/comparison-operators.md)の比較を実行するための多数の演算子を提供しています。</span><span class="sxs-lookup"><span data-stu-id="b7e19-338">C# provides a number of operators to perform [arithmetic](../language-reference/operators/arithmetic-operators.md), [logical](../language-reference/operators/boolean-logical-operators.md), [bitwise and shift](../language-reference/operators/bitwise-and-shift-operators.md) operations and [equality](../language-reference/operators/equality-operators.md) and [order](../language-reference/operators/comparison-operators.md) comparisons.</span></span>

<span data-ttu-id="b7e19-339">優先度順に並べられた C# 演算子の完全な一覧については、「[C# 演算子](../language-reference/operators/index.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="b7e19-339">For the complete list of C# operators ordered by precedence level, see [C# operators](../language-reference/operators/index.md).</span></span>

## <a name="statements"></a><span data-ttu-id="b7e19-340">ステートメント</span><span class="sxs-lookup"><span data-stu-id="b7e19-340">Statements</span></span>

<span data-ttu-id="b7e19-341">プログラムの処理は、"*ステートメント*" を使用して表されます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-341">The actions of a program are expressed using *statements*.</span></span> <span data-ttu-id="b7e19-342">C# はさまざまな種類のステートメントをサポートしており、その多くは埋め込みステートメントとして定義されています。</span><span class="sxs-lookup"><span data-stu-id="b7e19-342">C# supports several different kinds of statements, a number of which are defined in terms of embedded statements.</span></span>

- <span data-ttu-id="b7e19-343">"*ブロック*" を使用すると、1 つのステートメントしか使用できないコンテキストで複数のステートメントを記述できます。</span><span class="sxs-lookup"><span data-stu-id="b7e19-343">A *block* permits multiple statements to be written in contexts where a single statement is allowed.</span></span> <span data-ttu-id="b7e19-344">ブロックは、区切り記号 `{` と `}` の間に記述されたステートメントのリストから成ります。</span><span class="sxs-lookup"><span data-stu-id="b7e19-344">A block consists of a list of statements written between the delimiters `{` and `}`.</span></span>
- <span data-ttu-id="b7e19-345">"*宣言ステートメント*" は、ローカル変数および定数の宣言に使用します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-345">*Declaration statements* are used to declare local variables and constants.</span></span>
- <span data-ttu-id="b7e19-346">"*式ステートメント*" は、式の評価に使用します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-346">*Expression statements* are used to evaluate expressions.</span></span> <span data-ttu-id="b7e19-347">ステートメントとして使用できる式には、メソッドの呼び出し、`new` 演算子を使用したオブジェクトの割り当て、`=` 演算子と複合代入演算子を使用した代入、`++` 演算子と `--` 演算子を使用したインクリメント演算とデクリメント演算、および `await` 式があります。</span><span class="sxs-lookup"><span data-stu-id="b7e19-347">Expressions that can be used as statements include method invocations, object allocations using the `new` operator, assignments using `=` and the compound assignment operators, increment and decrement operations using the `++` and `--` operators and `await` expressions.</span></span>
- <span data-ttu-id="b7e19-348">"*選択ステートメント*" は、式の値に基づいて、実行できる多数のステートメントから 1 つを選択するために使用します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-348">*Selection statements* are used to select one of a number of possible statements for execution based on the value of some expression.</span></span> <span data-ttu-id="b7e19-349">このグループには、`if` および `switch` ステートメントが含まれています。</span><span class="sxs-lookup"><span data-stu-id="b7e19-349">This group contains the `if` and `switch` statements.</span></span>
- <span data-ttu-id="b7e19-350">"*繰り返しステートメント*" は、埋め込みステートメントを繰り返し実行するために使用します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-350">*Iteration statements* are used to execute repeatedly an embedded statement.</span></span> <span data-ttu-id="b7e19-351">このグループには、`while`、`do`、`for`、および `foreach` ステートメントが含まれています。</span><span class="sxs-lookup"><span data-stu-id="b7e19-351">This group contains the `while`, `do`, `for`, and `foreach` statements.</span></span>
- <span data-ttu-id="b7e19-352">"*ジャンプ ステートメント*" は、制御を移すために使用します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-352">*Jump statements* are used to transfer control.</span></span> <span data-ttu-id="b7e19-353">このグループには、`break`、`continue`、`goto`、`throw`、`return`、および `yield` ステートメントが含まれています。</span><span class="sxs-lookup"><span data-stu-id="b7e19-353">This group contains the `break`, `continue`, `goto`, `throw`, `return`, and `yield` statements.</span></span>
- <span data-ttu-id="b7e19-354">`try`...`catch` ステートメントはブロックの実行中に発生した例外をキャッチするために使用し、`try`...`finally` ステートメントは例外が発生したかどうかにかかわらず常に実行される終了処理コードを指定するために使用します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-354">The `try`...`catch` statement is used to catch exceptions that occur during execution of a block, and the `try`...`finally` statement is used to specify finalization code that is always executed, whether an exception occurred or not.</span></span>
- <span data-ttu-id="b7e19-355">`checked` および `unchecked` ステートメントは、整数型の算術演算および変換に対するオーバーフロー チェック コンテキストを制御するために使用します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-355">The `checked` and `unchecked` statements are used to control the overflow-checking context for integral-type arithmetic operations and conversions.</span></span>
- <span data-ttu-id="b7e19-356">`lock` ステートメントは、指定のオブジェクトに対する相互排他ロックを取得し、ステートメントを実行してからロックを解放するために使用します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-356">The `lock` statement is used to obtain the mutual-exclusion lock for a given object, execute a statement, and then release the lock.</span></span>
- <span data-ttu-id="b7e19-357">`using` ステートメントは、リソースを取得し、ステートメントを実行してからそのリソースを破棄するために使用します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-357">The `using` statement is used to obtain a resource, execute a statement, and then dispose of that resource.</span></span>

<span data-ttu-id="b7e19-358">使用できるステートメントの種類を次に示します。</span><span class="sxs-lookup"><span data-stu-id="b7e19-358">The following lists the kinds of statements that can be used:</span></span>

* <span data-ttu-id="b7e19-359">ローカル変数の宣言。</span><span class="sxs-lookup"><span data-stu-id="b7e19-359">Local variable declaration.</span></span>
* <span data-ttu-id="b7e19-360">ローカル定数の宣言。</span><span class="sxs-lookup"><span data-stu-id="b7e19-360">Local constant declaration.</span></span>
* <span data-ttu-id="b7e19-361">式ステートメント。</span><span class="sxs-lookup"><span data-stu-id="b7e19-361">Expression statement.</span></span>
* <span data-ttu-id="b7e19-362">`if` ステートメント。</span><span class="sxs-lookup"><span data-stu-id="b7e19-362">`if` statement.</span></span>
* <span data-ttu-id="b7e19-363">`switch` ステートメント。</span><span class="sxs-lookup"><span data-stu-id="b7e19-363">`switch` statement.</span></span>
* <span data-ttu-id="b7e19-364">`while` ステートメント。</span><span class="sxs-lookup"><span data-stu-id="b7e19-364">`while` statement.</span></span>
* <span data-ttu-id="b7e19-365">`do` ステートメント。</span><span class="sxs-lookup"><span data-stu-id="b7e19-365">`do` statement.</span></span>
* <span data-ttu-id="b7e19-366">`for` ステートメント。</span><span class="sxs-lookup"><span data-stu-id="b7e19-366">`for` statement.</span></span>
* <span data-ttu-id="b7e19-367">`foreach` ステートメント。</span><span class="sxs-lookup"><span data-stu-id="b7e19-367">`foreach` statement.</span></span>
* <span data-ttu-id="b7e19-368">`break` ステートメント。</span><span class="sxs-lookup"><span data-stu-id="b7e19-368">`break` statement.</span></span>
* <span data-ttu-id="b7e19-369">`continue` ステートメント。</span><span class="sxs-lookup"><span data-stu-id="b7e19-369">`continue` statement.</span></span>
* <span data-ttu-id="b7e19-370">`goto` ステートメント。</span><span class="sxs-lookup"><span data-stu-id="b7e19-370">`goto` statement.</span></span>
* <span data-ttu-id="b7e19-371">`return` ステートメント。</span><span class="sxs-lookup"><span data-stu-id="b7e19-371">`return` statement.</span></span>
* <span data-ttu-id="b7e19-372">`yield` ステートメント。</span><span class="sxs-lookup"><span data-stu-id="b7e19-372">`yield` statement.</span></span>
* <span data-ttu-id="b7e19-373">`throw` ステートメントと `try` ステートメント。</span><span class="sxs-lookup"><span data-stu-id="b7e19-373">`throw` statements and `try` statements.</span></span>
* <span data-ttu-id="b7e19-374">`checked` および `unchecked` ステートメント。</span><span class="sxs-lookup"><span data-stu-id="b7e19-374">`checked` and `unchecked` statements.</span></span>
* <span data-ttu-id="b7e19-375">`lock` ステートメント。</span><span class="sxs-lookup"><span data-stu-id="b7e19-375">`lock` statement.</span></span>
* <span data-ttu-id="b7e19-376">`using` ステートメント。</span><span class="sxs-lookup"><span data-stu-id="b7e19-376">`using` statement.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="b7e19-377">[前へ](types.md)
>[次へ](features.md)</span><span class="sxs-lookup"><span data-stu-id="b7e19-377">[Previous](types.md)
[Next](features.md)</span></span>
